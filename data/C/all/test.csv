id	context	question	answer0	answer1	answer2	answer3	label
cd228138-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif static int staticFive = 5; namespace CWE36_Absolute_Path_Traversal__char_console_ofstream_07 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(staticFive==5) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
char <start> dataBuffer[FILENAME_MAX] = """" <end> ;"	"outputFile.open((char * <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
outputFile.open((char * <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
size_t dataLen = <start> strlen(data) <end> ;"	2
4ec5d0c1-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_postinc_18_bad() { int data; data = 0; goto source; source: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } goto sink; sink: { data++; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"int <start> result = data <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"<start> data = 0 <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data <end> ++;"	"if  <start> recvResult == SOCKET_ERROR <end>  || recvResult == 0);
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	2
70279c3a-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif char * CWE134_Uncontrolled_Format_String__char_file_vfprintf_61b_badSource(char * data); static void badVaSink(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_file_vfprintf_61_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; data = CWE134_Uncontrolled_Format_String__char_file_vfprintf_61b_badSource(data); badVaSink(data, data); }"	where is the vulnerable dataflow from data to vfprintf ?	"static void badVaSink(char * <start> data <end> , ...);
<start> vfprintf(stdout, data, args) <end> ;
data = <start> CWE134_Uncontrolled_Format_String__char_file_vfprintf_61b_badSource <end> (data);
badVaSink <start> data <end> , data);"	"data = <start> CWE134_Uncontrolled_Format_String__char_file_vfprintf_61b_badSource <end> (data);
static void badVaSink(char * <start> data <end> , ...);"	"data = <start> CWE134_Uncontrolled_Format_String__char_file_vfprintf_61b_badSource <end> (data);
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);"	"vfprintf(stdout, <start> data <end> , args);
static void badVaSink(char * <start> data <end> , ...);
data = <start> CWE134_Uncontrolled_Format_String__char_file_vfprintf_61b_badSource <end> (data);"	2
4ec5d09c-6c15-11ed-81d4-94e6f77dd552	"void CWE190_Integer_Overflow__int_fscanf_postinc_17_bad() { int i,j; int data; data = 0; for(i = 0; i < 1; i++) { fscanf(stdin, ""%d"", &data); } for(j = 0; j < 1; j++) { { data++; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
fscanf(stdin, ""%d"", <start> &data <end> );"	"fscanf(stdin, ""%d"", <start> &data <end> );
int <start> result = data <end> ;"	"fscanf(stdin, ""%d"", <start> &data <end> );
<start> data = 0 <end> ;"	"fscanf(stdin, ""%d"", <start> &data <end> );
<start> data <end> ++;"	3
8df421ef-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define PATH_SZ 100 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define PATH_SZ PATH_MAX #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 void CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__accept_bind_listen_10_bad() { if(globalTrue) { { char data[100] = """"; #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[recvResult] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif printLine(data); } } }"	where is the vulnerable dataflow from data to printLine ?	"printLine <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	"recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);
<start> printLine(data) <end> ;"	"recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);
printLine <start> data <end> );"	"recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);
char <start> data[100] = """" <end> ;"	2
47a2a83f-6c15-11ed-81d4-94e6f77dd552	"void CWE190_Integer_Overflow__int_fscanf_multiply_31_bad() { int data; data = 0; fscanf(stdin, ""%d"", &data); { int dataCopy = data; int data = dataCopy; if(data > 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  * 2;
<start> printIntLine(result) <end> ;"	"fscanf(stdin, ""%d"", <start> &data <end> );
int result = <start> data <end>  * 2;"	"fscanf(stdin, ""%d"", <start> &data <end> );
<start> printIntLine(result) <end> ;"	"fscanf(stdin, ""%d"", <start> &data <end> );
int <start> data = dataCopy <end> ;"	1
c1366277-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif namespace CWE23_Relative_Path_Traversal__char_console_ifstream_53 { void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } badSink_b(data); }"	where is the vulnerable dataflow from data to badSink_b ?	"badSink_b <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	"dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
badSink_b <start> data <end> );"	"char <start> dataBuffer[FILENAME_MAX] = BASEPATH <end> ;
badSink_b <start> data <end> );"	2
c8600adc-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 static const int STATIC_CONST_FIVE = 5; namespace CWE23_Relative_Path_Traversal__char_listen_socket_ofstream_06 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(STATIC_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"replace = <start> strchr(data, '\n') <end> ;
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
size_t dataLen = <start> strlen(data) <end> ;"	"char <start> dataBuffer[FILENAME_MAX] = BASEPATH <end> ;
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
outputFile.open((char * <start> data <end> );"	3
bc721f7e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define EXECL _execl #else #define EXECL execl #endif void CWE78_OS_Command_Injection__char_file_execl_31_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } { char * dataCopy = data; char * data = dataCopy; EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL); } }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECL ?	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"<start> data = dataBuffer <end> ;
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"<start> EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	"char <start> dataBuffer[100] = COMMAND_ARG2 <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	0
80d9872e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_console_open_22 { int badGlobal = 0; char * badSource(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; badGlobal = 1; data = badSource(data); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } ; }"	where is the vulnerable dataflow from data to OPEN ?	"<start> data = dataBuffer <end> ;
data = <start> badSource <end> (data);"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
data = <start> badSource <end> (data);"	"fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);
data = <start> badSource <end> (data);"	"data = <start> badSource <end> (data);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	3
92bb8a2b-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING ""hello"" typedef union { size_t unionFirst; size_t unionSecond; } CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_34_unionType; void CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_34_bad() { size_t data; CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_34_unionType myUnion; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = strtoul(inputBuffer, NULL, 0); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } myUnion.unionFirst = data; { size_t data = myUnion.unionSecond; { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); } else { printLine(""Input is less than the length of the source string""); } } } }"	where is the vulnerable dataflow from data to malloc ?	"data = <start> strtoul(inputBuffer, NULL, 0) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"size_t <start> data = myUnion.unionSecond <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"myString = (char *)malloc <start> data*sizeof(char) <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
myString = (char *)malloc <start> data*sizeof(char) <end> );"	3
466e7eb9-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink(int data) { { int result = data + 1; printIntLine(result); } } void CWE190_Integer_Overflow__int_fgets_add_41_bad() { int data; data = 0; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } badSink(data); }"	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  + 1;
badSink <start> data <end> );
data = <start> atoi(inputBuffer) <end> ;
static void badSink(int <start> data <end> );"	"if  <start> fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) <end>  != NULL);
static void badSink(int <start> data <end> );
badSink <start> data <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
badSink <start> data <end> );
static void badSink(int <start> data <end> );
int result = <start> data <end>  + 1;"	"<start> printIntLine(result) <end> ;
static void badSink(int <start> data <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
badSink <start> data <end> );"	2
80d986e7-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_connect_socket_open_51 { void badSink(char * data) { { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"void badSink(char * <start> data <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"void badSink(char * <start> data <end> );
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	0
bb49c592-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #define EXECL _execl #else #define EXECL execl #endif namespace CWE78_OS_Command_Injection__char_console_execl_43 { static void badSource(char * &data) { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } void bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; badSource(data); EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECL ?	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
badSource <start> data <end> );
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"<start> EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL) <end> ;
badSource <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
badSource <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	0
6c938bec-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" void CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_17_bad() { int i,j; char * data; char dataBuffer[100] = """"; data = dataBuffer; for(i = 0; i < 1; i++) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } for(j = 0; j < 1; j++) { fprintf(stdout, data); } }"	where is the vulnerable dataflow from data to sizeof ?	recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) *  <start> 100 - dataLen - 1 <end> ), 0);	<start> data = dataBuffer <end> ;	recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);	size_t dataLen = <start> strlen(data) <end> ;	2
8df421f3-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define PATH_SZ 100 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define PATH_SZ PATH_MAX #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 void CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__accept_bind_listen_14_bad() { if(globalFive==5) { { char data[100] = """"; #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[recvResult] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif printLine(data); } } }"	where is the vulnerable dataflow from data to printLine ?	"recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);
replace = <start> strchr(data, '\r') <end> ;"	"recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100 <start> dataLen-1 <end> ), 0);
recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);"	"printLine <start> data <end> );
char <start> data[100] = """" <end> ;"	"recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);
printLine <start> data <end> );"	3
7e74f33a-6c15-11ed-81d4-94e6f77dd552	"namespace CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_82 { void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_82_bad::action(int data) { { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } } }"	where is the vulnerable dataflow from dest to printLine ?	"void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_82_bad::action(int <start> data <end> );
printLine <start> dest <end> );"	"void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_82_bad::action(int <start> data <end> );
<start> printLine(dest) <end> ;"	"printLine <start> dest <end> );
<start> memcpy(dest, source, data) <end> ;"	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	0
977ea7a7-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_13_bad() { int data; data = -1; if(GLOBAL_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(GLOBAL_CONST_FIVE==5) { { int i; int buffer[10] = { 0 }; if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } } } }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"printIntLine <start> buffer[i] <end> );
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"printIntLine <start> buffer[i] <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"<start> printIntLine(buffer[i]) <end> ;
printIntLine <start> buffer[i] <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[i] <end> );"	3
bed4a8d1-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_connect_socket_fopen_54 { void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badSink_b(data); }"	where is the vulnerable dataflow from data to badSink_b ?	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
badSink_b <start> data <end> );"	"badSink_b <start> data <end> );
char <start> dataBuffer[FILENAME_MAX] = BASEPATH <end> ;"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
badSink_b <start> data <end> );"	1
6dc61512-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif void CWE134_Uncontrolled_Format_String__char_console_snprintf_16_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; while(1) { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } break; } while(1) { { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } break; } }"	where is the vulnerable dataflow from dest to printLine ?	"dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	"<start> printLine(dest) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
printLine <start> dest <end> );"	"printLine <start> dest <end> );
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	2
b1b8084f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" static int staticFive = 5; void CWE197_Numeric_Truncation_Error__short_connect_socket_07_bad() { short data; data = -1; if(staticFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = (short)atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { char charData = (char)data; printHexCharLine(charData); } }"	where is the vulnerable dataflow from charData to printHexCharLine ?	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printHexCharLine <start> charData <end> );"	"char <start> charData = (char)data <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printHexCharLine <start> charData <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data = (short)atoi(inputBuffer) <end> ;"	2
c39a65bf-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif namespace CWE23_Relative_Path_Traversal__char_environment_ofstream_52 { void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } badSink_b(data); }"	where is the vulnerable dataflow from data to badSink_b ?	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
badSink_b <start> data <end> );"	"size_t <start> dataLen = strlen(data) <end> ;
badSink_b <start> data <end> );"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
<start> badSink_b(data) <end> ;"	"badSink_b <start> data <end> );
<start> data = dataBuffer <end> ;"	0
9059f3c4-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 256 void CWE681_Incorrect_Conversion_Between_Numeric_Types__double2float_17_bad() { int j; for(j = 0; j < 1; j++) { { char inputBuffer[CHAR_ARRAY_SIZE]; double doubleNumber = 0; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { doubleNumber = atof(inputBuffer); } else { printLine(""fgets() failed.""); } printFloatLine((float)doubleNumber); } } }"	where is the vulnerable dataflow from (float)doubleNumber to printFloatLine ?	"printFloatLine <start> (float)doubleNumber <end> );
if  <start> fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) <end>  != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printFloatLine <start> (float)doubleNumber <end> );"	"printFloatLine <start> (float)doubleNumber <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"printFloatLine <start> (float)doubleNumber <end> );
<start> doubleNumber = atof(inputBuffer) <end> ;"	1
6b862430-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink(int data) { { int i; int * buffer = (int *)malloc(10 * sizeof(int)); if (buffer == NULL) {exit(-1);} for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } free(buffer); } } void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_connect_socket_41_bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badSink(data); }"	where is the vulnerable dataflow from buffer to free ?	"if  <start> buffer == NULL <end> ) {exit(-1);};
free <start> buffer <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSink <start> data <end> );"	"badSink <start> data <end> );
free <start> buffer <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static void badSink(int <start> data <end> );"	"badSink <start> data <end> );
static void badSink(int <start> data <end> );
<start> free(buffer) <end> ;
free <start> buffer <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSink <start> data <end> );
static void badSink(int <start> data <end> );
free <start> buffer <end> );"	3
571e984b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_listen_socket_multiply_02_bad() { int data; data = 0; if(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(1) { if(data < 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"if <start> data < 0 <end> ) ;
int result = <start> data <end>  * 2;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int <start> result = data * 2 <end> ;"	"data = <start> atoi(inputBuffer) <end> ;
int result = <start> data <end>  * 2;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  * 2;"	3
8f278a59-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_15_bad() { int data; data = -1; switch(6) { case 6: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; default: printLine(""Benign, fixed string""); break; } { size_t i; int *intPointer; intPointer = (int*)malloc(data * sizeof(int)); if (intPointer == NULL) {exit(-1);} for (i = 0; i < (size_t)data; i++) { intPointer[i] = 0; } printIntLine(intPointer[0]); free(intPointer); } }"	where is the vulnerable dataflow from data to malloc ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	"intPointer = (int*)malloc <start> data * sizeof(int) <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"<start> data = atoi(inputBuffer) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"<start> data = atoi(inputBuffer) <end> ;
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	0
78800fe8-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 8 namespace CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_43 { static void badSource(short &data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } void bad() { short data; data = 0; badSource(data); { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"printLine <start> dest <end> );
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
badSource <start> data <end> );"	"badSource <start> data <end> );
printLine <start> dest <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSource <start> data <end> );
printLine <start> dest <end> );"	"printLine <start> dest <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	2
b54bcf13-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE 20 float CWE369_Divide_by_Zero__float_fgets_61b_badSource(float data); void CWE369_Divide_by_Zero__float_fgets_61_bad() { float data; data = 0.0F; data = CWE369_Divide_by_Zero__float_fgets_61b_badSource(data); { int result = (int)(100.0 / data); printIntLine(result); } }	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;"	"int result = <start> (int)(100.0 / data) <end> ;
data = <start> CWE369_Divide_by_Zero__float_fgets_61b_badSource <end> (data);"	"data = <start> CWE369_Divide_by_Zero__float_fgets_61b_badSource <end> (data);
printIntLine <start> result <end> );"	"int result = (int) <start> 100.0 / data <end> );
printIntLine <start> result <end> );"	2
761e2989-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 8 namespace CWE194_Unexpected_Sign_Extension__fgets_memmove_43 { static void badSource(short &data) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = (short)atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } void bad() { short data; data = 0; badSource(data); { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
badSource <start> data <end> );
printLine <start> dest <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> printLine(dest) <end> ;
badSource <start> data <end> );"	"<start> memmove(dest, source, data) <end> ;
printLine <start> dest <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if  <start> data < 100 <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printLine <start> dest <end> );"	0
d1e9da1f-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_file_open_63 { void badSink(char * * dataPtr) { char * data = *dataPtr; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
void badSink(char * * <start> dataPtr <end> );"	"void badSink(char * * <start> dataPtr <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	1
6ef76850-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } static void badVaSinkB(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_console_vprintf_08_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; if(staticReturnsTrue()) { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } if(staticReturnsTrue()) { badVaSinkB(data, data); } }"	where is the vulnerable dataflow from data to vprintf ?	"badVaSinkB <start> data <end> , data);
size_t dataLen = <start> strlen(data) <end> ;
vprintf <start> data <end> , args);
static void badVaSinkB(char * <start> data <end> , ...);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
static void badVaSinkB(char * <start> data <end> , ...);
size_t dataLen = <start> strlen(data) <end> ;
vprintf <start> data <end> , args);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);
vprintf <start> data <end> , args);"	"<start> va_start(args, data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
badVaSinkB <start> data <end> , data);
vprintf <start> data <end> , args);"	2
8a6310df-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; namespace CWE36_Absolute_Path_Traversal__char_listen_socket_fopen_04 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(STATIC_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"<start> data = dataBuffer <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"char <start> dataBuffer[FILENAME_MAX] = """" <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	0
cac216b3-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } namespace CWE36_Absolute_Path_Traversal__char_connect_socket_ofstream_08 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(staticReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
outputFile.open((char * <start> data <end> );"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"outputFile.open((char * <start> data <end> );
<start> data = dataBuffer <end> ;"	"outputFile.open((char * <start> data <end> );
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	0
6b86246a-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_66b_badSink(int dataArray[]) { int data = dataArray[2]; { int i; int * buffer = (int *)malloc(10 * sizeof(int)); if (buffer == NULL) {exit(-1);} for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } free(buffer); } }"	where is the vulnerable dataflow from buffer to free ?	"if  <start> buffer == NULL <end> ) {exit(-1);};
void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_66b_badSink(int <start> dataArray <end> []);"	"<start> free(buffer) <end> ;
free <start> buffer <end> );"	"free <start> buffer <end> );
int <start> * buffer = (int *)malloc(10 * sizeof(int)) <end> ;"	"void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_66b_badSink(int <start> dataArray <end> []);
free <start> buffer <end> );"	3
cd22816c-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_console_open_51 { void badSink(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } badSink(data); }"	where is the vulnerable dataflow from data to badSink ?	"badSink <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
badSink <start> data <end> );"	"<start> badSink(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	1
bc721f86-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif namespace CWE78_OS_Command_Injection__char_file_execl_81 { void bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } const CWE78_OS_Command_Injection__char_file_execl_81_base& baseObject = CWE78_OS_Command_Injection__char_file_execl_81_bad(); baseObject.action(data); }"	where is the vulnerable dataflow from data to action ?	"baseObject.action <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	"<start> data = dataBuffer <end> ;
baseObject.action <start> data <end> );"	"baseObject.action <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
baseObject.action <start> data <end> );"	3
78800fe5-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 8 typedef union { short unionFirst; short unionSecond; } CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_34_unionType; void CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_34_bad() { short data; CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_34_unionType myUnion; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } myUnion.unionFirst = data; { short data = myUnion.unionSecond; { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } } }"	where is the vulnerable dataflow from dest to printLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"printLine <start> dest <end> );
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
if  <start> recvResult == SOCKET_ERROR <end>  || recvResult == 0);"	0
54c58226-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) int CWE191_Integer_Underflow__int_connect_socket_sub_61b_badSource(int data); void CWE191_Integer_Underflow__int_connect_socket_sub_61_bad() { int data; data = 0; data = CWE191_Integer_Underflow__int_connect_socket_sub_61b_badSource(data); { int result = data - 1; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"data = <start> CWE191_Integer_Underflow__int_connect_socket_sub_61b_badSource <end> (data);
int result = <start> data <end>  - 1;"	"int <start> result = data - 1 <end> ;
data = <start> CWE191_Integer_Underflow__int_connect_socket_sub_61b_badSource <end> (data);"	"data = <start> CWE191_Integer_Underflow__int_connect_socket_sub_61b_badSource(data) <end> ;
int result = <start> data <end>  - 1;"	"int result = <start> data - 1 <end> ;
data = <start> CWE191_Integer_Underflow__int_connect_socket_sub_61b_badSource <end> (data);"	0
7c127568-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) typedef union { int unionFirst; int unionSecond; } CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_34_unionType; void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_34_bad() { int data; CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_34_unionType myUnion; data = -1; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } myUnion.unionFirst = data; { int data = myUnion.unionSecond; if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } } }"	where is the vulnerable dataflow from data to malloc ?	"<start> printLine(dataBuffer) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
char * dataBuffer = <start> (char *)malloc(data) <end> ;"	"char * dataBuffer = <start> (char *)malloc(data) <end> ;
char * dataBuffer = (char *)malloc <start> data <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
char * dataBuffer = (char *)malloc <start> data <end> );"	3
bb49c5af-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #define EXECLP _execlp #else #define EXECLP execlp #endif namespace CWE78_OS_Command_Injection__char_console_execlp_43 { static void badSource(char * &data) { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } void bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; badSource(data); EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECLP ?	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
badSource <start> data <end> );
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
badSource <start> data <end> );"	"<start> EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
badSource <start> data <end> );"	"EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
size_t dataLen = <start> strlen(data) <end> ;
badSource <start> data <end> );"	0
977ea790-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink(int data) { { int i; int buffer[10] = { 0 }; if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } } } void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_44_bad() { int data; void (*funcPtr) (int) = badSink; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } funcPtr(data); }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"printIntLine <start> buffer[i] <end> );
static void badSink(int <start> data <end> );
funcPtr <start> data <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
funcPtr <start> data <end> );
static void badSink(int <start> data <end> );
printIntLine <start> buffer[i] <end> );"	"static void badSink(int <start> data <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[i] <end> );
<start> funcPtr(data) <end> ;"	"static void badSink(int <start> data <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[i] <end> );
funcPtr <start> data <end> );"	1
9ebc76d1-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } void CWE127_Buffer_Underread__CWE839_listen_socket_08_bad() { int data; data = -1; if(staticReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticReturnsTrue()) { { int buffer[10] = { 0 }; if (data < 10) { printIntLine(buffer[data]); } else { printLine(""ERROR: Array index is too big.""); } } } }"	where is the vulnerable dataflow from buffer[data] to printIntLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[data] <end> );"	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> buffer[data] <end> );"	"int <start> buffer[10] = { 0 } <end> ;
printIntLine <start> buffer[data] <end> );"	"printIntLine <start> buffer[data] <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	0
cf8750be-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_file_fopen_43 { void badSource(char * &data) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; badSource(data); { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = FOPEN <start> data <end> , ""wb+"");
badSource <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
size_t dataLen = <start> strlen(data) <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
pFile = FOPEN <start> data <end> , ""wb+"");"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
badSource <start> data <end> );
pFile = FOPEN <start> data <end> , ""wb+"");"	3
9187cbd5-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define SEARCH_CHAR 'S' void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_11_bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\0'; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } if(globalReturnsTrue()) { for (; *data != '\0'; data++) { if (*data == SEARCH_CHAR) { printLine(""We have a match!""); break; } } free(data); } }"	where is the vulnerable dataflow from data to free ?	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (100 - dataLen - 1), 0);
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"free <start> data <end> );
<start> free(data) <end> ;"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
free <start> data <end> );"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
if  <start> data == NULL <end> ) {exit(-1);};"	2
b68484e5-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 namespace CWE36_Absolute_Path_Traversal__char_listen_socket_fopen_81 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } const CWE36_Absolute_Path_Traversal__char_listen_socket_fopen_81_base& baseObject = CWE36_Absolute_Path_Traversal__char_listen_socket_fopen_81_bad(); baseObject.action(data); }"	where is the vulnerable dataflow from data to action ?	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
baseObject.action <start> data <end> );"	"baseObject.action <start> data <end> );
<start> data = dataBuffer <end> ;"	"baseObject.action <start> data <end> );
recvResult = <start> recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0) <end> ;"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	0
4ff78265-6c15-11ed-81d4-94e6f77dd552	"static int staticTrue = 1; static int staticFalse = 0; void CWE190_Integer_Overflow__short_fscanf_postinc_05_bad() { short data; data = 0; if(staticTrue) { fscanf (stdin, ""%hd"", &data); } if(staticTrue) { { data++; short result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"short <start> result = data <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );"	"<start> data <end> ++;
short <start> result = data <end> ;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
<start> data <end> ++;"	"<start> data <end> ++;
fscanf (stdin, ""%hd"", <start> &data <end> );"	2
c8600b1f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_listen_socket_open_74 { void badSink(map<int, char *> dataMap) { char * data = dataMap[2]; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"void badSink(map<int, char *> <start> dataMap <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
void badSink(map<int, char *> <start> dataMap <end> );"	"fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	1
584fa875-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_listen_socket_sub_14_bad() { int data; data = 0; if(globalFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalFive==5) { { int result = data - 1; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"int <start> result = data - 1 <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"int result = <start> data <end>  - 1;
<start> recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  - 1;"	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  - 1;"	2
b41b87a6-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 20 #define IP_ADDRESS ""127.0.0.1"" static float badSource(float data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = (float)atof(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } return data; } void CWE369_Divide_by_Zero__float_connect_socket_42_bad() { float data; data = 0.0F; data = badSource(data); { int result = (int)(100.0 / data); printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static float <start> badSource <end> (float data);
data = <start> badSource <end> (data);
printIntLine <start> result <end> );"	"int <start> result = (int)(100.0 / data) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static float <start> badSource <end> (float data);
printIntLine <start> result <end> );"	"int <start> result = (int)(100.0 / data) <end> ;
static float <start> badSource <end> (float data);
data = <start> badSource <end> (data);
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"data = (float <start> atof(inputBuffer) <end> ;
static float <start> badSource <end> (float data);
printIntLine <start> result <end> );
data = <start> badSource <end> (data);"	0
cf875094-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_environment_open_45 { static char * badData; static char * goodG2BData; static void badSink() { char * data = badData; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } } void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } badData = data; badSink(); }"	where is the vulnerable dataflow from data to OPEN ?	"<start> strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
char * data = <start> badData <end> ;
static char * <start> badData <end> ;
<start> badData = data <end> ;"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
<start> badData = data <end> ;
static char * <start> badData <end> ;
char * data = <start> badData <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN(data, O_RDWR|O_CREAT, <start> S_IREAD|S_IWRITE <end> );
static char * <start> badData <end> ;
char * data = <start> badData <end> ;
char * environment = <start> GETENV <end> (ENV_VARIABLE);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);
<start> badData = data <end> ;
static char * <start> badData <end> ;
char * environment = <start> GETENV <end> (ENV_VARIABLE);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	1
951c5ea7-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FULL_COMMAND ""dir "" #else #define FULL_COMMAND ""ls "" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define POPEN _popen #define PCLOSE _pclose #else #define POPEN popen #define PCLOSE pclose #endif static int staticTrue = 1; static int staticFalse = 0; void CWE78_OS_Command_Injection__char_file_popen_05_bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; if(staticTrue) { { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } { FILE *pipe; pipe = POPEN(data, ""w""); if (pipe != NULL) { PCLOSE(pipe); } } }"	where is the vulnerable dataflow from data to POPEN ?	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
pipe = POPEN <start> data <end> , ""w"");"	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	"pipe = POPEN <start> data <end> , ""w"");
pipe = <start> POPEN(data, ""w"") <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
pipe = <start> POPEN(data, ""w"") <end> ;"	0
9b124d8d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE124_Buffer_Underwrite__CWE839_connect_socket_82 { void bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE124_Buffer_Underwrite__CWE839_connect_socket_82_base* baseObject = new CWE124_Buffer_Underwrite__CWE839_connect_socket_82_bad; baseObject->action(data); delete baseObject; }"	where is the vulnerable dataflow from data to action ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
baseObject->action <start> data <end> );"	"baseObject->action <start> data <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);
baseObject->action <start> data <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
data = <start> atoi(inputBuffer) <end> ;"	0
5e44fc5c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int badSource(int data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } return data; } void CWE191_Integer_Underflow__int_connect_socket_predec_42_bad() { int data; data = 0; data = badSource(data); { --data; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
data = <start> badSource <end> (data);
static int <start> badSource <end> (int data);
- <start> data <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static int <start> badSource <end> (int data);
data = <start> badSource <end> (data);
- <start> data <end> ;"	"- <start> data <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static int <start> badSource <end> (int data);
data = <start> badSource <end> (data);"	"<start> --data <end> ;
data = <start> badSource <end> (data);
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static int <start> badSource <end> (int data);"	1
55ef4c9c-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } void CWE191_Integer_Underflow__int_fgets_multiply_08_bad() { int data; data = 0; if(staticReturnsTrue()) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(staticReturnsTrue()) { if(data < 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  * 2;
<start> printIntLine(result) <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
int result = <start> data <end>  * 2;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
char <start> inputBuffer[CHAR_ARRAY_SIZE] = """" <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
int <start> result = data * 2 <end> ;"	1
9059f39d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_15_bad() { int data; data = -1; switch(6) { case 6: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; default: printLine(""Benign, fixed string""); break; } { size_t i; int *intPointer; intPointer = (int*)malloc(data * sizeof(int)); if (intPointer == NULL) {exit(-1);} for (i = 0; i < (size_t)data; i++) { intPointer[i] = 0; } printIntLine(intPointer[0]); free(intPointer); } }"	where is the vulnerable dataflow from data to malloc ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data = atoi(inputBuffer) <end> ;"	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	"intPointer = (int*)malloc <start> data * sizeof(int) <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	3
4db33f75-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_postinc_15_bad() { int data; data = 0; switch(6) { case 6: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; default: printLine(""Benign, fixed string""); break; } switch(7) { case 7: { data++; int result = data; printIntLine(result); } break; default: printLine(""Benign, fixed string""); break; } }"	where is the vulnerable dataflow from data ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data <end> ++;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
data = <start> atoi(inputBuffer) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printIntLine(result) <end> ;"	"<start> data++ <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	0
a10948fc-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__int_connect_socket_multiply_74 { void badSink(map<int, int> dataMap) { int data = dataMap[2]; if(data > 0) { int result = data * 2; printIntLine(result); } }	where is the vulnerable dataflow from result to printIntLine ?	"<start> printIntLine(result) <end> ;
void badSink(map<int, int> <start> dataMap <end> );"	"void badSink(map<int, int> <start> dataMap <end> );
int result = <start> data * 2 <end> ;"	"void badSink(map<int, int> <start> dataMap <end> );
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
int result = <start> data * 2 <end> ;"	2
5f76fc8a-6c15-11ed-81d4-94e6f77dd552	extern int CWE191_Integer_Underflow__int_listen_socket_predec_22_badGlobal; void CWE191_Integer_Underflow__int_listen_socket_predec_22_badSink(int data) { if(CWE191_Integer_Underflow__int_listen_socket_predec_22_badGlobal) { { --data; int result = data; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"- <start> data <end> ;
void CWE191_Integer_Underflow__int_listen_socket_predec_22_badSink(int <start> data <end> );"	"void CWE191_Integer_Underflow__int_listen_socket_predec_22_badSink(int <start> data <end> );
- <start> data <end> ;"	"- <start> data <end> ;
<start> printIntLine(result) <end> ;"	"int <start> result = data <end> ;
void CWE191_Integer_Underflow__int_listen_socket_predec_22_badSink(int <start> data <end> );"	1
c1366284-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif namespace CWE23_Relative_Path_Traversal__char_console_ofstream_11 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(globalReturnsTrue()) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"size_t dataLen = <start> strlen(data) <end> ;
outputFile.open((char * <start> data <end> );"	"dataLen = <start> strlen(data) <end> ;
outputFile.open((char * <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
size_t dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
outputFile.open((char * <start> data <end> );"	3
630ae7eb-6c15-11ed-81d4-94e6f77dd552	static void badSink(short data) { if(data > 0) { short result = data * 2; printIntLine(result); } } void CWE190_Integer_Overflow__short_rand_multiply_44_bad() { short data; void (*funcPtr) (short) = badSink; data = 0; data = (short)RAND32(); funcPtr(data); }	where is the vulnerable dataflow from data ?	"data = (short <start> RAND32() <end> ;
static void badSink(short <start> data <end> );
funcPtr <start> data <end> );
short <start> result = data * 2 <end> ;"	"<start> printIntLine(result) <end> ;
data = (short <start> RAND32() <end> ;
funcPtr <start> data <end> );
static void badSink(short <start> data <end> );"	"data = (short <start> RAND32() <end> ;
funcPtr <start> data <end> );
static void badSink(short <start> data <end> );
short result = <start> data <end>  * 2;"	"funcPtr <start> data <end> );
data = (short <start> RAND32() <end> ;
short result = <start> data <end>  * 2;"	2
a10948de-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_multiply_11_bad() { int data; data = 0; if(globalReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalReturnsTrue()) { if(data > 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
int result = <start> data * 2 <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> result <end> );"	"data = <start> atoi(inputBuffer) <end> ;
printIntLine <start> result <end> );"	1
a23a3e02-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink(int data) { { int result = data + 1; printIntLine(result); } } void CWE190_Integer_Overflow__int_fgets_add_44_bad() { int data; void (*funcPtr) (int) = badSink; data = 0; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } funcPtr(data); }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
<start> funcPtr(data) <end> ;
static void badSink(int <start> data <end> );
funcPtr <start> data <end> );"	"funcPtr <start> data <end> );
static void badSink(int <start> data <end> );"	"funcPtr <start> data <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
static void badSink(int <start> data <end> );
<start> data = 0 <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
funcPtr <start> data <end> );
static void badSink(int <start> data <end> );
printIntLine <start> result <end> );"	3
5af03e26-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int badSource(int data) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } return data; } void CWE191_Integer_Underflow__int_fgets_postdec_42_bad() { int data; data = 0; data = badSource(data); { data--; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"data = <start> badSource <end> (data);
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> data <end> --;
<start> printIntLine(result) <end> ;"	"data = <start> badSource <end> (data);
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> printIntLine(result) <end> ;
static int <start> badSource <end> (int data);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
static int <start> badSource <end> (int data);
data = <start> badSource <end> (data);
<start> data <end> --;"	"static int <start> badSource <end> (int data);
<start> data <end> --;
data = <start> badSource <end> (data);
<start> printIntLine(result) <end> ;"	2
8df42203-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define PATH_SZ 100 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define PATH_SZ PATH_MAX #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 void CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__accept_listen_bind_12_bad() { if(globalReturnsTrueOrFalse()) { { char data[100] = """"; #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[recvResult] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif printLine(data); } } else { { char data[100] = """"; #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[recvResult] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif printLine(data); } } }"	where is the vulnerable dataflow from data to printLine ?	"<start> recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0) <end> ;
printLine <start> data <end> );"	"recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);
printLine <start> data <end> );"	"if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );
recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);"	"printLine <start> data <end> );
replace = <start> strchr(data, '\r') <end> ;"	1
87ff984e-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_connect_socket_fopen_22 { int badGlobal = 0; char * badSource(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; badGlobal = 1; data = badSource(data); { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } ; }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
data = <start> badSource <end> (data);"	"data = <start> badSource <end> (data);
pFile = FOPEN <start> data <end> , ""wb+"");"	"<start> data = badSource(data) <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
data = <start> badSource <end> (data);"	1
99e16a98-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE124_Buffer_Underwrite__CWE839_connect_socket_02_bad() { int data; data = -1; if(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(1) { { int i; int buffer[10] = { 0 }; if (data < 10) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } } } }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[i] <end> );"	"printIntLine <start> buffer[i] <end> );
int <start> buffer[10] = { 0 } <end> ;"	"printIntLine <start> buffer[i] <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"printIntLine <start> buffer[i] <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	0
bc721f8d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define EXECLP _execlp #else #define EXECLP execlp #endif static const int STATIC_CONST_FIVE = 5; void CWE78_OS_Command_Injection__char_file_execlp_06_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(STATIC_CONST_FIVE==5) { { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECLP ?	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
<start> EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL) <end> ;"	"EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
<start> data = dataBuffer <end> ;"	1
6c938bde-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_54e_badSink(int data) { { int i; int * buffer = (int *)malloc(10 * sizeof(int)); if (buffer == NULL) {exit(-1);} for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } free(buffer); } }"	where is the vulnerable dataflow from buffer to free ?	"if  <start> buffer == NULL <end> ) {exit(-1);};
free <start> buffer <end> );"	"void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_54e_badSink(int <start> data <end> );
if  <start> buffer == NULL <end> ) {exit(-1);};"	"free <start> buffer <end> );
void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_54e_badSink(int <start> data <end> );"	"void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_54e_badSink(int <start> data <end> );
free <start> buffer <end> );"	3
466e7ec9-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__int_fgets_add_72 { void badSink(vector<int> dataVector) { int data = dataVector[2]; { int result = data + 1; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"void badSink(vector<int> <start> dataVector <end> );
int result = <start> data <end>  + 1;"	"<start> printIntLine(result) <end> ;
void badSink(vector<int> <start> dataVector <end> );"	"void badSink(vector<int> <start> dataVector <end> );
int result = <start> data + 1 <end> ;"	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  + 1;"	0
820a46ae-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_file_fopen_02 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(1) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = FOPEN <start> data <end> , ""wb+"");
size_t dataLen = <start> strlen(data) <end> ;"	"<start> data = dataBuffer <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
pFile = FOPEN <start> data <end> , ""wb+"");"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	2
669edae1-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__int_rand_postinc_10_bad() { int data; data = 0; if(globalTrue) { data = RAND32(); } if(globalTrue) { { data++; int result = data; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"data = <start> RAND32() <end> ;
<start> printIntLine(result) <end> ;"	"data = <start> RAND32() <end> ;
<start> data <end> ++;"	"<start> data <end> ++;
data = <start> RAND32() <end> ;"	"<start> data++ <end> ;
data = <start> RAND32() <end> ;"	1
5f76fc9e-6c15-11ed-81d4-94e6f77dd552	"void CWE191_Integer_Underflow__short_fscanf_predec_03_bad() { short data; data = 0; if(5==5) { fscanf (stdin, ""%hd"", &data); } if(5==5) { { --data; short result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"- <start> data <end> ;
<start> printIntLine(result) <end> ;"	"<start> data = 0 <end> ;
- <start> data <end> ;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
- <start> data <end> ;"	"- <start> data <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );"	2
a95fd843-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) extern int CWE191_Integer_Underflow__int_fgets_multiply_68_badData; extern int CWE191_Integer_Underflow__int_fgets_multiply_68_goodG2BData; extern int CWE191_Integer_Underflow__int_fgets_multiply_68_goodB2GData; void CWE191_Integer_Underflow__int_fgets_multiply_68b_badSink() { int data = CWE191_Integer_Underflow__int_fgets_multiply_68_badData; if(data < 0) { int result = data * 2; printIntLine(result); } }	where is the vulnerable dataflow from result to printIntLine ?	"<start> printIntLine(result) <end> ;
int data = <start> CWE191_Integer_Underflow__int_fgets_multiply_68_badData <end> ;"	"int data = <start> CWE191_Integer_Underflow__int_fgets_multiply_68_badData <end> ;
int <start> result = data * 2 <end> ;"	"int data = <start> CWE191_Integer_Underflow__int_fgets_multiply_68_badData <end> ;
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
int data = <start> CWE191_Integer_Underflow__int_fgets_multiply_68_badData <end> ;"	2
728a4ffa-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 static void badVaSink(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_54e_badSink(char * data) { badVaSink(data, data); }"	where is the vulnerable dataflow from data to vfprintf ?	"void CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_54e_badSink(char * <start> data <end> );
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);"	"void CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_54e_badSink(char * <start> data <end> );
badVaSink <start> data <end> , data);"	"<start> vfprintf(stdout, data, args) <end> ;
void CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_54e_badSink(char * <start> data <end> );
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);"	"badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
void CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_54e_badSink(char * <start> data <end> );"	0
c01af8bc-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" namespace CWE23_Relative_Path_Traversal__char_connect_socket_ofstream_51 { void badSink(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badSink(data); }"	where is the vulnerable dataflow from data to badSink ?	"badSink <start> data <end> );
replace = <start> strchr(data, '\n') <end> ;"	"<start> badSink(data) <end> ;
badSink <start> data <end> );"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
badSink <start> data <end> );"	"<start> data = dataBuffer <end> ;
badSink <start> data <end> );"	2
656cd3ff-6c15-11ed-81d4-94e6f77dd552	extern int CWE190_Integer_Overflow__int_rand_multiply_68_badData; extern int CWE190_Integer_Overflow__int_rand_multiply_68_goodG2BData; extern int CWE190_Integer_Overflow__int_rand_multiply_68_goodB2GData; void CWE190_Integer_Overflow__int_rand_multiply_68b_badSink() { int data = CWE190_Integer_Overflow__int_rand_multiply_68_badData; if(data > 0) { int result = data * 2; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"int data = <start> CWE190_Integer_Overflow__int_rand_multiply_68_badData <end> ;
int <start> result = data * 2 <end> ;"	"int data = <start> CWE190_Integer_Overflow__int_rand_multiply_68_badData <end> ;
<start> printIntLine(result) <end> ;"	"int data = <start> CWE190_Integer_Overflow__int_rand_multiply_68_badData <end> ;
int result = <start> data <end>  * 2;"	"int result = <start> data <end>  * 2;
int data = <start> CWE190_Integer_Overflow__int_rand_multiply_68_badData <end> ;"	2
525b648a-6c15-11ed-81d4-94e6f77dd552	"typedef union { short unionFirst; short unionSecond; } CWE190_Integer_Overflow__short_fscanf_preinc_34_unionType; void CWE190_Integer_Overflow__short_fscanf_preinc_34_bad() { short data; CWE190_Integer_Overflow__short_fscanf_preinc_34_unionType myUnion; data = 0; fscanf (stdin, ""%hd"", &data); myUnion.unionFirst = data; { short data = myUnion.unionSecond; { ++data; short result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"+ <start> data <end> ;
<start> printIntLine(result) <end> ;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
+ <start> data <end> ;"	"+ <start> data <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );"	"<start> ++data <end> ;
+ <start> data <end> ;"	1
74ee23e0-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" namespace CWE194_Unexpected_Sign_Extension__connect_socket_strncpy_43 { static void badSource(short &data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } void bad() { short data; data = 0; badSource(data); { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> printLine(dest) <end> ;
badSource <start> data <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"printLine <start> dest <end> );
badSource <start> data <end> );
<start> printLine(dest) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSource <start> data <end> );
printLine <start> dest <end> );"	"badSource <start> data <end> );
printLine <start> dest <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	2
453db040-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_square_16_bad() { int data; data = 0; while(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; } while(1) { { int result = data * data; printIntLine(result); } break; } }"	where is the vulnerable dataflow from data ?	"recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);
int result = <start> data <end>  * data;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  * data;"	"int result = <start> data <end>  * data;
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
data = <start> atoi(inputBuffer) <end> ;"	1
cbf237b1-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_console_fopen_22 { int badGlobal = 0; char * badSource(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; badGlobal = 1; data = badSource(data); { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } ; }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
data = <start> badSource <end> (data);"	"<start> data = dataBuffer <end> ;
data = <start> badSource <end> (data);"	"<start> data = badSource(data) <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"data = <start> badSource <end> (data);
pFile = FOPEN <start> data <end> , ""wb+"");"	3
a830bf71-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_connect_socket_multiply_14_bad() { int data; data = 0; if(globalFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalFive==5) { if(data < 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printIntLine(result) <end> ;"	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
if <start> data < 0 <end> ) ;"	0
5f76fc87-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_listen_socket_predec_17_bad() { int i,j; int data; data = 0; for(i = 0; i < 1; i++) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } for(j = 0; j < 1; j++) { { --data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"- <start> data <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int <start> result = data <end> ;"	"<start> data = atoi(inputBuffer) <end> ;
- <start> data <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
- <start> data <end> ;"	3
6dc61501-6c15-11ed-81d4-94e6f77dd552	namespace CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_81 { static void badVaSink(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_81_bad::action(char * data) const { badVaSink(data, data); } }	where is the vulnerable dataflow from data to vprintf ?	"static void badVaSink(char * <start> data <end> , ...);
badVaSink <start> data <end> , data);
<start> vprintf(data, args) <end> ;
void CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_81_bad::action(char * <start> data <end> ) const;"	"void CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_81_bad::action(char * <start> data <end> ) const;
badVaSink <start> data <end> , data);"	"static void badVaSink(char * <start> data <end> , ...);
badVaSink <start> data <end> , data);
void CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_81_bad::action(char * <start> data <end> ) const;
vprintf <start> data <end> , args);"	"void CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_81_bad::action(char * <start> data <end> ) const;
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
vprintf <start> data <end> , args);"	3
833ac92e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_listen_socket_open_02 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"size_t dataLen = <start> strlen(data) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"fileDesc = OPEN(data, O_RDWR|O_CREAT, <start> S_IREAD|S_IWRITE <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	1
abc37508-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int CWE191_Integer_Underflow__int_connect_socket_postdec_45_badData; static int CWE191_Integer_Underflow__int_connect_socket_postdec_45_goodG2BData; static int CWE191_Integer_Underflow__int_connect_socket_postdec_45_goodB2GData; static void badSink() { int data = CWE191_Integer_Underflow__int_connect_socket_postdec_45_badData; { data--; int result = data; printIntLine(result); } } void CWE191_Integer_Underflow__int_connect_socket_postdec_45_bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE191_Integer_Underflow__int_connect_socket_postdec_45_badData = data; badSink(); }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int data = <start> CWE191_Integer_Underflow__int_connect_socket_postdec_45_badData <end> ;
<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );
<start> CWE191_Integer_Underflow__int_connect_socket_postdec_45_badData = data <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> CWE191_Integer_Underflow__int_connect_socket_postdec_45_badData = data <end> ;
static int <start> CWE191_Integer_Underflow__int_connect_socket_postdec_45_badData <end> ;
int data = <start> CWE191_Integer_Underflow__int_connect_socket_postdec_45_badData <end> ;
printIntLine <start> result <end> );"	"<start> CWE191_Integer_Underflow__int_connect_socket_postdec_45_badData = data <end> ;
printIntLine <start> result <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"int data = <start> CWE191_Integer_Underflow__int_connect_socket_postdec_45_badData <end> ;
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
static int <start> CWE191_Integer_Underflow__int_connect_socket_postdec_45_badData <end> ;
<start> CWE191_Integer_Underflow__int_connect_socket_postdec_45_badData = data <end> ;
printIntLine <start> result <end> );"	1
b41b879e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 20 #define IP_ADDRESS ""127.0.0.1"" void CWE369_Divide_by_Zero__float_connect_socket_16_bad() { float data; data = 0.0F; while(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = (float)atof(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; } while(1) { { int result = (int)(100.0 / data); printIntLine(result); } break; } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"<start> printIntLine(result) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	1
9187cbf6-6c15-11ed-81d4-94e6f77dd552	"#define SEARCH_CHAR 'S' static int staticFive = 5; void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_console_07_bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\0'; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } if(staticFive==5) { for (; *data != '\0'; data++) { if (*data == SEARCH_CHAR) { printLine(""We have a match!""); break; } } free(data); } }"	where is the vulnerable dataflow from data to free ?	"free <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
free <start> data <end> );"	"for (; *data != '\0'; <start> data++ <end> );
free <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
if  <start> data == NULL <end> ) {exit(-1);};"	1
b1b8083c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_63b_badSink(int * dataPtr) { int data = *dataPtr; { short shortData = (short)data; printShortLine(shortData); } }"	where is the vulnerable dataflow from shortData to printShortLine ?	"void CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_63b_badSink(int * <start> dataPtr <end> );
printShortLine <start> shortData <end> );"	"void CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_63b_badSink(int * <start> dataPtr <end> );
short shortData = <start> (short)data <end> ;"	"void CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_63b_badSink(int * <start> dataPtr <end> );
<start> printShortLine(shortData) <end> ;"	"printShortLine <start> shortData <end> );
void CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_63b_badSink(int * <start> dataPtr <end> );"	0
bb49c5a7-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #define EXECLP _execlp #else #define EXECLP execlp #endif void CWE78_OS_Command_Injection__char_console_execlp_16_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; while(1) { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } break; } EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECLP ?	"dataLen = <start> strlen(data) <end> ;
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
size_t dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
<start> EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL) <end> ;"	1
47a2a846-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__int_fscanf_multiply_51b_badSink(int data) { if(data > 0) { int result = data * 2; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"int <start> result = data * 2 <end> ;
void CWE190_Integer_Overflow__int_fscanf_multiply_51b_badSink(int <start> data <end> );"	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  * 2;"	"void CWE190_Integer_Overflow__int_fscanf_multiply_51b_badSink(int <start> data <end> );
int result = <start> data <end>  * 2;"	"void CWE190_Integer_Overflow__int_fscanf_multiply_51b_badSink(int <start> data <end> );
int result = <start> data * 2 <end> ;"	2
80d98729-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_console_open_15 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; switch(6) { case 6: { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } break; default: printLine(""Benign, fixed string""); break; } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
size_t dataLen = <start> strlen(data) <end> ;"	"fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	0
c136625d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif namespace CWE23_Relative_Path_Traversal__char_console_ifstream_03 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(5==5) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
inputFile.open((char * <start> data <end> );"	"dataLen = <start> strlen(data) <end> ;
inputFile.open((char * <start> data <end> );"	"inputFile.open((char * <start> data <end> );
<start> data = dataBuffer <end> ;"	1
715a3bf7-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif void CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_52c_badSink(char * data) { { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"void CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_52c_badSink(char * <start> data <end> );
printLine <start> dest <end> );"	"void CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_52c_badSink(char * <start> data <end> );
<start> printLine(dest) <end> ;"	"printLine <start> dest <end> );
void CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_52c_badSink(char * <start> data <end> );"	"<start> SNPRINTF(dest, 100-1, data) <end> ;
void CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_52c_badSink(char * <start> data <end> );"	0
d0b64f03-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_file_open_09 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(GLOBAL_CONST_TRUE) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	0
9059f398-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_10_bad() { int data; data = -1; if(globalTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { size_t i; int *intPointer; intPointer = (int*)malloc(data * sizeof(int)); if (intPointer == NULL) {exit(-1);} for (i = 0; i < (size_t)data; i++) { intPointer[i] = 0; } printIntLine(intPointer[0]); free(intPointer); } }"	where is the vulnerable dataflow from data to malloc ?	"intPointer = (int*)malloc <start> data * sizeof(int) <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	"<start> data = atoi(inputBuffer) <end> ;
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	"intPointer = (int*)malloc <start> data * sizeof(int) <end> );
intPointer = (int* <start> malloc(data * sizeof(int)) <end> ;"	1
abc3753a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticTrue = 1; static int staticFalse = 0; void CWE191_Integer_Underflow__int_listen_socket_postdec_05_bad() { int data; data = 0; if(staticTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticTrue) { { data--; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"<start> printIntLine(result) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"printIntLine <start> result <end> );
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	1
c72d5d3e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_file_open_63 { void badSink(char * * dataPtr) { char * data = *dataPtr; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"void badSink(char * * <start> dataPtr <end> );
char <start> * data = *dataPtr <end> ;"	"void badSink(char * * <start> dataPtr <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
void badSink(char * * <start> dataPtr <end> );"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	1
d31a24f5-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 static const int STATIC_CONST_FIVE = 5; namespace CWE36_Absolute_Path_Traversal__char_listen_socket_ofstream_06 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(STATIC_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"replace = <start> strchr(data, '\n') <end> ;
outputFile.open((char * <start> data <end> );"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
outputFile.open((char * <start> data <end> );"	"recvResult = recv(acceptSocket, (char *)(data + dataLen), <start> sizeof(char) * (FILENAME_MAX - dataLen - 1) <end> , 0);
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
replace = <start> strchr(data, '\n') <end> ;"	1
833ac953-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_listen_socket_open_73 { void badSink(list<char *> dataList) { char * data = dataList.back(); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"void badSink(list<char *> <start> dataList <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);
void badSink(list<char *> <start> dataList <end> );"	"void badSink(list<char *> <start> dataList <end> );
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
void badSink(list<char *> <start> dataList <end> );"	0
60db83b4-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__char_rand_multiply_03_bad() { char data; data = ' '; if(5==5) { data = (char)RAND32(); } if(5==5) { if(data > 0) { char result = data * 2; printHexCharLine(result); } } }	where is the vulnerable dataflow from data ?	"data = (char <start> RAND32() <end> ;
char <start> result = data * 2 <end> ;"	"data = (char <start> RAND32() <end> ;
char result = <start> data <end>  * 2;"	"<start> printHexCharLine(result) <end> ;
char result = <start> data <end>  * 2;"	"char result = <start> data <end>  * 2;
data = (char <start> RAND32() <end> ;"	1
c4cd6f84-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif namespace CWE23_Relative_Path_Traversal__char_file_ifstream_02 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(1) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"inputFile.open((char * <start> data <end> );
<start> data = dataBuffer <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
inputFile.open((char * <start> data <end> );"	"inputFile.open((char * <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"size_t dataLen = <start> strlen(data) <end> ;
inputFile.open((char * <start> data <end> );"	1
85b15ecf-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; void CWE369_Divide_by_Zero__int_connect_socket_modulo_04_bad() { int data; data = -1; if(STATIC_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(STATIC_CONST_TRUE) { printIntLine(100 % data); } }"	where is the vulnerable dataflow from data to printIntLine ?	"printIntLine <start> 100 % data <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"data = <start> atoi(inputBuffer) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> 100 % data <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data = -1 <end> ;"	2
4b34afd1-6c15-11ed-81d4-94e6f77dd552	"static int staticFive = 5; void CWE190_Integer_Overflow__short_fscanf_multiply_07_bad() { short data; data = 0; if(staticFive==5) { fscanf (stdin, ""%hd"", &data); } if(staticFive==5) { if(data > 0) { short result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"short result = <start> data <end>  * 2;
<start> data = 0 <end> ;"	"if <start> data > 0 <end> ) ;
short result = <start> data <end>  * 2;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
short result = <start> data <end>  * 2;"	"<start> printIntLine(result) <end> ;
short result = <start> data <end>  * 2;"	2
47a2a837-6c15-11ed-81d4-94e6f77dd552	"void CWE190_Integer_Overflow__int_fscanf_multiply_13_bad() { int data; data = 0; if(GLOBAL_CONST_FIVE==5) { fscanf(stdin, ""%d"", &data); } if(GLOBAL_CONST_FIVE==5) { if(data > 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
fscanf(stdin, ""%d"", <start> &data <end> );"	"fscanf(stdin, ""%d"", <start> &data <end> );
int <start> result = data * 2 <end> ;"	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  * 2;"	"fscanf(stdin, ""%d"", <start> &data <end> );
int result = <start> data <end>  * 2;"	3
7d44fcad-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_02_bad() { int data; data = -1; if(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }"	where is the vulnerable dataflow from data to malloc ?	"if  <start> acceptSocket == SOCKET_ERROR <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"if  <start> data < 100 <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
char * dataBuffer = (char *)malloc <start> data <end> );"	"char * dataBuffer = (char *)malloc <start> data <end> );
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	2
9fe7ad3f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_add_03_bad() { int data; data = 0; if(5==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(5==5) { { int result = data + 1; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
data = <start> atoi(inputBuffer) <end> ;"	"<start> data = 0 <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	3
8f278a36-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define PATH_SZ 100 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define PATH_SZ PATH_MAX #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 void CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__listen_accept_bind_16_bad() { while(1) { { char data[100] = """"; #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[recvResult] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif printLine(data); } break; } }"	where is the vulnerable dataflow from data to printLine ?	"replace = <start> strchr(data, '\r') <end> ;
printLine <start> data <end> );"	"recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);
size_t dataLen = <start> strlen(data) <end> ;"	"<start> printLine(data) <end> ;
recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);"	"recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);
printLine <start> data <end> );"	3
5d16c9c8-6c15-11ed-81d4-94e6f77dd552	"static short badSource(short data) { fscanf (stdin, ""%hd"", &data); return data; } void CWE191_Integer_Underflow__short_fscanf_postdec_42_bad() { short data; data = 0; data = badSource(data); { data--; short result = data; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"<start> data <end> --;
static short <start> badSource <end> (short data);
fscanf (stdin, ""%hd"", <start> &data <end> );
short <start> result = data <end> ;"	"static short <start> badSource <end> (short data);
data = <start> badSource <end> (data);
<start> data <end> --;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
static short <start> badSource <end> (short data);
data = <start> badSource <end> (data);
<start> data <end> --;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
data = <start> badSource <end> (data);
static short <start> badSource <end> (short data);
<start> printIntLine(result) <end> ;"	2
669edab2-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__char_rand_postinc_03_bad() { char data; data = ' '; if(5==5) { data = (char)RAND32(); } if(5==5) { { data++; char result = data; printHexCharLine(result); } } }	where is the vulnerable dataflow from data ?	"char <start> result = data <end> ;
<start> data <end> ++;"	"<start> data++ <end> ;
data = (char <start> RAND32() <end> ;"	"<start> printHexCharLine(result) <end> ;
data = (char <start> RAND32() <end> ;"	"data = (char <start> RAND32() <end> ;
<start> data <end> ++;"	3
4a02110e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_multiply_53d_badSink(int data) { if(data > 0) { int result = data * 2; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"void CWE190_Integer_Overflow__int_listen_socket_multiply_53d_badSink(int <start> data <end> );
int result = <start> data <end>  * 2;"	"int result = <start> data <end>  * 2;
<start> printIntLine(result) <end> ;"	"int <start> result = data * 2 <end> ;
void CWE190_Integer_Overflow__int_listen_socket_multiply_53d_badSink(int <start> data <end> );"	"int result = <start> data <end>  * 2;
void CWE190_Integer_Overflow__int_listen_socket_multiply_53d_badSink(int <start> data <end> );"	0
a36a78e3-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_add_02_bad() { int data; data = 0; if(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(1) { { int result = data + 1; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"data = <start> atoi(inputBuffer) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printIntLine(result) <end> ;"	"printIntLine <start> result <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	0
78800fdd-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 8 void CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_14_bad() { short data; data = 0; if(globalFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"char <start> dest[100] = """" <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> tempInt = atoi(inputBuffer) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data = -1 <end> ;"	1
78800fb3-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 8 void CWE194_Unexpected_Sign_Extension__listen_socket_memmove_16_bad() { short data; data = 0; while(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
tempInt = <start> atoi(inputBuffer) <end> ;"	"<start> memmove(dest, source, data) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
if  <start> tempInt > SHRT_MAX <end>  || tempInt < SHRT_MIN);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	3
728a5042-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" void CWE194_Unexpected_Sign_Extension__connect_socket_malloc_17_bad() { int i; short data; data = 0; for(i = 0; i < 1; i++) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }"	where is the vulnerable dataflow from data to malloc ?	"<start> free(dataBuffer) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"char * dataBuffer = (char *)malloc <start> data <end> );
<start> free(dataBuffer) <end> ;"	"<start> tempInt = atoi(inputBuffer) <end> ;
char * dataBuffer = (char *)malloc <start> data <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
char * dataBuffer = (char *)malloc <start> data <end> );"	3
73bc8147-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" void CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_14_bad() { short data; data = 0; if(globalFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"<start> memcpy(dest, source, data) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
tempInt = <start> atoi(inputBuffer) <end> ;"	"recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);
printLine <start> dest <end> );"	0
525b6443-6c15-11ed-81d4-94e6f77dd552	"void CWE190_Integer_Overflow__int_fscanf_preinc_16_bad() { int data; data = 0; while(1) { fscanf(stdin, ""%d"", &data); break; } while(1) { { ++data; int result = data; printIntLine(result); } break; } }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
fscanf(stdin, ""%d"", <start> &data <end> );"	"<start> printIntLine(result) <end> ;
+ <start> data <end> ;"	"+ <start> data <end> ;
fscanf(stdin, ""%d"", <start> &data <end> );"	"fscanf(stdin, ""%d"", <start> &data <end> );
+ <start> data <end> ;"	3
951c5e67-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FULL_COMMAND ""dir "" #else #define FULL_COMMAND ""ls "" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define POPEN _popen #define PCLOSE _pclose #else #define POPEN popen #define PCLOSE pclose #endif static int staticFive = 5; void CWE78_OS_Command_Injection__char_connect_socket_popen_07_bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; if(staticFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { FILE *pipe; pipe = POPEN(data, ""w""); if (pipe != NULL) { PCLOSE(pipe); } } }"	where is the vulnerable dataflow from data to POPEN ?	"replace = <start> strchr(data, '\n') <end> ;
pipe = POPEN <start> data <end> , ""w"");"	"replace = <start> strchr(data, '\r') <end> ;
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
size_t dataLen = <start> strlen(data) <end> ;"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
pipe = POPEN <start> data <end> , ""w"");"	3
9187cc1e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #define SEARCH_CHAR 'S' void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_file_11_bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\0'; { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } if(globalReturnsTrue()) { for (; *data != '\0'; data++) { if (*data == SEARCH_CHAR) { printLine(""We have a match!""); break; } } free(data); } }"	where is the vulnerable dataflow from data to free ?	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
free <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
if  <start> data == NULL <end> ) {exit(-1);};"	"<start> free(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
size_t dataLen = <start> strlen(data) <end> ;"	0
4a021112-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_multiply_63b_badSink(int * dataPtr) { int data = *dataPtr; if(data > 0) { int result = data * 2; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"int <start> result = data * 2 <end> ;
void CWE190_Integer_Overflow__int_listen_socket_multiply_63b_badSink(int * <start> dataPtr <end> );"	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  * 2;"	"void CWE190_Integer_Overflow__int_listen_socket_multiply_63b_badSink(int * <start> dataPtr <end> );
int result = <start> data <end>  * 2;"	"int result = <start> data <end>  * 2;
void CWE190_Integer_Overflow__int_listen_socket_multiply_63b_badSink(int * <start> dataPtr <end> );"	2
a1094914-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_square_31_bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { int dataCopy = data; int data = dataCopy; { int result = data * data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
int result = <start> data * data <end> ;"	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data * data <end> ;"	0
7d44fcbe-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int badStatic = 0; static int badSource(int data) { if(badStatic) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } return data; } void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_21_bad() { int data; data = -1; badStatic = 1; data = badSource(data); if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }"	where is the vulnerable dataflow from data to malloc ?	"static int <start> badSource <end> (int data);
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> memset(dataBuffer, 'A', data-1) <end> ;
data = <start> badSource <end> (data);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static int <start> badSource <end> (int data);
data = <start> badSource <end> (data);
char * dataBuffer = (char *)malloc <start> data <end> );"	"char * dataBuffer = (char *)malloc <start> data <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
data = <start> badSource <end> (data);
static int <start> badSource <end> (int data);"	"char * dataBuffer = <start> (char *)malloc(data) <end> ;
data = <start> badSource <end> (data);
static int <start> badSource <end> (int data);
char * dataBuffer = (char *)malloc <start> data <end> );"	1
93ece2d7-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING ""hello"" void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_09_bad() { size_t data; data = 0; if(GLOBAL_CONST_TRUE) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = strtoul(inputBuffer, NULL, 0); } else { printLine(""fgets() failed.""); } } } if(GLOBAL_CONST_TRUE) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); } else { printLine(""Input is less than the length of the source string""); } } } }"	where is the vulnerable dataflow from data to malloc ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
myString = (char *)malloc <start> data*sizeof(char) <end> );"	"myString = (char *)malloc <start> data*sizeof(char) <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
if  <start> myString == NULL <end> ) {exit(-1);};"	"<start> data = strtoul(inputBuffer, NULL, 0) <end> ;
myString = (char *)malloc <start> data*sizeof(char) <end> );"	0
d31a2507-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 namespace CWE36_Absolute_Path_Traversal__char_listen_socket_ofstream_43 { void badSource(char * &data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; badSource(data); { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"if  <start> recvResult == SOCKET_ERROR <end>  || recvResult == 0);
badSource <start> data <end> );
outputFile.open((char * <start> data <end> );"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
badSource <start> data <end> );
outputFile.open((char * <start> data <end> );"	"replace = <start> strchr(data, '\n') <end> ;
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
badSource <start> data <end> );"	"outputFile.open((char * <start> data <end> );
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	1
86cea15d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE369_Divide_by_Zero__int_listen_socket_modulo_01_bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } printIntLine(100 % data); }"	where is the vulnerable dataflow from data to printIntLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> 100 % data <end> );"	"printIntLine <start> 100 % data <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"<start> recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> 100 % data <end> );"	"printIntLine <start> 100 % data <end> );
<start> data = atoi(inputBuffer) <end> ;"	0
cac216d9-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_connect_socket_open_15 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; switch(6) { case 6: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; default: printLine(""Benign, fixed string""); break; } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
char <start> dataBuffer[FILENAME_MAX] = """" <end> ;"	"recvResult = <start> recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0) <end> ;
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	1
584fa87b-6c15-11ed-81d4-94e6f77dd552	extern int CWE191_Integer_Underflow__int_listen_socket_sub_22_badGlobal; void CWE191_Integer_Underflow__int_listen_socket_sub_22_badSink(int data) { if(CWE191_Integer_Underflow__int_listen_socket_sub_22_badGlobal) { { int result = data - 1; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"int <start> result = data - 1 <end> ;
void CWE191_Integer_Underflow__int_listen_socket_sub_22_badSink(int <start> data <end> );"	"void CWE191_Integer_Underflow__int_listen_socket_sub_22_badSink(int <start> data <end> );
int result = <start> data <end>  - 1;"	"<start> printIntLine(result) <end> ;
void CWE191_Integer_Underflow__int_listen_socket_sub_22_badSink(int <start> data <end> );"	"void CWE191_Integer_Underflow__int_listen_socket_sub_22_badSink(int <start> data <end> );
int result = <start> data - 1 <end> ;"	1
b08640bd-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE197_Numeric_Truncation_Error__int_fgets_to_char_41_badSink(int data) { { char charData = (char)data; printHexCharLine(charData); } } void CWE197_Numeric_Truncation_Error__int_fgets_to_char_41_bad() { int data; data = -1; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } CWE197_Numeric_Truncation_Error__int_fgets_to_char_41_badSink(data); }"	where is the vulnerable dataflow from charData to printHexCharLine ?	"char <start> charData = (char)data <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
CWE197_Numeric_Truncation_Error__int_fgets_to_char_41_badSink <start> data <end> );
void CWE197_Numeric_Truncation_Error__int_fgets_to_char_41_badSink(int <start> data <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
char <start> charData = (char)data <end> ;
CWE197_Numeric_Truncation_Error__int_fgets_to_char_41_badSink <start> data <end> );
printHexCharLine <start> charData <end> );"	"<start> printHexCharLine(charData) <end> ;
printHexCharLine <start> charData <end> );
CWE197_Numeric_Truncation_Error__int_fgets_to_char_41_badSink <start> data <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
CWE197_Numeric_Truncation_Error__int_fgets_to_char_41_badSink <start> data <end> );
void CWE197_Numeric_Truncation_Error__int_fgets_to_char_41_badSink(int <start> data <end> );
printHexCharLine <start> charData <end> );"	3
a23a3e28-6c15-11ed-81d4-94e6f77dd552	extern int CWE190_Integer_Overflow__int_fgets_multiply_22_badGlobal; void CWE190_Integer_Overflow__int_fgets_multiply_22_badSink(int data) { if(CWE190_Integer_Overflow__int_fgets_multiply_22_badGlobal) { if(data > 0) { int result = data * 2; printIntLine(result); } } }	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
void CWE190_Integer_Overflow__int_fgets_multiply_22_badSink(int <start> data <end> );"	"<start> printIntLine(result) <end> ;
void CWE190_Integer_Overflow__int_fgets_multiply_22_badSink(int <start> data <end> );"	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	"void CWE190_Integer_Overflow__int_fgets_multiply_22_badSink(int <start> data <end> );
printIntLine <start> result <end> );"	3
d31a24ee-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 namespace CWE36_Absolute_Path_Traversal__char_listen_socket_ifstream_54 { void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badSink_b(data); }"	where is the vulnerable dataflow from data to badSink_b ?	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
replace = <start> strchr(data, '\n') <end> ;"	"<start> badSink_b(data) <end> ;
badSink_b <start> data <end> );"	"size_t dataLen = <start> strlen(data) <end> ;
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
badSink_b <start> data <end> );"	3
70279c0d-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif void CWE134_Uncontrolled_Format_String__char_file_snprintf_52c_badSink(char * data) { { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"printLine <start> dest <end> );
<start> printLine(dest) <end> ;"	"void CWE134_Uncontrolled_Format_String__char_file_snprintf_52c_badSink(char * <start> data <end> );
printLine <start> dest <end> );"	"printLine <start> dest <end> );
void CWE134_Uncontrolled_Format_String__char_file_snprintf_52c_badSink(char * <start> data <end> );"	"void CWE134_Uncontrolled_Format_String__char_file_snprintf_52c_badSink(char * <start> data <end> );
<start> printLine(dest) <end> ;"	1
774f5841-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 8 void CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_16_bad() { short data; data = 0; while(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"printLine <start> dest <end> );
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"if  <start> data < 100 <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"<start> memcpy(dest, source, data) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	1
73bc8129-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" void CWE194_Unexpected_Sign_Extension__connect_socket_malloc_51b_badSink(short data) { if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }"	where is the vulnerable dataflow from data to malloc ?	"char * dataBuffer = (char * <start> malloc(data) <end> ;
void CWE194_Unexpected_Sign_Extension__connect_socket_malloc_51b_badSink(short <start> data <end> );"	"char * dataBuffer = (char *)malloc <start> data <end> );
void CWE194_Unexpected_Sign_Extension__connect_socket_malloc_51b_badSink(short <start> data <end> );"	"void CWE194_Unexpected_Sign_Extension__connect_socket_malloc_51b_badSink(short <start> data <end> );
char * dataBuffer = (char *)malloc <start> data <end> );"	"<start> free(dataBuffer) <end> ;
char * dataBuffer = (char *)malloc <start> data <end> );"	2
b8e2bdb3-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define NEW_PATH ""%SystemRoot%\\system32"" #define PUTENV _putenv #else #define NEW_PATH ""/bin"" #define PUTENV putenv #endif namespace CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_73 { void badSink(list<char *> dataList) { char * data = dataList.back(); PUTENV(data); }"	where is the vulnerable dataflow from data to PUTENV ?	"void badSink(list<char *> <start> dataList <end> );
<start> PUTENV(data) <end> ;"	"PUTENV <start> data <end> );
void badSink(list<char *> <start> dataList <end> );"	"void badSink(list<char *> <start> dataList <end> );
char <start> * data = dataList.back() <end> ;"	"void badSink(list<char *> <start> dataList <end> );
PUTENV <start> data <end> );"	3
ce547d23-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_environment_fopen_22 { int badGlobal = 0; char * badSource(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; badGlobal = 1; data = badSource(data); { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } ; }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = FOPEN <start> data <end> , ""wb+"");
data = <start> badSource <end> (data);"	"pFile = FOPEN <start> data <end> , ""wb+"");
data = <start> badSource(data) <end> ;"	"data = <start> badSource <end> (data);
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	2
7fa68e11-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_51b_badSink(int data) { { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_51b_badSink(int <start> data <end> );
printLine <start> dest <end> );"	"char <start> dest[100] = """" <end> ;
printLine <start> dest <end> );"	"printLine <start> dest <end> );
void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_51b_badSink(int <start> data <end> );"	"<start> strncpy(dest, source, data) <end> ;
printLine <start> dest <end> );"	0
466e7f0b-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_square_31_bad() { int data; data = 0; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } { int dataCopy = data; int data = dataCopy; { int result = data * data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
int result = <start> data <end>  * data;"	"int result = <start> data <end>  * data;
<start> printIntLine(result) <end> ;"	"int <start> result = data * data <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
data = <start> atoi(inputBuffer) <end> ;"	0
a49c4f81-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__int_listen_socket_square_62 { void badSource(int &data); void bad() { int data; data = 0; badSource(data); { int result = data * data; printIntLine(result); } }	where is the vulnerable dataflow from result to printIntLine ?	"badSource <start> data <end> );
printIntLine <start> result <end> );"	"<start> printIntLine(result) <end> ;
badSource <start> data <end> );"	"printIntLine <start> result <end> );
int result = <start> data * data <end> ;"	"<start> data = 0 <end> ;
printIntLine <start> result <end> );"	0
9059f3c0-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 256 void CWE681_Incorrect_Conversion_Between_Numeric_Types__double2float_10_bad() { if(globalTrue) { { char inputBuffer[CHAR_ARRAY_SIZE]; double doubleNumber = 0; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { doubleNumber = atof(inputBuffer); } else { printLine(""fgets() failed.""); } printFloatLine((float)doubleNumber); } } }"	where is the vulnerable dataflow from (float)doubleNumber to printFloatLine ?	"printFloatLine <start> (float)doubleNumber <end> );
if  <start> fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) <end>  != NULL);"	"printFloatLine <start> (float)doubleNumber <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"doubleNumber = <start> atof(inputBuffer) <end> ;
printFloatLine <start> (float)doubleNumber <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printFloatLine <start> (float)doubleNumber <end> );"	3
c8600af9-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; namespace CWE23_Relative_Path_Traversal__char_listen_socket_open_04 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(STATIC_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"<start> data = dataBuffer <end> ;
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = OPEN(data, O_RDWR|O_CREAT, <start> S_IREAD|S_IWRITE <end> );"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	3
80d98727-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_console_open_13 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(GLOBAL_CONST_FIVE==5) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"<start> data = dataBuffer <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	2
48d25daf-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_add_31_bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { int dataCopy = data; int data = dataCopy; { int result = data + 1; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  + 1;"	"int result = <start> data <end>  + 1;
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"int result = <start> data <end>  + 1;
if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );"	"<start> data = atoi(inputBuffer) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	0
79b2752b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int badStatic = 0; static int badSource(int data) { if(badStatic) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } return data; } void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_21_bad() { int data; data = -1; badStatic = 1; data = badSource(data); if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }"	where is the vulnerable dataflow from data to malloc ?	"char * dataBuffer = (char * <start> malloc(data) <end> ;
data = <start> badSource <end> (data);
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
char * dataBuffer = (char *)malloc <start> data <end> );"	"static int <start> badSource <end> (int data);
data = <start> badSource <end> (data);
char * dataBuffer = (char *)malloc <start> data <end> );
char * dataBuffer = (char * <start> malloc(data) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static int <start> badSource <end> (int data);
data = <start> badSource <end> (data);
char * dataBuffer = (char *)malloc <start> data <end> );"	"static int <start> badSource <end> (int data);
<start> printLine(dataBuffer) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
data = <start> badSource <end> (data);"	2
b68484de-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif namespace CWE36_Absolute_Path_Traversal__char_file_fopen_81 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } const CWE36_Absolute_Path_Traversal__char_file_fopen_81_base& baseObject = CWE36_Absolute_Path_Traversal__char_file_fopen_81_bad(); baseObject.action(data); }"	where is the vulnerable dataflow from data to action ?	"baseObject.action <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
baseObject.action <start> data <end> );"	"size_t dataLen = <start> strlen(data) <end> ;
baseObject.action <start> data <end> );"	"baseObject.action <start> data <end> );
char <start> dataBuffer[FILENAME_MAX] = """" <end> ;"	1
584fa89b-6c15-11ed-81d4-94e6f77dd552	"void CWE191_Integer_Underflow__short_fscanf_multiply_10_bad() { short data; data = 0; if(globalTrue) { fscanf (stdin, ""%hd"", &data); } if(globalTrue) { if(data < 0) { short result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"fscanf (stdin, ""%hd"", <start> &data <end> );
short result = <start> data <end>  * 2;"	"<start> printIntLine(result) <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );"	"short result = <start> data <end>  * 2;
<start> printIntLine(result) <end> ;"	"short result = <start> data <end>  * 2;
if <start> data < 0 <end> ) ;"	0
79b2751c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_04_bad() { int data; data = -1; if(STATIC_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }"	where is the vulnerable dataflow from data to malloc ?	"char * dataBuffer = (char *)malloc <start> data <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"<start> memset(dataBuffer, 'A', data-1) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
char * dataBuffer = (char *)malloc <start> data <end> );"	"char * dataBuffer = (char *)malloc <start> data <end> );
<start> free(dataBuffer) <end> ;"	2
4ff7826a-6c15-11ed-81d4-94e6f77dd552	"void CWE190_Integer_Overflow__short_fscanf_postinc_10_bad() { short data; data = 0; if(globalTrue) { fscanf (stdin, ""%hd"", &data); } if(globalTrue) { { data++; short result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"fscanf (stdin, ""%hd"", <start> &data <end> );
<start> data <end> ++;"	"<start> data <end> ++;
fscanf (stdin, ""%hd"", <start> &data <end> );"	"fscanf (stdin, ""%hd"", <start> &data <end> );
<start> data = 0 <end> ;"	"<start> data <end> ++;
short <start> result = data <end> ;"	0
656cd3e5-6c15-11ed-81d4-94e6f77dd552	"void CWE190_Integer_Overflow__int_rand_multiply_12_bad() { int data; data = 0; if(globalReturnsTrueOrFalse()) { data = RAND32(); } else { data = 2; } if(globalReturnsTrueOrFalse()) { if(data > 0) { int result = data * 2; printIntLine(result); } } else { if(data > 0) { if (data < (INT_MAX/2)) { int result = data * 2; printIntLine(result); } else { printLine(""data value is too large to perform arithmetic safely.""); } } } }"	where is the vulnerable dataflow from data ?	"int result = <start> data * 2 <end> ;
data = <start> RAND32() <end> ;"	"data = <start> RAND32() <end> ;
int result = <start> data <end>  * 2;"	"data = <start> RAND32() <end> ;
<start> printIntLine(result) <end> ;"	"data = <start> RAND32() <end> ;
int <start> result = data * 2 <end> ;"	1
69161b57-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__short_rand_preinc_13_bad() { short data; data = 0; if(GLOBAL_CONST_FIVE==5) { data = (short)RAND32(); } if(GLOBAL_CONST_FIVE==5) { { ++data; short result = data; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"+ <start> data <end> ;
data = (short <start> RAND32() <end> ;"	"<start> ++data <end> ;
data = (short <start> RAND32() <end> ;"	"+ <start> data <end> ;
<start> printIntLine(result) <end> ;"	"data = (short <start> RAND32() <end> ;
+ <start> data <end> ;"	3
a10948f3-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) int CWE190_Integer_Overflow__int_connect_socket_multiply_61b_badSource(int data); void CWE190_Integer_Overflow__int_connect_socket_multiply_61_bad() { int data; data = 0; data = CWE190_Integer_Overflow__int_connect_socket_multiply_61b_badSource(data); if(data > 0) { int result = data * 2; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"data = <start> CWE190_Integer_Overflow__int_connect_socket_multiply_61b_badSource <end> (data);
printIntLine <start> result <end> );"	"<start> printIntLine(result) <end> ;
data = <start> CWE190_Integer_Overflow__int_connect_socket_multiply_61b_badSource <end> (data);"	"data = <start> CWE190_Integer_Overflow__int_connect_socket_multiply_61b_badSource <end> (data);
if <start> data > 0 <end> ) ;"	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	0
87ff9857-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_connect_socket_fopen_62 { void badSource(char * &data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; badSource(data); { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"badSource <start> data <end> );
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	"<start> badSource(data) <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
badSource <start> data <end> );"	"badSource <start> data <end> );
pFile = FOPEN <start> data <end> , ""wb+"");"	3
571e97fb-6c15-11ed-81d4-94e6f77dd552	"static int staticTrue = 1; static int staticFalse = 0; void CWE191_Integer_Underflow__int_fscanf_multiply_05_bad() { int data; data = 0; if(staticTrue) { fscanf(stdin, ""%d"", &data); } if(staticTrue) { if(data < 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"fscanf(stdin, ""%d"", <start> &data <end> );
<start> printIntLine(result) <end> ;"	"int <start> result = data * 2 <end> ;
fscanf(stdin, ""%d"", <start> &data <end> );"	"int result = <start> data <end>  * 2;
fscanf(stdin, ""%d"", <start> &data <end> );"	"fscanf(stdin, ""%d"", <start> &data <end> );
int result = <start> data <end>  * 2;"	3
61da66f0-6c15-11ed-81d4-94e6f77dd552	static char CWE190_Integer_Overflow__char_rand_square_45_badData; static char CWE190_Integer_Overflow__char_rand_square_45_goodG2BData; static char CWE190_Integer_Overflow__char_rand_square_45_goodB2GData; static void badSink() { char data = CWE190_Integer_Overflow__char_rand_square_45_badData; { char result = data * data; printHexCharLine(result); } } void CWE190_Integer_Overflow__char_rand_square_45_bad() { char data; data = ' '; data = (char)RAND32(); CWE190_Integer_Overflow__char_rand_square_45_badData = data; badSink(); }	where is the vulnerable dataflow from data ?	"data = (char <start> RAND32() <end> ;
<start> CWE190_Integer_Overflow__char_rand_square_45_badData = data <end> ;
static char <start> CWE190_Integer_Overflow__char_rand_square_45_badData <end> ;
char data = <start> CWE190_Integer_Overflow__char_rand_square_45_badData <end> ;
char result = <start> data <end>  * data;"	"<start> printHexCharLine(result) <end> ;
char data = <start> CWE190_Integer_Overflow__char_rand_square_45_badData <end> ;
char result = <start> data <end>  * data;
<start> CWE190_Integer_Overflow__char_rand_square_45_badData = data <end> ;
data = (char <start> RAND32() <end> ;"	"static char <start> CWE190_Integer_Overflow__char_rand_square_45_badData <end> ;
<start> CWE190_Integer_Overflow__char_rand_square_45_badData = data <end> ;
data = (char <start> RAND32() <end> ;
char data = <start> CWE190_Integer_Overflow__char_rand_square_45_badData <end> ;
char result = <start> data <end>  * data;"	"char data = <start> CWE190_Integer_Overflow__char_rand_square_45_badData <end> ;
static char <start> CWE190_Integer_Overflow__char_rand_square_45_badData <end> ;
data = (char <start> RAND32() <end> ;"	0
7e74f310-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_02_bad() { int data; data = -1; if(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );
printLine <start> dest <end> );"	"printLine <start> dest <end> );
<start> data = atoi(inputBuffer) <end> ;"	"<start> printLine(dest) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	0
6c938bee-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif void CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_01_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
<start> SNPRINTF(dest, 100-1, data) <end> ;"	"printLine <start> dest <end> );
recvResult = <start> recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0) <end> ;"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
printLine <start> dest <end> );"	"<start> SNPRINTF(dest, 100-1, data) <end> ;
printLine <start> dest <end> );"	2
acf67e3e-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticTrue = 1; static int staticFalse = 0; void CWE191_Integer_Underflow__int_fgets_predec_05_bad() { int data; data = 0; if(staticTrue) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(staticTrue) { { --data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"<start> data = atoi(inputBuffer) <end> ;
printIntLine <start> result <end> );"	"int <start> result = data <end> ;
printIntLine <start> result <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> data = atoi(inputBuffer) <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );"	3
b08640df-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE197_Numeric_Truncation_Error__int_fgets_to_short_14_bad() { int data; data = -1; if(globalFive==5) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } { short shortData = (short)data; printShortLine(shortData); } }"	where is the vulnerable dataflow from shortData to printShortLine ?	"printShortLine <start> shortData <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printShortLine <start> shortData <end> );"	"printShortLine <start> shortData <end> );
data = <start> atoi(inputBuffer) <end> ;"	"printShortLine <start> shortData <end> );
<start> data = -1 <end> ;"	1
5133a775-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_preinc_66b_badSink(int dataArray[]) { int data = dataArray[2]; { ++data; int result = data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"void CWE190_Integer_Overflow__int_fgets_preinc_66b_badSink(int <start> dataArray <end> []);
<start> printIntLine(result) <end> ;"	"<start> printIntLine(result) <end> ;
+ <start> data <end> ;"	"int <start> result = data <end> ;
+ <start> data <end> ;"	"void CWE190_Integer_Overflow__int_fgets_preinc_66b_badSink(int <start> dataArray <end> []);
+ <start> data <end> ;"	3
85b15f06-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } void CWE369_Divide_by_Zero__int_fgets_modulo_08_bad() { int data; data = -1; if(staticReturnsTrue()) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(staticReturnsTrue()) { printIntLine(100 % data); } }"	where is the vulnerable dataflow from data to printIntLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
if  <start> fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) <end>  != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
data = <start> atoi(inputBuffer) <end> ;"	"<start> data = atoi(inputBuffer) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> 100 % data <end> );"	3
55ef4cce-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_fgets_sub_16_bad() { int data; data = 0; while(1) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } break; } while(1) { { int result = data - 1; printIntLine(result); } break; } }"	where is the vulnerable dataflow from data ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
int result = <start> data <end>  - 1;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
int <start> result = data - 1 <end> ;"	"<start> data = 0 <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> printIntLine(result) <end> ;"	0
79b2751f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticFive = 5; void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_07_bad() { int data; data = -1; if(staticFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }"	where is the vulnerable dataflow from data to malloc ?	"char * dataBuffer = (char *)malloc <start> data <end> );
if  <start> dataBuffer == NULL <end> ) {exit(-1);};"	"char * dataBuffer = (char *)malloc <start> data <end> );
<start> printLine(dataBuffer) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
char * dataBuffer = (char *)malloc <start> data <end> );"	"char <start> * dataBuffer = (char *)malloc(data) <end> ;
char * dataBuffer = (char *)malloc <start> data <end> );"	2
c01af8cb-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_connect_socket_open_11 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(globalReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"size_t dataLen = <start> strlen(data) <end> ;
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = OPEN(data, O_RDWR|O_CREAT, <start> S_IREAD|S_IWRITE <end> );"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
<start> data = dataBuffer <end> ;"	2
d31a251e-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_listen_socket_open_16 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; while(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
char <start> dataBuffer[FILENAME_MAX] = """" <end> ;"	2
9d74536f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_FIVE = 5; void CWE126_Buffer_Overread__CWE129_listen_socket_06_bad() { int data; data = -1; if(STATIC_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(STATIC_CONST_FIVE==5) { { int buffer[10] = { 0 }; if (data >= 0) { printIntLine(buffer[data]); } else { printLine(""ERROR: Array index is negative""); } } } }"	where is the vulnerable dataflow from buffer[data] to printIntLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[data] <end> );"	"printIntLine <start> buffer[data] <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> buffer[data] <end> );"	"int <start> buffer[10] = { 0 } <end> ;
printIntLine <start> buffer[data] <end> );"	0
8df42206-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define PATH_SZ 100 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define PATH_SZ PATH_MAX #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 void CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__accept_listen_bind_15_bad() { switch(6) { case 6: { char data[100] = """"; #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[recvResult] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif printLine(data); } break; default: printLine(""Benign, fixed string""); break; } }"	where is the vulnerable dataflow from data to printLine ?	"<start> printLine(data) <end> ;
recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);"	"recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);
printLine <start> data <end> );"	"printLine <start> data <end> );
replace = <start> strchr(data, '\n') <end> ;"	"replace = <start> strchr(data, '\r') <end> ;
recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);"	1
630ae7fe-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__short_rand_square_03_bad() { short data; data = 0; if(5==5) { data = (short)RAND32(); } if(5==5) { { short result = data * data; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"<start> data = (short)RAND32() <end> ;
short result = <start> data <end>  * data;"	"short result = <start> data <end>  * data;
<start> printIntLine(result) <end> ;"	"data = (short <start> RAND32() <end> ;
short result = <start> data <end>  * data;"	"<start> printIntLine(result) <end> ;
data = (short <start> RAND32() <end> ;"	2
7ae3a72b-6c15-11ed-81d4-94e6f77dd552	"namespace CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_74 { void badSink(map<int, int> dataMap) { int data = dataMap[2]; { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> memmove(dest, source, data) <end> ;
printLine <start> dest <end> );"	"void badSink(map<int, int> <start> dataMap <end> );
printLine <start> dest <end> );"	"printLine <start> dest <end> );
<start> printLine(dest) <end> ;"	"<start> memmove(dest, source, data) <end> ;
void badSink(map<int, int> <start> dataMap <end> );"	1
ae26ae2b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticFive = 5; void CWE191_Integer_Underflow__int_listen_socket_predec_07_bad() { int data; data = 0; if(staticFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticFive==5) { { --data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
int <start> result = data <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data = atoi(inputBuffer) <end> ;"	"printIntLine <start> result <end> );
if  <start> listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	3
78800f8f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 8 static short badSource(short data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } return data; } void CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_42_bad() { short data; data = 0; data = badSource(data); { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static short <start> badSource <end> (short data);
data = <start> badSource <end> (data);
printLine <start> dest <end> );"	"<start> memcpy(dest, source, data) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );
data = <start> badSource <end> (data);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static short <start> badSource <end> (short data);
<start> memcpy(dest, source, data) <end> ;
printLine <start> dest <end> );"	"static short <start> badSource <end> (short data);
data = <start> badSource <end> (data);
<start> memcpy(dest, source, data) <end> ;
printLine <start> dest <end> );"	0
70279c18-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif namespace CWE134_Uncontrolled_Format_String__char_file_snprintf_73 { void badSink(list<char *> dataList) { char * data = dataList.back(); { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"void badSink(list<char *> <start> dataList <end> );
<start> SNPRINTF(dest, 100-1, data) <end> ;"	"<start> printLine(dest) <end> ;
void badSink(list<char *> <start> dataList <end> );"	"void badSink(list<char *> <start> dataList <end> );
printLine <start> dest <end> );"	"char <start> dest[100] = """" <end> ;
printLine <start> dest <end> );"	2
774f57ee-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 8 void CWE194_Unexpected_Sign_Extension__fgets_strncpy_31_bad() { short data; data = 0; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = (short)atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } { short dataCopy = data; short data = dataCopy; { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } } }"	where is the vulnerable dataflow from dest to printLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
data = (short <start> atoi(inputBuffer) <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printLine <start> dest <end> );"	"printLine <start> dest <end> );
<start> strncpy(dest, source, data) <end> ;"	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	1
c1366260-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif static const int STATIC_CONST_FIVE = 5; namespace CWE23_Relative_Path_Traversal__char_console_ifstream_06 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(STATIC_CONST_FIVE==5) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
char <start> dataBuffer[FILENAME_MAX] = BASEPATH <end> ;"	"inputFile.open((char * <start> data <end> );
dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
inputFile.open((char * <start> data <end> );"	"<start> data = dataBuffer <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	2
9b124da7-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE124_Buffer_Underwrite__CWE839_listen_socket_18_bad() { int data; data = -1; goto source; source: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } goto sink; sink: { int i; int buffer[10] = { 0 }; if (data < 10) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } } }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"if  <start> acceptSocket == SOCKET_ERROR <end> );
printIntLine <start> buffer[i] <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[i] <end> );"	"printIntLine <start> buffer[i] <end> );
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"printIntLine <start> buffer[i] <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	1
669edade-6c15-11ed-81d4-94e6f77dd552	static int staticFive = 5; void CWE190_Integer_Overflow__int_rand_postinc_07_bad() { int data; data = 0; if(staticFive==5) { data = RAND32(); } if(staticFive==5) { { data++; int result = data; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
<start> data <end> ++;"	"<start> data <end> ++;
int <start> result = data <end> ;"	"data = <start> RAND32() <end> ;
<start> data <end> ++;"	"<start> data <end> ++;
data = <start> RAND32() <end> ;"	2
bda4e42e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define EXECLP _execlp #else #define EXECLP execlp #endif static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; void CWE78_OS_Command_Injection__char_listen_socket_execlp_04_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(STATIC_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECLP ?	"EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"size_t dataLen = <start> strlen(data) <end> ;
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
size_t dataLen = <start> strlen(data) <end> ;"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	3
9fe7ad18-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" namespace CWE134_Uncontrolled_Format_String__char_connect_socket_printf_81 { void bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } const CWE134_Uncontrolled_Format_String__char_connect_socket_printf_81_base& baseObject = CWE134_Uncontrolled_Format_String__char_connect_socket_printf_81_bad(); baseObject.action(data); }"	where is the vulnerable dataflow from data to action ?	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
baseObject.action <start> data <end> );"	"<start> data = dataBuffer <end> ;
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"replace = <start> strchr(data, '\n') <end> ;
baseObject.action <start> data <end> );"	"size_t dataLen = <start> strlen(data) <end> ;
baseObject.action <start> data <end> );"	0
69161b6b-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__short_rand_preinc_66b_badSink(short dataArray[]) { short data = dataArray[2]; { ++data; short result = data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
void CWE190_Integer_Overflow__short_rand_preinc_66b_badSink(short <start> dataArray <end> []);"	"void CWE190_Integer_Overflow__short_rand_preinc_66b_badSink(short <start> dataArray <end> []);
+ <start> data <end> ;"	"+ <start> data <end> ;
void CWE190_Integer_Overflow__short_rand_preinc_66b_badSink(short <start> dataArray <end> []);"	"<start> printIntLine(result) <end> ;
+ <start> data <end> ;"	1
c99197dc-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif static int staticFive = 5; namespace CWE36_Absolute_Path_Traversal__char_connect_socket_fopen_07 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(staticFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
replace = <start> strchr(data, '\n') <end> ;"	"size_t <start> dataLen = strlen(data) <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	0
b68484e9-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 namespace CWE36_Absolute_Path_Traversal__char_listen_socket_ofstream_81 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } const CWE36_Absolute_Path_Traversal__char_listen_socket_ofstream_81_base& baseObject = CWE36_Absolute_Path_Traversal__char_listen_socket_ofstream_81_bad(); baseObject.action(data); }"	where is the vulnerable dataflow from data to action ?	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
baseObject.action <start> data <end> );"	"baseObject.action <start> data <end> );
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"size_t <start> dataLen = strlen(data) <end> ;
baseObject.action <start> data <end> );"	"size_t dataLen = <start> strlen(data) <end> ;
baseObject.action <start> data <end> );"	0
67d01098-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__int_rand_postinc_31_bad() { int data; data = 0; data = RAND32(); { int dataCopy = data; int data = dataCopy; { data++; int result = data; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"<start> data <end> ++;
data = <start> RAND32() <end> ;"	"data = <start> RAND32() <end> ;
<start> data <end> ++;"	"<start> data <end> ++;
<start> data = RAND32() <end> ;"	"<start> printIntLine(result) <end> ;
data = <start> RAND32() <end> ;"	1
c1366254-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_console_fopen_61 { char * badSource(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; data = badSource(data); { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"char <start> dataBuffer[FILENAME_MAX] = BASEPATH <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
data = <start> badSource(data) <end> ;"	"pFile = FOPEN <start> data <end> , ""wb+"");
data = <start> badSource <end> (data);"	"data = <start> badSource <end> (data);
pFile = FOPEN <start> data <end> , ""wb+"");"	3
99e16a7c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_FIVE = 5; namespace CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_listen_socket_06 { void bad() { int data; data = -1; if(STATIC_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(STATIC_CONST_FIVE==5) { { int i; int * buffer = new int[10]; for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } delete[] buffer; } } }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"data = <start> atoi(inputBuffer) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> buffer[i] <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int <start> * buffer = new int[10] <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[i] <end> );"	3
453db03a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_square_09_bad() { int data; data = 0; if(GLOBAL_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(GLOBAL_CONST_TRUE) { { int result = data * data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);
int result = <start> data <end>  * data;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  * data;"	"<start> data = atoi(inputBuffer) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"int result = <start> data <end>  * data;
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	1
8cc3a666-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define SLEEP Sleep #else #define SLEEP usleep #endif namespace CWE400_Resource_Exhaustion__connect_socket_sleep_73 { void badSink(list<int> countList) { int count = countList.back(); SLEEP(count); printLine(""Sleep time possibly too long""); }"	where is the vulnerable dataflow from count to SLEEP ?	"void badSink(list<int> <start> countList <end> );
int <start> count = countList.back() <end> ;"	"SLEEP <start> count <end> );
void badSink(list<int> <start> countList <end> );"	"void badSink(list<int> <start> countList <end> );
SLEEP <start> count <end> );"	"<start> SLEEP(count) <end> ;
SLEEP <start> count <end> );"	2
af58097a-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE197_Numeric_Truncation_Error__int_fgets_to_char_10_bad() { int data; data = -1; if(globalTrue) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } { char charData = (char)data; printHexCharLine(charData); } }"	where is the vulnerable dataflow from charData to printHexCharLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printHexCharLine <start> charData <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> printHexCharLine(charData) <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
char charData = <start> (char)data <end> ;"	"printHexCharLine <start> charData <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	0
ce547d36-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_environment_fopen_73 { void badSink(list<char *> dataList) { char * data = dataList.back(); { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"void badSink(list<char *> <start> dataList <end> );
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
void badSink(list<char *> <start> dataList <end> );"	"pFile = FOPEN <start> data <end> , ""wb+"");
char <start> * data = dataList.back() <end> ;"	0
67d010b4-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__short_rand_postinc_17_bad() { int i,j; short data; data = 0; for(i = 0; i < 1; i++) { data = (short)RAND32(); } for(j = 0; j < 1; j++) { { data++; short result = data; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"short <start> result = data <end> ;
data = (short <start> RAND32() <end> ;"	"data = (short <start> RAND32() <end> ;
<start> data <end> ++;"	"<start> printIntLine(result) <end> ;
data = (short <start> RAND32() <end> ;"	"<start> data <end> ++;
short <start> result = data <end> ;"	1
73bc8143-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" void CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_10_bad() { short data; data = 0; if(globalTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"tempInt = <start> atoi(inputBuffer) <end> ;
printLine <start> dest <end> );"	"printLine <start> dest <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"<start> memcpy(dest, source, data) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	0
6ef76823-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif static int staticTrue = 1; static int staticFalse = 0; static void badVaSinkB(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_console_vfprintf_05_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; if(staticTrue) { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } if(staticTrue) { badVaSinkB(data, data); } }"	where is the vulnerable dataflow from data to vfprintf ?	"<start> vfprintf(stdout, data, args) <end> ;
badVaSinkB <start> data <end> , data);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
static void badVaSinkB(char * <start> data <end> , ...);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);"	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);"	"vfprintf(stdout, <start> data <end> , args);
badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);"	1
c99197d9-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; namespace CWE36_Absolute_Path_Traversal__char_connect_socket_fopen_04 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(STATIC_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = FOPEN <start> data <end> , ""wb+"");
char <start> dataBuffer[FILENAME_MAX] = """" <end> ;"	"recvResult = <start> recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0) <end> ;
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"pFile = FOPEN <start> data <end> , ""wb+"");
size_t dataLen = <start> strlen(data) <end> ;"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	3
5be3a9bc-6c15-11ed-81d4-94e6f77dd552	"typedef union { int unionFirst; int unionSecond; } CWE191_Integer_Underflow__int_fscanf_postdec_34_unionType; void CWE191_Integer_Underflow__int_fscanf_postdec_34_bad() { int data; CWE191_Integer_Underflow__int_fscanf_postdec_34_unionType myUnion; data = 0; fscanf(stdin, ""%d"", &data); myUnion.unionFirst = data; { int data = myUnion.unionSecond; { data--; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"fscanf(stdin, ""%d"", <start> &data <end> );
<start> printIntLine(result) <end> ;"	"<start> data <end> --;
fscanf(stdin, ""%d"", <start> &data <end> );"	"fscanf(stdin, ""%d"", <start> &data <end> );
<start> data <end> --;"	"<start> data <end> --;
int <start> data = myUnion.unionSecond <end> ;"	2
964cdc2e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_09_bad() { int data; data = -1; if(GLOBAL_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(GLOBAL_CONST_TRUE) { { int i; int buffer[10] = { 0 }; if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } } } }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"int <start> buffer[10] = { 0 } <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"printIntLine <start> buffer[i] <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);
printIntLine <start> buffer[i] <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[i] <end> );"	3
b08640db-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE197_Numeric_Truncation_Error__int_fgets_to_short_10_bad() { int data; data = -1; if(globalTrue) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } { short shortData = (short)data; printShortLine(shortData); } }"	where is the vulnerable dataflow from shortData to printShortLine ?	"short <start> shortData = (short)data <end> ;
printShortLine <start> shortData <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
short <start> shortData = (short)data <end> ;"	"printShortLine <start> shortData <end> );
short shortData = <start> (short)data <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printShortLine <start> shortData <end> );"	3
571e980e-6c15-11ed-81d4-94e6f77dd552	"namespace CWE191_Integer_Underflow__int_fscanf_multiply_43 { static void badSource(int &data) { fscanf(stdin, ""%d"", &data); } void bad() { int data; data = 0; badSource(data); if(data < 0) { int result = data * 2; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"int <start> result = data * 2 <end> ;
fscanf(stdin, ""%d"", <start> &data <end> );
badSource <start> data <end> );"	"<start> data = 0 <end> ;
fscanf(stdin, ""%d"", <start> &data <end> );
badSource <start> data <end> );"	"badSource <start> data <end> );
int result = <start> data <end>  * 2;
fscanf(stdin, ""%d"", <start> &data <end> );"	"fscanf(stdin, ""%d"", <start> &data <end> );
badSource <start> data <end> );
int result = <start> data <end>  * 2;"	3
5be3a9be-6c15-11ed-81d4-94e6f77dd552	"static int badSource(int data) { fscanf(stdin, ""%d"", &data); return data; } void CWE191_Integer_Underflow__int_fscanf_postdec_42_bad() { int data; data = 0; data = badSource(data); { data--; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"static int <start> badSource <end> (int data);
fscanf(stdin, ""%d"", <start> &data <end> );
<start> data <end> --;
data = <start> badSource <end> (data);"	"fscanf(stdin, ""%d"", <start> &data <end> );
<start> data <end> --;
static int <start> badSource <end> (int data);
<start> data = badSource(data) <end> ;"	"data = <start> badSource <end> (data);
fscanf(stdin, ""%d"", <start> &data <end> );
<start> printIntLine(result) <end> ;
static int <start> badSource <end> (int data);"	"fscanf(stdin, ""%d"", <start> &data <end> );
static int <start> badSource <end> (int data);
data = <start> badSource <end> (data);
<start> data <end> --;"	3
a49c4f82-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_square_63b_badSink(int * dataPtr) { int data = *dataPtr; { int result = data * data; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"<start> printIntLine(result) <end> ;
void CWE190_Integer_Overflow__int_listen_socket_square_63b_badSink(int * <start> dataPtr <end> );"	"void CWE190_Integer_Overflow__int_listen_socket_square_63b_badSink(int * <start> dataPtr <end> );
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
void CWE190_Integer_Overflow__int_listen_socket_square_63b_badSink(int * <start> dataPtr <end> );"	"int <start> result = data * data <end> ;
void CWE190_Integer_Overflow__int_listen_socket_square_63b_badSink(int * <start> dataPtr <end> );"	1
8f278a6d-6c15-11ed-81d4-94e6f77dd552	namespace CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_73 { void badSink(list<int> dataList) { int data = dataList.back(); { size_t i; int *intPointer; intPointer = (int*)malloc(data * sizeof(int)); if (intPointer == NULL) {exit(-1);} for (i = 0; i < (size_t)data; i++) { intPointer[i] = 0; } printIntLine(intPointer[0]); free(intPointer); } }	where is the vulnerable dataflow from data to malloc ?	"intPointer = (int*)malloc <start> data * sizeof(int) <end> );
intPointer = (int* <start> malloc(data * sizeof(int)) <end> ;"	"intPointer = (int*)malloc <start> data * sizeof(int) <end> );
void badSink(list<int> <start> dataList <end> );"	"void badSink(list<int> <start> dataList <end> );
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	"void badSink(list<int> <start> dataList <end> );
intPointer = (int* <start> malloc(data * sizeof(int)) <end> ;"	2
7d44fcb6-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_11_bad() { int data; data = -1; if(globalReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }"	where is the vulnerable dataflow from data to malloc ?	"<start> printLine(dataBuffer) <end> ;
char * dataBuffer = (char *)malloc <start> data <end> );"	"<start> memset(dataBuffer, 'A', data-1) <end> ;
char * dataBuffer = (char *)malloc <start> data <end> );"	"char * dataBuffer = <start> (char *)malloc(data) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
char * dataBuffer = (char *)malloc <start> data <end> );"	3
893217db-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_console_open_02 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(1) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"size_t dataLen = <start> strlen(data) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	1
c4cd6f3c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_environment_open_14 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(globalFive==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
fileDesc = OPEN(data, O_RDWR|O_CREAT, <start> S_IREAD|S_IWRITE <end> );"	"char <start> dataBuffer[FILENAME_MAX] = BASEPATH <end> ;
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"strncat(data+dataLen, environment, FILENAME_MAX <start> dataLen-1 <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	3
48d25d99-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__int_fscanf_square_73 { void badSink(list<int> dataList) { int data = dataList.back(); { int result = data * data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"void badSink(list<int> <start> dataList <end> );
int <start> result = data * data <end> ;"	"void badSink(list<int> <start> dataList <end> );
int result = <start> data <end>  * data;"	"void badSink(list<int> <start> dataList <end> );
<start> printIntLine(result) <end> ;"	"int result = <start> data <end>  * data;
void badSink(list<int> <start> dataList <end> );"	1
584fa8a6-6c15-11ed-81d4-94e6f77dd552	"typedef union { short unionFirst; short unionSecond; } CWE191_Integer_Underflow__short_fscanf_multiply_34_unionType; void CWE191_Integer_Underflow__short_fscanf_multiply_34_bad() { short data; CWE191_Integer_Underflow__short_fscanf_multiply_34_unionType myUnion; data = 0; fscanf (stdin, ""%hd"", &data); myUnion.unionFirst = data; { short data = myUnion.unionSecond; if(data < 0) { short result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"fscanf (stdin, ""%hd"", <start> &data <end> );
short result = <start> data <end>  * 2;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
short result = <start> data * 2 <end> ;"	"short result = <start> data <end>  * 2;
<start> printIntLine(result) <end> ;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
short <start> result = data * 2 <end> ;"	0
8df42223-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define PATH_SZ 100 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define PATH_SZ PATH_MAX #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } void CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__listen_accept_bind_08_bad() { if(staticReturnsTrue()) { { char data[100] = """"; #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[recvResult] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif printLine(data); } } }"	where is the vulnerable dataflow from data to printLine ?	"recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);
printLine <start> data <end> );"	"recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);
if  <start> acceptSocket == SOCKET_ERROR <end> );"	"recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);
size_t <start> dataLen = strlen(data) <end> ;"	"recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);
size_t dataLen = <start> strlen(data) <end> ;"	0
c39a65a4-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif namespace CWE23_Relative_Path_Traversal__char_environment_ofstream_01 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"<start> data = dataBuffer <end> ;
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"<start> data = dataBuffer <end> ;
outputFile.open((char * <start> data <end> );"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
outputFile.open((char * <start> data <end> );"	"outputFile.open((char * <start> data <end> );
size_t <start> dataLen = strlen(data) <end> ;"	2
7d44fc7e-6c15-11ed-81d4-94e6f77dd552	"namespace CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_81 { void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_81_bad::action(int data) const { { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } } }"	where is the vulnerable dataflow from dest to printLine ?	"void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_81_bad::action(int <start> data <end> ) const;
printLine <start> dest <end> );"	"<start> memmove(dest, source, data) <end> ;
printLine <start> dest <end> );"	"void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_81_bad::action(int <start> data <end> ) const;
<start> memmove(dest, source, data) <end> ;"	"<start> printLine(dest) <end> ;
void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_81_bad::action(int <start> data <end> ) const;"	0
6b86245d-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int badSource(int data) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } return data; } void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_42_bad() { int data; data = -1; data = badSource(data); { int i; int * buffer = (int *)malloc(10 * sizeof(int)); if (buffer == NULL) {exit(-1);} for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } free(buffer); } }"	where is the vulnerable dataflow from buffer to free ?	"free <start> buffer <end> );
int <start> * buffer = (int *)malloc(10 * sizeof(int)) <end> ;
static int <start> badSource <end> (int data);
data = <start> badSource <end> (data);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> printIntLine(buffer[i]) <end> ;
data = <start> badSource <end> (data);
free <start> buffer <end> );"	"data = <start> badSource <end> (data);
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
static int <start> badSource <end> (int data);
free <start> buffer <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
static int <start> badSource <end> (int data);
data = <start> badSource <end> (data);
free <start> buffer <end> );"	3
86cea155-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE369_Divide_by_Zero__int_listen_socket_divide_31_bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { int dataCopy = data; int data = dataCopy; printIntLine(100 / data); } }"	where is the vulnerable dataflow from data to printIntLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> 100 / data <end> );"	"printIntLine <start> 100 / data <end> );
data = <start> atoi(inputBuffer) <end> ;"	"int <start> dataCopy = data <end> ;
printIntLine <start> 100 / data <end> );"	"printIntLine <start> 100 / data <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	0
7ae3a72f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_02_bad() { int data; data = -1; if(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"printLine <start> dest <end> );
char <start> dest[100] = """" <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"printLine <start> dest <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"printLine <start> dest <end> );
<start> data = atoi(inputBuffer) <end> ;"	1
79b27514-6c15-11ed-81d4-94e6f77dd552	"namespace CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_72 { void badSink(vector<short> dataVector) { short data = dataVector[2]; { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"void badSink(vector<short> <start> dataVector <end> );
<start> printLine(dest) <end> ;"	"void badSink(vector<short> <start> dataVector <end> );
printLine <start> dest <end> );"	"printLine <start> dest <end> );
short <start> data = dataVector[2] <end> ;"	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	1
acf67e36-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_connect_socket_predec_65b_badSink(int data) { { --data; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"int <start> result = data <end> ;
void CWE191_Integer_Underflow__int_connect_socket_predec_65b_badSink(int <start> data <end> );"	"<start> printIntLine(result) <end> ;
void CWE191_Integer_Underflow__int_connect_socket_predec_65b_badSink(int <start> data <end> );"	"printIntLine <start> result <end> );
<start> --data <end> ;"	"void CWE191_Integer_Underflow__int_connect_socket_predec_65b_badSink(int <start> data <end> );
printIntLine <start> result <end> );"	3
a1094908-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_square_09_bad() { int data; data = 0; if(GLOBAL_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(GLOBAL_CONST_TRUE) { { int result = data * data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"<start> printIntLine(result) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	0
598370bb-6c15-11ed-81d4-94e6f77dd552	"static int staticTrue = 1; static int staticFalse = 0; void CWE191_Integer_Underflow__short_fscanf_sub_05_bad() { short data; data = 0; if(staticTrue) { fscanf (stdin, ""%hd"", &data); } if(staticTrue) { { short result = data - 1; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
short result = <start> data <end>  - 1;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
short <start> result = data - 1 <end> ;"	"short result = <start> data <end>  - 1;
fscanf (stdin, ""%hd"", <start> &data <end> );"	"fscanf (stdin, ""%hd"", <start> &data <end> );
short result = <start> data <end>  - 1;"	3
98b0153e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_81 { void bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } const CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_81_base& baseObject = CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_81_bad(); baseObject.action(data); }"	where is the vulnerable dataflow from data to action ?	"baseObject.action <start> data <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"<start> recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
baseObject.action <start> data <end> );"	"baseObject.action <start> data <end> );
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
baseObject.action <start> data <end> );"	3
7d44fc91-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_18_bad() { int data; data = -1; goto source; source: { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printLine <start> dest <end> );"	"printLine <start> dest <end> );
data = <start> atoi(inputBuffer) <end> ;"	"printLine <start> dest <end> );
char <start> dest[100] = """" <end> ;"	"printLine <start> dest <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	0
cf8750c0-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_file_fopen_45 { static char * badData; static char * goodG2BData; static void badSink() { char * data = badData; { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } } void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } badData = data; badSink(); }"	where is the vulnerable dataflow from data to FOPEN ?	"char * data = <start> badData <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
<start> badData = data <end> ;
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
<start> badData = data <end> ;
static char * <start> badData <end> ;
char * data = <start> badData <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"<start> badData = data <end> ;
char * data = <start> badData <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
<start> badData = data <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	1
d1e9da4d-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_listen_socket_fopen_65 { void badSink(char * data); void bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } funcPtr(data); }"	where is the vulnerable dataflow from data to funcPtr ?	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
<start> funcPtr(data) <end> ;"	"if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );
funcPtr <start> data <end> );"	"funcPtr <start> data <end> );
<start> data = dataBuffer <end> ;"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
funcPtr <start> data <end> );"	3
833ac959-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif void CWE252_Unchecked_Return_Value__char_fgets_03_bad() { if(5==5) { { char dataBuffer[100] = """"; char * data = dataBuffer; printLine(""Please enter a string: ""); fgets(data, 100, stdin); printLine(data); } } }"	where is the vulnerable dataflow from data to printLine ?	"<start> printLine(data) <end> ;
fgets <start> data <end> , 100, stdin);"	"printLine <start> data <end> );
fgets <start> data <end> , 100, stdin);"	"fgets <start> data <end> , 100, stdin);
printLine <start> data <end> );"	"printLine <start> data <end> );
<start> printLine(data) <end> ;"	2
b8e2bdc7-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 256 void CWE681_Incorrect_Conversion_Between_Numeric_Types__doubleNaN2int_01_bad() { { char inputBuffer[CHAR_ARRAY_SIZE]; double doubleNumber = 0; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { doubleNumber = atof(inputBuffer); } else { printLine(""fgets() failed.""); } printIntLine((int)(sqrt(doubleNumber))); } }"	where is the vulnerable dataflow from doubleNumber to printIntLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine((int)(sqrt <start> doubleNumber <end> )));"	"printIntLine((int)(sqrt <start> doubleNumber <end> )));
<start> doubleNumber = atof(inputBuffer) <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine((int) <start> sqrt(doubleNumber) <end> ));"	"printIntLine((int) <start> sqrt(doubleNumber) <end> ));
printIntLine((int)(sqrt <start> doubleNumber <end> )));"	0
5133a735-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticTrue = 1; static int staticFalse = 0; void CWE190_Integer_Overflow__int_connect_socket_preinc_05_bad() { int data; data = 0; if(staticTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticTrue) { { ++data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);
+ <start> data <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
+ <start> data <end> ;"	"data = <start> atoi(inputBuffer) <end> ;
+ <start> data <end> ;"	"+ <start> data <end> ;
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	1
b68484fa-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define NEW_PATH ""%SystemRoot%\\system32"" #define PUTENV _putenv #else #define NEW_PATH ""/bin"" #define PUTENV putenv #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" void CWE427_Uncontrolled_Search_Path_Element__char_connect_socket_03_bad() { char * data; char dataBuffer[250] = ""PATH=""; data = dataBuffer; if(5==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (250 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } PUTENV(data); }"	where is the vulnerable dataflow from data to PUTENV ?	"size_t dataLen = <start> strlen(data) <end> ;
PUTENV <start> data <end> );"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (250 - dataLen - 1), 0);
replace = <start> strchr(data, '\n') <end> ;"	"size_t dataLen = <start> strlen(data) <end> ;
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (250 - dataLen - 1), 0);"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (250 - dataLen - 1), 0);
PUTENV <start> data <end> );"	3
5f76fcb4-6c15-11ed-81d4-94e6f77dd552	"static short CWE191_Integer_Underflow__short_fscanf_predec_45_badData; static short CWE191_Integer_Underflow__short_fscanf_predec_45_goodG2BData; static short CWE191_Integer_Underflow__short_fscanf_predec_45_goodB2GData; static void badSink() { short data = CWE191_Integer_Underflow__short_fscanf_predec_45_badData; { --data; short result = data; printIntLine(result); } } void CWE191_Integer_Underflow__short_fscanf_predec_45_bad() { short data; data = 0; fscanf (stdin, ""%hd"", &data); CWE191_Integer_Underflow__short_fscanf_predec_45_badData = data; badSink(); }"	where is the vulnerable dataflow from data ?	"fscanf (stdin, ""%hd"", <start> &data <end> );
<start> CWE191_Integer_Underflow__short_fscanf_predec_45_badData = data <end> ;
static short <start> CWE191_Integer_Underflow__short_fscanf_predec_45_badData <end> ;
short data = <start> CWE191_Integer_Underflow__short_fscanf_predec_45_badData <end> ;
- <start> data <end> ;"	"- <start> data <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );
short data = <start> CWE191_Integer_Underflow__short_fscanf_predec_45_badData <end> ;
static short <start> CWE191_Integer_Underflow__short_fscanf_predec_45_badData <end> ;
short <start> result = data <end> ;"	"<start> printIntLine(result) <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );
- <start> data <end> ;
short data = <start> CWE191_Integer_Underflow__short_fscanf_predec_45_badData <end> ;
<start> CWE191_Integer_Underflow__short_fscanf_predec_45_badData = data <end> ;"	"- <start> data <end> ;
short data = <start> CWE191_Integer_Underflow__short_fscanf_predec_45_badData <end> ;"	0
525b6450-6c15-11ed-81d4-94e6f77dd552	typedef struct _CWE190_Integer_Overflow__int_fscanf_preinc_67_structType { int structFirst; } CWE190_Integer_Overflow__int_fscanf_preinc_67_structType; void CWE190_Integer_Overflow__int_fscanf_preinc_67b_badSink(CWE190_Integer_Overflow__int_fscanf_preinc_67_structType myStruct) { int data = myStruct.structFirst; { ++data; int result = data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
void CWE190_Integer_Overflow__int_fscanf_preinc_67b_badSink(CWE190_Integer_Overflow__int_fscanf_preinc_67_structType <start> myStruct <end> );
int data = <start> myStruct <end> .structFirst;"	"void CWE190_Integer_Overflow__int_fscanf_preinc_67b_badSink(CWE190_Integer_Overflow__int_fscanf_preinc_67_structType <start> myStruct <end> );
int data = <start> myStruct <end> .structFirst;
+ <start> data <end> ;"	"<start> printIntLine(result) <end> ;
void CWE190_Integer_Overflow__int_fscanf_preinc_67b_badSink(CWE190_Integer_Overflow__int_fscanf_preinc_67_structType <start> myStruct <end> );
+ <start> data <end> ;"	"+ <start> data <end> ;
int data = <start> myStruct <end> .structFirst;
void CWE190_Integer_Overflow__int_fscanf_preinc_67b_badSink(CWE190_Integer_Overflow__int_fscanf_preinc_67_structType <start> myStruct <end> );"	1
5e44fca9-6c15-11ed-81d4-94e6f77dd552	void CWE191_Integer_Underflow__int_fscanf_predec_63b_badSink(int * dataPtr) { int data = *dataPtr; { --data; int result = data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
- <start> data <end> ;"	"- <start> data <end> ;
void CWE191_Integer_Underflow__int_fscanf_predec_63b_badSink(int * <start> dataPtr <end> );"	"int <start> result = data <end> ;
void CWE191_Integer_Underflow__int_fscanf_predec_63b_badSink(int * <start> dataPtr <end> );"	"void CWE191_Integer_Underflow__int_fscanf_predec_63b_badSink(int * <start> dataPtr <end> );
- <start> data <end> ;"	3
bc721f90-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define EXECLP _execlp #else #define EXECLP execlp #endif void CWE78_OS_Command_Injection__char_file_execlp_09_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(GLOBAL_CONST_TRUE) { { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECLP ?	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	"<start> EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	"EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
size_t dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	3
a10948d9-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_FIVE = 5; void CWE190_Integer_Overflow__int_connect_socket_multiply_06_bad() { int data; data = 0; if(STATIC_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(STATIC_CONST_FIVE==5) { if(data > 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"printIntLine <start> result <end> );
recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data = atoi(inputBuffer) <end> ;"	0
69161b5d-6c15-11ed-81d4-94e6f77dd552	static int badStatic = 0; static void badSink(short data) { if(badStatic) { { ++data; short result = data; printIntLine(result); } } } void CWE190_Integer_Overflow__short_rand_preinc_21_bad() { short data; data = 0; data = (short)RAND32(); badStatic = 1; badSink(data); }	where is the vulnerable dataflow from data ?	"data = (short <start> RAND32() <end> ;
badSink <start> data <end> );
static void badSink(short <start> data <end> );
+ <start> data <end> ;"	"badSink <start> data <end> );
static void badSink(short <start> data <end> );"	"short <start> result = data <end> ;
+ <start> data <end> ;
badSink <start> data <end> );
static void badSink(short <start> data <end> );"	"data = (short <start> RAND32() <end> ;
static void badSink(short <start> data <end> );
<start> data = (short)RAND32() <end> ;
+ <start> data <end> ;"	0
74ee240c-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 8 namespace CWE194_Unexpected_Sign_Extension__fgets_malloc_43 { static void badSource(short &data) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = (short)atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } void bad() { short data; data = 0; badSource(data); if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }"	where is the vulnerable dataflow from data to malloc ?	"badSource <start> data <end> );
<start> memset(dataBuffer, 'A', data-1) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"badSource <start> data <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
char <start> * dataBuffer = (char *)malloc(data) <end> ;"	"char * dataBuffer = (char * <start> malloc(data) <end> ;
badSource <start> data <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
badSource <start> data <end> );
char * dataBuffer = (char *)malloc <start> data <end> );"	3
ae26ae6e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_12_bad() { int data; data = -1; if(globalReturnsTrueOrFalse()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } else { data = CHAR_MAX-5; } { char charData = (char)data; printHexCharLine(charData); } }"	where is the vulnerable dataflow from charData to printHexCharLine ?	"<start> printHexCharLine(charData) <end> ;
printHexCharLine <start> charData <end> );"	"<start> data = atoi(inputBuffer) <end> ;
printHexCharLine <start> charData <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printHexCharLine <start> charData <end> );"	"<start> printHexCharLine(charData) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	2
a6fd823e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } void CWE190_Integer_Overflow__int_connect_socket_preinc_08_bad() { int data; data = 0; if(staticReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticReturnsTrue()) { { ++data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
int <start> result = data <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printIntLine(result) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"<start> data = 0 <end> ;
printIntLine <start> result <end> );"	2
669edaa0-6c15-11ed-81d4-94e6f77dd552	static void badSink(int data) { { int result = data * data; printIntLine(result); } } void CWE190_Integer_Overflow__int_rand_square_44_bad() { int data; void (*funcPtr) (int) = badSink; data = 0; data = RAND32(); funcPtr(data); }	where is the vulnerable dataflow from data ?	"data = <start> RAND32() <end> ;
funcPtr <start> data <end> );
static void badSink(int <start> data <end> );
int result = <start> data <end>  * data;"	"funcPtr <start> data <end> );
int result = <start> data <end>  * data;
<start> funcPtr(data) <end> ;
static void badSink(int <start> data <end> );"	"<start> printIntLine(result) <end> ;
funcPtr <start> data <end> );
int result = <start> data <end>  * data;
data = <start> RAND32() <end> ;"	"static void badSink(int <start> data <end> );
<start> printIntLine(result) <end> ;
funcPtr <start> data <end> );
int result = <start> data <end>  * data;"	0
d31a24e6-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 namespace CWE36_Absolute_Path_Traversal__char_listen_socket_ifstream_41 { void badSink(char * data) { { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } } void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badSink(data); }"	where is the vulnerable dataflow from data to badSink ?	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
badSink <start> data <end> );"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
<start> data = dataBuffer <end> ;"	"badSink <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
if  <start> recvResult == SOCKET_ERROR <end>  || recvResult == 0);"	0
67d010d1-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__char_rand_preinc_10_bad() { char data; data = ' '; if(globalTrue) { data = (char)RAND32(); } if(globalTrue) { { ++data; char result = data; printHexCharLine(result); } } }	where is the vulnerable dataflow from data ?	"<start> printHexCharLine(result) <end> ;
+ <start> data <end> ;"	"+ <start> data <end> ;
data = (char <start> RAND32() <end> ;"	"data = (char <start> RAND32() <end> ;
<start> printHexCharLine(result) <end> ;"	"data = (char <start> RAND32() <end> ;
+ <start> data <end> ;"	3
4a021130-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_square_31_bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { int dataCopy = data; int data = dataCopy; { int result = data * data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"int <start> dataCopy = data <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"int result = <start> data <end>  * data;
<start> data = atoi(inputBuffer) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  * data;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data * data <end> ;"	2
a5ce1c5c-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_postinc_17_bad() { int i,j; int data; data = 0; for(i = 0; i < 1; i++) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } for(j = 0; j < 1; j++) { { data++; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );"	"data = <start> atoi(inputBuffer) <end> ;
printIntLine <start> result <end> );"	"int <start> result = data <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	0
c991980d-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" namespace CWE36_Absolute_Path_Traversal__char_connect_socket_ifstream_16 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; while(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; } { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
inputFile.open((char * <start> data <end> );"	"recvResult = <start> recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0) <end> ;
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"inputFile.open((char * <start> data <end> );
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = <start> recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0) <end> ;
inputFile.open((char * <start> data <end> );"	0
d31a252b-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_listen_socket_open_52 { void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badSink_b(data); }"	where is the vulnerable dataflow from data to badSink_b ?	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
<start> recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0) <end> ;"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
badSink_b <start> data <end> );"	"char <start> dataBuffer[FILENAME_MAX] = """" <end> ;
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"size_t dataLen = <start> strlen(data) <end> ;
badSink_b <start> data <end> );"	1
d0b64ed1-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif namespace CWE36_Absolute_Path_Traversal__char_file_ifstream_18 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; goto source; source: { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
inputFile.open((char * <start> data <end> );"	"char <start> dataBuffer[FILENAME_MAX] = """" <end> ;
inputFile.open((char * <start> data <end> );"	"inputFile.open((char * <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	"inputFile.open((char * <start> data <end> );
<start> data = dataBuffer <end> ;"	0
7c127586-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_08_bad() { int data; data = -1; if(staticReturnsTrue()) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> memcpy(dest, source, data) <end> ;
printLine <start> dest <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> data = atoi(inputBuffer) <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printLine <start> dest <end> );"	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	2
4b34afeb-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__short_fscanf_multiply_65b_badSink(short data) { if(data > 0) { short result = data * 2; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
short result = <start> data <end>  * 2;"	"short <start> result = data * 2 <end> ;
void CWE190_Integer_Overflow__short_fscanf_multiply_65b_badSink(short <start> data <end> );"	"short result = <start> data <end>  * 2;
void CWE190_Integer_Overflow__short_fscanf_multiply_65b_badSink(short <start> data <end> );"	"void CWE190_Integer_Overflow__short_fscanf_multiply_65b_badSink(short <start> data <end> );
short result = <start> data <end>  * 2;"	3
7fa68e02-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_13_bad() { int data; data = -1; if(GLOBAL_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"if  <start> data < 100 <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );
printLine <start> dest <end> );"	"char <start> dest[100] = """" <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	0
5d16c9d0-6c15-11ed-81d4-94e6f77dd552	void CWE191_Integer_Underflow__short_fscanf_postdec_63b_badSink(short * dataPtr) { short data = *dataPtr; { data--; short result = data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"void CWE191_Integer_Underflow__short_fscanf_postdec_63b_badSink(short * <start> dataPtr <end> );
<start> data <end> --;"	"void CWE191_Integer_Underflow__short_fscanf_postdec_63b_badSink(short * <start> dataPtr <end> );
<start> printIntLine(result) <end> ;"	"<start> printIntLine(result) <end> ;
<start> data <end> --;"	"short <start> result = data <end> ;
void CWE191_Integer_Underflow__short_fscanf_postdec_63b_badSink(short * <start> dataPtr <end> );"	0
b1b80836-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_45_badData; static int CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_45_goodG2BData; static void badSink() { int data = CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_45_badData; { short shortData = (short)data; printShortLine(shortData); } } void CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_45_bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_45_badData = data; badSink(); }"	where is the vulnerable dataflow from shortData to printShortLine ?	"<start> CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_45_badData = data <end> ;
<start> printShortLine(shortData) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static int <start> CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_45_badData <end> ;
printShortLine <start> shortData <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_45_badData = data <end> ;
static int <start> CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_45_badData <end> ;
int data = <start> CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_45_badData <end> ;
printShortLine <start> shortData <end> );"	"<start> printShortLine(shortData) <end> ;
int data = <start> CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_45_badData <end> ;
static int <start> CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_45_badData <end> ;
printShortLine <start> shortData <end> );
<start> CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_45_badData = data <end> ;"	"<start> CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_45_badData = data <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static int <start> CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_45_badData <end> ;
int data = <start> CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_45_badData <end> ;"	1
87ff9863-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_connect_socket_open_03 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(5==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN(data, O_RDWR|O_CREAT, <start> S_IREAD|S_IWRITE <end> );
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) *  <start> FILENAME_MAX - dataLen - 1 <end> ), 0);"	"replace = <start> strchr(data, '\r') <end> ;
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	1
80d986ff-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_console_fopen_09 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(GLOBAL_CONST_TRUE) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
pFile = FOPEN <start> data <end> , ""wb+"");"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
if (dataLen > 0 && <start> data[dataLen-1] == '\n' <end> );"	"pFile = FOPEN <start> data <end> , ""wb+"");
<start> data = dataBuffer <end> ;"	"char <start> dataBuffer[FILENAME_MAX] = BASEPATH <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	0
78800fe7-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 8 static short badSource(short data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } return data; } void CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_42_bad() { short data; data = 0; data = badSource(data); { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> printLine(dest) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static short <start> badSource <end> (short data);
printLine <start> dest <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
data = <start> badSource <end> (data);
printLine <start> dest <end> );
<start> strncpy(dest, source, data) <end> ;"	"static short <start> badSource <end> (short data);
if  <start> data < 100 <end> );
data = <start> badSource <end> (data);
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static short <start> badSource <end> (short data);
data = <start> badSource <end> (data);
printLine <start> dest <end> );"	3
4b34afe6-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__short_fscanf_multiply_53d_badSink(short data) { if(data > 0) { short result = data * 2; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"void CWE190_Integer_Overflow__short_fscanf_multiply_53d_badSink(short <start> data <end> );
short result = <start> data <end>  * 2;"	"<start> printIntLine(result) <end> ;
void CWE190_Integer_Overflow__short_fscanf_multiply_53d_badSink(short <start> data <end> );"	"short <start> result = data * 2 <end> ;
void CWE190_Integer_Overflow__short_fscanf_multiply_53d_badSink(short <start> data <end> );"	"short result = <start> data <end>  * 2;
void CWE190_Integer_Overflow__short_fscanf_multiply_53d_badSink(short <start> data <end> );"	0
c39a6581-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif extern char * CWE23_Relative_Path_Traversal__char_environment_fopen_68_badData; extern char * CWE23_Relative_Path_Traversal__char_environment_fopen_68_goodG2BData; namespace CWE23_Relative_Path_Traversal__char_environment_fopen_68 { void badSink() { char * data = CWE23_Relative_Path_Traversal__char_environment_fopen_68_badData; { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = FOPEN <start> data <end> , ""wb+"");
char <start> * data = CWE23_Relative_Path_Traversal__char_environment_fopen_68_badData <end> ;"	"pFile = FOPEN <start> data <end> , ""wb+"");
char * data = <start> CWE23_Relative_Path_Traversal__char_environment_fopen_68_badData <end> ;"	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
char * data = <start> CWE23_Relative_Path_Traversal__char_environment_fopen_68_badData <end> ;"	"char * data = <start> CWE23_Relative_Path_Traversal__char_environment_fopen_68_badData <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	3
5be3a9b2-6c15-11ed-81d4-94e6f77dd552	"void CWE191_Integer_Underflow__int_fscanf_postdec_11_bad() { int data; data = 0; if(globalReturnsTrue()) { fscanf(stdin, ""%d"", &data); } if(globalReturnsTrue()) { { data--; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"int <start> result = data <end> ;
fscanf(stdin, ""%d"", <start> &data <end> );"	"<start> data <end> --;
int <start> result = data <end> ;"	"fscanf(stdin, ""%d"", <start> &data <end> );
<start> data <end> --;"	"fscanf(stdin, ""%d"", <start> &data <end> );
<start> data-- <end> ;"	2
bed4a8bf-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_connect_socket_fopen_13 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(GLOBAL_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"recvResult = recv(connectSocket, (char *)(data + dataLen), <start> sizeof(char) * (FILENAME_MAX - dataLen - 1) <end> , 0);
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	"replace = <start> strchr(data, '\n') <end> ;
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
recvResult = <start> recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0) <end> ;"	1
c4cd6f50-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_environment_open_63 { void badSink(char * * dataPtr) { char * data = *dataPtr; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"void badSink(char * * <start> dataPtr <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"void badSink(char * * <start> dataPtr <end> );
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"void badSink(char * * <start> dataPtr <end> );
fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
char <start> * data = *dataPtr <end> ;"	0
728a5024-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 static void badVaSink(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_53d_badSink(char * data) { badVaSink(data, data); }"	where is the vulnerable dataflow from data to vprintf ?	"<start> vprintf(data, args) <end> ;
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
vprintf <start> data <end> , args);"	"vprintf <start> data <end> , args);
badVaSink <start> data <end> , data);"	"void CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_53d_badSink(char * <start> data <end> );
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
vprintf <start> data <end> , args);"	"<start> vprintf(data, args) <end> ;
void CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_53d_badSink(char * <start> data <end> );
vprintf <start> data <end> , args);
badVaSink <start> data <end> , data);"	2
92bb89ed-6c15-11ed-81d4-94e6f77dd552	"#define SEARCH_CHAR 'S' namespace CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_file_62 { void badSource(char * &data); void bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\0'; badSource(data); for (; *data != '\0'; data++) { if (*data == SEARCH_CHAR) { printLine(""We have a match!""); break; } } free(data); }"	where is the vulnerable dataflow from data to free ?	"<start> free(data) <end> ;
free <start> data <end> );"	"badSource <start> data <end> );
<start> free(data) <end> ;"	"for (; *data != '\0'; <start> data++ <end> );
free <start> data <end> );"	"badSource <start> data <end> );
free <start> data <end> );"	3
8df421e1-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define PATH_SZ 100 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define PATH_SZ PATH_MAX #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 void CWE605_Multiple_Binds_Same_Port__basic_16_bad() { while(1) { { char data[100] = """"; #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); #ifdef _WIN32 BOOL bOptVal = TRUE; int bOptLen = sizeof(BOOL); #else int bOptVal = 1; int bOptLen = sizeof(int); #endif do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } if (setsockopt(listenSocket, SOL_SOCKET, SO_REUSEADDR, (char*)&bOptVal, bOptLen) != 0) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, data+dataLen, (int)(100-dataLen-1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[recvResult] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif printLine(data); } break; } }"	where is the vulnerable dataflow from data to printLine ?	"recvResult = recv(acceptSocket, <start> data+dataLen <end> , (int)(100-dataLen-1), 0);
printLine <start> data <end> );"	"<start> recvResult = recv(acceptSocket, data+dataLen, (int)(100-dataLen-1), 0) <end> ;
printLine <start> data <end> );"	"printLine <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	"printLine <start> data <end> );
replace = <start> strchr(data, '\r') <end> ;"	0
6b86242d-6c15-11ed-81d4-94e6f77dd552	"extern int CWE122_Heap_Based_Buffer_Overflow__c_CWE129_connect_socket_22_badGlobal; void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_connect_socket_22_badSink(int data) { if(CWE122_Heap_Based_Buffer_Overflow__c_CWE129_connect_socket_22_badGlobal) { { int i; int * buffer = (int *)malloc(10 * sizeof(int)); if (buffer == NULL) {exit(-1);} for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } free(buffer); } } }"	where is the vulnerable dataflow from buffer to free ?	"void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_connect_socket_22_badSink(int <start> data <end> );
free <start> buffer <end> );"	"void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_connect_socket_22_badSink(int <start> data <end> );
<start> printIntLine(buffer[i]) <end> ;"	"void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_connect_socket_22_badSink(int <start> data <end> );
<start> free(buffer) <end> ;"	"free <start> buffer <end> );
<start> printIntLine(buffer[i]) <end> ;"	0
d1e9da2b-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_listen_socket_fopen_02 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	"pFile = FOPEN <start> data <end> , ""wb+"");
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"size_t dataLen = <start> strlen(data) <end> ;
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	0
b41b8791-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 20 #define IP_ADDRESS ""127.0.0.1"" void CWE369_Divide_by_Zero__float_connect_socket_02_bad() { float data; data = 0.0F; if(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = (float)atof(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(1) { { int result = (int)(100.0 / data); printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"<start> data = (float)atof(inputBuffer) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"printIntLine <start> result <end> );
int result = <start> (int)(100.0 / data) <end> ;"	"int <start> result = (int)(100.0 / data) <end> ;
printIntLine <start> result <end> );"	0
a5ce1c82-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_postinc_18_bad() { int data; data = 0; goto source; source: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } goto sink; sink: { data++; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"int <start> result = data <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"printIntLine <start> result <end> );
<start> data = 0 <end> ;"	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	3
4b34afc8-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__short_fscanf_add_73 { void badSink(list<short> dataList) { short data = dataList.back(); { short result = data + 1; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
short result = <start> data <end>  + 1;"	"short result = <start> data <end>  + 1;
short <start> data = dataList.back() <end> ;"	"short result = <start> data <end>  + 1;
void badSink(list<short> <start> dataList <end> );"	"void badSink(list<short> <start> dataList <end> );
short result = <start> data <end>  + 1;"	3
69161b2e-6c15-11ed-81d4-94e6f77dd552	static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } void CWE190_Integer_Overflow__int_rand_preinc_08_bad() { int data; data = 0; if(staticReturnsTrue()) { data = RAND32(); } if(staticReturnsTrue()) { { ++data; int result = data; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"<start> ++data <end> ;
data = <start> RAND32() <end> ;"	"data = <start> RAND32() <end> ;
+ <start> data <end> ;"	"<start> printIntLine(result) <end> ;
+ <start> data <end> ;"	"int <start> result = data <end> ;
+ <start> data <end> ;"	1
a95fd829-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_fgets_multiply_12_bad() { int data; data = 0; if(globalReturnsTrueOrFalse()) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } else { data = -2; } if(globalReturnsTrueOrFalse()) { if(data < 0) { int result = data * 2; printIntLine(result); } } else { if(data < 0) { if (data > (INT_MIN/2)) { int result = data * 2; printIntLine(result); } else { printLine(""data value is too small to perform multiplication.""); } } } }"	where is the vulnerable dataflow from result to printIntLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );"	"if <start> data < 0 <end> ) ;
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;"	"printIntLine <start> result <end> );
int <start> result = data * 2 <end> ;"	0
cd228133-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif namespace CWE36_Absolute_Path_Traversal__char_console_ofstream_02 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(1) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
outputFile.open((char * <start> data <end> );"	"<start> data = dataBuffer <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
size_t dataLen = <start> strlen(data) <end> ;"	1
a23a3e27-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int badStatic = 0; static void badSink(int data) { if(badStatic) { if(data > 0) { int result = data * 2; printIntLine(result); } } } void CWE190_Integer_Overflow__int_fgets_multiply_21_bad() { int data; data = 0; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } badStatic = 1; badSink(data); }"	where is the vulnerable dataflow from result to printIntLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
badSink <start> data <end> );
static void badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"<start> badSink(data) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
static void badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"static void badSink(int <start> data <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
badSink <start> data <end> );
printIntLine <start> result <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );
static void badSink(int <start> data <end> );"	0
9fe7ad33-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 namespace CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_81 { void bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } const CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_81_base& baseObject = CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_81_bad(); baseObject.action(data); }"	where is the vulnerable dataflow from data to action ?	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
baseObject.action <start> data <end> );"	"baseObject.action <start> data <end> );
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (100 - dataLen - 1), 0);"	"size_t dataLen = <start> strlen(data) <end> ;
baseObject.action <start> data <end> );"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (100 - dataLen - 1), 0);
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	0
728a502f-6c15-11ed-81d4-94e6f77dd552	#ifndef _WIN32 #endif namespace CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_74 { static void badVaSink(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); va_end(args); } } void badSink(map<int, char *> dataMap) { char * data = dataMap[2]; badVaSink(data, data); }	where is the vulnerable dataflow from data to vprintf ?	"void badSink(map<int, char *> <start> dataMap <end> );
vprintf <start> data <end> , args);
badVaSink <start> data <end> , data);"	"void badSink(map<int, char *> <start> dataMap <end> );
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
vprintf <start> data <end> , args);"	"vprintf <start> data <end> , args);
badVaSink <start> data <end> , data);"	"static void badVaSink(char * <start> data <end> , ...);
vprintf <start> data <end> , args);
badVaSink <start> data <end> , data);
<start> vprintf(data, args) <end> ;"	1
69161b61-6c15-11ed-81d4-94e6f77dd552	static void badSink(short data) { { ++data; short result = data; printIntLine(result); } } void CWE190_Integer_Overflow__short_rand_preinc_41_bad() { short data; data = 0; data = (short)RAND32(); badSink(data); }	where is the vulnerable dataflow from data ?	"badSink <start> data <end> );
<start> badSink(data) <end> ;
+ <start> data <end> ;
data = (short <start> RAND32() <end> ;"	"data = (short <start> RAND32() <end> ;
static void badSink(short <start> data <end> );"	"static void badSink(short <start> data <end> );
<start> data = (short)RAND32() <end> ;
+ <start> data <end> ;
badSink <start> data <end> );"	"data = (short <start> RAND32() <end> ;
badSink <start> data <end> );
static void badSink(short <start> data <end> );
+ <start> data <end> ;"	3
78800fc2-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 8 void CWE194_Unexpected_Sign_Extension__listen_socket_memmove_54e_badSink(short data) { { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"printLine <start> dest <end> );
void CWE194_Unexpected_Sign_Extension__listen_socket_memmove_54e_badSink(short <start> data <end> );"	"printLine <start> dest <end> );
<start> memmove(dest, source, data) <end> ;"	"void CWE194_Unexpected_Sign_Extension__listen_socket_memmove_54e_badSink(short <start> data <end> );
<start> printLine(dest) <end> ;"	"void CWE194_Unexpected_Sign_Extension__listen_socket_memmove_54e_badSink(short <start> data <end> );
printLine <start> dest <end> );"	3
87ff983c-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_connect_socket_fopen_02 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
<start> data = dataBuffer <end> ;"	"pFile = FOPEN <start> data <end> , ""wb+"");
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
size_t dataLen = <start> strlen(data) <end> ;"	0
a95fd848-6c15-11ed-81d4-94e6f77dd552	namespace CWE191_Integer_Underflow__int_fgets_multiply_82 { void CWE191_Integer_Underflow__int_fgets_multiply_82_bad::action(int data) { if(data < 0) { int result = data * 2; printIntLine(result); } } }	where is the vulnerable dataflow from result to printIntLine ?	"void CWE191_Integer_Underflow__int_fgets_multiply_82_bad::action(int <start> data <end> );
printIntLine <start> result <end> );"	"int <start> result = data * 2 <end> ;
printIntLine <start> result <end> );"	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
void CWE191_Integer_Underflow__int_fgets_multiply_82_bad::action(int <start> data <end> );"	0
80d9872c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_console_open_18 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; goto source; source: { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"size_t dataLen = <start> strlen(data) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
dataLen = <start> strlen(data) <end> ;"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	1
af580946-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; void CWE197_Numeric_Truncation_Error__int_connect_socket_to_short_04_bad() { int data; data = -1; if(STATIC_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { short shortData = (short)data; printShortLine(shortData); } }"	where is the vulnerable dataflow from shortData to printShortLine ?	"printShortLine <start> shortData <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"printShortLine <start> shortData <end> );
<start> printShortLine(shortData) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printShortLine <start> shortData <end> );"	"short shortData = <start> (short)data <end> ;
printShortLine <start> shortData <end> );"	2
a5ce1c75-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticTrue = 1; static int staticFalse = 0; void CWE190_Integer_Overflow__int_listen_socket_postinc_05_bad() { int data; data = 0; if(staticTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticTrue) { { data++; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
if  <start> recvResult == SOCKET_ERROR <end>  || recvResult == 0);"	"printIntLine <start> result <end> );
<start> data++ <end> ;"	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	3
453db063-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } void CWE190_Integer_Overflow__int_fgets_add_08_bad() { int data; data = 0; if(staticReturnsTrue()) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(staticReturnsTrue()) { { int result = data + 1; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
int result = <start> data <end>  + 1;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
int result = <start> data + 1 <end> ;"	"<start> printIntLine(result) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"char <start> inputBuffer[CHAR_ARRAY_SIZE] = """" <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	0
833ac942-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_listen_socket_open_34 { typedef union { char * unionFirst; char * unionSecond; } unionType; void bad() { char * data; unionType myUnion; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } } }"	where is the vulnerable dataflow from data to OPEN ?	"char <start> * data = myUnion.unionSecond <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"char <start> * data = myUnion.unionSecond <end> ;
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	3
b1b8080f-6c15-11ed-81d4-94e6f77dd552	namespace CWE197_Numeric_Truncation_Error__int_listen_socket_to_char_62 { void badSource(int &data); void bad() { int data; data = -1; badSource(data); { char charData = (char)data; printHexCharLine(charData); } }	where is the vulnerable dataflow from charData to printHexCharLine ?	"badSource <start> data <end> );
char <start> charData = (char)data <end> ;"	"printHexCharLine <start> charData <end> );
badSource <start> data <end> );"	"badSource <start> data <end> );
printHexCharLine <start> charData <end> );"	"printHexCharLine <start> charData <end> );
char <start> charData = (char)data <end> ;"	2
a830bf85-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_connect_socket_multiply_63b_badSink(int * dataPtr) { int data = *dataPtr; if(data < 0) { int result = data * 2; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	"void CWE191_Integer_Underflow__int_connect_socket_multiply_63b_badSink(int * <start> dataPtr <end> );
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
if <start> data < 0 <end> ) ;"	"void CWE191_Integer_Underflow__int_connect_socket_multiply_63b_badSink(int * <start> dataPtr <end> );
if <start> data < 0 <end> ) ;"	1
b54bcf4e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE369_Divide_by_Zero__int_connect_socket_modulo_82 { void bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE369_Divide_by_Zero__int_connect_socket_modulo_82_base* baseObject = new CWE369_Divide_by_Zero__int_connect_socket_modulo_82_bad; baseObject->action(data); delete baseObject; }"	where is the vulnerable dataflow from data to action ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
baseObject->action <start> data <end> );"	"baseObject->action <start> data <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"baseObject->action <start> data <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"baseObject->action <start> data <end> );
recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);"	0
61da670f-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__short_rand_add_17_bad() { int i,j; short data; data = 0; for(i = 0; i < 1; i++) { data = (short)RAND32(); } for(j = 0; j < 1; j++) { { short result = data + 1; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"data = (short <start> RAND32() <end> ;
short result = <start> data <end>  + 1;"	"<start> data = (short)RAND32() <end> ;
short result = <start> data <end>  + 1;"	"short result = <start> data <end>  + 1;
<start> data = 0 <end> ;"	"<start> printIntLine(result) <end> ;
data = (short <start> RAND32() <end> ;"	0
87ff9846-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_connect_socket_fopen_12 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(globalReturnsTrueOrFalse()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } else { #ifdef _WIN32 strcat(data, ""c:\\temp\\file.txt""); #else strcat(data, ""/tmp/file.txt""); #endif } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"size_t <start> dataLen = strlen(data) <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"replace = <start> strchr(data, '\n') <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
size_t dataLen = <start> strlen(data) <end> ;"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	3
b41b87b0-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 20 #define IP_ADDRESS ""127.0.0.1"" void CWE369_Divide_by_Zero__float_connect_socket_63b_badSink(float * dataPtr) { float data = *dataPtr; { int result = (int)(100.0 / data); printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"void CWE369_Divide_by_Zero__float_connect_socket_63b_badSink(float * <start> dataPtr <end> );
printIntLine <start> result <end> );"	"int <start> result = (int)(100.0 / data) <end> ;
void CWE369_Divide_by_Zero__float_connect_socket_63b_badSink(float * <start> dataPtr <end> );"	"void CWE369_Divide_by_Zero__float_connect_socket_63b_badSink(float * <start> dataPtr <end> );
<start> printIntLine(result) <end> ;"	"float <start> data = *dataPtr <end> ;
printIntLine <start> result <end> );"	0
b2ea8da2-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" void CWE197_Numeric_Truncation_Error__short_connect_socket_51b_badSink(short data) { { char charData = (char)data; printHexCharLine(charData); } }"	where is the vulnerable dataflow from charData to printHexCharLine ?	"printHexCharLine <start> charData <end> );
<start> printHexCharLine(charData) <end> ;"	"char <start> charData = (char)data <end> ;
printHexCharLine <start> charData <end> );"	"printHexCharLine <start> charData <end> );
void CWE197_Numeric_Truncation_Error__short_connect_socket_51b_badSink(short <start> data <end> );"	"void CWE197_Numeric_Truncation_Error__short_connect_socket_51b_badSink(short <start> data <end> );
printHexCharLine <start> charData <end> );"	3
893217b9-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_console_fopen_03 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(5==5) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
pFile = FOPEN <start> data <end> , ""wb+"");"	"<start> data = dataBuffer <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"dataLen = <start> strlen(data) <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	0
728a5013-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 static void badVaSinkB(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_13_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; if(GLOBAL_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(GLOBAL_CONST_FIVE==5) { badVaSinkB(data, data); } }"	where is the vulnerable dataflow from data to vprintf ?	"static void badVaSinkB(char * <start> data <end> , ...);
vprintf <start> data <end> , args);
badVaSinkB <start> data <end> , data);
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"size_t <start> dataLen = strlen(data) <end> ;
badVaSinkB <start> data <end> , data);
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
static void badVaSinkB(char * <start> data <end> , ...);"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);
vprintf <start> data <end> , args);"	"static void badVaSinkB(char * <start> data <end> , ...);
vprintf <start> data <end> , args);
size_t dataLen = <start> strlen(data) <end> ;
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	2
a1094903-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; void CWE190_Integer_Overflow__int_connect_socket_square_04_bad() { int data; data = 0; if(STATIC_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(STATIC_CONST_TRUE) { { int result = data * data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"<start> data = atoi(inputBuffer) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);
printIntLine <start> result <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"<start> data = 0 <end> ;
printIntLine <start> result <end> );"	2
c72d5d42-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_file_open_67 { typedef struct _structType { char * structFirst; } structType; void badSink(structType myStruct) { char * data = myStruct.structFirst; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"char <start> * data = myStruct.structFirst <end> ;
void badSink(structType <start> myStruct <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"char * data = <start> myStruct <end> .structFirst;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
void badSink(structType <start> myStruct <end> );"	"char * data = <start> myStruct <end> .structFirst;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"void badSink(structType <start> myStruct <end> );
char * data = <start> myStruct <end> .structFirst;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	3
a36a7912-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticTrue = 1; static int staticFalse = 0; void CWE190_Integer_Overflow__int_listen_socket_multiply_05_bad() { int data; data = 0; if(staticTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticTrue) { if(data > 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int <start> result = data * 2 <end> ;"	"if  <start> acceptSocket == SOCKET_ERROR <end> );
printIntLine <start> result <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	2
7d44fcc2-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_41_badSink(int data) { if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } } void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_41_bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_41_badSink(data); }"	where is the vulnerable dataflow from data to malloc ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_41_badSink <start> data <end> );
void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_41_badSink(int <start> data <end> );
char * dataBuffer = (char *)malloc <start> data <end> );"	"<start> free(dataBuffer) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_41_badSink(int <start> data <end> );
CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_41_badSink <start> data <end> );"	"char * dataBuffer = <start> (char *)malloc(data) <end> ;
char * dataBuffer = (char *)malloc <start> data <end> );
void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_41_badSink(int <start> data <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
char * dataBuffer = (char *)malloc <start> data <end> );
<start> memset(dataBuffer, 'A', data-1) <end> ;
void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_41_badSink(int <start> data <end> );"	0
78800fd5-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 8 static const int STATIC_CONST_FIVE = 5; void CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_06_bad() { short data; data = 0; if(STATIC_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"printLine <start> dest <end> );
if (tempInt > SHRT_MAX || <start> tempInt < SHRT_MIN <end> );"	"if (tempInt > SHRT_MAX || <start> tempInt < SHRT_MIN <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"printLine <start> dest <end> );
<start> data = tempInt <end> ;"	2
93ece313-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING ""hello"" void CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_51b_badSink(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); } else { printLine(""Input is less than the length of the source string""); } } }"	where is the vulnerable dataflow from data to malloc ?	"myString = (char * <start> malloc(data*sizeof(char)) <end> ;
myString = (char *)malloc <start> data*sizeof(char) <end> );"	"myString = (char * <start> malloc(data*sizeof(char)) <end> ;
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_51b_badSink(size_t <start> data <end> );"	"void CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_51b_badSink(size_t <start> data <end> );
myString = (char *)malloc <start> data*sizeof(char) <end> );"	"myString = (char *)malloc <start> data*sizeof(char) <end> );
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_51b_badSink(size_t <start> data <end> );"	2
73bc816b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" static const int STATIC_CONST_FIVE = 5; void CWE194_Unexpected_Sign_Extension__connect_socket_memmove_06_bad() { short data; data = 0; if(STATIC_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"printLine <start> dest <end> );
<start> data = tempInt <end> ;"	"tempInt = <start> atoi(inputBuffer) <end> ;
printLine <start> dest <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"char <start> dest[100] = """" <end> ;
printLine <start> dest <end> );"	2
55ef4c94-6c15-11ed-81d4-94e6f77dd552	namespace CWE191_Integer_Underflow__int_connect_socket_sub_82 { void CWE191_Integer_Underflow__int_connect_socket_sub_82_bad::action(int data) { { int result = data - 1; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"void CWE191_Integer_Underflow__int_connect_socket_sub_82_bad::action(int <start> data <end> );
int <start> result = data - 1 <end> ;"	"<start> printIntLine(result) <end> ;
void CWE191_Integer_Underflow__int_connect_socket_sub_82_bad::action(int <start> data <end> );"	"int result = <start> data - 1 <end> ;
void CWE191_Integer_Underflow__int_connect_socket_sub_82_bad::action(int <start> data <end> );"	"void CWE191_Integer_Underflow__int_connect_socket_sub_82_bad::action(int <start> data <end> );
int result = <start> data <end>  - 1;"	3
4ff7826c-6c15-11ed-81d4-94e6f77dd552	"void CWE190_Integer_Overflow__short_fscanf_postinc_13_bad() { short data; data = 0; if(GLOBAL_CONST_FIVE==5) { fscanf (stdin, ""%hd"", &data); } if(GLOBAL_CONST_FIVE==5) { { data++; short result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"fscanf (stdin, ""%hd"", <start> &data <end> );
<start> printIntLine(result) <end> ;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
short <start> result = data <end> ;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
<start> data <end> ++;"	"<start> data <end> ++;
fscanf (stdin, ""%hd"", <start> &data <end> );"	2
728a5034-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" void CWE194_Unexpected_Sign_Extension__connect_socket_malloc_03_bad() { short data; data = 0; if(5==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }"	where is the vulnerable dataflow from data to malloc ?	"<start> free(dataBuffer) <end> ;
char * dataBuffer = (char *)malloc <start> data <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
char * dataBuffer = (char *)malloc <start> data <end> );"	"<start> printLine(dataBuffer) <end> ;
char * dataBuffer = (char *)malloc <start> data <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> free(dataBuffer) <end> ;"	1
67d010cd-6c15-11ed-81d4-94e6f77dd552	static const int STATIC_CONST_FIVE = 5; void CWE190_Integer_Overflow__char_rand_preinc_06_bad() { char data; data = ' '; if(STATIC_CONST_FIVE==5) { data = (char)RAND32(); } if(STATIC_CONST_FIVE==5) { { ++data; char result = data; printHexCharLine(result); } } }	where is the vulnerable dataflow from data ?	"<start> printHexCharLine(result) <end> ;
+ <start> data <end> ;"	"data = (char <start> RAND32() <end> ;
+ <start> data <end> ;"	"char <start> result = data <end> ;
data = (char <start> RAND32() <end> ;"	"char <start> result = data <end> ;
+ <start> data <end> ;"	1
6ef7680f-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif void CWE134_Uncontrolled_Format_String__char_console_snprintf_52c_badSink(char * data) { { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"void CWE134_Uncontrolled_Format_String__char_console_snprintf_52c_badSink(char * <start> data <end> );
printLine <start> dest <end> );"	"printLine <start> dest <end> );
<start> printLine(dest) <end> ;"	"printLine <start> dest <end> );
void CWE134_Uncontrolled_Format_String__char_console_snprintf_52c_badSink(char * <start> data <end> );"	"void CWE134_Uncontrolled_Format_String__char_console_snprintf_52c_badSink(char * <start> data <end> );
<start> printLine(dest) <end> ;"	0
4a021122-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_FIVE = 5; void CWE190_Integer_Overflow__int_listen_socket_square_06_bad() { int data; data = 0; if(STATIC_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(STATIC_CONST_FIVE==5) { { int result = data * data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  * data;
if  <start> listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  * data;"	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  * data;"	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
int result = <start> data <end>  * data;"	1
c72d5d62-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_listen_socket_fopen_45 { static char * badData; static char * goodG2BData; static void badSink() { char * data = badData; { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } } void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badData = data; badSink(); }"	where is the vulnerable dataflow from data to FOPEN ?	"char * data = <start> badData <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");
size_t dataLen = <start> strlen(data) <end> ;
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
static char * <start> badData <end> ;"	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
static char * <start> badData <end> ;
<start> badData = data <end> ;"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
<start> badData = data <end> ;
static char * <start> badData <end> ;
char * data = <start> badData <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"static char * <start> badData <end> ;
<start> badData = data <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	2
a49c4f6f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_square_15_bad() { int data; data = 0; switch(6) { case 6: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; default: printLine(""Benign, fixed string""); break; } switch(7) { case 7: { int result = data * data; printIntLine(result); } break; default: printLine(""Benign, fixed string""); break; } }"	where is the vulnerable dataflow from result to printIntLine ?	"int result = <start> data * data <end> ;
printIntLine <start> result <end> );"	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	"int <start> result = data * data <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	3
656cd403-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__int_rand_multiply_81 { void CWE190_Integer_Overflow__int_rand_multiply_81_bad::action(int data) const { if(data > 0) { int result = data * 2; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"void CWE190_Integer_Overflow__int_rand_multiply_81_bad::action(int <start> data <end> ) const;
int <start> result = data * 2 <end> ;"	"void CWE190_Integer_Overflow__int_rand_multiply_81_bad::action(int <start> data <end> ) const;
int result = <start> data <end>  * 2;"	"int result = <start> data <end>  * 2;
void CWE190_Integer_Overflow__int_rand_multiply_81_bad::action(int <start> data <end> ) const;"	"<start> printIntLine(result) <end> ;
void CWE190_Integer_Overflow__int_rand_multiply_81_bad::action(int <start> data <end> ) const;"	1
cd228163-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_console_open_21 { static int badStatic = 0; static char * badSource(char * data) { if(badStatic) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } return data; } void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; badStatic = 1; data = badSource(data); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } ; }"	where is the vulnerable dataflow from data to OPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN(data, O_RDWR|O_CREAT, <start> S_IREAD|S_IWRITE <end> );
static char * <start> badSource <end> (char * data);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
data = <start> badSource <end> (data);"	"size_t dataLen = <start> strlen(data) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
data = <start> badSource <end> (data);
static char * <start> badSource <end> (char * data);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
data = <start> badSource <end> (data);
static char * <start> badSource <end> (char * data);"	0
4b34afd9-6c15-11ed-81d4-94e6f77dd552	"void CWE190_Integer_Overflow__short_fscanf_multiply_16_bad() { short data; data = 0; while(1) { fscanf (stdin, ""%hd"", &data); break; } while(1) { if(data > 0) { short result = data * 2; printIntLine(result); } break; } }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );"	"fscanf (stdin, ""%hd"", <start> &data <end> );
short result = <start> data <end>  * 2;"	"short result = <start> data <end>  * 2;
if <start> data > 0 <end> ) ;"	"short <start> result = data * 2 <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );"	1
833ac932-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif static const int STATIC_CONST_FIVE = 5; namespace CWE23_Relative_Path_Traversal__char_listen_socket_open_06 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(STATIC_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"replace = <start> strchr(data, '\n') <end> ;
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
size_t dataLen = <start> strlen(data) <end> ;"	1
9187cc13-6c15-11ed-81d4-94e6f77dd552	"#define SEARCH_CHAR 'S' namespace CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_console_74 { void badSink(map<int, char *> dataMap) { char * data = dataMap[2]; for (; *data != '\0'; data++) { if (*data == SEARCH_CHAR) { printLine(""We have a match!""); break; } } free(data); }"	where is the vulnerable dataflow from data to free ?	"void badSink(map<int, char *> <start> dataMap <end> );
<start> free(data) <end> ;"	"void badSink(map<int, char *> <start> dataMap <end> );
free <start> data <end> );"	"<start> free(data) <end> ;
free <start> data <end> );"	"for (; *data != '\0'; <start> data++ <end> );
free <start> data <end> );"	1
630ae80a-6c15-11ed-81d4-94e6f77dd552	"void CWE190_Integer_Overflow__short_rand_square_15_bad() { short data; data = 0; switch(6) { case 6: data = (short)RAND32(); break; default: printLine(""Benign, fixed string""); break; } switch(7) { case 7: { short result = data * data; printIntLine(result); } break; default: printLine(""Benign, fixed string""); break; } }"	where is the vulnerable dataflow from data ?	"data = (short <start> RAND32() <end> ;
short result = <start> data * data <end> ;"	"<start> printIntLine(result) <end> ;
short result = <start> data <end>  * data;"	"data = (short <start> RAND32() <end> ;
short result = <start> data <end>  * data;"	"data = (short <start> RAND32() <end> ;
<start> printIntLine(result) <end> ;"	2
453db037-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_FIVE = 5; void CWE190_Integer_Overflow__int_connect_socket_square_06_bad() { int data; data = 0; if(STATIC_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(STATIC_CONST_FIVE==5) { { int result = data * data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"data = <start> atoi(inputBuffer) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"int result = <start> data <end>  * data;
data = <start> atoi(inputBuffer) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  * data;"	"int <start> result = data * data <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	2
8a6310ce-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_file_open_53 { void badSink_d(char * data) { { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"void badSink_d(char * <start> data <end> );
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
void badSink_d(char * <start> data <end> );"	"void badSink_d(char * <start> data <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	3
ce547d5d-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } namespace CWE36_Absolute_Path_Traversal__char_environment_ofstream_08 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(staticReturnsTrue()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"size_t dataLen = <start> strlen(data) <end> ;
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"outputFile.open((char * <start> data <end> );
<start> data = dataBuffer <end> ;"	"strncat <start> data+dataLen <end> , environment, FILENAME_MAX-dataLen-1);
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
outputFile.open((char * <start> data <end> );"	3
7fa68e3e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_connect_socket_fopen_62 { void badSource(char * &data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; badSource(data); { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"badSource <start> data <end> );
pFile = FOPEN <start> data <end> , ""wb+"");"	"badSource <start> data <end> );
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	"pFile = FOPEN <start> data <end> , ""wb+"");
badSource <start> data <end> );"	"pFile = FOPEN <start> data <end> , ""wb+"");
<start> data = dataBuffer <end> ;"	0
7c127560-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_14_bad() { int data; data = -1; if(globalFive==5) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }"	where is the vulnerable dataflow from data to malloc ?	"<start> memset(dataBuffer, 'A', data-1) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"<start> free(dataBuffer) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
char * dataBuffer = (char *)malloc <start> data <end> );"	"<start> data = -1 <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	2
5e44fc76-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_fgets_predec_14_bad() { int data; data = 0; if(globalFive==5) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(globalFive==5) { { --data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
- <start> data <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> --data <end> ;"	"- <start> data <end> ;
int <start> result = data <end> ;"	"data = <start> atoi(inputBuffer) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	0
b1b80804-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) typedef union { int unionFirst; int unionSecond; } CWE197_Numeric_Truncation_Error__int_listen_socket_to_char_34_unionType; void CWE197_Numeric_Truncation_Error__int_listen_socket_to_char_34_bad() { int data; CWE197_Numeric_Truncation_Error__int_listen_socket_to_char_34_unionType myUnion; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } myUnion.unionFirst = data; { int data = myUnion.unionSecond; { char charData = (char)data; printHexCharLine(charData); } } }"	where is the vulnerable dataflow from charData to printHexCharLine ?	"if  <start> listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printHexCharLine <start> charData <end> );"	"<start> printHexCharLine(charData) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"char <start> charData = (char)data <end> ;
printHexCharLine <start> charData <end> );"	1
7fa68e14-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_54e_badSink(int data) { { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_54e_badSink(int <start> data <end> );
<start> strncpy(dest, source, data) <end> ;"	"void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_54e_badSink(int <start> data <end> );
printLine <start> dest <end> );"	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	"void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_54e_badSink(int <start> data <end> );
if  <start> data < 100 <end> );"	1
846ad2fc-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif void CWE253_Incorrect_Check_of_Function_Return_Value__char_fgets_03_bad() { if(5==5) { { char dataBuffer[100] = """"; char * data = dataBuffer; printLine(""Please enter a string: ""); if (fgets(data, 100, stdin) < 0) { printLine(""fgets failed!""); exit(1); } printLine(data); } } }"	where is the vulnerable dataflow from data to printLine ?	"if (fgets <start> data <end> , 100, stdin) < 0);
<start> printLine(data) <end> ;"	"printLine <start> data <end> );
<start> printLine(data) <end> ;"	"printLine <start> data <end> );
if (fgets <start> data <end> , 100, stdin) < 0);"	"if (fgets <start> data <end> , 100, stdin) < 0);
printLine <start> data <end> );"	3
d31a2527-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_listen_socket_open_43 { void badSource(char * &data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; badSource(data); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"replace = <start> strchr(data, '\n') <end> ;
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
badSource <start> data <end> );"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
badSource <start> data <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"<start> recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0) <end> ;
badSource <start> data <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	2
70279be9-6c15-11ed-81d4-94e6f77dd552	#ifndef _WIN32 #endif static void badVaSink(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_console_vprintf_66b_badSink(char * dataArray[]) { char * data = dataArray[2]; badVaSink(data, data); }	where is the vulnerable dataflow from data to vprintf ?	"void CWE134_Uncontrolled_Format_String__char_console_vprintf_66b_badSink(char * <start> dataArray <end> []);
vprintf <start> data <end> , args);
static void badVaSink(char * <start> data <end> , ...);
badVaSink <start> data <end> , data);"	"void CWE134_Uncontrolled_Format_String__char_console_vprintf_66b_badSink(char * <start> dataArray <end> []);
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
vprintf <start> data <end> , args);"	"static void badVaSink(char * <start> data <end> , ...);
void CWE134_Uncontrolled_Format_String__char_console_vprintf_66b_badSink(char * <start> dataArray <end> []);
vprintf <start> data <end> , args);
<start> vprintf(data, args) <end> ;"	"vprintf <start> data <end> , args);
<start> vprintf(data, args) <end> ;
badVaSink <start> data <end> , data);
void CWE134_Uncontrolled_Format_String__char_console_vprintf_66b_badSink(char * <start> dataArray <end> []);"	1
669edaab-6c15-11ed-81d4-94e6f77dd552	typedef struct _CWE190_Integer_Overflow__int_rand_square_67_structType { int structFirst; } CWE190_Integer_Overflow__int_rand_square_67_structType; void CWE190_Integer_Overflow__int_rand_square_67b_badSink(CWE190_Integer_Overflow__int_rand_square_67_structType myStruct) { int data = myStruct.structFirst; { int result = data * data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
int data = <start> myStruct <end> .structFirst;
int result = <start> data <end>  * data;"	"void CWE190_Integer_Overflow__int_rand_square_67b_badSink(CWE190_Integer_Overflow__int_rand_square_67_structType <start> myStruct <end> );
int data = <start> myStruct <end> .structFirst;
int result = <start> data <end>  * data;"	"int data = <start> myStruct <end> .structFirst;
int result = <start> data * data <end> ;
void CWE190_Integer_Overflow__int_rand_square_67b_badSink(CWE190_Integer_Overflow__int_rand_square_67_structType <start> myStruct <end> );"	"int result = <start> data <end>  * data;
int data = <start> myStruct <end> .structFirst;
void CWE190_Integer_Overflow__int_rand_square_67b_badSink(CWE190_Integer_Overflow__int_rand_square_67_structType <start> myStruct <end> );"	1
acf67e2f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_connect_socket_predec_51b_badSink(int data) { { --data; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"<start> --data <end> ;
printIntLine <start> result <end> );"	"void CWE191_Integer_Underflow__int_connect_socket_predec_51b_badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
int <start> result = data <end> ;"	"printIntLine <start> result <end> );
void CWE191_Integer_Underflow__int_connect_socket_predec_51b_badSink(int <start> data <end> );"	1
728a501a-6c15-11ed-81d4-94e6f77dd552	#ifndef _WIN32 #endif extern int CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_22_badGlobal; void CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_22_badVaSink(char * data, ...) { if(CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_22_badGlobal) { { va_list args; va_start(args, data); vprintf(data, args); va_end(args); } } }	where is the vulnerable dataflow from data to vprintf ?	"void CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_22_badVaSink(char * <start> data <end> , ...);
vprintf <start> data <end> , args);"	"<start> vprintf(data, args) <end> ;
void CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_22_badVaSink(char * <start> data <end> , ...);"	"vprintf <start> data <end> , args);
void CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_22_badVaSink(char * <start> data <end> , ...);"	"vprintf <start> data <end> , args);
<start> va_start(args, data) <end> ;"	0
656cd41b-6c15-11ed-81d4-94e6f77dd552	static int badSource(int data) { data = RAND32(); return data; } void CWE190_Integer_Overflow__int_rand_square_42_bad() { int data; data = 0; data = badSource(data); { int result = data * data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"static int <start> badSource <end> (int data);
data = <start> RAND32() <end> ;"	"<start> printIntLine(result) <end> ;
data = <start> RAND32() <end> ;
data = <start> badSource <end> (data);
static int <start> badSource <end> (int data);"	"data = <start> RAND32() <end> ;
static int <start> badSource <end> (int data);
data = <start> badSource <end> (data);
int result = <start> data <end>  * data;"	"int result = <start> data <end>  * data;
data = <start> badSource <end> (data);
<start> printIntLine(result) <end> ;
data = <start> RAND32() <end> ;"	2
79b2754c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_08_bad() { int data; data = -1; if(staticReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"printLine <start> dest <end> );
if  <start> data < 100 <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
char <start> dest[100] = """" <end> ;"	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printLine <start> dest <end> );"	1
bed4a8f6-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" namespace CWE23_Relative_Path_Traversal__char_connect_socket_ifstream_53 { void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badSink_b(data); }"	where is the vulnerable dataflow from data to badSink_b ?	"badSink_b <start> data <end> );
replace = <start> strchr(data, '\n') <end> ;"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
badSink_b <start> data <end> );"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
size_t <start> dataLen = strlen(data) <end> ;"	"recvResult = <start> recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0) <end> ;
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	1
964cdbef-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FULL_COMMAND ""dir "" #else #define FULL_COMMAND ""ls "" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define POPEN _popen #define PCLOSE _pclose #else #define POPEN popen #define PCLOSE pclose #endif void CWE78_OS_Command_Injection__char_file_popen_18_bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; goto source; source: { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } { FILE *pipe; pipe = POPEN(data, ""w""); if (pipe != NULL) { PCLOSE(pipe); } } }"	where is the vulnerable dataflow from data to POPEN ?	"pipe = POPEN <start> data <end> , ""w"");
pipe = <start> POPEN(data, ""w"") <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
pipe = <start> POPEN(data, ""w"") <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
pipe = POPEN <start> data <end> , ""w"");"	"size_t dataLen = <start> strlen(data) <end> ;
pipe = POPEN <start> data <end> , ""w"");"	2
761e2986-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 8 typedef union { short unionFirst; short unionSecond; } CWE194_Unexpected_Sign_Extension__fgets_memmove_34_unionType; void CWE194_Unexpected_Sign_Extension__fgets_memmove_34_bad() { short data; CWE194_Unexpected_Sign_Extension__fgets_memmove_34_unionType myUnion; data = 0; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = (short)atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } myUnion.unionFirst = data; { short data = myUnion.unionSecond; { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } } }"	where is the vulnerable dataflow from dest to printLine ?	"printLine <start> dest <end> );
<start> memmove(dest, source, data) <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printLine <start> dest <end> );"	"<start> printLine(dest) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"<start> memmove(dest, source, data) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	1
9b124d9c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticFive = 5; void CWE124_Buffer_Underwrite__CWE839_listen_socket_07_bad() { int data; data = -1; if(staticFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticFive==5) { { int i; int buffer[10] = { 0 }; if (data < 10) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } } } }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> buffer[i] <end> );"	"data = <start> atoi(inputBuffer) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"printIntLine <start> buffer[i] <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[i] <end> );"	3
d1e9da5a-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 namespace CWE36_Absolute_Path_Traversal__char_listen_socket_ifstream_09 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(GLOBAL_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
replace = <start> strchr(data, '\n') <end> ;"	"<start> data = dataBuffer <end> ;
inputFile.open((char * <start> data <end> );"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
inputFile.open((char * <start> data <end> );"	"size_t dataLen = <start> strlen(data) <end> ;
inputFile.open((char * <start> data <end> );"	2
7ae3a71f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_53d_badSink(int data) { { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"char <start> dest[100] = """" <end> ;
printLine <start> dest <end> );"	"printLine <start> dest <end> );
void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_53d_badSink(int <start> data <end> );"	"void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_53d_badSink(int <start> data <end> );
printLine <start> dest <end> );"	"void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_53d_badSink(int <start> data <end> );
char <start> dest[100] = """" <end> ;"	2
54c581e6-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_connect_socket_multiply_09_bad() { int data; data = 0; if(GLOBAL_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(GLOBAL_CONST_TRUE) { if(data < 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> data = 0 <end> ;
int result = <start> data <end>  * 2;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  * 2;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printIntLine(result) <end> ;"	"int result = <start> data <end>  * 2;
<start> printIntLine(result) <end> ;"	1
48d25d9a-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__int_fscanf_square_74 { void badSink(map<int, int> dataMap) { int data = dataMap[2]; { int result = data * data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"int <start> result = data * data <end> ;
void badSink(map<int, int> <start> dataMap <end> );"	"<start> printIntLine(result) <end> ;
void badSink(map<int, int> <start> dataMap <end> );"	"int result = <start> data <end>  * data;
void badSink(map<int, int> <start> dataMap <end> );"	"void badSink(map<int, int> <start> dataMap <end> );
int result = <start> data <end>  * data;"	3
acf67e0c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_listen_socket_postdec_53d_badSink(int data) { { data--; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;"	"<start> printIntLine(result) <end> ;
void CWE191_Integer_Underflow__int_listen_socket_postdec_53d_badSink(int <start> data <end> );"	"printIntLine <start> result <end> );
void CWE191_Integer_Underflow__int_listen_socket_postdec_53d_badSink(int <start> data <end> );"	"void CWE191_Integer_Underflow__int_listen_socket_postdec_53d_badSink(int <start> data <end> );
printIntLine <start> result <end> );"	3
a36a78ca-6c15-11ed-81d4-94e6f77dd552	extern int CWE190_Integer_Overflow__int_fgets_square_22_badGlobal; void CWE190_Integer_Overflow__int_fgets_square_22_badSink(int data) { if(CWE190_Integer_Overflow__int_fgets_square_22_badGlobal) { { int result = data * data; printIntLine(result); } } }	where is the vulnerable dataflow from result to printIntLine ?	"int <start> result = data * data <end> ;
void CWE190_Integer_Overflow__int_fgets_square_22_badSink(int <start> data <end> );"	"printIntLine <start> result <end> );
void CWE190_Integer_Overflow__int_fgets_square_22_badSink(int <start> data <end> );"	"<start> printIntLine(result) <end> ;
void CWE190_Integer_Overflow__int_fgets_square_22_badSink(int <start> data <end> );"	"void CWE190_Integer_Overflow__int_fgets_square_22_badSink(int <start> data <end> );
printIntLine <start> result <end> );"	3
598370b4-6c15-11ed-81d4-94e6f77dd552	namespace CWE191_Integer_Underflow__short_fscanf_multiply_74 { void badSink(map<int, short> dataMap) { short data = dataMap[2]; if(data < 0) { short result = data * 2; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"void badSink(map<int, short> <start> dataMap <end> );
short result = <start> data <end>  * 2;"	"<start> printIntLine(result) <end> ;
short result = <start> data <end>  * 2;"	"void badSink(map<int, short> <start> dataMap <end> );
short <start> result = data * 2 <end> ;"	"short result = <start> data <end>  * 2;
void badSink(map<int, short> <start> dataMap <end> );"	0
8b91e471-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_listen_socket_open_13 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(GLOBAL_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"replace = <start> strchr(data, '\r') <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
replace = <start> strchr(data, '\n') <end> ;"	"size_t dataLen = <start> strlen(data) <end> ;
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	0
c26a7e76-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_environment_fopen_34 { typedef union { char * unionFirst; char * unionSecond; } unionType; void bad() { char * data; unionType myUnion; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } } }"	where is the vulnerable dataflow from data to FOPEN ?	"strncat(data+dataLen, environment, FILENAME_MAX <start> dataLen-1 <end> );
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"<start> data = dataBuffer <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
size_t dataLen = <start> strlen(data) <end> ;"	2
48d25d85-6c15-11ed-81d4-94e6f77dd552	extern int CWE190_Integer_Overflow__int_fscanf_square_22_badGlobal; void CWE190_Integer_Overflow__int_fscanf_square_22_badSink(int data) { if(CWE190_Integer_Overflow__int_fscanf_square_22_badGlobal) { { int result = data * data; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"int <start> result = data * data <end> ;
void CWE190_Integer_Overflow__int_fscanf_square_22_badSink(int <start> data <end> );"	"int result = <start> data <end>  * data;
void CWE190_Integer_Overflow__int_fscanf_square_22_badSink(int <start> data <end> );"	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  * data;"	"void CWE190_Integer_Overflow__int_fscanf_square_22_badSink(int <start> data <end> );
int result = <start> data <end>  * data;"	3
b1b80822-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticFive = 5; void CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_07_bad() { int data; data = -1; if(staticFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { short shortData = (short)data; printShortLine(shortData); } }"	where is the vulnerable dataflow from shortData to printShortLine ?	"printShortLine <start> shortData <end> );
if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printShortLine <start> shortData <end> );"	"short shortData = <start> (short)data <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"short shortData = <start> (short)data <end> ;
printShortLine <start> shortData <end> );"	1
bed4a8cc-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_connect_socket_fopen_44 { static void badSink(char * data) { { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } } void bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } funcPtr(data); }"	where is the vulnerable dataflow from data to funcPtr ?	"funcPtr <start> data <end> );
replace = <start> strchr(data, '\n') <end> ;"	"funcPtr <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
funcPtr <start> data <end> );"	3
d1e9da60-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 namespace CWE36_Absolute_Path_Traversal__char_listen_socket_ifstream_15 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; switch(6) { case 6: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; default: printLine(""Benign, fixed string""); break; } { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"inputFile.open((char * <start> data <end> );
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"inputFile.open((char * <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	"if  <start> listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR <end> );
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
inputFile.open((char * <start> data <end> );"	3
bed4a8d2-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_connect_socket_fopen_61 { char * badSource(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; data = badSource(data); { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"data = <start> badSource <end> (data);
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	"pFile = FOPEN <start> data <end> , ""wb+"");
data = <start> badSource(data) <end> ;"	"pFile = FOPEN <start> data <end> , ""wb+"");
data = <start> badSource <end> (data);"	0
b54bcf21-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 20 void CWE369_Divide_by_Zero__float_listenSocket_02_bad() { float data; data = 0.0F; if(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = (float)atof(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(1) { { int result = (int)(100.0 / data); printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"int <start> result = (int)(100.0 / data) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data = (float)atof(inputBuffer) <end> ;"	"data = (float <start> atof(inputBuffer) <end> ;
printIntLine <start> result <end> );"	1
61da66d8-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__char_rand_square_02_bad() { char data; data = ' '; if(1) { data = (char)RAND32(); } if(1) { { char result = data * data; printHexCharLine(result); } } }	where is the vulnerable dataflow from data ?	"data = (char <start> RAND32() <end> ;
char result = <start> data <end>  * data;"	"char result = <start> data * data <end> ;
data = (char <start> RAND32() <end> ;"	"<start> data = (char)RAND32() <end> ;
char result = <start> data <end>  * data;"	"char result = <start> data <end>  * data;
data = (char <start> RAND32() <end> ;"	0
b2ea8db2-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" namespace CWE197_Numeric_Truncation_Error__short_connect_socket_81 { void bad() { short data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = (short)atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } const CWE197_Numeric_Truncation_Error__short_connect_socket_81_base& baseObject = CWE197_Numeric_Truncation_Error__short_connect_socket_81_bad(); baseObject.action(data); }"	where is the vulnerable dataflow from data to action ?	"recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);
baseObject.action <start> data <end> );"	"baseObject.action <start> data <end> );
data = (short <start> atoi(inputBuffer) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
baseObject.action <start> data <end> );"	"data = (short <start> atoi(inputBuffer) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	2
5be3a9a0-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_fgets_postdec_54e_badSink(int data) { { data--; int result = data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
void CWE191_Integer_Underflow__int_fgets_postdec_54e_badSink(int <start> data <end> );"	"<start> printIntLine(result) <end> ;
<start> data <end> --;"	"<start> data <end> --;
void CWE191_Integer_Underflow__int_fgets_postdec_54e_badSink(int <start> data <end> );"	"void CWE191_Integer_Underflow__int_fgets_postdec_54e_badSink(int <start> data <end> );
<start> data <end> --;"	3
b41b87ba-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 20 #define IP_ADDRESS ""127.0.0.1"" namespace CWE369_Divide_by_Zero__float_connect_socket_81 { void bad() { float data; data = 0.0F; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = (float)atof(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } const CWE369_Divide_by_Zero__float_connect_socket_81_base& baseObject = CWE369_Divide_by_Zero__float_connect_socket_81_bad(); baseObject.action(data); }"	where is the vulnerable dataflow from data to action ?	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
baseObject.action <start> data <end> );"	"data = (float <start> atof(inputBuffer) <end> ;
baseObject.action <start> data <end> );"	"recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);
baseObject.action <start> data <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
baseObject.action <start> data <end> );"	3
67d010ce-6c15-11ed-81d4-94e6f77dd552	static int staticFive = 5; void CWE190_Integer_Overflow__char_rand_preinc_07_bad() { char data; data = ' '; if(staticFive==5) { data = (char)RAND32(); } if(staticFive==5) { { ++data; char result = data; printHexCharLine(result); } } }	where is the vulnerable dataflow from data ?	"data = (char <start> RAND32() <end> ;
+ <start> data <end> ;"	"<start> printHexCharLine(result) <end> ;
data = (char <start> RAND32() <end> ;"	"<start> data = ' ' <end> ;
+ <start> data <end> ;"	"char <start> result = data <end> ;
+ <start> data <end> ;"	0
c4cd6f61-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif static int staticFive = 5; namespace CWE23_Relative_Path_Traversal__char_file_fopen_07 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(staticFive==5) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
<start> data = dataBuffer <end> ;"	"size_t dataLen = <start> strlen(data) <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
pFile = FOPEN <start> data <end> , ""wb+"");"	3
453db036-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticTrue = 1; static int staticFalse = 0; void CWE190_Integer_Overflow__int_connect_socket_square_05_bad() { int data; data = 0; if(staticTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticTrue) { { int result = data * data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"data = <start> atoi(inputBuffer) <end> ;
int result = <start> data <end>  * data;"	"int result = <start> data <end>  * data;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"<start> printIntLine(result) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  * data;"	3
bed4a8b5-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_connect_socket_fopen_03 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(5==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
replace = <start> strchr(data, '\r') <end> ;"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
size_t dataLen = <start> strlen(data) <end> ;"	"pFile = FOPEN <start> data <end> , ""wb+"");
size_t dataLen = <start> strlen(data) <end> ;"	1
a36a78c4-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_square_14_bad() { int data; data = 0; if(globalFive==5) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(globalFive==5) { { int result = data * data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
int <start> result = data * data <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
if  <start> fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) <end>  != NULL);"	1
ce547d62-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif namespace CWE36_Absolute_Path_Traversal__char_environment_ofstream_13 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(GLOBAL_CONST_FIVE==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
size_t dataLen = <start> strlen(data) <end> ;"	"size_t dataLen = <start> strlen(data) <end> ;
outputFile.open((char * <start> data <end> );"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
outputFile.open((char * <start> data <end> );"	"size_t <start> dataLen = strlen(data) <end> ;
outputFile.open((char * <start> data <end> );"	2
55ef4cc4-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticTrue = 1; static int staticFalse = 0; void CWE191_Integer_Underflow__int_fgets_sub_05_bad() { int data; data = 0; if(staticTrue) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(staticTrue) { { int result = data - 1; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
int result = <start> data <end>  - 1;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
int result = <start> data - 1 <end> ;"	"<start> printIntLine(result) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"int result = <start> data <end>  - 1;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	0
a5ce1c5b-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_postinc_16_bad() { int data; data = 0; while(1) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } break; } while(1) { { data++; int result = data; printIntLine(result); } break; } }"	where is the vulnerable dataflow from result to printIntLine ?	"<start> data = atoi(inputBuffer) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"printIntLine <start> result <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> data++ <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );"	3
c8600b14-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_listen_socket_open_54 { void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badSink_b(data); }"	where is the vulnerable dataflow from data to badSink_b ?	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
badSink_b <start> data <end> );"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
if  <start> acceptSocket == SOCKET_ERROR <end> );"	"char <start> dataBuffer[FILENAME_MAX] = BASEPATH <end> ;
badSink_b <start> data <end> );"	0
977ea78c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) typedef union { int unionFirst; int unionSecond; } CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_34_unionType; void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_34_bad() { int data; CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_34_unionType myUnion; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } myUnion.unionFirst = data; { int data = myUnion.unionSecond; { int i; int buffer[10] = { 0 }; if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } } } }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[i] <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printIntLine(buffer[i]) <end> ;"	"printIntLine <start> buffer[i] <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"printIntLine <start> buffer[i] <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	0
b8e2bdaf-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define NEW_PATH ""%SystemRoot%\\system32"" #define PUTENV _putenv #else #define NEW_PATH ""/bin"" #define PUTENV putenv #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 void CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_66b_badSink(char * dataArray[]) { char * data = dataArray[2]; PUTENV(data); }"	where is the vulnerable dataflow from data to PUTENV ?	"void CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_66b_badSink(char * <start> dataArray <end> []);
PUTENV <start> data <end> );"	"char <start> * data = dataArray[2] <end> ;
void CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_66b_badSink(char * <start> dataArray <end> []);"	"<start> PUTENV(data) <end> ;
void CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_66b_badSink(char * <start> dataArray <end> []);"	"PUTENV <start> data <end> );
void CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_66b_badSink(char * <start> dataArray <end> []);"	0
bed4a8f7-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" namespace CWE23_Relative_Path_Traversal__char_connect_socket_ifstream_54 { void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badSink_b(data); }"	where is the vulnerable dataflow from data to badSink_b ?	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
badSink_b <start> data <end> );"	"badSink_b <start> data <end> );
replace = <start> strchr(data, '\n') <end> ;"	"badSink_b <start> data <end> );
<start> badSink_b(data) <end> ;"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	0
a49c4f6b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_square_11_bad() { int data; data = 0; if(globalReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalReturnsTrue()) { { int result = data * data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"data = <start> atoi(inputBuffer) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"if  <start> listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR <end> );
printIntLine <start> result <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
if  <start> listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR <end> );"	0
7e74f349-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_15_bad() { int data; data = -1; switch(6) { case 6: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; default: printLine(""Benign, fixed string""); break; } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> printLine(dest) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"<start> memmove(dest, source, data) <end> ;
printLine <start> dest <end> );"	"printLine <start> dest <end> );
<start> data = atoi(inputBuffer) <end> ;"	1
a5ce1c41-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_postinc_51b_badSink(int data) { { data++; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
void CWE190_Integer_Overflow__int_connect_socket_postinc_51b_badSink(int <start> data <end> );"	"printIntLine <start> result <end> );
<start> data++ <end> ;"	"void CWE190_Integer_Overflow__int_connect_socket_postinc_51b_badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"int <start> result = data <end> ;
printIntLine <start> result <end> );"	2
c8600b0d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_listen_socket_open_42 { static char * badSource(char * data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } return data; } void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; data = badSource(data); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
data = <start> badSource <end> (data);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
static char * <start> badSource <end> (char * data);"	"static char * <start> badSource <end> (char * data);
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	0
648a9bf1-6c15-11ed-81d4-94e6f77dd552	static void badSink(int64_t data) { if(data > 0) { int64_t result = data * 2; printLongLongLine(result); } } void CWE190_Integer_Overflow__int64_t_rand_multiply_41_bad() { int64_t data; data = 0LL; data = (int64_t)RAND64(); badSink(data); }	where is the vulnerable dataflow from data ?	"data = (int64_t <start> RAND64() <end> ;
static void badSink(int64_t <start> data <end> );
<start> data = (int64_t)RAND64() <end> ;
int64_t result = <start> data <end>  * 2;"	"badSink <start> data <end> );
int64_t result = <start> data <end>  * 2;
data = (int64_t <start> RAND64() <end> ;"	"badSink <start> data <end> );
int64_t result = <start> data <end>  * 2;
data = (int64_t <start> RAND64() <end> ;
static void badSink(int64_t <start> data <end> );"	"data = (int64_t <start> RAND64() <end> ;
badSink <start> data <end> );
static void badSink(int64_t <start> data <end> );
int64_t result = <start> data <end>  * 2;"	3
b68484d9-6c15-11ed-81d4-94e6f77dd552	"namespace CWE36_Absolute_Path_Traversal__char_console_ifstream_82 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } CWE36_Absolute_Path_Traversal__char_console_ifstream_82_base* baseObject = new CWE36_Absolute_Path_Traversal__char_console_ifstream_82_bad; baseObject->action(data); delete baseObject; }"	where is the vulnerable dataflow from data to action ?	"baseObject->action <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
baseObject->action <start> data <end> );"	"<start> data = dataBuffer <end> ;
baseObject->action <start> data <end> );"	2
cf875098-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_environment_open_54 { void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } badSink_b(data); }"	where is the vulnerable dataflow from data to badSink_b ?	"<start> data = dataBuffer <end> ;
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
badSink_b <start> data <end> );"	"badSink_b <start> data <end> );
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"badSink_b <start> data <end> );
strncat(data+dataLen, environment, FILENAME_MAX <start> dataLen-1 <end> );"	1
87ff9876-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_connect_socket_open_41 { void badSink(char * data) { { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } } void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badSink(data); }"	where is the vulnerable dataflow from data to OPEN ?	"void badSink(char * <start> data <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
recvResult = <start> recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0) <end> ;
badSink <start> data <end> );"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
badSink <start> data <end> );
void badSink(char * <start> data <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"<start> badSink(data) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
void badSink(char * <start> data <end> );"	"void badSink(char * <start> data <end> );
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
replace = <start> strchr(data, '\r') <end> ;
badSink <start> data <end> );"	1
b7b09a6f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define NEW_PATH ""%SystemRoot%\\system32"" #define PUTENV _putenv #else #define NEW_PATH ""/bin"" #define PUTENV putenv #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif extern char * CWE427_Uncontrolled_Search_Path_Element__char_file_68_badData; extern char * CWE427_Uncontrolled_Search_Path_Element__char_file_68_goodG2BData; void CWE427_Uncontrolled_Search_Path_Element__char_file_68b_badSink() { char * data = CWE427_Uncontrolled_Search_Path_Element__char_file_68_badData; PUTENV(data); }"	where is the vulnerable dataflow from data to PUTENV ?	"char * data = <start> CWE427_Uncontrolled_Search_Path_Element__char_file_68_badData <end> ;
<start> PUTENV(data) <end> ;"	"PUTENV <start> data <end> );
char * data = <start> CWE427_Uncontrolled_Search_Path_Element__char_file_68_badData <end> ;"	"char * data = <start> CWE427_Uncontrolled_Search_Path_Element__char_file_68_badData <end> ;
PUTENV <start> data <end> );"	"PUTENV <start> data <end> );
<start> PUTENV(data) <end> ;"	2
87ff9861-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_connect_socket_open_01 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"size_t dataLen = <start> strlen(data) <end> ;
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"<start> data = dataBuffer <end> ;
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"replace = <start> strchr(data, '\r') <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	0
669edaba-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__char_rand_postinc_11_bad() { char data; data = ' '; if(globalReturnsTrue()) { data = (char)RAND32(); } if(globalReturnsTrue()) { { data++; char result = data; printHexCharLine(result); } } }	where is the vulnerable dataflow from data ?	"<start> data <end> ++;
<start> printHexCharLine(result) <end> ;"	"<start> data <end> ++;
data = (char <start> RAND32() <end> ;"	"data = (char <start> RAND32() <end> ;
char <start> result = data <end> ;"	"data = (char <start> RAND32() <end> ;
<start> data <end> ++;"	3
ce547d53-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif namespace CWE36_Absolute_Path_Traversal__char_environment_ifstream_53 { void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } badSink_b(data); }"	where is the vulnerable dataflow from data to badSink_b ?	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
badSink_b <start> data <end> );"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
strncat(data+dataLen, environment, <start> FILENAME_MAX-dataLen-1 <end> );"	"badSink_b <start> data <end> );
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"badSink_b <start> data <end> );
<start> data = dataBuffer <end> ;"	0
b1b8085d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" void CWE197_Numeric_Truncation_Error__short_connect_socket_31_bad() { short data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = (short)atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { short dataCopy = data; short data = dataCopy; { char charData = (char)data; printHexCharLine(charData); } } }"	where is the vulnerable dataflow from charData to printHexCharLine ?	"<start> printHexCharLine(charData) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printHexCharLine <start> charData <end> );"	"data = (short <start> atoi(inputBuffer) <end> ;
printHexCharLine <start> charData <end> );"	"char charData = <start> (char)data <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	1
92bb89e7-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #define SEARCH_CHAR 'S' static void badSink(char * data) { for (; *data != '\0'; data++) { if (*data == SEARCH_CHAR) { printLine(""We have a match!""); break; } } free(data); } void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_file_41_bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\0'; { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } badSink(data); }"	where is the vulnerable dataflow from data to free ?	"badSink <start> data <end> );
free <start> data <end> );
static void badSink(char * <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
badSink <start> data <end> );
static void badSink(char * <start> data <end> );
free <start> data <end> );"	"badSink <start> data <end> );
free <start> data <end> );
<start> badSink(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	"badSink <start> data <end> );
<start> free(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
free <start> data <end> );"	1
7ae3a73a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_13_bad() { int data; data = -1; if(GLOBAL_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"printLine <start> dest <end> );
recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printLine <start> dest <end> );"	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	1
ae26ae5b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_81 { void bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } const CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_81_base& baseObject = CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_81_bad(); baseObject.action(data); }"	where is the vulnerable dataflow from data to action ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
baseObject.action <start> data <end> );"	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
baseObject.action <start> data <end> );"	"if  <start> recvResult == SOCKET_ERROR <end>  || recvResult == 0);
baseObject.action <start> data <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
data = <start> atoi(inputBuffer) <end> ;"	0
79b27556-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_18_bad() { int data; data = -1; goto source; source: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> memcpy(dest, source, data) <end> ;"	"<start> memcpy(dest, source, data) <end> ;
printLine <start> dest <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	2
6b86241c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_connect_socket_03_bad() { int data; data = -1; if(5==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(5==5) { { int i; int * buffer = (int *)malloc(10 * sizeof(int)); if (buffer == NULL) {exit(-1);} for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } free(buffer); } } }"	where is the vulnerable dataflow from buffer to free ?	"if  <start> buffer == NULL <end> ) {exit(-1);};
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"<start> printIntLine(buffer[i]) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"free <start> buffer <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
free <start> buffer <end> );"	3
a1094912-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int badStatic = 0; static void badSink(int data) { if(badStatic) { { int result = data * data; printIntLine(result); } } } void CWE190_Integer_Overflow__int_connect_socket_square_21_bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badStatic = 1; badSink(data); }"	where is the vulnerable dataflow from result to printIntLine ?	"static void badSink(int <start> data <end> );
printIntLine <start> result <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
badSink <start> data <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSink <start> data <end> );
static void badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"static void badSink(int <start> data <end> );
badSink <start> data <end> );
printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;"	"int result = <start> data * data <end> ;
badSink <start> data <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	1
a49c4f61-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_square_01_bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { int result = data * data; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"data = <start> atoi(inputBuffer) <end> ;
printIntLine <start> result <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printIntLine(result) <end> ;"	2
9059f39f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_17_bad() { int i; int data; data = -1; for(i = 0; i < 1; i++) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { size_t i; int *intPointer; intPointer = (int*)malloc(data * sizeof(int)); if (intPointer == NULL) {exit(-1);} for (i = 0; i < (size_t)data; i++) { intPointer[i] = 0; } printIntLine(intPointer[0]); free(intPointer); } }"	where is the vulnerable dataflow from data to malloc ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
if  <start> intPointer == NULL <end> ) {exit(-1);};"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data = atoi(inputBuffer) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	"intPointer = (int*)malloc <start> data * sizeof(int) <end> );
if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );"	2
598370bc-6c15-11ed-81d4-94e6f77dd552	"static const int STATIC_CONST_FIVE = 5; void CWE191_Integer_Underflow__short_fscanf_sub_06_bad() { short data; data = 0; if(STATIC_CONST_FIVE==5) { fscanf (stdin, ""%hd"", &data); } if(STATIC_CONST_FIVE==5) { { short result = data - 1; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
short result = <start> data <end>  - 1;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
short <start> result = data - 1 <end> ;"	"<start> printIntLine(result) <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );"	"fscanf (stdin, ""%hd"", <start> &data <end> );
short result = <start> data <end>  - 1;"	3
584fa85b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_listen_socket_multiply_52c_badSink(int data) { if(data < 0) { int result = data * 2; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  * 2;"	"void CWE191_Integer_Underflow__int_listen_socket_multiply_52c_badSink(int <start> data <end> );
int result = <start> data <end>  * 2;"	"int result = <start> data <end>  * 2;
void CWE191_Integer_Underflow__int_listen_socket_multiply_52c_badSink(int <start> data <end> );"	"int <start> result = data * 2 <end> ;
void CWE191_Integer_Underflow__int_listen_socket_multiply_52c_badSink(int <start> data <end> );"	1
b7b09a51-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define NEW_PATH ""%SystemRoot%\\system32"" #define PUTENV _putenv #else #define NEW_PATH ""/bin"" #define PUTENV putenv #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif void CWE427_Uncontrolled_Search_Path_Element__char_file_03_bad() { char * data; char dataBuffer[250] = ""PATH=""; data = dataBuffer; if(5==5) { { size_t dataLen = strlen(data); FILE * pFile; if (250-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(250-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } PUTENV(data); }"	where is the vulnerable dataflow from data to PUTENV ?	"if (fgets <start> data+dataLen <end> , (int)(250-dataLen), pFile) == NULL);
char <start> dataBuffer[250] = ""PATH="" <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(250-dataLen), pFile) == NULL);
PUTENV <start> data <end> );"	"PUTENV <start> data <end> );
char <start> dataBuffer[250] = ""PATH="" <end> ;"	"PUTENV <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(250-dataLen), pFile) == NULL);"	1
584fa8a7-6c15-11ed-81d4-94e6f77dd552	"static void badSink(short data) { if(data < 0) { short result = data * 2; printIntLine(result); } } void CWE191_Integer_Underflow__short_fscanf_multiply_41_bad() { short data; data = 0; fscanf (stdin, ""%hd"", &data); badSink(data); }"	where is the vulnerable dataflow from data ?	"badSink <start> data <end> );
static void badSink(short <start> data <end> );
fscanf (stdin, ""%hd"", <start> &data <end> );
short result = <start> data <end>  * 2;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
static void badSink(short <start> data <end> );
short result = <start> data <end>  * 2;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
badSink <start> data <end> );
static void badSink(short <start> data <end> );
short result = <start> data <end>  * 2;"	"static void badSink(short <start> data <end> );
short result = <start> data <end>  * 2;"	2
5f76fcb8-6c15-11ed-81d4-94e6f77dd552	void CWE191_Integer_Underflow__short_fscanf_predec_54e_badSink(short data) { { --data; short result = data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"- <start> data <end> ;
<start> printIntLine(result) <end> ;"	"short <start> result = data <end> ;
- <start> data <end> ;"	"- <start> data <end> ;
void CWE191_Integer_Underflow__short_fscanf_predec_54e_badSink(short <start> data <end> );"	"void CWE191_Integer_Underflow__short_fscanf_predec_54e_badSink(short <start> data <end> );
- <start> data <end> ;"	3
977ea789-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_18_bad() { int data; data = -1; goto source; source: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } goto sink; sink: { int i; int buffer[10] = { 0 }; if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } } }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> buffer[i] <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[i] <end> );"	"printIntLine <start> buffer[i] <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"printIntLine <start> buffer[i] <end> );
int <start> buffer[10] = { 0 } <end> ;"	1
a10948e4-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_multiply_17_bad() { int i,j; int data; data = 0; for(i = 0; i < 1; i++) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } for(j = 0; j < 1; j++) { if(data > 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"<start> printIntLine(result) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> result <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
data = <start> atoi(inputBuffer) <end> ;"	2
8f278a65-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_45_badData; static int CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_45_goodG2BData; static void badSink() { int data = CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_45_badData; { size_t i; int *intPointer; intPointer = (int*)malloc(data * sizeof(int)); if (intPointer == NULL) {exit(-1);} for (i = 0; i < (size_t)data; i++) { intPointer[i] = 0; } printIntLine(intPointer[0]); free(intPointer); } } void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_45_bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_45_badData = data; badSink(); }"	where is the vulnerable dataflow from data to malloc ?	"intPointer = (int*)malloc <start> data * sizeof(int) <end> );
recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);
static int <start> CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_45_badData <end> ;
<start> CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_45_badData = data <end> ;
int data = <start> CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_45_badData <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_45_badData = data <end> ;
static int <start> CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_45_badData <end> ;
int data = <start> CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_45_badData <end> ;
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	"<start> CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_45_badData = data <end> ;
static int <start> CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_45_badData <end> ;
int data = <start> CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_45_badData <end> ;
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	"<start> intPointer = (int*)malloc(data * sizeof(int)) <end> ;
<start> CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_45_badData = data <end> ;
int data = <start> CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_45_badData <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	1
99e16a72-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fgets_42 { static int badSource(int data) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } return data; } void bad() { int data; data = -1; data = badSource(data); { int i; int * buffer = new int[10]; for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } delete[] buffer; } }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"data = <start> badSource <end> (data);
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
static int <start> badSource <end> (int data);
printIntLine <start> buffer[i] <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
static int <start> badSource <end> (int data);
data = <start> badSource <end> (data);
printIntLine <start> buffer[i] <end> );"	"static int <start> badSource <end> (int data);
printIntLine <start> buffer[i] <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"printIntLine <start> buffer[i] <end> );
static int <start> badSource <end> (int data);
int <start> * buffer = new int[10] <end> ;
data = <start> badSource <end> (data);"	1
453db016-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_multiply_17_bad() { int i,j; int data; data = 0; for(i = 0; i < 1; i++) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } for(j = 0; j < 1; j++) { if(data > 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  * 2;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
if <start> data > 0 <end> ) ;"	"int result = <start> data <end>  * 2;
data = <start> atoi(inputBuffer) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  * 2;"	3
4c666146-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__short_fscanf_square_74 { void badSink(map<int, short> dataMap) { short data = dataMap[2]; { short result = data * data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"short result = <start> data <end>  * data;
<start> printIntLine(result) <end> ;"	"void badSink(map<int, short> <start> dataMap <end> );
short result = <start> data <end>  * data;"	"short result = <start> data <end>  * data;
void badSink(map<int, short> <start> dataMap <end> );"	"<start> printIntLine(result) <end> ;
void badSink(map<int, short> <start> dataMap <end> );"	1
b1b80860-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" static short badSource(short data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = (short)atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } return data; } void CWE197_Numeric_Truncation_Error__short_connect_socket_42_bad() { short data; data = -1; data = badSource(data); { char charData = (char)data; printHexCharLine(charData); } }"	where is the vulnerable dataflow from charData to printHexCharLine ?	"data = <start> badSource <end> (data);
printHexCharLine <start> charData <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
static short <start> badSource <end> (short data);"	"data = <start> badSource <end> (data);
<start> printHexCharLine(charData) <end> ;
static short <start> badSource <end> (short data);
printHexCharLine <start> charData <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static short <start> badSource <end> (short data);
data = <start> badSource <end> (data);
printHexCharLine <start> charData <end> );"	"<start> printHexCharLine(charData) <end> ;
data = <start> badSource <end> (data);
static short <start> badSource <end> (short data);
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	2
525b6477-6c15-11ed-81d4-94e6f77dd552	"void CWE190_Integer_Overflow__short_fscanf_preinc_02_bad() { short data; data = 0; if(1) { fscanf (stdin, ""%hd"", &data); } if(1) { { ++data; short result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
+ <start> data <end> ;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
+ <start> data <end> ;"	"<start> printIntLine(result) <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );"	"+ <start> data <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );"	1
55ef4c8b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_connect_socket_sub_64b_badSink(void * dataVoidPtr) { int * dataPtr = (int *)dataVoidPtr; int data = (*dataPtr); { int result = data - 1; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  - 1;
<start> printIntLine(result) <end> ;"	"void CWE191_Integer_Underflow__int_connect_socket_sub_64b_badSink(void * <start> dataVoidPtr <end> );
int result = <start> data <end>  - 1;"	"<start> printIntLine(result) <end> ;
void CWE191_Integer_Underflow__int_connect_socket_sub_64b_badSink(void * <start> dataVoidPtr <end> );"	"int result = <start> data <end>  - 1;
void CWE191_Integer_Underflow__int_connect_socket_sub_64b_badSink(void * <start> dataVoidPtr <end> );"	1
453db034-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_square_03_bad() { int data; data = 0; if(5==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(5==5) { { int result = data * data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  * data;"	"int result = <start> data <end>  * data;
<start> data = 0 <end> ;"	"<start> data = atoi(inputBuffer) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"int result = <start> data <end>  * data;
data = <start> atoi(inputBuffer) <end> ;"	0
a5ce1c4d-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_postinc_02_bad() { int data; data = 0; if(1) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(1) { { data++; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"<start> data++ <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
<start> data++ <end> ;"	"printIntLine <start> result <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	1
893217ce-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_console_fopen_42 { static char * badSource(char * data) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } return data; } void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; data = badSource(data); { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");
static char * <start> badSource <end> (char * data);
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
static char * <start> badSource <end> (char * data);"	0
630ae7ee-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__short_rand_multiply_53d_badSink(short data) { if(data > 0) { short result = data * 2; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"short result = <start> data <end>  * 2;
void CWE190_Integer_Overflow__short_rand_multiply_53d_badSink(short <start> data <end> );"	"short result = <start> data * 2 <end> ;
void CWE190_Integer_Overflow__short_rand_multiply_53d_badSink(short <start> data <end> );"	"void CWE190_Integer_Overflow__short_rand_multiply_53d_badSink(short <start> data <end> );
short result = <start> data <end>  * 2;"	"short result = <start> data <end>  * 2;
<start> printIntLine(result) <end> ;"	2
893217f4-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_console_open_45 { static char * badData; static char * goodG2BData; static void badSink() { char * data = badData; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } } void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } badData = data; badSink(); }"	where is the vulnerable dataflow from data to OPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
static char * <start> badData <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
char * data = <start> badData <end> ;
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
<start> badData = data <end> ;
char * data = <start> badData <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
<start> badData = data <end> ;
static char * <start> badData <end> ;
char * data = <start> badData <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"<start> badData = data <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	2
6ef76838-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif static char * CWE134_Uncontrolled_Format_String__char_console_vfprintf_45_badData; static char * CWE134_Uncontrolled_Format_String__char_console_vfprintf_45_goodG2BData; static char * CWE134_Uncontrolled_Format_String__char_console_vfprintf_45_goodB2GData; static void badVaSink(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); va_end(args); } } static void badSink() { char * data = CWE134_Uncontrolled_Format_String__char_console_vfprintf_45_badData; badVaSink(data, data); } void CWE134_Uncontrolled_Format_String__char_console_vfprintf_45_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } CWE134_Uncontrolled_Format_String__char_console_vfprintf_45_badData = data; badSink(); }"	where is the vulnerable dataflow from data to vfprintf ?	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
<start> CWE134_Uncontrolled_Format_String__char_console_vfprintf_45_badData = data <end> ;
static char * <start> CWE134_Uncontrolled_Format_String__char_console_vfprintf_45_badData <end> ;
char * data = <start> CWE134_Uncontrolled_Format_String__char_console_vfprintf_45_badData <end> ;
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
<start> vfprintf(stdout, data, args) <end> ;
static void badVaSink(char * <start> data <end> , ...);
<start> CWE134_Uncontrolled_Format_String__char_console_vfprintf_45_badData = data <end> ;
char * data = <start> CWE134_Uncontrolled_Format_String__char_console_vfprintf_45_badData <end> ;
static char * <start> CWE134_Uncontrolled_Format_String__char_console_vfprintf_45_badData <end> ;
badVaSink <start> data <end> , data);"	"static void badVaSink(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);
static char * <start> CWE134_Uncontrolled_Format_String__char_console_vfprintf_45_badData <end> ;
char * data = <start> CWE134_Uncontrolled_Format_String__char_console_vfprintf_45_badData <end> ;
badVaSink <start> data <end> , data);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
<start> CWE134_Uncontrolled_Format_String__char_console_vfprintf_45_badData = data <end> ;"	"<start> CWE134_Uncontrolled_Format_String__char_console_vfprintf_45_badData = data <end> ;
<start> va_start(args, data) <end> ;
char * data = <start> CWE134_Uncontrolled_Format_String__char_console_vfprintf_45_badData <end> ;
static void badVaSink(char * <start> data <end> , ...);
badVaSink <start> data <end> , data);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
static char * <start> CWE134_Uncontrolled_Format_String__char_console_vfprintf_45_badData <end> ;"	0
cd228149-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif namespace CWE36_Absolute_Path_Traversal__char_console_ofstream_43 { void badSource(char * &data) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; badSource(data); { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
badSource <start> data <end> );
outputFile.open((char * <start> data <end> );"	"badSource <start> data <end> );
outputFile.open((char * <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"size_t dataLen = <start> strlen(data) <end> ;
badSource <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"outputFile.open((char * <start> data <end> );
badSource <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	0
9187cc23-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #define SEARCH_CHAR 'S' void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_file_16_bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\0'; { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } while(1) { for (; *data != '\0'; data++) { if (*data == SEARCH_CHAR) { printLine(""We have a match!""); break; } } free(data); break; } }"	where is the vulnerable dataflow from data to free ?	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
<start> free(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
free <start> data <end> );"	"free <start> data <end> );
<start> free(data) <end> ;"	"if  <start> data == NULL <end> ) {exit(-1);};
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	1
a1094920-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__int_connect_socket_square_62 { void badSource(int &data); void bad() { int data; data = 0; badSource(data); { int result = data * data; printIntLine(result); } }	where is the vulnerable dataflow from result to printIntLine ?	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	"<start> printIntLine(result) <end> ;
badSource <start> data <end> );"	"printIntLine <start> result <end> );
badSource <start> data <end> );"	"badSource <start> data <end> );
printIntLine <start> result <end> );"	3
c9919803-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" static const int STATIC_CONST_FIVE = 5; namespace CWE36_Absolute_Path_Traversal__char_connect_socket_ifstream_06 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(STATIC_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"recvResult = recv(connectSocket, (char *)(data + dataLen), <start> sizeof(char) * (FILENAME_MAX - dataLen - 1) <end> , 0);
inputFile.open((char * <start> data <end> );"	"inputFile.open((char * <start> data <end> );
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"replace = <start> strchr(data, '\n') <end> ;
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
inputFile.open((char * <start> data <end> );"	3
cf8750a6-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_file_fopen_01 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
pFile = FOPEN <start> data <end> , ""wb+"");"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
size_t dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	"pFile = FOPEN <start> data <end> , ""wb+"");
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	0
6dc614ea-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" static int badStatic = 0; static void badVaSink(char * data, ...) { if(badStatic) { { va_list args; va_start(args, data); vprintf(data, args); va_end(args); } } } void CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_21_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badStatic = 1; badVaSink(data, data); }"	where is the vulnerable dataflow from data to vprintf ?	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
static void badVaSink(char * <start> data <end> , ...);"	"recvResult = recv(connectSocket, (char *)(data + dataLen), <start> sizeof(char) * (100 - dataLen - 1) <end> , 0);
static void badVaSink(char * <start> data <end> , ...);
vprintf <start> data <end> , args);
badVaSink <start> data <end> , data);"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
vprintf <start> data <end> , args);"	"<start> data = dataBuffer <end> ;
static void badVaSink(char * <start> data <end> , ...);
badVaSink <start> data <end> , data);
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	2
571e9816-6c15-11ed-81d4-94e6f77dd552	namespace CWE191_Integer_Underflow__int_fscanf_multiply_62 { void badSource(int &data); void bad() { int data; data = 0; badSource(data); if(data < 0) { int result = data * 2; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"badSource <start> data <end> );
if <start> data < 0 <end> ) ;"	"int result = <start> data <end>  * 2;
badSource <start> data <end> );"	"badSource <start> data <end> );
int result = <start> data <end>  * 2;"	"<start> data = 0 <end> ;
badSource <start> data <end> );"	2
5e44fc80-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int badSource(int data) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } return data; } void CWE191_Integer_Underflow__int_fgets_predec_42_bad() { int data; data = 0; data = badSource(data); { --data; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"static int <start> badSource <end> (int data);
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
- <start> data <end> ;
data = <start> badSource <end> (data);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
static int <start> badSource <end> (int data);
data = <start> badSource <end> (data);
- <start> data <end> ;"	"- <start> data <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
static int <start> badSource <end> (int data);"	"static int <start> badSource <end> (int data);
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	1
656cd3fc-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__int_rand_multiply_65b_badSink(int data) { if(data > 0) { int result = data * 2; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  * 2;
void CWE190_Integer_Overflow__int_rand_multiply_65b_badSink(int <start> data <end> );"	"void CWE190_Integer_Overflow__int_rand_multiply_65b_badSink(int <start> data <end> );
int result = <start> data <end>  * 2;"	"int result = <start> data <end>  * 2;
<start> printIntLine(result) <end> ;"	"void CWE190_Integer_Overflow__int_rand_multiply_65b_badSink(int <start> data <end> );
<start> printIntLine(result) <end> ;"	1
a109491d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_square_53d_badSink(int data) { { int result = data * data; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
void CWE190_Integer_Overflow__int_connect_socket_square_53d_badSink(int <start> data <end> );"	"void CWE190_Integer_Overflow__int_connect_socket_square_53d_badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"void CWE190_Integer_Overflow__int_connect_socket_square_53d_badSink(int <start> data <end> );
<start> printIntLine(result) <end> ;"	"int <start> result = data * data <end> ;
printIntLine <start> result <end> );"	1
cac216b1-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" static const int STATIC_CONST_FIVE = 5; namespace CWE36_Absolute_Path_Traversal__char_connect_socket_ofstream_06 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(STATIC_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
outputFile.open((char * <start> data <end> );"	"replace = <start> strchr(data, '\r') <end> ;
outputFile.open((char * <start> data <end> );"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
replace = <start> strchr(data, '\n') <end> ;"	"outputFile.open((char * <start> data <end> );
replace = <start> strchr(data, '\n') <end> ;"	0
453db025-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) int CWE190_Integer_Overflow__int_connect_socket_multiply_61b_badSource(int data); void CWE190_Integer_Overflow__int_connect_socket_multiply_61_bad() { int data; data = 0; data = CWE190_Integer_Overflow__int_connect_socket_multiply_61b_badSource(data); if(data > 0) { int result = data * 2; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"data = <start> CWE190_Integer_Overflow__int_connect_socket_multiply_61b_badSource <end> (data);
int result = <start> data <end>  * 2;"	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  * 2;"	"int result = <start> data <end>  * 2;
data = <start> CWE190_Integer_Overflow__int_connect_socket_multiply_61b_badSource <end> (data);"	"<start> printIntLine(result) <end> ;
data = <start> CWE190_Integer_Overflow__int_connect_socket_multiply_61b_badSource <end> (data);"	0
9b124da6-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE124_Buffer_Underwrite__CWE839_listen_socket_17_bad() { int i,j; int data; data = -1; for(i = 0; i < 1; i++) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } for(j = 0; j < 1; j++) { { int i; int buffer[10] = { 0 }; if (data < 10) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } } } }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"printIntLine <start> buffer[i] <end> );
<start> printIntLine(buffer[i]) <end> ;"	"printIntLine <start> buffer[i] <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"printIntLine <start> buffer[i] <end> );
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[i] <end> );"	3
6dc614fb-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" static void badVaSink(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_66b_badSink(char * dataArray[]) { char * data = dataArray[2]; badVaSink(data, data); }"	where is the vulnerable dataflow from data to vprintf ?	"<start> vprintf(data, args) <end> ;
vprintf <start> data <end> , args);
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);"	"void CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_66b_badSink(char * <start> dataArray <end> []);
badVaSink <start> data <end> , data);
vprintf <start> data <end> , args);"	"void CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_66b_badSink(char * <start> dataArray <end> []);
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
vprintf <start> data <end> , args);"	"static void badVaSink(char * <start> data <end> , ...);
void CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_66b_badSink(char * <start> dataArray <end> []);
<start> vprintf(data, args) <end> ;
vprintf <start> data <end> , args);"	2
55ef4cc1-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_fgets_sub_02_bad() { int data; data = 0; if(1) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(1) { { int result = data - 1; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  - 1;
<start> printIntLine(result) <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
int result = <start> data <end>  - 1;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> data = 0 <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> data = atoi(inputBuffer) <end> ;"	1
5e44fc8b-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_fgets_predec_66b_badSink(int dataArray[]) { int data = dataArray[2]; { --data; int result = data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"<start> --data <end> ;
void CWE191_Integer_Underflow__int_fgets_predec_66b_badSink(int <start> dataArray <end> []);"	"void CWE191_Integer_Underflow__int_fgets_predec_66b_badSink(int <start> dataArray <end> []);
- <start> data <end> ;"	"int <start> result = data <end> ;
void CWE191_Integer_Underflow__int_fgets_predec_66b_badSink(int <start> dataArray <end> []);"	"- <start> data <end> ;
void CWE191_Integer_Underflow__int_fgets_predec_66b_badSink(int <start> dataArray <end> []);"	1
d31a24f0-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 namespace CWE36_Absolute_Path_Traversal__char_listen_socket_ofstream_01 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
<start> data = dataBuffer <end> ;"	"size_t dataLen = <start> strlen(data) <end> ;
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"outputFile.open((char * <start> data <end> );
if  <start> acceptSocket == SOCKET_ERROR <end> );"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
outputFile.open((char * <start> data <end> );"	3
60db8398-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__char_rand_add_13_bad() { char data; data = ' '; if(GLOBAL_CONST_FIVE==5) { data = (char)RAND32(); } if(GLOBAL_CONST_FIVE==5) { { char result = data + 1; printHexCharLine(result); } } }	where is the vulnerable dataflow from data ?	"<start> data = ' ' <end> ;
data = (char <start> RAND32() <end> ;"	"char result = <start> data + 1 <end> ;
data = (char <start> RAND32() <end> ;"	"data = (char <start> RAND32() <end> ;
char result = <start> data <end>  + 1;"	"<start> printHexCharLine(result) <end> ;
data = (char <start> RAND32() <end> ;"	2
86cea13a-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE369_Divide_by_Zero__int_fgets_modulo_17_bad() { int i,j; int data; data = -1; for(i = 0; i < 1; i++) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } for(j = 0; j < 1; j++) { printIntLine(100 % data); } }"	where is the vulnerable dataflow from data to printIntLine ?	"printIntLine <start> 100 % data <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> 100 % data <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> data = -1 <end> ;"	"char <start> inputBuffer[CHAR_ARRAY_SIZE] = """" <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	1
4ec5d073-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_postinc_10_bad() { int data; data = 0; if(globalTrue) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(globalTrue) { { data++; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> data <end> ++;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> data++ <end> ;"	"<start> printIntLine(result) <end> ;
<start> data <end> ++;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> data = 0 <end> ;"	0
74ee23b9-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" void CWE194_Unexpected_Sign_Extension__connect_socket_memmove_53d_badSink(short data) { { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"void CWE194_Unexpected_Sign_Extension__connect_socket_memmove_53d_badSink(short <start> data <end> );
<start> memmove(dest, source, data) <end> ;"	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	"void CWE194_Unexpected_Sign_Extension__connect_socket_memmove_53d_badSink(short <start> data <end> );
printLine <start> dest <end> );"	"printLine <start> dest <end> );
<start> memmove(dest, source, data) <end> ;"	2
bc721f9c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define EXECLP _execlp #else #define EXECLP execlp #endif typedef union { char * unionFirst; char * unionSecond; } CWE78_OS_Command_Injection__char_file_execlp_34_unionType; void CWE78_OS_Command_Injection__char_file_execlp_34_bad() { char * data; CWE78_OS_Command_Injection__char_file_execlp_34_unionType myUnion; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } myUnion.unionFirst = data; { char * data = myUnion.unionSecond; EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL); } }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECLP ?	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
<start> EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL) <end> ;"	"EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	"if (fgets(data+dataLen, (int) <start> 100-dataLen <end> ), pFile) == NULL);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	0
c4cd6f4a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_environment_open_51 { void badSink(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } badSink(data); }"	where is the vulnerable dataflow from data to badSink ?	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
badSink <start> data <end> );"	"badSink <start> data <end> );
<start> data = dataBuffer <end> ;"	"<start> strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1) <end> ;
badSink <start> data <end> );"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
char <start> dataBuffer[FILENAME_MAX] = BASEPATH <end> ;"	0
5af03e0e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) typedef struct _CWE191_Integer_Underflow__int_connect_socket_postdec_67_structType { int structFirst; } CWE191_Integer_Underflow__int_connect_socket_postdec_67_structType; void CWE191_Integer_Underflow__int_connect_socket_postdec_67b_badSink(CWE191_Integer_Underflow__int_connect_socket_postdec_67_structType myStruct) { int data = myStruct.structFirst; { data--; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"void CWE191_Integer_Underflow__int_connect_socket_postdec_67b_badSink(CWE191_Integer_Underflow__int_connect_socket_postdec_67_structType <start> myStruct <end> );
int data = <start> myStruct <end> .structFirst;
<start> data <end> --;"	"void CWE191_Integer_Underflow__int_connect_socket_postdec_67b_badSink(CWE191_Integer_Underflow__int_connect_socket_postdec_67_structType <start> myStruct <end> );
<start> data <end> --;
int data = <start> myStruct <end> .structFirst;"	"<start> printIntLine(result) <end> ;
int data = <start> myStruct <end> .structFirst;
void CWE191_Integer_Underflow__int_connect_socket_postdec_67b_badSink(CWE191_Integer_Underflow__int_connect_socket_postdec_67_structType <start> myStruct <end> );"	"void CWE191_Integer_Underflow__int_connect_socket_postdec_67b_badSink(CWE191_Integer_Underflow__int_connect_socket_postdec_67_structType <start> myStruct <end> );
<start> data <end> --;"	0
761e297d-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 8 void CWE194_Unexpected_Sign_Extension__fgets_memmove_13_bad() { short data; data = 0; if(GLOBAL_CONST_FIVE==5) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = (short)atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printLine <start> dest <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
char <start> inputBuffer[CHAR_ARRAY_SIZE] = """" <end> ;"	"data = <start> (short)atoi(inputBuffer) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"char <start> inputBuffer[CHAR_ARRAY_SIZE] = """" <end> ;
printLine <start> dest <end> );"	0
b41b8769-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 8 extern short CWE197_Numeric_Truncation_Error__short_listen_socket_68_badData; extern short CWE197_Numeric_Truncation_Error__short_listen_socket_68_goodG2BData; void CWE197_Numeric_Truncation_Error__short_listen_socket_68b_badSink() { short data = CWE197_Numeric_Truncation_Error__short_listen_socket_68_badData; { char charData = (char)data; printHexCharLine(charData); } }"	where is the vulnerable dataflow from charData to printHexCharLine ?	"short data = <start> CWE197_Numeric_Truncation_Error__short_listen_socket_68_badData <end> ;
printHexCharLine <start> charData <end> );"	"printHexCharLine <start> charData <end> );
<start> printHexCharLine(charData) <end> ;"	"short data = <start> CWE197_Numeric_Truncation_Error__short_listen_socket_68_badData <end> ;
<start> printHexCharLine(charData) <end> ;"	"char <start> charData = (char)data <end> ;
printHexCharLine <start> charData <end> );"	0
715a3c06-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 static void badVaSink(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_01_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badVaSink(data, data); }"	where is the vulnerable dataflow from data to vfprintf ?	"badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);
size_t dataLen = <start> strlen(data) <end> ;"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);"	"<start> recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0) <end> ;
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);"	"replace = <start> strchr(data, '\r') <end> ;
badVaSink <start> data <end> , data);
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
static void badVaSink(char * <start> data <end> , ...);"	1
846ad32a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define STAT _stat #define OPEN _open #define WRITE _write #define O_RDWR _O_RDWR #define CLOSE _close #else #define STAT stat #define OPEN open #define WRITE write #define CLOSE close #endif #define BAD_SINK_STRING ""Bad Sink..."" #define GOOD_SINK_STRING ""Good Sink..."" void CWE367_TOC_TOU__stat_15_bad() { switch(6) { case 6: { char filename[100] = """"; struct STAT statBuffer; int fileDesc = -1; if (fgets(filename, 100, stdin) == NULL) { printLine(""fgets() failed""); filename[0] = '\0'; } if (strlen(filename) > 0) { filename[strlen(filename)-1] = '\0'; } if (STAT(filename, &statBuffer) == -1) { exit(1); } fileDesc  = OPEN(filename, O_RDWR); if (fileDesc == -1) { exit(1); } if (WRITE(fileDesc, BAD_SINK_STRING, strlen(BAD_SINK_STRING)) == -1) { exit(1); } if (fileDesc != -1) { CLOSE(fileDesc); } } break; default: printLine(""Benign, fixed string""); break; } }"	where is the vulnerable dataflow from filename to OPEN ?	"if (fgets <start> filename <end> , 100, stdin) == NULL);
filename <start> strlen(filename) <end> -1] = '\0'; ;"	"fileDesc  = OPEN <start> filename <end> , O_RDWR);
if  <start> STAT(filename, &statBuffer) <end>  == -1);"	"fileDesc  = <start> OPEN(filename, O_RDWR) <end> ;
if (fgets <start> filename <end> , 100, stdin) == NULL);"	"if (fgets <start> filename <end> , 100, stdin) == NULL);
fileDesc  = OPEN <start> filename <end> , O_RDWR);"	3
47a2a812-6c15-11ed-81d4-94e6f77dd552	"void CWE190_Integer_Overflow__int_fscanf_add_18_bad() { int data; data = 0; goto source; source: fscanf(stdin, ""%d"", &data); goto sink; sink: { int result = data + 1; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"fscanf(stdin, ""%d"", <start> &data <end> );
int result = <start> data <end>  + 1;"	"int result = <start> data <end>  + 1;
fscanf(stdin, ""%d"", <start> &data <end> );"	"<start> printIntLine(result) <end> ;
fscanf(stdin, ""%d"", <start> &data <end> );"	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  + 1;"	0
b7b09a38-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define NEW_PATH ""%SystemRoot%\\system32"" #define PUTENV _putenv #else #define NEW_PATH ""/bin"" #define PUTENV putenv #endif void CWE427_Uncontrolled_Search_Path_Element__char_console_14_bad() { char * data; char dataBuffer[250] = ""PATH=""; data = dataBuffer; if(globalFive==5) { { size_t dataLen = strlen(data); if (250-dataLen > 1) { if (fgets(data+dataLen, (int)(250-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } PUTENV(data); }"	where is the vulnerable dataflow from data to PUTENV ?	"if (fgets <start> data+dataLen <end> , (int)(250-dataLen), stdin) != NULL);
PUTENV <start> data <end> );"	"PUTENV <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	"<start> PUTENV(data) <end> ;
PUTENV <start> data <end> );"	"<start> data = dataBuffer <end> ;
PUTENV <start> data <end> );"	0
70279c22-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif static int staticFive = 5; static void badVaSinkB(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_file_vfprintf_07_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; if(staticFive==5) { { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } if(staticFive==5) { badVaSinkB(data, data); } }"	where is the vulnerable dataflow from data to vfprintf ?	"badVaSinkB <start> data <end> , data);
size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
static void badVaSinkB(char * <start> data <end> , ...);"	"badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);"	"char <start> dataBuffer[100] = """" <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
vfprintf(stdout, <start> data <end> , args);
badVaSinkB <start> data <end> , data);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);"	3
b8e2bdc6-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE680_Integer_Overflow_to_Buffer_Overflow__new_listen_socket_82 { void bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE680_Integer_Overflow_to_Buffer_Overflow__new_listen_socket_82_base* baseObject = new CWE680_Integer_Overflow_to_Buffer_Overflow__new_listen_socket_82_bad; baseObject->action(data); delete baseObject; }"	where is the vulnerable dataflow from data to action ?	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
baseObject->action <start> data <end> );"	"if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );
baseObject->action <start> data <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
baseObject->action <start> data <end> );"	3
977ea7a4-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_10_bad() { int data; data = -1; if(globalTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalTrue) { { int i; int buffer[10] = { 0 }; if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } } } }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"printIntLine <start> buffer[i] <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"printIntLine <start> buffer[i] <end> );
<start> recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> buffer[i] <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[i] <end> );"	3
78800fcb-6c15-11ed-81d4-94e6f77dd552	"namespace CWE194_Unexpected_Sign_Extension__listen_socket_memmove_72 { void badSink(vector<short> dataVector) { short data = dataVector[2]; { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> memmove(dest, source, data) <end> ;
void badSink(vector<short> <start> dataVector <end> );"	"printLine <start> dest <end> );
void badSink(vector<short> <start> dataVector <end> );"	"printLine <start> dest <end> );
<start> printLine(dest) <end> ;"	"void badSink(vector<short> <start> dataVector <end> );
printLine <start> dest <end> );"	3
b1b80835-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink(int data) { { short shortData = (short)data; printShortLine(shortData); } } void CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_44_bad() { int data; void (*funcPtr) (int) = badSink; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } funcPtr(data); }"	where is the vulnerable dataflow from shortData to printShortLine ?	"short <start> shortData = (short)data <end> ;
printShortLine <start> shortData <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
funcPtr <start> data <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
funcPtr <start> data <end> );
static void badSink(int <start> data <end> );
printShortLine <start> shortData <end> );"	"printShortLine <start> shortData <end> );
static void badSink(int <start> data <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"funcPtr <start> data <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static void badSink(int <start> data <end> );
<start> printShortLine(shortData) <end> ;"	1
9187cbe6-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define SEARCH_CHAR 'S' char * CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_61b_badSource(char * data); void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_61_bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\0'; data = CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_61b_badSource(data); for (; *data != '\0'; data++) { if (*data == SEARCH_CHAR) { printLine(""We have a match!""); break; } } free(data); }"	where is the vulnerable dataflow from data to free ?	"<start> free(data) <end> ;
data = <start> CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_61b_badSource <end> (data);"	"free <start> data <end> );
<start> data = CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_61b_badSource(data) <end> ;"	"free <start> data <end> );
data = <start> CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_61b_badSource <end> (data);"	"data = <start> CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_61b_badSource <end> (data);
free <start> data <end> );"	3
761e2969-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 8 void CWE194_Unexpected_Sign_Extension__fgets_memcpy_66b_badSink(short dataArray[]) { short data = dataArray[2]; { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"printLine <start> dest <end> );
<start> memcpy(dest, source, data) <end> ;"	"void CWE194_Unexpected_Sign_Extension__fgets_memcpy_66b_badSink(short <start> dataArray <end> []);
printLine <start> dest <end> );"	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	"void CWE194_Unexpected_Sign_Extension__fgets_memcpy_66b_badSink(short <start> dataArray <end> []);
<start> memcpy(dest, source, data) <end> ;"	1
774f57e7-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 8 void CWE194_Unexpected_Sign_Extension__fgets_strncpy_14_bad() { short data; data = 0; if(globalFive==5) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = (short)atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printLine <start> dest <end> );"	"<start> printLine(dest) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"printLine <start> dest <end> );
<start> printLine(dest) <end> ;"	"<start> strncpy(dest, source, data) <end> ;
printLine <start> dest <end> );"	0
d1e9da55-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; namespace CWE36_Absolute_Path_Traversal__char_listen_socket_ifstream_04 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(STATIC_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
if  <start> listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR <end> );"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
inputFile.open((char * <start> data <end> );"	"size_t dataLen = <start> strlen(data) <end> ;
inputFile.open((char * <start> data <end> );"	"size_t dataLen = <start> strlen(data) <end> ;
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	1
d1e9da24-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif extern char * CWE36_Absolute_Path_Traversal__char_file_open_68_badData; extern char * CWE36_Absolute_Path_Traversal__char_file_open_68_goodG2BData; namespace CWE36_Absolute_Path_Traversal__char_file_open_68 { void badSink() { char * data = CWE36_Absolute_Path_Traversal__char_file_open_68_badData; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"char * data = <start> CWE36_Absolute_Path_Traversal__char_file_open_68_badData <end> ;
fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);"	"char * data = <start> CWE36_Absolute_Path_Traversal__char_file_open_68_badData <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = OPEN(data, O_RDWR|O_CREAT, <start> S_IREAD|S_IWRITE <end> );"	1
669edad8-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__int_rand_postinc_01_bad() { int data; data = 0; data = RAND32(); { data++; int result = data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"int <start> result = data <end> ;
<start> data <end> ++;"	"<start> data <end> ++;
data = <start> RAND32() <end> ;"	"<start> printIntLine(result) <end> ;
data = <start> RAND32() <end> ;"	"data = <start> RAND32() <end> ;
<start> data <end> ++;"	3
54c58212-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_connect_socket_sub_10_bad() { int data; data = 0; if(globalTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalTrue) { { int result = data - 1; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"data = <start> atoi(inputBuffer) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  - 1;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printIntLine(result) <end> ;"	"int result = <start> data <end>  - 1;
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	1
b68484db-6c15-11ed-81d4-94e6f77dd552	"namespace CWE36_Absolute_Path_Traversal__char_console_ofstream_82 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } CWE36_Absolute_Path_Traversal__char_console_ofstream_82_base* baseObject = new CWE36_Absolute_Path_Traversal__char_console_ofstream_82_bad; baseObject->action(data); delete baseObject; }"	where is the vulnerable dataflow from data to action ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
baseObject->action <start> data <end> );"	"baseObject->action <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	"dataLen = <start> strlen(data) <end> ;
baseObject->action <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
dataLen = <start> strlen(data) <end> ;"	0
4ff78287-6c15-11ed-81d4-94e6f77dd552	"static unsigned int badSource(unsigned int data) { fscanf (stdin, ""%u"", &data); return data; } void CWE190_Integer_Overflow__unsigned_int_fscanf_postinc_42_bad() { unsigned int data; data = 0; data = badSource(data); { data++; unsigned int result = data; printUnsignedLine(result); } }"	where is the vulnerable dataflow from data ?	"static unsigned int <start> badSource <end> (unsigned int data);
<start> data <end> ++;
fscanf (stdin, ""%u"", <start> &data <end> );
data = <start> badSource <end> (data);"	"fscanf (stdin, ""%u"", <start> &data <end> );
static unsigned int <start> badSource <end> (unsigned int data);
data = <start> badSource <end> (data);
<start> data <end> ++;"	"static unsigned int <start> badSource <end> (unsigned int data);
fscanf (stdin, ""%u"", <start> &data <end> );"	"fscanf (stdin, ""%u"", <start> &data <end> );
data = <start> badSource <end> (data);
static unsigned int <start> badSource <end> (unsigned int data);"	1
cd22817b-6c15-11ed-81d4-94e6f77dd552	#ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_console_open_81 { void CWE36_Absolute_Path_Traversal__char_console_open_81_bad::action(char * data) const { { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } } }	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"void CWE36_Absolute_Path_Traversal__char_console_open_81_bad::action(char * <start> data <end> ) const;
fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);"	"fileDesc = OPEN(data, O_RDWR|O_CREAT, <start> S_IREAD|S_IWRITE <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"void CWE36_Absolute_Path_Traversal__char_console_open_81_bad::action(char * <start> data <end> ) const;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	3
9059f3a0-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_18_bad() { int data; data = -1; goto source; source: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { size_t i; int *intPointer; intPointer = (int*)malloc(data * sizeof(int)); if (intPointer == NULL) {exit(-1);} for (i = 0; i < (size_t)data; i++) { intPointer[i] = 0; } printIntLine(intPointer[0]); free(intPointer); } }"	where is the vulnerable dataflow from data to malloc ?	"if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	"intPointer = (int*)malloc <start> data * sizeof(int) <end> );
if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );"	"<start> data = atoi(inputBuffer) <end> ;
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	1
4ec5d087-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) int CWE190_Integer_Overflow__int_fgets_postinc_61b_badSource(int data); void CWE190_Integer_Overflow__int_fgets_postinc_61_bad() { int data; data = 0; data = CWE190_Integer_Overflow__int_fgets_postinc_61b_badSource(data); { data++; int result = data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"data = <start> CWE190_Integer_Overflow__int_fgets_postinc_61b_badSource <end> (data);
<start> data++ <end> ;"	"data = <start> CWE190_Integer_Overflow__int_fgets_postinc_61b_badSource <end> (data);
<start> printIntLine(result) <end> ;"	"<start> data <end> ++;
data = <start> CWE190_Integer_Overflow__int_fgets_postinc_61b_badSource <end> (data);"	"data = <start> CWE190_Integer_Overflow__int_fgets_postinc_61b_badSource <end> (data);
<start> data <end> ++;"	3
55ef4cd2-6c15-11ed-81d4-94e6f77dd552	extern int CWE191_Integer_Underflow__int_fgets_sub_22_badGlobal; void CWE191_Integer_Underflow__int_fgets_sub_22_badSink(int data) { if(CWE191_Integer_Underflow__int_fgets_sub_22_badGlobal) { { int result = data - 1; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  - 1;
void CWE191_Integer_Underflow__int_fgets_sub_22_badSink(int <start> data <end> );"	"void CWE191_Integer_Underflow__int_fgets_sub_22_badSink(int <start> data <end> );
int result = <start> data <end>  - 1;"	"<start> printIntLine(result) <end> ;
void CWE191_Integer_Underflow__int_fgets_sub_22_badSink(int <start> data <end> );"	"void CWE191_Integer_Underflow__int_fgets_sub_22_badSink(int <start> data <end> );
int <start> result = data - 1 <end> ;"	1
73bc815d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" void CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_65b_badSink(short data) { { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"void CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_65b_badSink(short <start> data <end> );
<start> memcpy(dest, source, data) <end> ;"	"printLine <start> dest <end> );
void CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_65b_badSink(short <start> data <end> );"	"<start> memcpy(dest, source, data) <end> ;
printLine <start> dest <end> );"	"void CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_65b_badSink(short <start> data <end> );
printLine <start> dest <end> );"	3
466e7ece-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_multiply_01_bad() { int data; data = 0; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } if(data > 0) { int result = data * 2; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
int result = <start> data <end>  * 2;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> printIntLine(result) <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
int <start> result = data * 2 <end> ;"	"<start> data = atoi(inputBuffer) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	0
af58095b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE197_Numeric_Truncation_Error__int_connect_socket_to_short_43 { static void badSource(int &data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } void bad() { int data; data = -1; badSource(data); { short shortData = (short)data; printShortLine(shortData); } }"	where is the vulnerable dataflow from shortData to printShortLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSource <start> data <end> );
printShortLine <start> shortData <end> );"	"printShortLine <start> shortData <end> );
badSource <start> data <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
short <start> shortData = (short)data <end> ;
printShortLine <start> shortData <end> );"	"printShortLine <start> shortData <end> );
badSource <start> data <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	0
b1b8081f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; void CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_04_bad() { int data; data = -1; if(STATIC_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { short shortData = (short)data; printShortLine(shortData); } }"	where is the vulnerable dataflow from shortData to printShortLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
data = <start> atoi(inputBuffer) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
short <start> shortData = (short)data <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printShortLine <start> shortData <end> );"	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printShortLine <start> shortData <end> );"	2
9fe7ad5c-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__int_connect_socket_add_62 { void badSource(int &data); void bad() { int data; data = 0; badSource(data); { int result = data + 1; printIntLine(result); } }	where is the vulnerable dataflow from result to printIntLine ?	"badSource <start> data <end> );
printIntLine <start> result <end> );"	"int result = <start> data + 1 <end> ;
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
badSource <start> data <end> );"	"printIntLine <start> result <end> );
<start> data = 0 <end> ;"	0
86cea16d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE369_Divide_by_Zero__int_listen_socket_modulo_17_bad() { int i,j; int data; data = -1; for(i = 0; i < 1; i++) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } for(j = 0; j < 1; j++) { printIntLine(100 % data); } }"	where is the vulnerable dataflow from data to printIntLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> 100 % data <end> );"	"<start> data = -1 <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"printIntLine <start> 100 % data <end> );
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"printIntLine <start> 100 % data <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	0
846ad2f6-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif void CWE252_Unchecked_Return_Value__char_fgets_15_bad() { switch(6) { case 6: { char dataBuffer[100] = """"; char * data = dataBuffer; printLine(""Please enter a string: ""); fgets(data, 100, stdin); printLine(data); } break; default: printLine(""Benign, fixed string""); break; } }"	where is the vulnerable dataflow from data to printLine ?	"fgets <start> data <end> , 100, stdin);
printLine <start> data <end> );"	"printLine <start> data <end> );
<start> printLine(data) <end> ;"	"<start> printLine(data) <end> ;
fgets <start> data <end> , 100, stdin);"	"printLine <start> data <end> );
char <start> * data = dataBuffer <end> ;"	0
c39a6584-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_environment_fopen_74 { void badSink(map<int, char *> dataMap) { char * data = dataMap[2]; { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = FOPEN <start> data <end> , ""wb+"");
void badSink(map<int, char *> <start> dataMap <end> );"	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
char <start> * data = dataMap[2] <end> ;"	"void badSink(map<int, char *> <start> dataMap <end> );
pFile = FOPEN <start> data <end> , ""wb+"");"	3
5f76fc7b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; void CWE191_Integer_Underflow__int_listen_socket_predec_04_bad() { int data; data = 0; if(STATIC_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(STATIC_CONST_TRUE) { { --data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
- <start> data <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printIntLine(result) <end> ;"	"- <start> data <end> ;
if  <start> recvResult == SOCKET_ERROR <end>  || recvResult == 0);"	"<start> data = atoi(inputBuffer) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	0
6c938c00-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif static int badStatic = 0; static void badSink(char * data) { if(badStatic) { { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } } } void CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_21_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badStatic = 1; badSink(data); }"	where is the vulnerable dataflow from dest to printLine ?	"static void badSink(char * <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;
printLine <start> dest <end> );
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"printLine <start> dest <end> );
<start> badSink(data) <end> ;
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
badSink <start> data <end> );"	"badSink <start> data <end> );
replace = <start> strchr(data, '\n') <end> ;
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
static void badSink(char * <start> data <end> );"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
badSink <start> data <end> );
static void badSink(char * <start> data <end> );
printLine <start> dest <end> );"	3
846ad340-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE369_Divide_by_Zero__int_connect_socket_divide_18_bad() { int data; data = -1; goto source; source: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } goto sink; sink: printIntLine(100 / data); }"	where is the vulnerable dataflow from data to printIntLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data = -1 <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> 100 / data <end> );"	"<start> data = atoi(inputBuffer) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"printIntLine <start> 100 / data <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	1
453db02f-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__int_connect_socket_multiply_74 { void badSink(map<int, int> dataMap) { int data = dataMap[2]; if(data > 0) { int result = data * 2; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"int result = <start> data * 2 <end> ;
void badSink(map<int, int> <start> dataMap <end> );"	"int <start> data = dataMap[2] <end> ;
void badSink(map<int, int> <start> dataMap <end> );"	"void badSink(map<int, int> <start> dataMap <end> );
int <start> result = data * 2 <end> ;"	"void badSink(map<int, int> <start> dataMap <end> );
int result = <start> data <end>  * 2;"	3
630ae7fd-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__short_rand_square_02_bad() { short data; data = 0; if(1) { data = (short)RAND32(); } if(1) { { short result = data * data; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"short result = <start> data * data <end> ;
data = (short <start> RAND32() <end> ;"	"short result = <start> data <end>  * data;
data = (short <start> RAND32() <end> ;"	"data = (short <start> RAND32() <end> ;
short result = <start> data <end>  * data;"	"<start> printIntLine(result) <end> ;
data = (short <start> RAND32() <end> ;"	2
b2ea8dbd-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 8 void CWE197_Numeric_Truncation_Error__short_fgets_09_bad() { short data; data = -1; if(GLOBAL_CONST_TRUE) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = (short)atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } { char charData = (char)data; printHexCharLine(charData); } }"	where is the vulnerable dataflow from charData to printHexCharLine ?	"data = (short <start> atoi(inputBuffer) <end> ;
printHexCharLine <start> charData <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printHexCharLine <start> charData <end> );"	"<start> printHexCharLine(charData) <end> ;
printHexCharLine <start> charData <end> );"	"char <start> charData = (char)data <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	1
aa91a168-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int badStatic = 0; static void badSink(int data) { if(badStatic) { if(data < 0) { int result = data * 2; printIntLine(result); } } } void CWE191_Integer_Underflow__int_listen_socket_multiply_21_bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badStatic = 1; badSink(data); }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSink <start> data <end> );
static void badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"static void badSink(int <start> data <end> );
printIntLine <start> result <end> );
badSink <start> data <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"static void badSink(int <start> data <end> );
badSink <start> data <end> );
if  <start> recvResult == SOCKET_ERROR <end>  || recvResult == 0);
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
badSink <start> data <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int <start> result = data * 2 <end> ;"	0
af580966-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE197_Numeric_Truncation_Error__int_connect_socket_to_short_65b_badSink(int data) { { short shortData = (short)data; printShortLine(shortData); } }"	where is the vulnerable dataflow from shortData to printShortLine ?	"void CWE197_Numeric_Truncation_Error__int_connect_socket_to_short_65b_badSink(int <start> data <end> );
printShortLine <start> shortData <end> );"	"printShortLine <start> shortData <end> );
void CWE197_Numeric_Truncation_Error__int_connect_socket_to_short_65b_badSink(int <start> data <end> );"	"printShortLine <start> shortData <end> );
<start> printShortLine(shortData) <end> ;"	"void CWE197_Numeric_Truncation_Error__int_connect_socket_to_short_65b_badSink(int <start> data <end> );
short <start> shortData = (short)data <end> ;"	0
4b34b013-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__short_fscanf_square_63b_badSink(short * dataPtr) { short data = *dataPtr; { short result = data * data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
void CWE190_Integer_Overflow__short_fscanf_square_63b_badSink(short * <start> dataPtr <end> );"	"<start> printIntLine(result) <end> ;
short result = <start> data <end>  * data;"	"void CWE190_Integer_Overflow__short_fscanf_square_63b_badSink(short * <start> dataPtr <end> );
short result = <start> data <end>  * data;"	"short <start> data = *dataPtr <end> ;
short result = <start> data <end>  * data;"	2
b08640e2-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE197_Numeric_Truncation_Error__int_fgets_to_short_17_bad() { int i; int data; data = -1; for(i = 0; i < 1; i++) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } { short shortData = (short)data; printShortLine(shortData); } }"	where is the vulnerable dataflow from shortData to printShortLine ?	"<start> printShortLine(shortData) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
short shortData = <start> (short)data <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printShortLine <start> shortData <end> );"	"short shortData = <start> (short)data <end> ;
printShortLine <start> shortData <end> );"	2
b8e2bdb9-6c15-11ed-81d4-94e6f77dd552	"namespace CWE606_Unchecked_Loop_Condition__char_console_81 { void bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } const CWE606_Unchecked_Loop_Condition__char_console_81_base& baseObject = CWE606_Unchecked_Loop_Condition__char_console_81_bad(); baseObject.action(data); }"	where is the vulnerable dataflow from data to action ?	"baseObject.action <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	"baseObject.action <start> data <end> );
char <start> dataBuffer[100] = """" <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
baseObject.action <start> data <end> );"	"dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	2
a95fd84f-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticFive = 5; void CWE191_Integer_Underflow__int_fgets_sub_07_bad() { int data; data = 0; if(staticFive==5) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(staticFive==5) { { int result = data - 1; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
int <start> result = data - 1 <end> ;"	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );"	"int <start> result = data - 1 <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	2
6b86244a-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticTrue = 1; static int staticFalse = 0; void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_05_bad() { int data; data = -1; if(staticTrue) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(staticTrue) { { int i; int * buffer = (int *)malloc(10 * sizeof(int)); if (buffer == NULL) {exit(-1);} for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } free(buffer); } } }"	where is the vulnerable dataflow from buffer to free ?	"free <start> buffer <end> );
<start> free(buffer) <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
if  <start> fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
free <start> buffer <end> );"	"if  <start> fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL <end> );
free <start> buffer <end> );"	2
c8600af3-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 namespace CWE23_Relative_Path_Traversal__char_listen_socket_ofstream_53 { void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badSink_b(data); }"	where is the vulnerable dataflow from data to badSink_b ?	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
<start> recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0) <end> ;"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
badSink_b <start> data <end> );"	"size_t dataLen = <start> strlen(data) <end> ;
badSink_b <start> data <end> );"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
replace = <start> strchr(data, '\n') <end> ;"	1
ae26ae40-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_listen_socket_predec_52c_badSink(int data) { { --data; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"void CWE191_Integer_Underflow__int_listen_socket_predec_52c_badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"<start> printIntLine(result) <end> ;
void CWE191_Integer_Underflow__int_listen_socket_predec_52c_badSink(int <start> data <end> );"	"void CWE191_Integer_Underflow__int_listen_socket_predec_52c_badSink(int <start> data <end> );
int <start> result = data <end> ;"	"<start> --data <end> ;
printIntLine <start> result <end> );"	0
9fe7ad3b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 namespace CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_81 { void bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } const CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_81_base& baseObject = CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_81_bad(); baseObject.action(data); }"	where is the vulnerable dataflow from data to action ?	"<start> data = dataBuffer <end> ;
baseObject.action <start> data <end> );"	"baseObject.action <start> data <end> );
<start> recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0) <end> ;"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
baseObject.action <start> data <end> );"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (100 - dataLen - 1), 0);
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	2
c4cd6f4c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_environment_open_53 { void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } badSink_b(data); }"	where is the vulnerable dataflow from data to badSink_b ?	"size_t dataLen = <start> strlen(data) <end> ;
badSink_b <start> data <end> );"	"badSink_b <start> data <end> );
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"badSink_b <start> data <end> );
strncat(data+dataLen, environment, FILENAME_MAX <start> dataLen-1 <end> );"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
badSink_b <start> data <end> );"	3
b7b09a5a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define NEW_PATH ""%SystemRoot%\\system32"" #define PUTENV _putenv #else #define NEW_PATH ""/bin"" #define PUTENV putenv #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif void CWE427_Uncontrolled_Search_Path_Element__char_file_12_bad() { char * data; char dataBuffer[250] = ""PATH=""; data = dataBuffer; if(globalReturnsTrueOrFalse()) { { size_t dataLen = strlen(data); FILE * pFile; if (250-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(250-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } else { strcat(data, NEW_PATH); } PUTENV(data); }"	where is the vulnerable dataflow from data to PUTENV ?	"<start> PUTENV(data) <end> ;
PUTENV <start> data <end> );"	"PUTENV <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(250-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(250-dataLen), pFile) == NULL);
PUTENV <start> data <end> );"	"<start> data = dataBuffer <end> ;
if (fgets <start> data+dataLen <end> , (int)(250-dataLen), pFile) == NULL);"	2
5e44fc5e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int CWE191_Integer_Underflow__int_connect_socket_predec_45_badData; static int CWE191_Integer_Underflow__int_connect_socket_predec_45_goodG2BData; static int CWE191_Integer_Underflow__int_connect_socket_predec_45_goodB2GData; static void badSink() { int data = CWE191_Integer_Underflow__int_connect_socket_predec_45_badData; { --data; int result = data; printIntLine(result); } } void CWE191_Integer_Underflow__int_connect_socket_predec_45_bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE191_Integer_Underflow__int_connect_socket_predec_45_badData = data; badSink(); }"	where is the vulnerable dataflow from data ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> CWE191_Integer_Underflow__int_connect_socket_predec_45_badData = data <end> ;
static int <start> CWE191_Integer_Underflow__int_connect_socket_predec_45_badData <end> ;
int data = <start> CWE191_Integer_Underflow__int_connect_socket_predec_45_badData <end> ;
- <start> data <end> ;"	"<start> CWE191_Integer_Underflow__int_connect_socket_predec_45_badData = data <end> ;
data = <start> atoi(inputBuffer) <end> ;
int data = <start> CWE191_Integer_Underflow__int_connect_socket_predec_45_badData <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
- <start> data <end> ;"	"int data = <start> CWE191_Integer_Underflow__int_connect_socket_predec_45_badData <end> ;
static int <start> CWE191_Integer_Underflow__int_connect_socket_predec_45_badData <end> ;
<start> printIntLine(result) <end> ;
<start> CWE191_Integer_Underflow__int_connect_socket_predec_45_badData = data <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int data = <start> CWE191_Integer_Underflow__int_connect_socket_predec_45_badData <end> ;
static int <start> CWE191_Integer_Underflow__int_connect_socket_predec_45_badData <end> ;"	0
abc37541-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_listen_socket_postdec_12_bad() { int data; data = 0; if(globalReturnsTrueOrFalse()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } else { data = -2; } if(globalReturnsTrueOrFalse()) { { data--; int result = data; printIntLine(result); } } else { if (data > INT_MIN) { data--; int result = data; printIntLine(result); } else { printLine(""data value is too large to perform arithmetic safely.""); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
if  <start> data > INT_MIN <end> );"	"printIntLine <start> result <end> );
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"<start> printIntLine(result) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	0
b1b8084e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" static const int STATIC_CONST_FIVE = 5; void CWE197_Numeric_Truncation_Error__short_connect_socket_06_bad() { short data; data = -1; if(STATIC_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = (short)atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { char charData = (char)data; printHexCharLine(charData); } }"	where is the vulnerable dataflow from charData to printHexCharLine ?	"data = <start> (short)atoi(inputBuffer) <end> ;
printHexCharLine <start> charData <end> );"	"printHexCharLine <start> charData <end> );
recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printHexCharLine <start> charData <end> );"	"char <start> charData = (char)data <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	2
453db043-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int badStatic = 0; static void badSink(int data) { if(badStatic) { { int result = data * data; printIntLine(result); } } } void CWE190_Integer_Overflow__int_connect_socket_square_21_bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badStatic = 1; badSink(data); }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  * data;
static void badSink(int <start> data <end> );
badSink <start> data <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSink <start> data <end> );
static void badSink(int <start> data <end> );
int result = <start> data <end>  * data;"	"static void badSink(int <start> data <end> );
badSink <start> data <end> );
int result = <start> data * data <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSink <start> data <end> );
static void badSink(int <start> data <end> );"	1
70279c25-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif static void badVaSinkB(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_file_vfprintf_10_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; if(globalTrue) { { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } if(globalTrue) { badVaSinkB(data, data); } }"	where is the vulnerable dataflow from data to vfprintf ?	"badVaSinkB <start> data <end> , data);
vfprintf(stdout, <start> data <end> , args);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	"<start> data = dataBuffer <end> ;
badVaSinkB <start> data <end> , data);
vfprintf(stdout, <start> data <end> , args);
static void badVaSinkB(char * <start> data <end> , ...);"	"badVaSinkB <start> data <end> , data);
<start> vfprintf(stdout, data, args) <end> ;
static void badVaSinkB(char * <start> data <end> , ...);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);"	3
86cea164-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } void CWE369_Divide_by_Zero__int_listen_socket_modulo_08_bad() { int data; data = -1; if(staticReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticReturnsTrue()) { printIntLine(100 % data); } }"	where is the vulnerable dataflow from data to printIntLine ?	"if  <start> acceptSocket == SOCKET_ERROR <end> );
printIntLine <start> 100 % data <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> 100 % data <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
if  <start> acceptSocket == SOCKET_ERROR <end> );"	"printIntLine <start> 100 % data <end> );
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	1
48d25dba-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__int_listen_socket_add_62 { void badSource(int &data); void bad() { int data; data = 0; badSource(data); { int result = data + 1; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  + 1;
badSource <start> data <end> );"	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  + 1;"	"badSource <start> data <end> );
int result = <start> data + 1 <end> ;"	"badSource <start> data <end> );
int result = <start> data <end>  + 1;"	3
ae26ae65-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_03_bad() { int data; data = -1; if(5==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { char charData = (char)data; printHexCharLine(charData); } }"	where is the vulnerable dataflow from charData to printHexCharLine ?	"printHexCharLine <start> charData <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"char charData = <start> (char)data <end> ;
printHexCharLine <start> charData <end> );"	"<start> printHexCharLine(charData) <end> ;
printHexCharLine <start> charData <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printHexCharLine <start> charData <end> );"	3
820a46d7-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif static const int STATIC_CONST_FIVE = 5; namespace CWE23_Relative_Path_Traversal__char_file_open_06 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(STATIC_CONST_FIVE==5) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"char <start> dataBuffer[FILENAME_MAX] = BASEPATH <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	3
7d44fc8e-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_15_bad() { int data; data = -1; switch(6) { case 6: { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } break; default: printLine(""Benign, fixed string""); break; } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"printLine <start> dest <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"<start> printLine(dest) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printLine <start> dest <end> );"	"<start> data = atoi(inputBuffer) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	2
86cea14a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } void CWE369_Divide_by_Zero__int_listen_socket_divide_08_bad() { int data; data = -1; if(staticReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticReturnsTrue()) { printIntLine(100 / data); } }"	where is the vulnerable dataflow from data to printIntLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
if  <start> acceptSocket == SOCKET_ERROR <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data = atoi(inputBuffer) <end> ;"	"data = <start> atoi(inputBuffer) <end> ;
printIntLine <start> 100 / data <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> 100 / data <end> );"	3
c72d5d41-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_file_open_66 { void badSink(char * dataArray[]) { char * data = dataArray[2]; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
void badSink(char * <start> dataArray <end> []);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"void badSink(char * <start> dataArray <end> []);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
void badSink(char * <start> dataArray <end> []);"	2
728a5019-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 static int badStatic = 0; static void badVaSink(char * data, ...) { if(badStatic) { { va_list args; va_start(args, data); vprintf(data, args); va_end(args); } } } void CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_21_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badStatic = 1; badVaSink(data, data); }"	where is the vulnerable dataflow from data to vprintf ?	"size_t dataLen = <start> strlen(data) <end> ;
vprintf <start> data <end> , args);
static void badVaSink(char * <start> data <end> , ...);
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
vprintf <start> data <end> , args);"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
size_t dataLen = <start> strlen(data) <end> ;
badVaSink <start> data <end> , data);
vprintf <start> data <end> , args);"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
static void badVaSink(char * <start> data <end> , ...);
badVaSink <start> data <end> , data);"	1
5f76fcc4-6c15-11ed-81d4-94e6f77dd552	"static unsigned int CWE191_Integer_Underflow__unsigned_int_fscanf_predec_45_badData; static unsigned int CWE191_Integer_Underflow__unsigned_int_fscanf_predec_45_goodG2BData; static unsigned int CWE191_Integer_Underflow__unsigned_int_fscanf_predec_45_goodB2GData; static void badSink() { unsigned int data = CWE191_Integer_Underflow__unsigned_int_fscanf_predec_45_badData; { --data; unsigned int result = data; printUnsignedLine(result); } } void CWE191_Integer_Underflow__unsigned_int_fscanf_predec_45_bad() { unsigned int data; data = 0; fscanf (stdin, ""%u"", &data); CWE191_Integer_Underflow__unsigned_int_fscanf_predec_45_badData = data; badSink(); }"	where is the vulnerable dataflow from data ?	"fscanf (stdin, ""%u"", <start> &data <end> );
<start> CWE191_Integer_Underflow__unsigned_int_fscanf_predec_45_badData = data <end> ;
static unsigned int <start> CWE191_Integer_Underflow__unsigned_int_fscanf_predec_45_badData <end> ;
unsigned int data = <start> CWE191_Integer_Underflow__unsigned_int_fscanf_predec_45_badData <end> ;
- <start> data <end> ;"	"static unsigned int <start> CWE191_Integer_Underflow__unsigned_int_fscanf_predec_45_badData <end> ;
fscanf (stdin, ""%u"", <start> &data <end> );
<start> CWE191_Integer_Underflow__unsigned_int_fscanf_predec_45_badData = data <end> ;
unsigned int data = <start> CWE191_Integer_Underflow__unsigned_int_fscanf_predec_45_badData <end> ;"	"<start> CWE191_Integer_Underflow__unsigned_int_fscanf_predec_45_badData = data <end> ;
fscanf (stdin, ""%u"", <start> &data <end> );"	"- <start> data <end> ;
fscanf (stdin, ""%u"", <start> &data <end> );
<start> CWE191_Integer_Underflow__unsigned_int_fscanf_predec_45_badData = data <end> ;
unsigned int data = <start> CWE191_Integer_Underflow__unsigned_int_fscanf_predec_45_badData <end> ;
static unsigned int <start> CWE191_Integer_Underflow__unsigned_int_fscanf_predec_45_badData <end> ;"	0
cd22814b-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif namespace CWE36_Absolute_Path_Traversal__char_console_ofstream_45 { static char * badData; static char * goodG2BData; static void badSink() { char * data = badData; { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } } void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } badData = data; badSink(); }"	where is the vulnerable dataflow from data to open ?	"dataLen = <start> strlen(data) <end> ;
outputFile.open((char * <start> data <end> );
char * data = <start> badData <end> ;
<start> badData = data <end> ;
static char * <start> badData <end> ;"	"<start> data = dataBuffer <end> ;
static char * <start> badData <end> ;
outputFile.open((char * <start> data <end> );
<start> badData = data <end> ;
char * data = <start> badData <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
<start> badData = data <end> ;
static char * <start> badData <end> ;
char * data = <start> badData <end> ;
outputFile.open((char * <start> data <end> );"	"dataLen = <start> strlen(data) <end> ;
outputFile.open((char * <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
static char * <start> badData <end> ;
char * data = <start> badData <end> ;"	2
820a46c3-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_file_fopen_41 { void badSink(char * data) { { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } } void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } badSink(data); }"	where is the vulnerable dataflow from data to FOPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
badSink <start> data <end> );
void badSink(char * <start> data <end> );
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
<start> badSink(data) <end> ;
void badSink(char * <start> data <end> );
badSink <start> data <end> );"	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
pFile = FOPEN <start> data <end> , ""wb+"");
void badSink(char * <start> data <end> );"	"void badSink(char * <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
badSink <start> data <end> );"	0
4b34b006-6c15-11ed-81d4-94e6f77dd552	"void CWE190_Integer_Overflow__short_fscanf_square_31_bad() { short data; data = 0; fscanf (stdin, ""%hd"", &data); { short dataCopy = data; short data = dataCopy; { short result = data * data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"fscanf (stdin, ""%hd"", <start> &data <end> );
short result = <start> data <end>  * data;"	"short result = <start> data <end>  * data;
<start> printIntLine(result) <end> ;"	"short result = <start> data <end>  * data;
fscanf (stdin, ""%hd"", <start> &data <end> );"	"short <start> dataCopy = data <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );"	0
bda4e40e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif namespace CWE78_OS_Command_Injection__char_file_system_82 { void bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } CWE78_OS_Command_Injection__char_file_system_82_base* baseObject = new CWE78_OS_Command_Injection__char_file_system_82_bad; baseObject->action(data); delete baseObject; }"	where is the vulnerable dataflow from data to action ?	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	"size_t dataLen = <start> strlen(data) <end> ;
baseObject->action <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
baseObject->action <start> data <end> );"	"baseObject->action <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	2
bb49c59c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #define EXECLP _execlp #else #define EXECLP execlp #endif static int staticTrue = 1; static int staticFalse = 0; void CWE78_OS_Command_Injection__char_console_execlp_05_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(staticTrue) { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECLP ?	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
<start> EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL) <end> ;"	"<start> data = dataBuffer <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"dataLen = <start> strlen(data) <end> ;
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	2
571e984e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticTrue = 1; static int staticFalse = 0; void CWE191_Integer_Underflow__int_listen_socket_multiply_05_bad() { int data; data = 0; if(staticTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticTrue) { if(data < 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  * 2;
if <start> data < 0 <end> ) ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
if <start> data < 0 <end> ) ;"	"int <start> result = data * 2 <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  * 2;"	3
55ef4c97-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_fgets_multiply_03_bad() { int data; data = 0; if(5==5) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(5==5) { if(data < 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
int result = <start> data <end>  * 2;"	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  * 2;"	"data = <start> atoi(inputBuffer) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"<start> data = atoi(inputBuffer) <end> ;
int result = <start> data <end>  * 2;"	0
5be3a9eb-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_listen_socket_postdec_66b_badSink(int dataArray[]) { int data = dataArray[2]; { data--; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
void CWE191_Integer_Underflow__int_listen_socket_postdec_66b_badSink(int <start> dataArray <end> []);"	"<start> data <end> --;
<start> printIntLine(result) <end> ;"	"<start> data <end> --;
void CWE191_Integer_Underflow__int_listen_socket_postdec_66b_badSink(int <start> dataArray <end> []);"	"void CWE191_Integer_Underflow__int_listen_socket_postdec_66b_badSink(int <start> dataArray <end> []);
<start> data <end> --;"	3
5af03dea-6c15-11ed-81d4-94e6f77dd552	"static int64_t badSource(int64_t data) { fscanf (stdin, ""%"" SCNd64, &data); return data; } void CWE191_Integer_Underflow__int64_t_fscanf_postdec_42_bad() { int64_t data; data = 0LL; data = badSource(data); { data--; int64_t result = data; printLongLongLine(result); } }"	where is the vulnerable dataflow from data ?	"data = <start> badSource <end> (data);
<start> data <end> --;
static int64_t <start> badSource <end> (int64_t data);
fscanf (stdin, ""%"" SCNd64, <start> &data <end> );"	"fscanf (stdin, ""%"" SCNd64, <start> &data <end> );
static int64_t <start> badSource <end> (int64_t data);
data = <start> badSource <end> (data);"	"fscanf (stdin, ""%"" SCNd64, <start> &data <end> );
static int64_t <start> badSource <end> (int64_t data);"	"fscanf (stdin, ""%"" SCNd64, <start> &data <end> );
static int64_t <start> badSource <end> (int64_t data);
data = <start> badSource <end> (data);
<start> data <end> --;"	3
d0b64eff-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif static int staticTrue = 1; static int staticFalse = 0; namespace CWE36_Absolute_Path_Traversal__char_file_open_05 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(staticTrue) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"<start> data = dataBuffer <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	2
7e74f36b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticTrue = 1; static int staticFalse = 0; void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_05_bad() { int data; data = -1; if(staticTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"printLine <start> dest <end> );
<start> data = atoi(inputBuffer) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printLine(dest) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
data = <start> atoi(inputBuffer) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	3
c8600ae7-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 namespace CWE23_Relative_Path_Traversal__char_listen_socket_ofstream_17 { void bad() { int i; char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; for(i = 0; i < 1; i++) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"outputFile.open((char * <start> data <end> );
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"if  <start> listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR <end> );
outputFile.open((char * <start> data <end> );"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
size_t dataLen = <start> strlen(data) <end> ;"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
outputFile.open((char * <start> data <end> );"	3
abc37524-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_fgets_postdec_17_bad() { int i,j; int data; data = 0; for(i = 0; i < 1; i++) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } for(j = 0; j < 1; j++) { { data--; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> printIntLine(result) <end> ;"	"int <start> result = data <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	1
73bc8146-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" void CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_13_bad() { short data; data = 0; if(GLOBAL_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"tempInt = <start> atoi(inputBuffer) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"printLine <start> dest <end> );
tempInt = <start> atoi(inputBuffer) <end> ;"	"<start> data = 0 <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	3
4b34afda-6c15-11ed-81d4-94e6f77dd552	"void CWE190_Integer_Overflow__short_fscanf_multiply_17_bad() { int i,j; short data; data = 0; for(i = 0; i < 1; i++) { fscanf (stdin, ""%hd"", &data); } for(j = 0; j < 1; j++) { if(data > 0) { short result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"fscanf (stdin, ""%hd"", <start> &data <end> );
<start> printIntLine(result) <end> ;"	"short result = <start> data <end>  * 2;
fscanf (stdin, ""%hd"", <start> &data <end> );"	"fscanf (stdin, ""%hd"", <start> &data <end> );
short result = <start> data <end>  * 2;"	"short result = <start> data <end>  * 2;
<start> printIntLine(result) <end> ;"	2
80d98723-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_console_open_09 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(GLOBAL_CONST_TRUE) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
size_t dataLen = <start> strlen(data) <end> ;"	"char <start> dataBuffer[FILENAME_MAX] = BASEPATH <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"if (dataLen > 0 && <start> data[dataLen-1] == '\n' <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	3
bed4a8c4-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_connect_socket_fopen_18 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; goto source; source: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"replace = <start> strchr(data, '\r') <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
<start> data = dataBuffer <end> ;"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
size_t dataLen = <start> strlen(data) <end> ;"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	3
964cdbfd-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FULL_COMMAND ""dir "" #else #define FULL_COMMAND ""ls "" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define POPEN _popen #define PCLOSE _pclose #else #define POPEN popen #define PCLOSE pclose #endif typedef struct _CWE78_OS_Command_Injection__char_file_popen_67_structType { char * structFirst; } CWE78_OS_Command_Injection__char_file_popen_67_structType; void CWE78_OS_Command_Injection__char_file_popen_67b_badSink(CWE78_OS_Command_Injection__char_file_popen_67_structType myStruct) { char * data = myStruct.structFirst; { FILE *pipe; pipe = POPEN(data, ""w""); if (pipe != NULL) { PCLOSE(pipe); } } }"	where is the vulnerable dataflow from data to POPEN ?	"pipe = <start> POPEN(data, ""w"") <end> ;
void CWE78_OS_Command_Injection__char_file_popen_67b_badSink(CWE78_OS_Command_Injection__char_file_popen_67_structType <start> myStruct <end> );
pipe = POPEN <start> data <end> , ""w"");"	"void CWE78_OS_Command_Injection__char_file_popen_67b_badSink(CWE78_OS_Command_Injection__char_file_popen_67_structType <start> myStruct <end> );
char * data = <start> myStruct <end> .structFirst;
pipe = POPEN <start> data <end> , ""w"");"	"pipe = POPEN <start> data <end> , ""w"");
char * data = <start> myStruct <end> .structFirst;
pipe = <start> POPEN(data, ""w"") <end> ;"	"char * data = <start> myStruct <end> .structFirst;
pipe = POPEN <start> data <end> , ""w"");"	1
648a9c01-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__int_rand_add_09_bad() { int data; data = 0; if(GLOBAL_CONST_TRUE) { data = RAND32(); } if(GLOBAL_CONST_TRUE) { { int result = data + 1; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"data = <start> RAND32() <end> ;
<start> printIntLine(result) <end> ;"	"data = <start> RAND32() <end> ;
int result = <start> data <end>  + 1;"	"int <start> result = data + 1 <end> ;
data = <start> RAND32() <end> ;"	"int result = <start> data + 1 <end> ;
data = <start> RAND32() <end> ;"	1
98b01559-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_connect_socket_45 { static int badData; static int goodG2BData; static int goodB2GData; static void badSink() { int data = badData; { int i; int * buffer = new int[10]; for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } delete[] buffer; } } void bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badData = data; badSink(); }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"printIntLine <start> buffer[i] <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> badData = data <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> badData = data <end> ;
static int <start> badData <end> ;
int data = <start> badData <end> ;
printIntLine <start> buffer[i] <end> );"	"int data = <start> badData <end> ;
<start> badData = data <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[i] <end> );"	"<start> badData = data <end> ;
printIntLine <start> buffer[i] <end> );
int data = <start> badData <end> ;
static int <start> badData <end> ;
recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);"	1
9d74538a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; void CWE127_Buffer_Underread__CWE839_connect_socket_04_bad() { int data; data = -1; if(STATIC_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(STATIC_CONST_TRUE) { { int buffer[10] = { 0 }; if (data < 10) { printIntLine(buffer[data]); } else { printLine(""ERROR: Array index is too big.""); } } } }"	where is the vulnerable dataflow from buffer[data] to printIntLine ?	"printIntLine <start> buffer[data] <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[data] <end> );"	"<start> printIntLine(buffer[data]) <end> ;
printIntLine <start> buffer[data] <end> );"	"data = <start> atoi(inputBuffer) <end> ;
printIntLine <start> buffer[data] <end> );"	1
b2ea8dce-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 8 static void badSink(short data) { { char charData = (char)data; printHexCharLine(charData); } } void CWE197_Numeric_Truncation_Error__short_fgets_44_bad() { short data; void (*funcPtr) (short) = badSink; data = -1; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = (short)atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } funcPtr(data); }"	where is the vulnerable dataflow from charData to printHexCharLine ?	"char charData = <start> (char)data <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
static void badSink(short <start> data <end> );
funcPtr <start> data <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
funcPtr <start> data <end> );
static void badSink(short <start> data <end> );
printHexCharLine <start> charData <end> );"	"static void badSink(short <start> data <end> );
printHexCharLine <start> charData <end> );
funcPtr <start> data <end> );"	"<start> funcPtr(data) <end> ;
static void badSink(short <start> data <end> );
printHexCharLine <start> charData <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	1
833ac947-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_listen_socket_open_45 { static char * badData; static char * goodG2BData; static void badSink() { char * data = badData; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } } void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badData = data; badSink(); }"	where is the vulnerable dataflow from data to OPEN ?	"static char * <start> badData <end> ;
<start> badData = data <end> ;"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
<start> badData = data <end> ;
static char * <start> badData <end> ;
char * data = <start> badData <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"<start> badData = data <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
char * data = <start> badData <end> ;
static char * <start> badData <end> ;
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"<start> recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
<start> badData = data <end> ;
char * data = <start> badData <end> ;
static char * <start> badData <end> ;"	1
6b862451-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_12_bad() { int data; data = -1; if(globalReturnsTrueOrFalse()) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } else { data = 7; } if(globalReturnsTrueOrFalse()) { { int i; int * buffer = (int *)malloc(10 * sizeof(int)); if (buffer == NULL) {exit(-1);} for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } free(buffer); } } else { { int i; int * buffer = (int *)malloc(10 * sizeof(int)); if (buffer == NULL) {exit(-1);} for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0 && data < (10)) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is out-of-bounds""); } free(buffer); } } }"	where is the vulnerable dataflow from buffer to free ?	"<start> printIntLine(buffer[i]) <end> ;
free <start> buffer <end> );"	"free <start> buffer <end> );
if  <start> fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) <end>  != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
free <start> buffer <end> );"	"<start> free(buffer) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	2
73bc815a-6c15-11ed-81d4-94e6f77dd552	"namespace CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_62 { void badSource(short &data); void bad() { short data; data = 0; badSource(data); { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"printLine <start> dest <end> );
if  <start> data < 100 <end> );"	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	"badSource <start> data <end> );
printLine <start> dest <end> );"	"<start> memcpy(dest, source, data) <end> ;
printLine <start> dest <end> );"	2
7d44fc6f-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_51b_badSink(int data) { { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"printLine <start> dest <end> );
if  <start> data < 100 <end> );"	"void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_51b_badSink(int <start> data <end> );
printLine <start> dest <end> );"	"char <start> dest[100] = """" <end> ;
void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_51b_badSink(int <start> data <end> );"	"void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_51b_badSink(int <start> data <end> );
<start> memmove(dest, source, data) <end> ;"	1
5f76fcae-6c15-11ed-81d4-94e6f77dd552	extern int CWE191_Integer_Underflow__short_fscanf_predec_22_badGlobal; void CWE191_Integer_Underflow__short_fscanf_predec_22_badSink(short data) { if(CWE191_Integer_Underflow__short_fscanf_predec_22_badGlobal) { { --data; short result = data; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"void CWE191_Integer_Underflow__short_fscanf_predec_22_badSink(short <start> data <end> );
<start> --data <end> ;"	"void CWE191_Integer_Underflow__short_fscanf_predec_22_badSink(short <start> data <end> );
- <start> data <end> ;"	"- <start> data <end> ;
void CWE191_Integer_Underflow__short_fscanf_predec_22_badSink(short <start> data <end> );"	"<start> printIntLine(result) <end> ;
void CWE191_Integer_Underflow__short_fscanf_predec_22_badSink(short <start> data <end> );"	1
b8e2bdc4-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE680_Integer_Overflow_to_Buffer_Overflow__new_connect_socket_81 { void bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } const CWE680_Integer_Overflow_to_Buffer_Overflow__new_connect_socket_81_base& baseObject = CWE680_Integer_Overflow_to_Buffer_Overflow__new_connect_socket_81_bad(); baseObject.action(data); }"	where is the vulnerable dataflow from data to action ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
baseObject.action <start> data <end> );"	"data = <start> atoi(inputBuffer) <end> ;
baseObject.action <start> data <end> );"	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
baseObject.action <start> data <end> );"	"recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);
baseObject.action <start> data <end> );"	0
761e2981-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 8 void CWE194_Unexpected_Sign_Extension__fgets_memmove_17_bad() { int i; short data; data = 0; for(i = 0; i < 1; i++) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = (short)atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> memmove(dest, source, data) <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printLine <start> dest <end> );"	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	"<start> memmove(dest, source, data) <end> ;
printLine <start> dest <end> );"	1
73bc8157-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" void CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_53d_badSink(short data) { { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"char <start> dest[100] = """" <end> ;
printLine <start> dest <end> );"	"void CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_53d_badSink(short <start> data <end> );
printLine <start> dest <end> );"	"printLine <start> dest <end> );
<start> memcpy(dest, source, data) <end> ;"	"<start> printLine(dest) <end> ;
void CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_53d_badSink(short <start> data <end> );"	1
8a6310ec-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_listen_socket_fopen_17 { void bad() { int i; char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; for(i = 0; i < 1; i++) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to sizeof ?	recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);	"pFile = <start> FOPEN(data, ""wb+"") <end> ;"	replace = <start> strchr(data, '\r') <end> ;	size_t dataLen = <start> strlen(data) <end> ;	0
8b91e494-6c15-11ed-81d4-94e6f77dd552	"static int staticTrue = 1; static int staticFalse = 0; void CWE390_Error_Without_Action__fgets_char_05_bad() { if(staticTrue) { { char dataBuffer[100] = """"; char * data = dataBuffer; printLine(""Please enter a string: ""); if (fgets(data, 100, stdin) == NULL) { } printLine(data); } } }"	where is the vulnerable dataflow from data to printLine ?	"<start> printLine(data) <end> ;
printLine <start> data <end> );"	"printLine <start> data <end> );
if (fgets <start> data <end> , 100, stdin) == NULL);"	"if (fgets <start> data <end> , 100, stdin) == NULL);
<start> printLine(data) <end> ;"	"if (fgets <start> data <end> , 100, stdin) == NULL);
printLine <start> data <end> );"	3
5af03df8-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_connect_socket_postdec_13_bad() { int data; data = 0; if(GLOBAL_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(GLOBAL_CONST_FIVE==5) { { data--; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data <end> --;"	"data = <start> atoi(inputBuffer) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"<start> data <end> --;
recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);"	"<start> data <end> --;
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	0
67d010b5-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__short_rand_postinc_18_bad() { short data; data = 0; goto source; source: data = (short)RAND32(); goto sink; sink: { data++; short result = data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"data = (short <start> RAND32() <end> ;
<start> data <end> ++;"	"short <start> result = data <end> ;
<start> data <end> ++;"	"<start> printIntLine(result) <end> ;
data = (short <start> RAND32() <end> ;"	"data = (short <start> RAND32() <end> ;
short <start> result = data <end> ;"	0
cd22815a-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_console_open_10 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(globalTrue) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
<start> data = dataBuffer <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
size_t dataLen = <start> strlen(data) <end> ;"	2
6b86243e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_connect_socket_66b_badSink(int dataArray[]) { int data = dataArray[2]; { int i; int * buffer = (int *)malloc(10 * sizeof(int)); if (buffer == NULL) {exit(-1);} for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } free(buffer); } }"	where is the vulnerable dataflow from buffer to free ?	"void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_connect_socket_66b_badSink(int <start> dataArray <end> []);
<start> free(buffer) <end> ;"	"void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_connect_socket_66b_badSink(int <start> dataArray <end> []);
free <start> buffer <end> );"	"free <start> buffer <end> );
void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_connect_socket_66b_badSink(int <start> dataArray <end> []);"	"free <start> buffer <end> );
<start> free(buffer) <end> ;"	1
bc721fa1-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define EXECLP _execlp #else #define EXECLP execlp #endif static char * CWE78_OS_Command_Injection__char_file_execlp_45_badData; static char * CWE78_OS_Command_Injection__char_file_execlp_45_goodG2BData; static void badSink() { char * data = CWE78_OS_Command_Injection__char_file_execlp_45_badData; EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL); } void CWE78_OS_Command_Injection__char_file_execlp_45_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } CWE78_OS_Command_Injection__char_file_execlp_45_badData = data; badSink(); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECLP ?	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
<start> CWE78_OS_Command_Injection__char_file_execlp_45_badData = data <end> ;
static char * <start> CWE78_OS_Command_Injection__char_file_execlp_45_badData <end> ;
char * data = <start> CWE78_OS_Command_Injection__char_file_execlp_45_badData <end> ;
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"<start> CWE78_OS_Command_Injection__char_file_execlp_45_badData = data <end> ;
char * data = <start> CWE78_OS_Command_Injection__char_file_execlp_45_badData <end> ;
size_t dataLen = <start> strlen(data) <end> ;
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
static char * <start> CWE78_OS_Command_Injection__char_file_execlp_45_badData <end> ;"	"static char * <start> CWE78_OS_Command_Injection__char_file_execlp_45_badData <end> ;
char * data = <start> CWE78_OS_Command_Injection__char_file_execlp_45_badData <end> ;
<start> CWE78_OS_Command_Injection__char_file_execlp_45_badData = data <end> ;
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"<start> EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL) <end> ;
char * data = <start> CWE78_OS_Command_Injection__char_file_execlp_45_badData <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
<start> CWE78_OS_Command_Injection__char_file_execlp_45_badData = data <end> ;
static char * <start> CWE78_OS_Command_Injection__char_file_execlp_45_badData <end> ;"	0
977ea79b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_01_bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { int i; int buffer[10] = { 0 }; if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } } }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"<start> recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> buffer[i] <end> );"	"printIntLine <start> buffer[i] <end> );
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"printIntLine <start> buffer[i] <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[i] <end> );"	3
525b6494-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__short_fscanf_preinc_64b_badSink(void * dataVoidPtr) { short * dataPtr = (short *)dataVoidPtr; short data = (*dataPtr); { ++data; short result = data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"void CWE190_Integer_Overflow__short_fscanf_preinc_64b_badSink(void * <start> dataVoidPtr <end> );
+ <start> data <end> ;"	"<start> printIntLine(result) <end> ;
void CWE190_Integer_Overflow__short_fscanf_preinc_64b_badSink(void * <start> dataVoidPtr <end> );"	"void CWE190_Integer_Overflow__short_fscanf_preinc_64b_badSink(void * <start> dataVoidPtr <end> );
short <start> result = data <end> ;"	"+ <start> data <end> ;
void CWE190_Integer_Overflow__short_fscanf_preinc_64b_badSink(void * <start> dataVoidPtr <end> );"	0
5af03dfc-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_connect_socket_postdec_17_bad() { int i,j; int data; data = 0; for(i = 0; i < 1; i++) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } for(j = 0; j < 1; j++) { { data--; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
<start> data <end> --;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data <end> --;"	"<start> data = atoi(inputBuffer) <end> ;
<start> data <end> --;"	"<start> data <end> --;
data = <start> atoi(inputBuffer) <end> ;"	1
833ac92a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_listen_socket_fopen_73 { void badSink(list<char *> dataList) { char * data = dataList.back(); { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"void badSink(list<char *> <start> dataList <end> );
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	"void badSink(list<char *> <start> dataList <end> );
pFile = FOPEN <start> data <end> , ""wb+"");"	"void badSink(list<char *> <start> dataList <end> );
char <start> * data = dataList.back() <end> ;"	"pFile = FOPEN <start> data <end> , ""wb+"");
void badSink(list<char *> <start> dataList <end> );"	1
b08640d9-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } void CWE197_Numeric_Truncation_Error__int_fgets_to_short_08_bad() { int data; data = -1; if(staticReturnsTrue()) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } { short shortData = (short)data; printShortLine(shortData); } }"	where is the vulnerable dataflow from shortData to printShortLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printShortLine <start> shortData <end> );"	"printShortLine <start> shortData <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> printShortLine(shortData) <end> ;"	"printShortLine <start> shortData <end> );
data = <start> atoi(inputBuffer) <end> ;"	0
a10948ef-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_multiply_51b_badSink(int data) { if(data > 0) { int result = data * 2; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"void CWE190_Integer_Overflow__int_connect_socket_multiply_51b_badSink(int <start> data <end> );
<start> printIntLine(result) <end> ;"	"printIntLine <start> result <end> );
void CWE190_Integer_Overflow__int_connect_socket_multiply_51b_badSink(int <start> data <end> );"	"void CWE190_Integer_Overflow__int_connect_socket_multiply_51b_badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
int <start> result = data * 2 <end> ;"	2
d0b64f04-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_file_open_10 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(globalTrue) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"<start> data = dataBuffer <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	0
c4cd6f4f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_environment_open_62 { void badSource(char * &data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; badSource(data); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"badSource <start> data <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
char <start> dataBuffer[FILENAME_MAX] = BASEPATH <end> ;"	"badSource <start> data <end> );
fileDesc = OPEN(data, O_RDWR|O_CREAT, <start> S_IREAD|S_IWRITE <end> );"	1
774f5810-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 8 void CWE194_Unexpected_Sign_Extension__listen_socket_malloc_11_bad() { short data; data = 0; if(globalReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }"	where is the vulnerable dataflow from data to malloc ?	"char * dataBuffer = (char *)malloc <start> data <end> );
<start> printLine(dataBuffer) <end> ;"	"if  <start> data < 100 <end> );
char * dataBuffer = (char *)malloc <start> data <end> );"	"<start> printLine(dataBuffer) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
char * dataBuffer = (char *)malloc <start> data <end> );"	3
964cdc0b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FULL_COMMAND ""dir "" #else #define FULL_COMMAND ""ls "" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define POPEN _popen #define PCLOSE _pclose #else #define POPEN popen #define PCLOSE pclose #endif void CWE78_OS_Command_Injection__char_listen_socket_popen_10_bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; if(globalTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { FILE *pipe; pipe = POPEN(data, ""w""); if (pipe != NULL) { PCLOSE(pipe); } } }"	where is the vulnerable dataflow from data to POPEN ?	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
pipe = POPEN <start> data <end> , ""w"");"	"pipe = <start> POPEN(data, ""w"") <end> ;
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
size_t dataLen = <start> strlen(data) <end> ;"	"pipe = POPEN <start> data <end> , ""w"");
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (100 - dataLen - 1), 0);"	0
c39a6588-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; namespace CWE23_Relative_Path_Traversal__char_environment_ifstream_04 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(STATIC_CONST_TRUE) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } } { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"inputFile.open((char * <start> data <end> );
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
inputFile.open((char * <start> data <end> );"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
strncat(data+dataLen, environment, FILENAME_MAX <start> dataLen-1 <end> );"	"<start> strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1) <end> ;
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	1
a5ce1c5d-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_postinc_18_bad() { int data; data = 0; goto source; source: { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } goto sink; sink: { data++; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"int <start> result = data <end> ;
printIntLine <start> result <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );"	"<start> data = atoi(inputBuffer) <end> ;
printIntLine <start> result <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> data = atoi(inputBuffer) <end> ;"	1
5e44fc9e-6c15-11ed-81d4-94e6f77dd552	"static int badStatic = 0; static void badSink(int data) { if(badStatic) { { --data; int result = data; printIntLine(result); } } } void CWE191_Integer_Underflow__int_fscanf_predec_21_bad() { int data; data = 0; fscanf(stdin, ""%d"", &data); badStatic = 1; badSink(data); }"	where is the vulnerable dataflow from data ?	"badSink <start> data <end> );
- <start> data <end> ;
<start> printIntLine(result) <end> ;
fscanf(stdin, ""%d"", <start> &data <end> );"	"fscanf(stdin, ""%d"", <start> &data <end> );
badSink <start> data <end> );
static void badSink(int <start> data <end> );
- <start> data <end> ;"	"fscanf(stdin, ""%d"", <start> &data <end> );
- <start> data <end> ;
badSink <start> data <end> );"	"static void badSink(int <start> data <end> );
fscanf(stdin, ""%d"", <start> &data <end> );
<start> badSink(data) <end> ;
- <start> data <end> ;"	1
d0b64ed5-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif namespace CWE36_Absolute_Path_Traversal__char_file_ifstream_41 { void badSink(char * data) { { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } } void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } badSink(data); }"	where is the vulnerable dataflow from data to badSink ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
badSink <start> data <end> );"	"badSink <start> data <end> );
<start> badSink(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
<start> badSink(data) <end> ;"	"badSink <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	0
893217d1-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_console_fopen_45 { static char * badData; static char * goodG2BData; static void badSink() { char * data = badData; { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } } void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } badData = data; badSink(); }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = FOPEN <start> data <end> , ""wb+"");
char * data = <start> badData <end> ;
static char * <start> badData <end> ;
dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
<start> badData = data <end> ;
static char * <start> badData <end> ;
char * data = <start> badData <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"char <start> dataBuffer[FILENAME_MAX] = """" <end> ;
static char * <start> badData <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
pFile = FOPEN <start> data <end> , ""wb+"");
<start> badData = data <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
static char * <start> badData <end> ;
<start> badData = data <end> ;
pFile = <start> FOPEN(data, ""wb+"") <end> ;
char * data = <start> badData <end> ;"	1
6b86243d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_connect_socket_65b_badSink(int data) { { int i; int * buffer = (int *)malloc(10 * sizeof(int)); if (buffer == NULL) {exit(-1);} for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } free(buffer); } }"	where is the vulnerable dataflow from buffer to free ?	"void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_connect_socket_65b_badSink(int <start> data <end> );
free <start> buffer <end> );"	"<start> printIntLine(buffer[i]) <end> ;
void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_connect_socket_65b_badSink(int <start> data <end> );"	"<start> free(buffer) <end> ;
void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_connect_socket_65b_badSink(int <start> data <end> );"	"free <start> buffer <end> );
<start> printIntLine(buffer[i]) <end> ;"	0
8f278a3c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define PATH_SZ 100 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define PATH_SZ PATH_MAX #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; void CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__listen_bind_accept_04_bad() { if(STATIC_CONST_TRUE) { { char data[100] = """"; #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[recvResult] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif printLine(data); } } }"	where is the vulnerable dataflow from data to printLine ?	"printLine <start> data <end> );
recvResult = recv(acceptSocket, (char *)data+dataLen, (int) <start> 100-dataLen-1 <end> ), 0);"	"recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);
printLine <start> data <end> );"	"printLine <start> data <end> );
replace = <start> strchr(data, '\n') <end> ;"	"printLine <start> data <end> );
if  <start> recvResult == SOCKET_ERROR <end>  || recvResult == 0);"	1
bda4e417-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define EXECL _execl #else #define EXECL execl #endif void CWE78_OS_Command_Injection__char_listen_socket_execl_09_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(GLOBAL_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECL ?	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (100 - dataLen - 1), 0);
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
recvResult = <start> recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0) <end> ;"	"EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
size_t dataLen = <start> strlen(data) <end> ;"	0
9c4551b5-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink(int data) { { int buffer[10] = { 0 }; if (data >= 0) { printIntLine(buffer[data]); } else { printLine(""ERROR: Array index is negative""); } } } void CWE126_Buffer_Overread__CWE129_fgets_41_bad() { int data; data = -1; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } badSink(data); }"	where is the vulnerable dataflow from buffer[data] to printIntLine ?	"badSink <start> data <end> );
printIntLine <start> buffer[data] <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"<start> badSink(data) <end> ;
printIntLine <start> buffer[data] <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
static void badSink(int <start> data <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
badSink <start> data <end> );
static void badSink(int <start> data <end> );
printIntLine <start> buffer[data] <end> );"	"badSink <start> data <end> );
printIntLine <start> buffer[data] <end> );"	2
7fa68e25-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; namespace CWE23_Relative_Path_Traversal__char_connect_socket_fopen_04 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(STATIC_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
char <start> dataBuffer[FILENAME_MAX] = BASEPATH <end> ;"	"recvResult = recv(connectSocket, (char *)(data + dataLen), <start> sizeof(char) * (FILENAME_MAX - dataLen - 1) <end> , 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	"replace = <start> strchr(data, '\r') <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	0
85b15f05-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticFive = 5; void CWE369_Divide_by_Zero__int_fgets_modulo_07_bad() { int data; data = -1; if(staticFive==5) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(staticFive==5) { printIntLine(100 % data); } }"	where is the vulnerable dataflow from data to printIntLine ?	"printIntLine <start> 100 % data <end> );
<start> data = atoi(inputBuffer) <end> ;"	"printIntLine <start> 100 % data <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"printIntLine <start> 100 % data <end> );
data = <start> atoi(inputBuffer) <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> 100 % data <end> );"	3
6b862437-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_connect_socket_53d_badSink(int data) { { int i; int * buffer = (int *)malloc(10 * sizeof(int)); if (buffer == NULL) {exit(-1);} for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } free(buffer); } }"	where is the vulnerable dataflow from buffer to free ?	"free <start> buffer <end> );
<start> free(buffer) <end> ;"	"<start> printIntLine(buffer[i]) <end> ;
void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_connect_socket_53d_badSink(int <start> data <end> );"	"void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_connect_socket_53d_badSink(int <start> data <end> );
free <start> buffer <end> );"	"<start> printIntLine(buffer[i]) <end> ;
free <start> buffer <end> );"	2
aa91a19b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE191_Integer_Underflow__int_listen_socket_sub_43 { static void badSource(int &data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } void bad() { int data; data = 0; badSource(data); { int result = data - 1; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"<start> badSource(data) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
badSource <start> data <end> );"	"<start> badSource(data) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSource <start> data <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSource <start> data <end> );
printIntLine <start> result <end> );"	3
98b01550-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_connect_socket_17 { void bad() { int i,j; int data; data = -1; for(i = 0; i < 1; i++) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } for(j = 0; j < 1; j++) { { int i; int * buffer = new int[10]; for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } delete[] buffer; } } }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"printIntLine <start> buffer[i] <end> );
recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);"	"data = <start> atoi(inputBuffer) <end> ;
printIntLine <start> buffer[i] <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[i] <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
data = <start> atoi(inputBuffer) <end> ;"	2
8df421d1-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define NEW_PATH ""%SystemRoot%\\system32"" #define PUTENV _putenv #else #define NEW_PATH ""/bin"" #define PUTENV putenv #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 void CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_17_bad() { int i; char * data; char dataBuffer[250] = ""PATH=""; data = dataBuffer; for(i = 0; i < 1; i++) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (250 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } PUTENV(data); }"	where is the vulnerable dataflow from data to sizeof ?	<start> data = dataBuffer <end> ;	<start> recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (250 - dataLen - 1), 0) <end> ;	recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (250 - dataLen - 1), 0);	size_t dataLen = <start> strlen(data) <end> ;	2
453db023-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_multiply_53d_badSink(int data) { if(data > 0) { int result = data * 2; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"void CWE190_Integer_Overflow__int_connect_socket_multiply_53d_badSink(int <start> data <end> );
int result = <start> data <end>  * 2;"	"<start> printIntLine(result) <end> ;
void CWE190_Integer_Overflow__int_connect_socket_multiply_53d_badSink(int <start> data <end> );"	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  * 2;"	"int result = <start> data <end>  * 2;
void CWE190_Integer_Overflow__int_connect_socket_multiply_53d_badSink(int <start> data <end> );"	0
538bfae5-6c15-11ed-81d4-94e6f77dd552	"static void badSink(unsigned int data) { { ++data; unsigned int result = data; printUnsignedLine(result); } } void CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_41_bad() { unsigned int data; data = 0; fscanf (stdin, ""%u"", &data); badSink(data); }"	where is the vulnerable dataflow from data ?	"fscanf (stdin, ""%u"", <start> &data <end> );
badSink <start> data <end> );
static void badSink(unsigned int <start> data <end> );
+ <start> data <end> ;"	"badSink <start> data <end> );
<start> badSink(data) <end> ;
static void badSink(unsigned int <start> data <end> );
+ <start> data <end> ;"	"badSink <start> data <end> );
static void badSink(unsigned int <start> data <end> );
<start> badSink(data) <end> ;
fscanf (stdin, ""%u"", <start> &data <end> );"	"fscanf (stdin, ""%u"", <start> &data <end> );
static void badSink(unsigned int <start> data <end> );
badSink <start> data <end> );
+ <start> data <end> ;"	0
aa91a196-6c15-11ed-81d4-94e6f77dd552	extern int CWE191_Integer_Underflow__int_listen_socket_sub_22_badGlobal; void CWE191_Integer_Underflow__int_listen_socket_sub_22_badSink(int data) { if(CWE191_Integer_Underflow__int_listen_socket_sub_22_badGlobal) { { int result = data - 1; printIntLine(result); } } }	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
int result = <start> data - 1 <end> ;"	"printIntLine <start> result <end> );
void CWE191_Integer_Underflow__int_listen_socket_sub_22_badSink(int <start> data <end> );"	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	"void CWE191_Integer_Underflow__int_listen_socket_sub_22_badSink(int <start> data <end> );
printIntLine <start> result <end> );"	3
525b645d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_preinc_13_bad() { int data; data = 0; if(GLOBAL_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(GLOBAL_CONST_FIVE==5) { { ++data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"int <start> result = data <end> ;
+ <start> data <end> ;"	"<start> printIntLine(result) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"if  <start> acceptSocket == SOCKET_ERROR <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
+ <start> data <end> ;"	3
4a02113a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) int CWE190_Integer_Overflow__int_listen_socket_square_61b_badSource(int data); void CWE190_Integer_Overflow__int_listen_socket_square_61_bad() { int data; data = 0; data = CWE190_Integer_Overflow__int_listen_socket_square_61b_badSource(data); { int result = data * data; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"int <start> result = data * data <end> ;
data = <start> CWE190_Integer_Overflow__int_listen_socket_square_61b_badSource <end> (data);"	"data = <start> CWE190_Integer_Overflow__int_listen_socket_square_61b_badSource <end> (data);
<start> printIntLine(result) <end> ;"	"data = <start> CWE190_Integer_Overflow__int_listen_socket_square_61b_badSource <end> (data);
int result = <start> data <end>  * data;"	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  * data;"	2
5af03e1c-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_fgets_postdec_14_bad() { int data; data = 0; if(globalFive==5) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(globalFive==5) { { data--; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> data <end> --;"	"<start> data = atoi(inputBuffer) <end> ;
<start> data <end> --;"	"<start> printIntLine(result) <end> ;
<start> data <end> --;"	"<start> printIntLine(result) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	0
60db83d2-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__char_rand_multiply_62 { void badSource(char &data); void bad() { char data; data = ' '; badSource(data); if(data > 0) { char result = data * 2; printHexCharLine(result); } }	where is the vulnerable dataflow from data ?	"<start> badSource(data) <end> ;
char result = <start> data <end>  * 2;"	"badSource <start> data <end> );
char result = <start> data <end>  * 2;"	"badSource <start> data <end> );
<start> badSource(data) <end> ;"	"badSource <start> data <end> );
char <start> result = data * 2 <end> ;"	1
571e982b-6c15-11ed-81d4-94e6f77dd552	"void CWE191_Integer_Underflow__int_fscanf_sub_11_bad() { int data; data = 0; if(globalReturnsTrue()) { fscanf(stdin, ""%d"", &data); } if(globalReturnsTrue()) { { int result = data - 1; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"fscanf(stdin, ""%d"", <start> &data <end> );
int result = <start> data - 1 <end> ;"	"int result = <start> data <end>  - 1;
fscanf(stdin, ""%d"", <start> &data <end> );"	"fscanf(stdin, ""%d"", <start> &data <end> );
int result = <start> data <end>  - 1;"	"<start> printIntLine(result) <end> ;
fscanf(stdin, ""%d"", <start> &data <end> );"	2
6b862463-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_53d_badSink(int data) { { int i; int * buffer = (int *)malloc(10 * sizeof(int)); if (buffer == NULL) {exit(-1);} for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } free(buffer); } }"	where is the vulnerable dataflow from buffer to free ?	"<start> printIntLine(buffer[i]) <end> ;
free <start> buffer <end> );"	"void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_53d_badSink(int <start> data <end> );
free <start> buffer <end> );"	"free <start> buffer <end> );
<start> free(buffer) <end> ;"	"free <start> buffer <end> );
void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_53d_badSink(int <start> data <end> );"	1
b8e2bdcc-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 256 static const int STATIC_CONST_FIVE = 5; void CWE681_Incorrect_Conversion_Between_Numeric_Types__doubleNaN2int_06_bad() { if(STATIC_CONST_FIVE==5) { { char inputBuffer[CHAR_ARRAY_SIZE]; double doubleNumber = 0; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { doubleNumber = atof(inputBuffer); } else { printLine(""fgets() failed.""); } printIntLine((int)(sqrt(doubleNumber))); } } }"	where is the vulnerable dataflow from doubleNumber to printIntLine ?	"printIntLine((int)(sqrt <start> doubleNumber <end> )));
printIntLine((int) <start> sqrt(doubleNumber) <end> ));"	"printIntLine((int)(sqrt <start> doubleNumber <end> )));
if  <start> fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) <end>  != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine((int) <start> sqrt(doubleNumber) <end> ));"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine((int)(sqrt <start> doubleNumber <end> )));"	3
7fa68e49-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif static int staticTrue = 1; static int staticFalse = 0; namespace CWE23_Relative_Path_Traversal__char_connect_socket_open_05 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(staticTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
<start> data = dataBuffer <end> ;"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	3
7ae3a71a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_43 { static void badSource(int &data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } void bad() { int data; data = -1; badSource(data); { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"data = <start> atoi(inputBuffer) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSource <start> data <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> badSource(data) <end> ;
badSource <start> data <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSource <start> data <end> );
printLine <start> dest <end> );"	"if  <start> data < 100 <end> );
badSource <start> data <end> );
printLine <start> dest <end> );"	2
98b0153d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) typedef struct _CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_67_structType { int structFirst; } CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_67_structType; void CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_67b_badSink(CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_67_structType myStruct) { int data = myStruct.structFirst; { int i; int buffer[10] = { 0 }; if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } } }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"int <start> buffer[10] = { 0 } <end> ;
void CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_67b_badSink(CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_67_structType <start> myStruct <end> );
int data = <start> myStruct <end> .structFirst;"	"void CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_67b_badSink(CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_67_structType <start> myStruct <end> );
int data = <start> myStruct <end> .structFirst;
printIntLine <start> buffer[i] <end> );"	"void CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_67b_badSink(CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_67_structType <start> myStruct <end> );
int data = <start> myStruct <end> .structFirst;"	"int data = <start> myStruct <end> .structFirst;
void CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_67b_badSink(CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_67_structType <start> myStruct <end> );
printIntLine <start> buffer[i] <end> );"	1
78800fb6-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 8 static int badStatic = 0; static short badSource(short data) { if(badStatic) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } return data; } void CWE194_Unexpected_Sign_Extension__listen_socket_memmove_21_bad() { short data; data = 0; badStatic = 1; data = badSource(data); { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
static short <start> badSource <end> (short data);
data = <start> badSource <end> (data);
printLine <start> dest <end> );"	"data = <start> badSource <end> (data);
static short <start> badSource <end> (short data);
<start> memmove(dest, source, data) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"data = <start> badSource <end> (data);
static short <start> badSource <end> (short data);
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static short <start> badSource <end> (short data);
data = <start> badSource <end> (data);
printLine <start> dest <end> );"	3
8f278a8a-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_52c_badSink(int data) { { size_t i; int *intPointer; intPointer = (int*)malloc(data * sizeof(int)); if (intPointer == NULL) {exit(-1);} for (i = 0; i < (size_t)data; i++) { intPointer[i] = 0; } printIntLine(intPointer[0]); free(intPointer); } }	where is the vulnerable dataflow from data to malloc ?	"void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_52c_badSink(int <start> data <end> );
<start> free(intPointer) <end> ;"	"void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_52c_badSink(int <start> data <end> );
<start> printIntLine(intPointer[0]) <end> ;"	"void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_52c_badSink(int <start> data <end> );
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	"intPointer = (int*)malloc <start> data * sizeof(int) <end> );
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_52c_badSink(int <start> data <end> );"	2
6c938c0e-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif namespace CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_62 { void badSource(char * &data); void bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; badSource(data); { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"badSource <start> data <end> );
printLine <start> dest <end> );"	"<start> SNPRINTF(dest, 100-1, data) <end> ;
badSource <start> data <end> );"	"printLine <start> dest <end> );
<start> SNPRINTF(dest, 100-1, data) <end> ;"	"SNPRINTF(dest, <start> 100-1 <end> , data);
badSource <start> data <end> );"	0
4ff7827a-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__short_fscanf_postinc_51b_badSink(short data) { { data++; short result = data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"short <start> result = data <end> ;
<start> data <end> ++;"	"void CWE190_Integer_Overflow__short_fscanf_postinc_51b_badSink(short <start> data <end> );
<start> data <end> ++;"	"void CWE190_Integer_Overflow__short_fscanf_postinc_51b_badSink(short <start> data <end> );
short <start> result = data <end> ;"	"<start> printIntLine(result) <end> ;
void CWE190_Integer_Overflow__short_fscanf_postinc_51b_badSink(short <start> data <end> );"	1
ba102b86-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define EXECL _execl #else #define EXECL execl #endif void CWE78_OS_Command_Injection__char_connect_socket_execl_16_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; while(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; } EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECL ?	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"<start> data = dataBuffer <end> ;
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (100 - dataLen - 1), 0);
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"size_t dataLen = <start> strlen(data) <end> ;
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	0
5133a741-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_preinc_18_bad() { int data; data = 0; goto source; source: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } goto sink; sink: { ++data; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
+ <start> data <end> ;"	"+ <start> data <end> ;
<start> data = atoi(inputBuffer) <end> ;"	"+ <start> data <end> ;
recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);"	"<start> printIntLine(result) <end> ;
+ <start> data <end> ;"	0
92bb8a17-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING ""hello"" void CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_02_bad() { size_t data; data = 0; if(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = strtoul(inputBuffer, NULL, 0); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(1) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); } else { printLine(""Input is less than the length of the source string""); } } } }"	where is the vulnerable dataflow from data to malloc ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
myString = (char *)malloc <start> data*sizeof(char) <end> );"	"data = <start> strtoul(inputBuffer, NULL, 0) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"if  <start> data > strlen(HELLO_STRING) <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> strcpy(myString, HELLO_STRING) <end> ;"	0
cbf2379f-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_console_fopen_02 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(1) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
dataLen = <start> strlen(data) <end> ;"	"<start> data = dataBuffer <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"if (dataLen > 0 && <start> data[dataLen-1] == '\n' <end> );
pFile = FOPEN <start> data <end> , ""wb+"");"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
pFile = FOPEN <start> data <end> , ""wb+"");"	3
630ae821-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__short_rand_square_72 { void badSink(vector<short> dataVector) { short data = dataVector[2]; { short result = data * data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
short result = <start> data <end>  * data;"	"short result = <start> data <end>  * data;
void badSink(vector<short> <start> dataVector <end> );"	"short result = <start> data <end>  * data;
short <start> data = dataVector[2] <end> ;"	"void badSink(vector<short> <start> dataVector <end> );
short result = <start> data <end>  * data;"	3
cac216cd-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_connect_socket_open_03 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(5==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"<start> data = dataBuffer <end> ;
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
char <start> dataBuffer[FILENAME_MAX] = """" <end> ;"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	3
bda4e41e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define EXECL _execl #else #define EXECL execl #endif void CWE78_OS_Command_Injection__char_listen_socket_execl_16_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; while(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; } EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECL ?	"replace = <start> strchr(data, '\r') <end> ;
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
if  <start> acceptSocket == SOCKET_ERROR <end> );"	"if  <start> acceptSocket == SOCKET_ERROR <end> );
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	3
ba102b9d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define EXECLP _execlp #else #define EXECLP execlp #endif void CWE78_OS_Command_Injection__char_connect_socket_execlp_11_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(globalReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECLP ?	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"<start> data = dataBuffer <end> ;
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
size_t <start> dataLen = strlen(data) <end> ;"	"<start> EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL) <end> ;
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	0
c39a6599-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif namespace CWE23_Relative_Path_Traversal__char_environment_ifstream_34 { typedef union { char * unionFirst; char * unionSecond; } unionType; void bad() { char * data; unionType myUnion; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } } }"	where is the vulnerable dataflow from data to open ?	"inputFile.open((char * <start> data <end> );
<start> data = dataBuffer <end> ;"	"inputFile.open((char * <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
size_t <start> dataLen = strlen(data) <end> ;"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
inputFile.open((char * <start> data <end> );"	3
584fa887-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) int CWE191_Integer_Underflow__int_listen_socket_sub_61b_badSource(int data); void CWE191_Integer_Underflow__int_listen_socket_sub_61_bad() { int data; data = 0; data = CWE191_Integer_Underflow__int_listen_socket_sub_61b_badSource(data); { int result = data - 1; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"int <start> result = data - 1 <end> ;
data = <start> CWE191_Integer_Underflow__int_listen_socket_sub_61b_badSource <end> (data);"	"<start> data = CWE191_Integer_Underflow__int_listen_socket_sub_61b_badSource(data) <end> ;
int result = <start> data <end>  - 1;"	"data = <start> CWE191_Integer_Underflow__int_listen_socket_sub_61b_badSource <end> (data);
int result = <start> data <end>  - 1;"	"int result = <start> data <end>  - 1;
data = <start> CWE191_Integer_Underflow__int_listen_socket_sub_61b_badSource <end> (data);"	2
8b91e4ab-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(count) + 2) #ifdef _WIN32 #define SLEEP Sleep #else #define SLEEP usleep #endif void CWE400_Resource_Exhaustion__connect_socket_sleep_11_bad() { int count; count = -1; if(globalReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; count = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalReturnsTrue()) { SLEEP(count); printLine(""Sleep time possibly too long""); } }"	where is the vulnerable dataflow from count to SLEEP ?	"SLEEP <start> count <end> );
count = <start> atoi(inputBuffer) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
count = <start> atoi(inputBuffer) <end> ;"	"SLEEP <start> count <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
SLEEP <start> count <end> );"	3
584fa893-6c15-11ed-81d4-94e6f77dd552	"void CWE191_Integer_Underflow__short_fscanf_multiply_02_bad() { short data; data = 0; if(1) { fscanf (stdin, ""%hd"", &data); } if(1) { if(data < 0) { short result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"fscanf (stdin, ""%hd"", <start> &data <end> );
short result = <start> data * 2 <end> ;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
short result = <start> data <end>  * 2;"	"<start> printIntLine(result) <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );"	"fscanf (stdin, ""%hd"", <start> &data <end> );
short <start> result = data * 2 <end> ;"	1
5af03e02-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink(int data) { { data--; int result = data; printIntLine(result); } } void CWE191_Integer_Underflow__int_connect_socket_postdec_41_bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badSink(data); }"	where is the vulnerable dataflow from data ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSink <start> data <end> );
static void badSink(int <start> data <end> );
<start> printIntLine(result) <end> ;"	"<start> data <end> --;
badSink <start> data <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
static void badSink(int <start> data <end> );"	"<start> badSink(data) <end> ;
static void badSink(int <start> data <end> );
badSink <start> data <end> );
<start> data <end> --;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSink <start> data <end> );
static void badSink(int <start> data <end> );
<start> data <end> --;"	3
b08640dc-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE197_Numeric_Truncation_Error__int_fgets_to_short_11_bad() { int data; data = -1; if(globalReturnsTrue()) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } { short shortData = (short)data; printShortLine(shortData); } }"	where is the vulnerable dataflow from shortData to printShortLine ?	"printShortLine <start> shortData <end> );
short <start> shortData = (short)data <end> ;"	"short <start> shortData = (short)data <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printShortLine <start> shortData <end> );"	"short shortData = <start> (short)data <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	2
b68484ee-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(count) + 2) namespace CWE400_Resource_Exhaustion__connect_socket_for_loop_82 { void bad() { int count; count = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; count = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE400_Resource_Exhaustion__connect_socket_for_loop_82_base* baseObject = new CWE400_Resource_Exhaustion__connect_socket_for_loop_82_bad; baseObject->action(count); delete baseObject; }"	where is the vulnerable dataflow from count to action ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
baseObject->action <start> count <end> );"	"baseObject->action <start> count <end> );
count = <start> atoi(inputBuffer) <end> ;"	"baseObject->action <start> count <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"baseObject->action <start> count <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	0
b2ea8dae-6c15-11ed-81d4-94e6f77dd552	namespace CWE197_Numeric_Truncation_Error__short_connect_socket_72 { void badSink(vector<short> dataVector) { short data = dataVector[2]; { char charData = (char)data; printHexCharLine(charData); } }	where is the vulnerable dataflow from charData to printHexCharLine ?	"void badSink(vector<short> <start> dataVector <end> );
<start> printHexCharLine(charData) <end> ;"	"void badSink(vector<short> <start> dataVector <end> );
printHexCharLine <start> charData <end> );"	"<start> printHexCharLine(charData) <end> ;
printHexCharLine <start> charData <end> );"	"printHexCharLine <start> charData <end> );
void badSink(vector<short> <start> dataVector <end> );"	1
6b862458-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int badStatic = 0; static void badSink(int data) { if(badStatic) { { int i; int * buffer = (int *)malloc(10 * sizeof(int)); if (buffer == NULL) {exit(-1);} for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } free(buffer); } } } void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_21_bad() { int data; data = -1; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } badStatic = 1; badSink(data); }"	where is the vulnerable dataflow from buffer to free ?	"if  <start> buffer == NULL <end> ) {exit(-1);};
badSink <start> data <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
free <start> buffer <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
badSink <start> data <end> );
static void badSink(int <start> data <end> );
free <start> buffer <end> );"	"<start> data = atoi(inputBuffer) <end> ;
free <start> buffer <end> );
static void badSink(int <start> data <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"static void badSink(int <start> data <end> );
badSink <start> data <end> );
free <start> buffer <end> );
<start> badSink(data) <end> ;"	1
78800fcc-6c15-11ed-81d4-94e6f77dd552	"namespace CWE194_Unexpected_Sign_Extension__listen_socket_memmove_73 { void badSink(list<short> dataList) { short data = dataList.back(); { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"void badSink(list<short> <start> dataList <end> );
printLine <start> dest <end> );"	"void badSink(list<short> <start> dataList <end> );
if  <start> data < 100 <end> );"	"printLine <start> dest <end> );
if  <start> data < 100 <end> );"	"char <start> dest[100] = """" <end> ;
printLine <start> dest <end> );"	0
951c5e5c-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #define HELLO_STRING ""hello"" namespace CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_73 { void badSink(list<size_t> dataList) { size_t data = dataList.back(); { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); } else { printLine(""Input is less than the length of the source string""); } } }"	where is the vulnerable dataflow from data to malloc ?	"if  <start> data > strlen(HELLO_STRING) <end> );
void badSink(list<size_t> <start> dataList <end> );"	"void badSink(list<size_t> <start> dataList <end> );
myString = (char *)malloc <start> data*sizeof(char) <end> );"	"void badSink(list<size_t> <start> dataList <end> );
myString = <start> (char *)malloc(data*sizeof(char)) <end> ;"	"if  <start> data > strlen(HELLO_STRING) <end> );
myString = (char *)malloc <start> data*sizeof(char) <end> );"	1
820a46c4-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_file_fopen_42 { static char * badSource(char * data) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } return data; } void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; data = badSource(data); { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"data = <start> badSource <end> (data);
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
<start> data = dataBuffer <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"data = <start> badSource <end> (data);
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
pFile = FOPEN <start> data <end> , ""wb+"");"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
pFile = FOPEN <start> data <end> , ""wb+"");"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
pFile = FOPEN <start> data <end> , ""wb+"");"	2
78800fa1-6c15-11ed-81d4-94e6f77dd552	"namespace CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_74 { void badSink(map<int, short> dataMap) { short data = dataMap[2]; { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"void badSink(map<int, short> <start> dataMap <end> );
printLine <start> dest <end> );"	"void badSink(map<int, short> <start> dataMap <end> );
<start> memcpy(dest, source, data) <end> ;"	"printLine <start> dest <end> );
void badSink(map<int, short> <start> dataMap <end> );"	"<start> memcpy(dest, source, data) <end> ;
printLine <start> dest <end> );"	0
79b27542-6c15-11ed-81d4-94e6f77dd552	namespace CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_74 { void badSink(map<int, int> dataMap) { int data = dataMap[2]; if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }	where is the vulnerable dataflow from data to malloc ?	"void badSink(map<int, int> <start> dataMap <end> );
char * dataBuffer = (char *)malloc <start> data <end> );"	"void badSink(map<int, int> <start> dataMap <end> );
memset(dataBuffer, 'A', <start> data-1 <end> );"	"if  <start> dataBuffer == NULL <end> ) {exit(-1);};
char * dataBuffer = (char *)malloc <start> data <end> );"	"char <start> * dataBuffer = (char *)malloc(data) <end> ;
char * dataBuffer = (char *)malloc <start> data <end> );"	0
85b15ee8-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE369_Divide_by_Zero__int_fgets_divide_03_bad() { int data; data = -1; if(5==5) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(5==5) { printIntLine(100 / data); } }"	where is the vulnerable dataflow from data to printIntLine ?	"printIntLine <start> 100 / data <end> );
<start> data = atoi(inputBuffer) <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
if  <start> fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) <end>  != NULL);"	"printIntLine <start> 100 / data <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> 100 / data <end> );"	3
c5fc236f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } namespace CWE23_Relative_Path_Traversal__char_file_open_08 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(staticReturnsTrue()) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
size_t dataLen = <start> strlen(data) <end> ;"	"size_t dataLen = <start> strlen(data) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"char <start> dataBuffer[FILENAME_MAX] = BASEPATH <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	2
7e74f360-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) typedef struct _CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_67_structType { int structFirst; } CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_67_structType; void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_67b_badSink(CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_67_structType myStruct) { int data = myStruct.structFirst; { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> printLine(dest) <end> ;
int data = <start> myStruct <end> .structFirst;
void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_67b_badSink(CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_67_structType <start> myStruct <end> );"	"if  <start> data < 100 <end> );
printLine <start> dest <end> );
void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_67b_badSink(CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_67_structType <start> myStruct <end> );"	"int data = <start> myStruct <end> .structFirst;
void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_67b_badSink(CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_67_structType <start> myStruct <end> );
if  <start> data < 100 <end> );"	"void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_67b_badSink(CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_67_structType <start> myStruct <end> );
int data = <start> myStruct <end> .structFirst;
printLine <start> dest <end> );"	3
525b647d-6c15-11ed-81d4-94e6f77dd552	"static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } void CWE190_Integer_Overflow__short_fscanf_preinc_08_bad() { short data; data = 0; if(staticReturnsTrue()) { fscanf (stdin, ""%hd"", &data); } if(staticReturnsTrue()) { { ++data; short result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"fscanf (stdin, ""%hd"", <start> &data <end> );
<start> printIntLine(result) <end> ;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
short <start> result = data <end> ;"	"+ <start> data <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );"	"fscanf (stdin, ""%hd"", <start> &data <end> );
+ <start> data <end> ;"	3
cd228137-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif static const int STATIC_CONST_FIVE = 5; namespace CWE36_Absolute_Path_Traversal__char_console_ofstream_06 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(STATIC_CONST_FIVE==5) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
size_t dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
outputFile.open((char * <start> data <end> );"	"outputFile.open((char * <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	2
8b91e4a0-6c15-11ed-81d4-94e6f77dd552	"void CWE390_Error_Without_Action__fgets_char_18_bad() { goto sink; sink: { char dataBuffer[100] = """"; char * data = dataBuffer; printLine(""Please enter a string: ""); if (fgets(data, 100, stdin) == NULL) { } printLine(data); } }"	where is the vulnerable dataflow from data to printLine ?	"if (fgets <start> data <end> , 100, stdin) == NULL);
if  <start> fgets(data, 100, stdin) <end>  == NULL);"	"if (fgets <start> data <end> , 100, stdin) == NULL);
printLine <start> data <end> );"	"printLine <start> data <end> );
if  <start> fgets(data, 100, stdin) <end>  == NULL);"	"printLine <start> data <end> );
if (fgets <start> data <end> , 100, stdin) == NULL);"	1
9fe7ad3a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 namespace CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_82 { void bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_82_base* baseObject = new CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_82_bad; baseObject->action(data); delete baseObject; }"	where is the vulnerable dataflow from data to action ?	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
baseObject->action <start> data <end> );"	"baseObject->action <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
size_t dataLen = <start> strlen(data) <end> ;"	0
86cea134-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE369_Divide_by_Zero__int_fgets_modulo_11_bad() { int data; data = -1; if(globalReturnsTrue()) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(globalReturnsTrue()) { printIntLine(100 % data); } }"	where is the vulnerable dataflow from data to printIntLine ?	"if  <start> fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) <end>  != NULL);
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"printIntLine <start> 100 % data <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> 100 % data <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> data = -1 <end> ;"	2
73bc815b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" void CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_63b_badSink(short * dataPtr) { short data = *dataPtr; { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"if  <start> data < 100 <end> );
printLine <start> dest <end> );"	"printLine <start> dest <end> );
<start> memcpy(dest, source, data) <end> ;"	"void CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_63b_badSink(short * <start> dataPtr <end> );
printLine <start> dest <end> );"	"void CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_63b_badSink(short * <start> dataPtr <end> );
if  <start> data < 100 <end> );"	2
6a52bee6-6c15-11ed-81d4-94e6f77dd552	static int badStatic = 0; static void badSink(unsigned int data) { if(badStatic) { { unsigned int result = data - 1; printUnsignedLine(result); } } } void CWE191_Integer_Underflow__unsigned_int_rand_sub_21_bad() { unsigned int data; data = 0; data = (unsigned int)RAND32(); badStatic = 1; badSink(data); }	where is the vulnerable dataflow from data ?	"<start> data = (unsigned int)RAND32() <end> ;
static void badSink(unsigned int <start> data <end> );
unsigned int result = <start> data <end>  - 1;
badSink <start> data <end> );"	"static void badSink(unsigned int <start> data <end> );
badSink <start> data <end> );
data = (unsigned int <start> RAND32() <end> ;"	"data = (unsigned int <start> RAND32() <end> ;
badSink <start> data <end> );
static void badSink(unsigned int <start> data <end> );
unsigned int result = <start> data <end>  - 1;"	"static void badSink(unsigned int <start> data <end> );
badSink <start> data <end> );"	2
74ee23c1-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" typedef struct _CWE194_Unexpected_Sign_Extension__connect_socket_memmove_67_structType { short structFirst; } CWE194_Unexpected_Sign_Extension__connect_socket_memmove_67_structType; void CWE194_Unexpected_Sign_Extension__connect_socket_memmove_67b_badSink(CWE194_Unexpected_Sign_Extension__connect_socket_memmove_67_structType myStruct) { short data = myStruct.structFirst; { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> memmove(dest, source, data) <end> ;
short data = <start> myStruct <end> .structFirst;
void CWE194_Unexpected_Sign_Extension__connect_socket_memmove_67b_badSink(CWE194_Unexpected_Sign_Extension__connect_socket_memmove_67_structType <start> myStruct <end> );"	"short data = <start> myStruct <end> .structFirst;
<start> memmove(dest, source, data) <end> ;
printLine <start> dest <end> );"	"void CWE194_Unexpected_Sign_Extension__connect_socket_memmove_67b_badSink(CWE194_Unexpected_Sign_Extension__connect_socket_memmove_67_structType <start> myStruct <end> );
printLine <start> dest <end> );
<start> memmove(dest, source, data) <end> ;"	"void CWE194_Unexpected_Sign_Extension__connect_socket_memmove_67b_badSink(CWE194_Unexpected_Sign_Extension__connect_socket_memmove_67_structType <start> myStruct <end> );
short data = <start> myStruct <end> .structFirst;
printLine <start> dest <end> );"	3
acf67e5c-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_fgets_predec_66b_badSink(int dataArray[]) { int data = dataArray[2]; { --data; int result = data; printIntLine(result); } }	where is the vulnerable dataflow from result to printIntLine ?	"void CWE191_Integer_Underflow__int_fgets_predec_66b_badSink(int <start> dataArray <end> []);
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
void CWE191_Integer_Underflow__int_fgets_predec_66b_badSink(int <start> dataArray <end> []);"	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;"	"<start> --data <end> ;
void CWE191_Integer_Underflow__int_fgets_predec_66b_badSink(int <start> dataArray <end> []);"	0
6ef7681f-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif static void badVaSink(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_console_vfprintf_01_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } badVaSink(data, data); }"	where is the vulnerable dataflow from data to vfprintf ?	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
size_t dataLen = <start> strlen(data) <end> ;
vfprintf(stdout, <start> data <end> , args);
static void badVaSink(char * <start> data <end> , ...);"	"dataLen = <start> strlen(data) <end> ;
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);"	"static void badVaSink(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
dataLen = <start> strlen(data) <end> ;"	0
67d010ad-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__short_rand_postinc_10_bad() { short data; data = 0; if(globalTrue) { data = (short)RAND32(); } if(globalTrue) { { data++; short result = data; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"data = (short <start> RAND32() <end> ;
<start> data++ <end> ;"	"<start> data <end> ++;
<start> printIntLine(result) <end> ;"	"<start> data <end> ++;
short <start> result = data <end> ;"	"data = (short <start> RAND32() <end> ;
<start> data <end> ++;"	3
bed4a8d9-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_connect_socket_fopen_73 { void badSink(list<char *> dataList) { char * data = dataList.back(); { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"void badSink(list<char *> <start> dataList <end> );
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
void badSink(list<char *> <start> dataList <end> );"	"pFile = FOPEN <start> data <end> , ""wb+"");
void badSink(list<char *> <start> dataList <end> );"	"pFile = FOPEN <start> data <end> , ""wb+"");
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	0
598370c3-6c15-11ed-81d4-94e6f77dd552	"void CWE191_Integer_Underflow__short_fscanf_sub_15_bad() { short data; data = 0; switch(6) { case 6: fscanf (stdin, ""%hd"", &data); break; default: printLine(""Benign, fixed string""); break; } switch(7) { case 7: { short result = data - 1; printIntLine(result); } break; default: printLine(""Benign, fixed string""); break; } }"	where is the vulnerable dataflow from data ?	"short <start> result = data - 1 <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );"	"fscanf (stdin, ""%hd"", <start> &data <end> );
short result = <start> data <end>  - 1;"	"<start> printIntLine(result) <end> ;
short result = <start> data <end>  - 1;"	"short result = <start> data - 1 <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );"	1
5133a754-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_preinc_01_bad() { int data; data = 0; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } { ++data; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
+ <start> data <end> ;"	"<start> ++data <end> ;
+ <start> data <end> ;"	"<start> printIntLine(result) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"+ <start> data <end> ;
<start> printIntLine(result) <end> ;"	0
b8e2bd90-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif namespace CWE427_Uncontrolled_Search_Path_Element__char_file_81 { void bad() { char * data; char dataBuffer[250] = ""PATH=""; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (250-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(250-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } const CWE427_Uncontrolled_Search_Path_Element__char_file_81_base& baseObject = CWE427_Uncontrolled_Search_Path_Element__char_file_81_bad(); baseObject.action(data); }"	where is the vulnerable dataflow from data to action ?	"if (fgets <start> data+dataLen <end> , (int)(250-dataLen), pFile) == NULL);
size_t dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(250-dataLen), pFile) == NULL);
baseObject.action <start> data <end> );"	"baseObject.action <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(250-dataLen), pFile) == NULL);"	"<start> data = dataBuffer <end> ;
baseObject.action <start> data <end> );"	1
6c938c12-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif void CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_66b_badSink(char * dataArray[]) { char * data = dataArray[2]; { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	"void CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_66b_badSink(char * <start> dataArray <end> []);
printLine <start> dest <end> );"	"void CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_66b_badSink(char * <start> dataArray <end> []);
<start> printLine(dest) <end> ;"	"printLine <start> dest <end> );
void CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_66b_badSink(char * <start> dataArray <end> []);"	1
656cd407-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__int_rand_square_03_bad() { int data; data = 0; if(5==5) { data = RAND32(); } if(5==5) { { int result = data * data; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"data = <start> RAND32() <end> ;
<start> printIntLine(result) <end> ;"	"data = <start> RAND32() <end> ;
int result = <start> data <end>  * data;"	"data = <start> RAND32() <end> ;
int <start> result = data * data <end> ;"	"int result = <start> data <end>  * data;
data = <start> RAND32() <end> ;"	1
a6fd8270-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) typedef union { int unionFirst; int unionSecond; } CWE190_Integer_Overflow__int_fgets_preinc_34_unionType; void CWE190_Integer_Overflow__int_fgets_preinc_34_bad() { int data; CWE190_Integer_Overflow__int_fgets_preinc_34_unionType myUnion; data = 0; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } myUnion.unionFirst = data; { int data = myUnion.unionSecond; { ++data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> printIntLine(result) <end> ;"	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	2
715a3bdc-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif void CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_02_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; if(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(1) { { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } } }"	where is the vulnerable dataflow from dest to printLine ?	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
printLine <start> dest <end> );"	"printLine <start> dest <end> );
size_t dataLen = <start> strlen(data) <end> ;"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
<start> SNPRINTF(dest, 100-1, data) <end> ;"	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	0
48d25db7-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_add_53d_badSink(int data) { { int result = data + 1; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"void CWE190_Integer_Overflow__int_listen_socket_add_53d_badSink(int <start> data <end> );
int result = <start> data <end>  + 1;"	"void CWE190_Integer_Overflow__int_listen_socket_add_53d_badSink(int <start> data <end> );
<start> printIntLine(result) <end> ;"	"int <start> result = data + 1 <end> ;
void CWE190_Integer_Overflow__int_listen_socket_add_53d_badSink(int <start> data <end> );"	"int result = <start> data <end>  + 1;
void CWE190_Integer_Overflow__int_listen_socket_add_53d_badSink(int <start> data <end> );"	0
92bb89f0-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #define SEARCH_CHAR 'S' void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_file_66b_badSink(char * dataArray[]) { char * data = dataArray[2]; for (; *data != '\0'; data++) { if (*data == SEARCH_CHAR) { printLine(""We have a match!""); break; } } free(data); }"	where is the vulnerable dataflow from data to free ?	"free <start> data <end> );
char <start> * data = dataArray[2] <end> ;"	"void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_file_66b_badSink(char * <start> dataArray <end> []);
free <start> data <end> );"	"for (; *data != '\0'; <start> data++ <end> );
free <start> data <end> );"	"<start> free(data) <end> ;
free <start> data <end> );"	1
ce547d5b-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif static const int STATIC_CONST_FIVE = 5; namespace CWE36_Absolute_Path_Traversal__char_environment_ofstream_06 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(STATIC_CONST_FIVE==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"size_t dataLen = <start> strlen(data) <end> ;
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"outputFile.open((char * <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	"outputFile.open((char * <start> data <end> );
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
outputFile.open((char * <start> data <end> );"	3
656cd416-6c15-11ed-81d4-94e6f77dd552	static int badStatic = 0; static void badSink(int data) { if(badStatic) { { int result = data * data; printIntLine(result); } } } void CWE190_Integer_Overflow__int_rand_square_21_bad() { int data; data = 0; data = RAND32(); badStatic = 1; badSink(data); }	where is the vulnerable dataflow from data ?	"static void badSink(int <start> data <end> );
int <start> result = data * data <end> ;
data = <start> RAND32() <end> ;
badSink <start> data <end> );"	"badSink <start> data <end> );
static void badSink(int <start> data <end> );
int result = <start> data <end>  * data;"	"int result = <start> data <end>  * data;
static void badSink(int <start> data <end> );
badSink <start> data <end> );
data = <start> RAND32() <end> ;"	"data = <start> RAND32() <end> ;
badSink <start> data <end> );
static void badSink(int <start> data <end> );
int result = <start> data <end>  * data;"	3
9b124d9d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } void CWE124_Buffer_Underwrite__CWE839_listen_socket_08_bad() { int data; data = -1; if(staticReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticReturnsTrue()) { { int i; int buffer[10] = { 0 }; if (data < 10) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } } } }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
data = <start> atoi(inputBuffer) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[i] <end> );"	"<start> recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> buffer[i] <end> );"	"<start> printIntLine(buffer[i]) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	1
9fe7ad2e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif namespace CWE134_Uncontrolled_Format_String__char_file_snprintf_81 { void bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } const CWE134_Uncontrolled_Format_String__char_file_snprintf_81_base& baseObject = CWE134_Uncontrolled_Format_String__char_file_snprintf_81_bad(); baseObject.action(data); }"	where is the vulnerable dataflow from data to action ?	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
baseObject.action <start> data <end> );"	"baseObject.action <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	"baseObject.action <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
size_t dataLen = <start> strlen(data) <end> ;"	0
7fa68e46-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_connect_socket_open_02 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"recvResult = recv(connectSocket, (char *)(data + dataLen), <start> sizeof(char) * (FILENAME_MAX - dataLen - 1) <end> , 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"<start> data = dataBuffer <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	2
b54bcf17-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE 20 void CWE369_Divide_by_Zero__float_fgets_65b_badSink(float data) { { int result = (int)(100.0 / data); printIntLine(result); } }	where is the vulnerable dataflow from result to printIntLine ?	"void CWE369_Divide_by_Zero__float_fgets_65b_badSink(float <start> data <end> );
printIntLine <start> result <end> );"	"<start> printIntLine(result) <end> ;
void CWE369_Divide_by_Zero__float_fgets_65b_badSink(float <start> data <end> );"	"void CWE369_Divide_by_Zero__float_fgets_65b_badSink(float <start> data <end> );
int <start> result = (int)(100.0 / data) <end> ;"	"printIntLine <start> result <end> );
void CWE369_Divide_by_Zero__float_fgets_65b_badSink(float <start> data <end> );"	0
61da66ec-6c15-11ed-81d4-94e6f77dd552	static void badSink(char data) { { char result = data * data; printHexCharLine(result); } } void CWE190_Integer_Overflow__char_rand_square_41_bad() { char data; data = ' '; data = (char)RAND32(); badSink(data); }	where is the vulnerable dataflow from data ?	"<start> printHexCharLine(result) <end> ;
badSink <start> data <end> );
static void badSink(char <start> data <end> );
data = (char <start> RAND32() <end> ;"	"static void badSink(char <start> data <end> );
data = (char <start> RAND32() <end> ;"	"data = (char <start> RAND32() <end> ;
badSink <start> data <end> );
static void badSink(char <start> data <end> );
char result = <start> data <end>  * data;"	"static void badSink(char <start> data <end> );
data = (char <start> RAND32() <end> ;
badSink <start> data <end> );
char <start> result = data * data <end> ;"	2
584fa86e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_FIVE = 5; void CWE191_Integer_Underflow__int_listen_socket_sub_06_bad() { int data; data = 0; if(STATIC_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(STATIC_CONST_FIVE==5) { { int result = data - 1; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
int result = <start> data <end>  - 1;"	"int result = <start> data <end>  - 1;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  - 1;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int <start> result = data - 1 <end> ;"	2
cf87508d-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_environment_open_22 { int badGlobal = 0; char * badSource(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; badGlobal = 1; data = badSource(data); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } ; }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
data = <start> badSource <end> (data);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
<start> data = dataBuffer <end> ;"	"data = <start> badSource <end> (data);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"<start> data = dataBuffer <end> ;
data = <start> badSource <end> (data);"	2
ba102b76-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_82 { void bad() { size_t data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = strtoul(inputBuffer, NULL, 0); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_82_base* baseObject = new CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_82_bad; baseObject->action(data); delete baseObject; }"	where is the vulnerable dataflow from data to action ?	"baseObject->action <start> data <end> );
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
baseObject->action <start> data <end> );"	"baseObject->action <start> data <end> );
data = <start> strtoul(inputBuffer, NULL, 0) <end> ;"	"baseObject->action <start> data <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	1
5f76fc77-6c15-11ed-81d4-94e6f77dd552	extern int CWE191_Integer_Underflow__int_fscanf_predec_68_badData; extern int CWE191_Integer_Underflow__int_fscanf_predec_68_goodG2BData; extern int CWE191_Integer_Underflow__int_fscanf_predec_68_goodB2GData; void CWE191_Integer_Underflow__int_fscanf_predec_68b_badSink() { int data = CWE191_Integer_Underflow__int_fscanf_predec_68_badData; { --data; int result = data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"- <start> data <end> ;
int <start> data = CWE191_Integer_Underflow__int_fscanf_predec_68_badData <end> ;"	"- <start> data <end> ;
<start> --data <end> ;"	"- <start> data <end> ;
int data = <start> CWE191_Integer_Underflow__int_fscanf_predec_68_badData <end> ;"	"int data = <start> CWE191_Integer_Underflow__int_fscanf_predec_68_badData <end> ;
- <start> data <end> ;"	3
67d010dd-6c15-11ed-81d4-94e6f77dd552	typedef union { char unionFirst; char unionSecond; } CWE190_Integer_Overflow__char_rand_preinc_34_unionType; void CWE190_Integer_Overflow__char_rand_preinc_34_bad() { char data; CWE190_Integer_Overflow__char_rand_preinc_34_unionType myUnion; data = ' '; data = (char)RAND32(); myUnion.unionFirst = data; { char data = myUnion.unionSecond; { ++data; char result = data; printHexCharLine(result); } } }	where is the vulnerable dataflow from data ?	"data = (char <start> RAND32() <end> ;
<start> ++data <end> ;"	"<start> printHexCharLine(result) <end> ;
data = (char <start> RAND32() <end> ;"	"data = (char <start> RAND32() <end> ;
+ <start> data <end> ;"	"+ <start> data <end> ;
data = (char <start> RAND32() <end> ;"	2
5be3a9c1-6c15-11ed-81d4-94e6f77dd552	void CWE191_Integer_Underflow__int_fscanf_postdec_51b_badSink(int data) { { data--; int result = data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"void CWE191_Integer_Underflow__int_fscanf_postdec_51b_badSink(int <start> data <end> );
<start> data <end> --;"	"int <start> result = data <end> ;
<start> data <end> --;"	"void CWE191_Integer_Underflow__int_fscanf_postdec_51b_badSink(int <start> data <end> );
<start> printIntLine(result) <end> ;"	"<start> data <end> --;
void CWE191_Integer_Underflow__int_fscanf_postdec_51b_badSink(int <start> data <end> );"	0
453db020-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int CWE190_Integer_Overflow__int_connect_socket_multiply_45_badData; static int CWE190_Integer_Overflow__int_connect_socket_multiply_45_goodG2BData; static int CWE190_Integer_Overflow__int_connect_socket_multiply_45_goodB2GData; static void badSink() { int data = CWE190_Integer_Overflow__int_connect_socket_multiply_45_badData; if(data > 0) { int result = data * 2; printIntLine(result); } } void CWE190_Integer_Overflow__int_connect_socket_multiply_45_bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE190_Integer_Overflow__int_connect_socket_multiply_45_badData = data; badSink(); }"	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  * 2;
static int <start> CWE190_Integer_Overflow__int_connect_socket_multiply_45_badData <end> ;
<start> CWE190_Integer_Overflow__int_connect_socket_multiply_45_badData = data <end> ;
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
int data = <start> CWE190_Integer_Overflow__int_connect_socket_multiply_45_badData <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static int <start> CWE190_Integer_Overflow__int_connect_socket_multiply_45_badData <end> ;"	"int <start> result = data * 2 <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int data = <start> CWE190_Integer_Overflow__int_connect_socket_multiply_45_badData <end> ;
static int <start> CWE190_Integer_Overflow__int_connect_socket_multiply_45_badData <end> ;
<start> CWE190_Integer_Overflow__int_connect_socket_multiply_45_badData = data <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> CWE190_Integer_Overflow__int_connect_socket_multiply_45_badData = data <end> ;
static int <start> CWE190_Integer_Overflow__int_connect_socket_multiply_45_badData <end> ;
int data = <start> CWE190_Integer_Overflow__int_connect_socket_multiply_45_badData <end> ;
int result = <start> data <end>  * 2;"	3
7c127574-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_63b_badSink(int * dataPtr) { int data = *dataPtr; if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }	where is the vulnerable dataflow from data to malloc ?	"char * dataBuffer = (char *)malloc <start> data <end> );
<start> free(dataBuffer) <end> ;"	"void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_63b_badSink(int * <start> dataPtr <end> );
<start> memset(dataBuffer, 'A', data-1) <end> ;"	"void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_63b_badSink(int * <start> dataPtr <end> );
char * dataBuffer = (char *)malloc <start> data <end> );"	"void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_63b_badSink(int * <start> dataPtr <end> );
if  <start> data < 100 <end> );"	2
abc3752b-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int badSource(int data) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } return data; } void CWE191_Integer_Underflow__int_fgets_postdec_42_bad() { int data; data = 0; data = badSource(data); { data--; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
static int <start> badSource <end> (int data);
data = <start> badSource <end> (data);
printIntLine <start> result <end> );"	"int <start> result = data <end> ;
printIntLine <start> result <end> );
data = <start> badSource <end> (data);
static int <start> badSource <end> (int data);"	"printIntLine <start> result <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
data = <start> badSource <end> (data);
printIntLine <start> result <end> );"	0
8f278a75-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticFive = 5; void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_07_bad() { int data; data = -1; if(staticFive==5) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } { size_t i; int *intPointer; intPointer = (int*)malloc(data * sizeof(int)); if (intPointer == NULL) {exit(-1);} for (i = 0; i < (size_t)data; i++) { intPointer[i] = 0; } printIntLine(intPointer[0]); free(intPointer); } }"	where is the vulnerable dataflow from data to malloc ?	"intPointer = (int*)malloc <start> data * sizeof(int) <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"intPointer = (int*)malloc <start> data * sizeof(int) <end> );
<start> free(intPointer) <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	"<start> free(intPointer) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	2
a5ce1c47-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_postinc_64b_badSink(void * dataVoidPtr) { int * dataPtr = (int *)dataVoidPtr; int data = (*dataPtr); { data++; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"void CWE190_Integer_Overflow__int_connect_socket_postinc_64b_badSink(void * <start> dataVoidPtr <end> );
printIntLine <start> result <end> );"	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	"int <start> data = (*dataPtr) <end> ;
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
void CWE190_Integer_Overflow__int_connect_socket_postinc_64b_badSink(void * <start> dataVoidPtr <end> );"	0
525b647b-6c15-11ed-81d4-94e6f77dd552	"static const int STATIC_CONST_FIVE = 5; void CWE190_Integer_Overflow__short_fscanf_preinc_06_bad() { short data; data = 0; if(STATIC_CONST_FIVE==5) { fscanf (stdin, ""%hd"", &data); } if(STATIC_CONST_FIVE==5) { { ++data; short result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"fscanf (stdin, ""%hd"", <start> &data <end> );
<start> printIntLine(result) <end> ;"	"<start> data = 0 <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );"	"fscanf (stdin, ""%hd"", <start> &data <end> );
+ <start> data <end> ;"	"+ <start> data <end> ;
<start> printIntLine(result) <end> ;"	2
a23a3df3-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_add_11_bad() { int data; data = 0; if(globalReturnsTrue()) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(globalReturnsTrue()) { { int result = data + 1; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
<start> data = 0 <end> ;"	"printIntLine <start> result <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"data = <start> atoi(inputBuffer) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	0
bb49c57f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #define EXECL _execl #else #define EXECL execl #endif static int staticTrue = 1; static int staticFalse = 0; void CWE78_OS_Command_Injection__char_console_execl_05_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(staticTrue) { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECL ?	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
<start> EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
if  <start> 100-dataLen <end>  > 1);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
<start> data = dataBuffer <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	3
c39a657b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_environment_fopen_62 { void badSource(char * &data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; badSource(data); { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = FOPEN <start> data <end> , ""wb+"");
<start> badSource(data) <end> ;"	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
badSource <start> data <end> );"	"badSource <start> data <end> );
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
badSource <start> data <end> );"	2
acf67e1b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticFive = 5; void CWE191_Integer_Underflow__int_connect_socket_predec_07_bad() { int data; data = 0; if(staticFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticFive==5) { { --data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> result <end> );"	"int <start> result = data <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printIntLine(result) <end> ;"	2
7d44fcc6-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_45_badData; static int CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_45_goodG2BData; static void badSink() { int data = CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_45_badData; if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } } void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_45_bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_45_badData = data; badSink(); }"	where is the vulnerable dataflow from data to malloc ?	"memset(dataBuffer, 'A', <start> data-1 <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
char * dataBuffer = (char *)malloc <start> data <end> );
<start> CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_45_badData = data <end> ;
static int <start> CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_45_badData <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static int <start> CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_45_badData <end> ;
int data = <start> CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_45_badData <end> ;
<start> CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_45_badData = data <end> ;
<start> memset(dataBuffer, 'A', data-1) <end> ;"	"<start> CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_45_badData = data <end> ;
static int <start> CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_45_badData <end> ;
int data = <start> CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_45_badData <end> ;
<start> recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
char * dataBuffer = (char *)malloc <start> data <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_45_badData = data <end> ;
static int <start> CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_45_badData <end> ;
int data = <start> CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_45_badData <end> ;
char * dataBuffer = (char *)malloc <start> data <end> );"	3
acf67e19-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticTrue = 1; static int staticFalse = 0; void CWE191_Integer_Underflow__int_connect_socket_predec_05_bad() { int data; data = 0; if(staticTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticTrue) { { --data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"<start> printIntLine(result) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	2
964cdc0c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FULL_COMMAND ""dir "" #else #define FULL_COMMAND ""ls "" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define POPEN _popen #define PCLOSE _pclose #else #define POPEN popen #define PCLOSE pclose #endif void CWE78_OS_Command_Injection__char_listen_socket_popen_11_bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; if(globalReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { FILE *pipe; pipe = POPEN(data, ""w""); if (pipe != NULL) { PCLOSE(pipe); } } }"	where is the vulnerable dataflow from data to POPEN ?	"replace = <start> strchr(data, '\n') <end> ;
pipe = POPEN <start> data <end> , ""w"");"	"replace = <start> strchr(data, '\r') <end> ;
pipe = POPEN <start> data <end> , ""w"");"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
pipe = POPEN <start> data <end> , ""w"");"	"pipe = POPEN <start> data <end> , ""w"");
if  <start> acceptSocket == SOCKET_ERROR <end> );"	2
d31a2519-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_listen_socket_open_11 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(globalReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
size_t dataLen = <start> strlen(data) <end> ;"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
char <start> dataBuffer[FILENAME_MAX] = """" <end> ;"	0
6c938bdd-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_53d_badSink(int data) { { int i; int * buffer = (int *)malloc(10 * sizeof(int)); if (buffer == NULL) {exit(-1);} for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } free(buffer); } }"	where is the vulnerable dataflow from buffer to free ?	"void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_53d_badSink(int <start> data <end> );
int <start> * buffer = (int *)malloc(10 * sizeof(int)) <end> ;"	"free <start> buffer <end> );
void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_53d_badSink(int <start> data <end> );"	"void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_53d_badSink(int <start> data <end> );
<start> free(buffer) <end> ;"	"void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_53d_badSink(int <start> data <end> );
free <start> buffer <end> );"	3
c01af8be-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" namespace CWE23_Relative_Path_Traversal__char_connect_socket_ofstream_53 { void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badSink_b(data); }"	where is the vulnerable dataflow from data to badSink_b ?	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
badSink_b <start> data <end> );"	"badSink_b <start> data <end> );
replace = <start> strchr(data, '\r') <end> ;"	"badSink_b <start> data <end> );
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(connectSocket, (char *)(data + dataLen), <start> sizeof(char) * (FILENAME_MAX - dataLen - 1) <end> , 0);
badSink_b <start> data <end> );"	0
9fe7ad1c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" namespace CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_81 { void bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } const CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_81_base& baseObject = CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_81_bad(); baseObject.action(data); }"	where is the vulnerable dataflow from data to action ?	"baseObject.action <start> data <end> );
char <start> dataBuffer[100] = """" <end> ;"	"recvResult = <start> recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0) <end> ;
baseObject.action <start> data <end> );"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (100 - dataLen - 1), 0);
baseObject.action <start> data <end> );"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
baseObject.action <start> data <end> );"	3
78800fb5-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 8 void CWE194_Unexpected_Sign_Extension__listen_socket_memmove_18_bad() { short data; data = 0; goto source; source: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"printLine <start> dest <end> );
<start> data = 0 <end> ;"	"<start> data = 0 <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"printLine <start> dest <end> );
<start> memmove(dest, source, data) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	3
9187cc12-6c15-11ed-81d4-94e6f77dd552	"#define SEARCH_CHAR 'S' namespace CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_console_73 { void badSink(list<char *> dataList) { char * data = dataList.back(); for (; *data != '\0'; data++) { if (*data == SEARCH_CHAR) { printLine(""We have a match!""); break; } } free(data); }"	where is the vulnerable dataflow from data to free ?	"char <start> * data = dataList.back() <end> ;
void badSink(list<char *> <start> dataList <end> );"	"void badSink(list<char *> <start> dataList <end> );
free <start> data <end> );"	"free <start> data <end> );
void badSink(list<char *> <start> dataList <end> );"	"void badSink(list<char *> <start> dataList <end> );
<start> free(data) <end> ;"	1
cd228160-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_console_open_16 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; while(1) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } break; } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"if (dataLen > 0 && <start> data[dataLen-1] == '\n' <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN(data, O_RDWR|O_CREAT, <start> S_IREAD|S_IWRITE <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
dataLen = <start> strlen(data) <end> ;"	0
630ae802-6c15-11ed-81d4-94e6f77dd552	static int staticFive = 5; void CWE190_Integer_Overflow__short_rand_square_07_bad() { short data; data = 0; if(staticFive==5) { data = (short)RAND32(); } if(staticFive==5) { { short result = data * data; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
data = (short <start> RAND32() <end> ;"	"<start> printIntLine(result) <end> ;
short result = <start> data <end>  * data;"	"data = (short <start> RAND32() <end> ;
<start> data = (short)RAND32() <end> ;"	"data = (short <start> RAND32() <end> ;
short result = <start> data <end>  * data;"	3
6c938bdc-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_52c_badSink(int data) { { int i; int * buffer = (int *)malloc(10 * sizeof(int)); if (buffer == NULL) {exit(-1);} for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } free(buffer); } }"	where is the vulnerable dataflow from buffer to free ?	"void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_52c_badSink(int <start> data <end> );
<start> free(buffer) <end> ;"	"free <start> buffer <end> );
if  <start> buffer == NULL <end> ) {exit(-1);};"	"free <start> buffer <end> );
void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_52c_badSink(int <start> data <end> );"	"void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_52c_badSink(int <start> data <end> );
free <start> buffer <end> );"	3
61da670a-6c15-11ed-81d4-94e6f77dd552	"void CWE190_Integer_Overflow__short_rand_add_12_bad() { short data; data = 0; if(globalReturnsTrueOrFalse()) { data = (short)RAND32(); } else { data = 2; } if(globalReturnsTrueOrFalse()) { { short result = data + 1; printIntLine(result); } } else { if (data < SHRT_MAX) { short result = data + 1; printIntLine(result); } else { printLine(""data value is too large to perform arithmetic safely.""); } } }"	where is the vulnerable dataflow from data ?	"data = (short <start> RAND32() <end> ;
if  <start> data < SHRT_MAX <end> );"	"data = (short <start> RAND32() <end> ;
short result = <start> data <end>  + 1;"	"data = (short <start> RAND32() <end> ;
short <start> result = data + 1 <end> ;"	"data = (short <start> RAND32() <end> ;
short result = <start> data + 1 <end> ;"	1
8df42214-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define PATH_SZ 100 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define PATH_SZ PATH_MAX #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 void CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__bind_accept_listen_11_bad() { if(globalReturnsTrue()) { { char data[100] = """"; #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[recvResult] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif printLine(data); } } }"	where is the vulnerable dataflow from data to printLine ?	"size_t dataLen = <start> strlen(data) <end> ;
recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);"	"recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);
printLine <start> data <end> );"	"printLine <start> data <end> );
<start> printLine(data) <end> ;"	"printLine <start> data <end> );
replace = <start> strchr(data, '\n') <end> ;"	1
b1b80841-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) extern int CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_68_badData; extern int CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_68_goodG2BData; void CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_68b_badSink() { int data = CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_68_badData; { short shortData = (short)data; printShortLine(shortData); } }"	where is the vulnerable dataflow from shortData to printShortLine ?	"printShortLine <start> shortData <end> );
int data = <start> CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_68_badData <end> ;"	"int data = <start> CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_68_badData <end> ;
printShortLine <start> shortData <end> );"	"printShortLine <start> shortData <end> );
<start> printShortLine(shortData) <end> ;"	"short <start> shortData = (short)data <end> ;
int data = <start> CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_68_badData <end> ;"	1
d1e9da31-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } namespace CWE36_Absolute_Path_Traversal__char_listen_socket_fopen_08 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(staticReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = FOPEN <start> data <end> , ""wb+"");
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	"<start> recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0) <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
<start> data = dataBuffer <end> ;"	1
4b34b001-6c15-11ed-81d4-94e6f77dd552	"void CWE190_Integer_Overflow__short_fscanf_square_15_bad() { short data; data = 0; switch(6) { case 6: fscanf (stdin, ""%hd"", &data); break; default: printLine(""Benign, fixed string""); break; } switch(7) { case 7: { short result = data * data; printIntLine(result); } break; default: printLine(""Benign, fixed string""); break; } }"	where is the vulnerable dataflow from data ?	"fscanf (stdin, ""%hd"", <start> &data <end> );
short result = <start> data <end>  * data;"	"short result = <start> data <end>  * data;
<start> printIntLine(result) <end> ;"	"<start> printIntLine(result) <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );"	"short result = <start> data <end>  * data;
fscanf (stdin, ""%hd"", <start> &data <end> );"	0
70279beb-6c15-11ed-81d4-94e6f77dd552	#ifndef _WIN32 #endif extern char * CWE134_Uncontrolled_Format_String__char_console_vprintf_68_badData; extern char * CWE134_Uncontrolled_Format_String__char_console_vprintf_68_goodG2BData; extern char * CWE134_Uncontrolled_Format_String__char_console_vprintf_68_goodB2GData; static void badVaSink(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_console_vprintf_68b_badSink() { char * data = CWE134_Uncontrolled_Format_String__char_console_vprintf_68_badData; badVaSink(data, data); }	where is the vulnerable dataflow from data to vprintf ?	"char * data = <start> CWE134_Uncontrolled_Format_String__char_console_vprintf_68_badData <end> ;
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
vprintf <start> data <end> , args);"	"badVaSink <start> data <end> , data);
char * data = <start> CWE134_Uncontrolled_Format_String__char_console_vprintf_68_badData <end> ;"	"char * data = <start> CWE134_Uncontrolled_Format_String__char_console_vprintf_68_badData <end> ;
badVaSink <start> data <end> , data);
<start> vprintf(data, args) <end> ;
static void badVaSink(char * <start> data <end> , ...);"	"char * data = <start> CWE134_Uncontrolled_Format_String__char_console_vprintf_68_badData <end> ;
badVaSink <start> data <end> , data);
vprintf <start> data <end> , args);
static void badVaSink(char * <start> data <end> , ...);"	0
656cd405-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__int_rand_square_01_bad() { int data; data = 0; data = RAND32(); { int result = data * data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  * data;
data = <start> RAND32() <end> ;"	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  * data;"	"data = <start> RAND32() <end> ;
int result = <start> data <end>  * data;"	"data = <start> RAND32() <end> ;
<start> printIntLine(result) <end> ;"	2
951c5e83-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FULL_COMMAND ""dir "" #else #define FULL_COMMAND ""ls "" #endif #ifdef _WIN32 #define POPEN _popen #define PCLOSE _pclose #else #define POPEN popen #define PCLOSE pclose #endif void CWE78_OS_Command_Injection__char_console_popen_01_bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } { FILE *pipe; pipe = POPEN(data, ""w""); if (pipe != NULL) { PCLOSE(pipe); } } }"	where is the vulnerable dataflow from data to POPEN ?	"if (dataLen > 0 && <start> data[dataLen-1] == '\n' <end> );
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
pipe = POPEN <start> data <end> , ""w"");"	"pipe = POPEN <start> data <end> , ""w"");
size_t dataLen = <start> strlen(data) <end> ;"	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	1
c5fc2340-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif namespace CWE23_Relative_Path_Traversal__char_file_ifstream_42 { static char * badSource(char * data) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } return data; } void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; data = badSource(data); { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"size_t dataLen = <start> strlen(data) <end> ;
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
inputFile.open((char * <start> data <end> );"	"inputFile.open((char * <start> data <end> );
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
inputFile.open((char * <start> data <end> );"	"inputFile.open((char * <start> data <end> );
data = <start> badSource <end> (data);
static char * <start> badSource <end> (char * data);"	2
c26a7e33-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif namespace CWE23_Relative_Path_Traversal__char_console_ofstream_53 { void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } badSink_b(data); }"	where is the vulnerable dataflow from data to badSink_b ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
<start> data = dataBuffer <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
badSink_b <start> data <end> );"	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	2
c99197b6-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define STAT _stat #define OPEN _open #define WRITE _write #define O_RDWR _O_RDWR #define CLOSE _close #else #define STAT stat #define OPEN open #define WRITE write #define CLOSE close #endif #define BAD_SINK_STRING ""Bad Sink..."" #define GOOD_SINK_STRING ""Good Sink..."" #ifdef _WIN32 #define ACCESS _access #define W_OK 02 #else #define ACCESS access #endif static int staticTrue = 1; static int staticFalse = 0; void CWE367_TOC_TOU__access_05_bad() { if(staticTrue) { { char filename[100] = """"; int fileDesc = -1; if (fgets(filename, 100, stdin) == NULL) { printLine(""fgets() failed""); filename[0] = '\0'; } if (strlen(filename) > 0) { filename[strlen(filename)-1] = '\0'; } if (ACCESS(filename, W_OK) == -1) { exit(1); } fileDesc  = OPEN(filename, O_RDWR); if (fileDesc == -1) { exit(1); } if (WRITE(fileDesc, BAD_SINK_STRING, strlen(BAD_SINK_STRING)) == -1) { exit(1); } if (fileDesc != -1) { CLOSE(fileDesc); } } } }"	where is the vulnerable dataflow from filename to OPEN ?	"if (fgets <start> filename <end> , 100, stdin) == NULL);
if  <start> ACCESS(filename, W_OK) <end>  == -1);"	"fileDesc  = OPEN <start> filename <end> , O_RDWR);
fileDesc  = <start> OPEN(filename, O_RDWR) <end> ;"	"if  <start> fgets(filename, 100, stdin) <end>  == NULL);
if (fgets <start> filename <end> , 100, stdin) == NULL);"	"if (fgets <start> filename <end> , 100, stdin) == NULL);
fileDesc  = OPEN <start> filename <end> , O_RDWR);"	3
48d25db4-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink(int data) { { int result = data + 1; printIntLine(result); } } void CWE190_Integer_Overflow__int_listen_socket_add_44_bad() { int data; void (*funcPtr) (int) = badSink; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } funcPtr(data); }"	where is the vulnerable dataflow from data ?	"static void badSink(int <start> data <end> );
int result = <start> data <end>  + 1;
funcPtr <start> data <end> );
<start> data = atoi(inputBuffer) <end> ;"	"static void badSink(int <start> data <end> );
if  <start> listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR <end> );
funcPtr <start> data <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"<start> funcPtr(data) <end> ;
int result = <start> data <end>  + 1;
static void badSink(int <start> data <end> );
funcPtr <start> data <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
funcPtr <start> data <end> );
static void badSink(int <start> data <end> );
int result = <start> data <end>  + 1;"	3
86cea137-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE369_Divide_by_Zero__int_fgets_modulo_14_bad() { int data; data = -1; if(globalFive==5) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(globalFive==5) { printIntLine(100 % data); } }"	where is the vulnerable dataflow from data to printIntLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> data = atoi(inputBuffer) <end> ;"	"printIntLine <start> 100 % data <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> 100 % data <end> );"	"printIntLine <start> 100 % data <end> );
<start> data = atoi(inputBuffer) <end> ;"	2
c39a6596-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif namespace CWE23_Relative_Path_Traversal__char_environment_ifstream_18 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; goto source; source: { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
inputFile.open((char * <start> data <end> );"	"strncat(data+dataLen, environment, FILENAME_MAX <start> dataLen-1 <end> );
inputFile.open((char * <start> data <end> );"	"<start> data = dataBuffer <end> ;
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"strncat(data+dataLen, environment, <start> FILENAME_MAX-dataLen-1 <end> );
inputFile.open((char * <start> data <end> );"	0
453db033-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_square_02_bad() { int data; data = 0; if(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(1) { { int result = data * data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  * data;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);
int result = <start> data <end>  * data;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  * data;"	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
int result = <start> data <end>  * data;"	2
aa91a161-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_listen_socket_multiply_12_bad() { int data; data = 0; if(globalReturnsTrueOrFalse()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } else { data = -2; } if(globalReturnsTrueOrFalse()) { if(data < 0) { int result = data * 2; printIntLine(result); } } else { if(data < 0) { if (data > (INT_MIN/2)) { int result = data * 2; printIntLine(result); } else { printLine(""data value is too small to perform multiplication.""); } } } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"printIntLine <start> result <end> );
<start> recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"<start> printIntLine(result) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	3
60db83c0-6c15-11ed-81d4-94e6f77dd552	"void CWE190_Integer_Overflow__char_rand_multiply_15_bad() { char data; data = ' '; switch(6) { case 6: data = (char)RAND32(); break; default: printLine(""Benign, fixed string""); break; } switch(7) { case 7: if(data > 0) { char result = data * 2; printHexCharLine(result); } break; default: printLine(""Benign, fixed string""); break; } }"	where is the vulnerable dataflow from data ?	"data = (char <start> RAND32() <end> ;
char result = <start> data <end>  * 2;"	"char result = <start> data <end>  * 2;
<start> data = ' ' <end> ;"	"data = (char <start> RAND32() <end> ;
char result = <start> data * 2 <end> ;"	"char result = <start> data <end>  * 2;
<start> printHexCharLine(result) <end> ;"	0
6dc614f7-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif namespace CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_62 { void badSource(char * &data); static void badVaSink(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); va_end(args); } } void bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; badSource(data); badVaSink(data, data); }"	where is the vulnerable dataflow from data to vprintf ?	"static void badVaSink(char * <start> data <end> , ...);
badSource <start> data <end> );"	"badSource <start> data <end> );
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
vprintf <start> data <end> , args);"	"static void badVaSink(char * <start> data <end> , ...);
vprintf <start> data <end> , args);
badVaSink <start> data <end> , data);
<start> vprintf(data, args) <end> ;"	"static void badVaSink(char * <start> data <end> , ...);
badVaSink <start> data <end> , data);
<start> vprintf(data, args) <end> ;
badSource <start> data <end> );"	1
d1e9da16-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_file_open_43 { void badSource(char * &data) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; badSource(data); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"badSource <start> data <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"badSource <start> data <end> );
<start> data = dataBuffer <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"badSource <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
<start> data = dataBuffer <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
badSource <start> data <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	3
466e7edd-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_multiply_17_bad() { int i,j; int data; data = 0; for(i = 0; i < 1; i++) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } for(j = 0; j < 1; j++) { if(data > 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
int result = <start> data * 2 <end> ;"	"int result = <start> data <end>  * 2;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
int <start> result = data * 2 <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
int result = <start> data <end>  * 2;"	3
6dc61507-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif static int staticTrue = 1; static int staticFalse = 0; void CWE134_Uncontrolled_Format_String__char_console_snprintf_05_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; if(staticTrue) { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } if(staticTrue) { { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } } }"	where is the vulnerable dataflow from dest to printLine ?	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
printLine <start> dest <end> );"	"size_t dataLen = <start> strlen(data) <end> ;
printLine <start> dest <end> );"	"printLine <start> dest <end> );
<start> printLine(dest) <end> ;"	1
73bc8164-6c15-11ed-81d4-94e6f77dd552	"namespace CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_81 { void CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_81_bad::action(short data) const { { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> memcpy(dest, source, data) <end> ;
void CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_81_bad::action(short <start> data <end> ) const;"	"void CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_81_bad::action(short <start> data <end> ) const;
printLine <start> dest <end> );"	"printLine <start> dest <end> );
void CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_81_bad::action(short <start> data <end> ) const;"	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	1
a10948e5-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_multiply_18_bad() { int data; data = 0; goto source; source: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } goto sink; sink: if(data > 0) { int result = data * 2; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> result <end> );"	1
a49c4f56-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_multiply_65b_badSink(int data) { if(data > 0) { int result = data * 2; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"void CWE190_Integer_Overflow__int_listen_socket_multiply_65b_badSink(int <start> data <end> );
<start> printIntLine(result) <end> ;"	"void CWE190_Integer_Overflow__int_listen_socket_multiply_65b_badSink(int <start> data <end> );
int <start> result = data * 2 <end> ;"	"int <start> result = data * 2 <end> ;
printIntLine <start> result <end> );"	"void CWE190_Integer_Overflow__int_listen_socket_multiply_65b_badSink(int <start> data <end> );
printIntLine <start> result <end> );"	3
525b6491-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__short_fscanf_preinc_53d_badSink(short data) { { ++data; short result = data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"void CWE190_Integer_Overflow__short_fscanf_preinc_53d_badSink(short <start> data <end> );
+ <start> data <end> ;"	"short <start> result = data <end> ;
+ <start> data <end> ;"	"+ <start> data <end> ;
void CWE190_Integer_Overflow__short_fscanf_preinc_53d_badSink(short <start> data <end> );"	"short <start> result = data <end> ;
void CWE190_Integer_Overflow__short_fscanf_preinc_53d_badSink(short <start> data <end> );"	0
48d25db8-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_add_54e_badSink(int data) { { int result = data + 1; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"void CWE190_Integer_Overflow__int_listen_socket_add_54e_badSink(int <start> data <end> );
<start> printIntLine(result) <end> ;"	"void CWE190_Integer_Overflow__int_listen_socket_add_54e_badSink(int <start> data <end> );
int result = <start> data <end>  + 1;"	"int result = <start> data <end>  + 1;
void CWE190_Integer_Overflow__int_listen_socket_add_54e_badSink(int <start> data <end> );"	"int <start> result = data + 1 <end> ;
void CWE190_Integer_Overflow__int_listen_socket_add_54e_badSink(int <start> data <end> );"	1
630ae800-6c15-11ed-81d4-94e6f77dd552	static int staticTrue = 1; static int staticFalse = 0; void CWE190_Integer_Overflow__short_rand_square_05_bad() { short data; data = 0; if(staticTrue) { data = (short)RAND32(); } if(staticTrue) { { short result = data * data; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"short result = <start> data * data <end> ;
data = (short <start> RAND32() <end> ;"	"short result = <start> data <end>  * data;
<start> data = (short)RAND32() <end> ;"	"short <start> result = data * data <end> ;
data = (short <start> RAND32() <end> ;"	"data = (short <start> RAND32() <end> ;
short result = <start> data <end>  * data;"	3
715a3bc3-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif typedef union { char * unionFirst; char * unionSecond; } CWE134_Uncontrolled_Format_String__char_file_vprintf_34_unionType; static void badVaSink(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_file_vprintf_34_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } { char * dataCopy = data; char * data = dataCopy; badVaSink(data, data); } }"	where is the vulnerable dataflow from data to vprintf ?	"size_t dataLen = <start> strlen(data) <end> ;
badVaSink <start> data <end> , data);
vprintf <start> data <end> , args);
static void badVaSink(char * <start> data <end> , ...);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
vprintf <start> data <end> , args);
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
vprintf <start> data <end> , args);"	"static void badVaSink(char * <start> data <end> , ...);
vprintf <start> data <end> , args);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	2
aa91a184-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_listen_socket_sub_02_bad() { int data; data = 0; if(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(1) { { int result = data - 1; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
data = <start> atoi(inputBuffer) <end> ;"	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> result <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"data = <start> atoi(inputBuffer) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	2
bda4e419-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define EXECL _execl #else #define EXECL execl #endif void CWE78_OS_Command_Injection__char_listen_socket_execl_11_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(globalReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECL ?	"<start> data = dataBuffer <end> ;
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"if  <start> recvResult == SOCKET_ERROR <end>  || recvResult == 0);
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	3
656cd3f6-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__int_rand_multiply_52c_badSink(int data) { if(data > 0) { int result = data * 2; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  * 2;
<start> printIntLine(result) <end> ;"	"int result = <start> data <end>  * 2;
void CWE190_Integer_Overflow__int_rand_multiply_52c_badSink(int <start> data <end> );"	"void CWE190_Integer_Overflow__int_rand_multiply_52c_badSink(int <start> data <end> );
int result = <start> data <end>  * 2;"	"void CWE190_Integer_Overflow__int_rand_multiply_52c_badSink(int <start> data <end> );
int result = <start> data * 2 <end> ;"	2
cac216ac-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" namespace CWE36_Absolute_Path_Traversal__char_connect_socket_ofstream_01 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"outputFile.open((char * <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
outputFile.open((char * <start> data <end> );"	"outputFile.open((char * <start> data <end> );
recvResult = recv(connectSocket, (char *)(data + dataLen), <start> sizeof(char) * (FILENAME_MAX - dataLen - 1) <end> , 0);"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
outputFile.open((char * <start> data <end> );"	3
d0b64efd-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_file_open_03 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(5==5) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"<start> data = dataBuffer <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"<start> data = dataBuffer <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"size_t dataLen = <start> strlen(data) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	0
79b2750c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 8 short CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_61b_badSource(short data); void CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_61_bad() { short data; data = 0; data = CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_61b_badSource(data); { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> printLine(dest) <end> ;
data = <start> CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_61b_badSource <end> (data);"	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	"char <start> dest[100] = """" <end> ;
data = <start> CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_61b_badSource <end> (data);"	"data = <start> CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_61b_badSource <end> (data);
printLine <start> dest <end> );"	3
5af03e25-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink(int data) { { data--; int result = data; printIntLine(result); } } void CWE191_Integer_Underflow__int_fgets_postdec_41_bad() { int data; data = 0; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } badSink(data); }"	where is the vulnerable dataflow from data ?	"badSink <start> data <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"<start> data <end> --;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
static void badSink(int <start> data <end> );
<start> printIntLine(result) <end> ;"	"static void badSink(int <start> data <end> );
<start> data = 0 <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
badSink <start> data <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
badSink <start> data <end> );
static void badSink(int <start> data <end> );
<start> data <end> --;"	3
cac216de-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_connect_socket_open_22 { int badGlobal = 0; char * badSource(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; badGlobal = 1; data = badSource(data); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } ; }"	where is the vulnerable dataflow from data to OPEN ?	"data = <start> badSource <end> (data);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"data = <start> badSource <end> (data);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
data = <start> badSource <end> (data);"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	1
5d16c9df-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_connect_socket_predec_01_bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { --data; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"- <start> data <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
data = <start> atoi(inputBuffer) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
- <start> data <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data = atoi(inputBuffer) <end> ;"	2
a36a78f2-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_add_17_bad() { int i,j; int data; data = 0; for(i = 0; i < 1; i++) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } for(j = 0; j < 1; j++) { { int result = data + 1; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"int result = <start> data + 1 <end> ;
printIntLine <start> result <end> );"	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> result <end> );"	"<start> data = 0 <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	3
8b91e47d-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_listen_socket_open_43 { void badSource(char * &data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; badSource(data); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
badSource <start> data <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"badSource <start> data <end> );
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
badSource <start> data <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"badSource <start> data <end> );
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	0
bc721f70-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define EXECL _execl #else #define EXECL execl #endif static const int STATIC_CONST_FIVE = 5; void CWE78_OS_Command_Injection__char_file_execl_06_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(STATIC_CONST_FIVE==5) { { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECL ?	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
size_t dataLen = <start> strlen(data) <end> ;"	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	"if  <start> fgets(data+dataLen, (int)(100-dataLen), pFile) <end>  == NULL);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	0
9b124d92-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE124_Buffer_Underwrite__CWE839_fgets_43 { static void badSource(int &data) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } void bad() { int data; data = -1; badSource(data); { int i; int buffer[10] = { 0 }; if (data < 10) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } } }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> buffer[i] <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
badSource <start> data <end> );
printIntLine <start> buffer[i] <end> );"	"printIntLine <start> buffer[i] <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> printIntLine(buffer[i]) <end> ;"	"printIntLine <start> buffer[i] <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
badSource <start> data <end> );"	1
93ece2ce-6c15-11ed-81d4-94e6f77dd552	"#define HELLO_STRING ""hello"" namespace CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_82 { void CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_82_bad::action(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); } else { printLine(""Input is less than the length of the source string""); } } } }"	where is the vulnerable dataflow from data to malloc ?	"myString = (char * <start> malloc(data*sizeof(char)) <end> ;
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_82_bad::action(size_t <start> data <end> );"	"myString = (char *)malloc <start> data*sizeof(char) <end> );
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_82_bad::action(size_t <start> data <end> );"	"void CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_82_bad::action(size_t <start> data <end> );
myString = (char *)malloc <start> data*sizeof(char) <end> );"	"myString = (char *)malloc <start> data*sizeof(char) <end> );
myString = (char * <start> malloc(data*sizeof(char)) <end> ;"	2
b2ea8df0-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 8 void CWE197_Numeric_Truncation_Error__short_listen_socket_18_bad() { short data; data = -1; goto source; source: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = (short)atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { char charData = (char)data; printHexCharLine(charData); } }"	where is the vulnerable dataflow from charData to printHexCharLine ?	"printHexCharLine <start> charData <end> );
<start> printHexCharLine(charData) <end> ;"	"recvResult = recv(acceptSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);
printHexCharLine <start> charData <end> );"	"data = (short <start> atoi(inputBuffer) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printHexCharLine <start> charData <end> );"	3
630ae80c-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__short_rand_square_17_bad() { int i,j; short data; data = 0; for(i = 0; i < 1; i++) { data = (short)RAND32(); } for(j = 0; j < 1; j++) { { short result = data * data; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"data = (short <start> RAND32() <end> ;
short result = <start> data * data <end> ;"	"data = (short <start> RAND32() <end> ;
short result = <start> data <end>  * data;"	"<start> printIntLine(result) <end> ;
short result = <start> data <end>  * data;"	"short result = <start> data <end>  * data;
data = (short <start> RAND32() <end> ;"	1
92bb89fd-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define SEARCH_CHAR 'S' void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_09_bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\0'; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } if(GLOBAL_CONST_TRUE) { for (; *data != '\0'; data++) { if (*data == SEARCH_CHAR) { printLine(""We have a match!""); break; } } free(data); } }"	where is the vulnerable dataflow from data to free ?	"if  <start> data == NULL <end> ) {exit(-1);};
free <start> data <end> );"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
free <start> data <end> );"	"<start> free(data) <end> ;
free <start> data <end> );"	"<start> free(data) <end> ;
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	1
4ec5d0a4-6c15-11ed-81d4-94e6f77dd552	"static void badSink(int data) { { data++; int result = data; printIntLine(result); } } void CWE190_Integer_Overflow__int_fscanf_postinc_44_bad() { int data; void (*funcPtr) (int) = badSink; data = 0; fscanf(stdin, ""%d"", &data); funcPtr(data); }"	where is the vulnerable dataflow from data ?	"fscanf(stdin, ""%d"", <start> &data <end> );
static void badSink(int <start> data <end> );
funcPtr <start> data <end> );"	"<start> data++ <end> ;
fscanf(stdin, ""%d"", <start> &data <end> );
funcPtr <start> data <end> );
static void badSink(int <start> data <end> );"	"fscanf(stdin, ""%d"", <start> &data <end> );
funcPtr <start> data <end> );
static void badSink(int <start> data <end> );
<start> data <end> ++;"	"<start> printIntLine(result) <end> ;
static void badSink(int <start> data <end> );
fscanf(stdin, ""%d"", <start> &data <end> );
funcPtr <start> data <end> );"	2
80d986e4-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_connect_socket_open_43 { void badSource(char * &data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; badSource(data); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
badSource <start> data <end> );
fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
badSource <start> data <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"size_t dataLen = <start> strlen(data) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	2
74ee23ec-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" void CWE194_Unexpected_Sign_Extension__connect_socket_strncpy_66b_badSink(short dataArray[]) { short data = dataArray[2]; { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"printLine <start> dest <end> );
<start> printLine(dest) <end> ;"	"printLine <start> dest <end> );
<start> strncpy(dest, source, data) <end> ;"	"<start> strncpy(dest, source, data) <end> ;
void CWE194_Unexpected_Sign_Extension__connect_socket_strncpy_66b_badSink(short <start> dataArray <end> []);"	"void CWE194_Unexpected_Sign_Extension__connect_socket_strncpy_66b_badSink(short <start> dataArray <end> []);
printLine <start> dest <end> );"	3
93ece305-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING ""hello"" void CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_14_bad() { size_t data; data = 0; if(globalFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = strtoul(inputBuffer, NULL, 0); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalFive==5) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); } else { printLine(""Input is less than the length of the source string""); } } } }"	where is the vulnerable dataflow from data to malloc ?	"recvResult = recv(acceptSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);
myString = (char *)malloc <start> data*sizeof(char) <end> );"	"if  <start> data > strlen(HELLO_STRING) <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
myString = (char *)malloc <start> data*sizeof(char) <end> );"	"if  <start> data > strlen(HELLO_STRING) <end> );
myString = (char *)malloc <start> data*sizeof(char) <end> );"	2
a95fd81b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE191_Integer_Underflow__int_connect_socket_sub_81 { void bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } const CWE191_Integer_Underflow__int_connect_socket_sub_81_base& baseObject = CWE191_Integer_Underflow__int_connect_socket_sub_81_bad(); baseObject.action(data); }"	where is the vulnerable dataflow from data to action ?	"baseObject.action <start> data <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
baseObject.action <start> data <end> );"	"data = <start> atoi(inputBuffer) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"baseObject.action <start> data <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	1
c72d5d61-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_listen_socket_fopen_44 { static void badSink(char * data) { { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } } void bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } funcPtr(data); }"	where is the vulnerable dataflow from data to funcPtr ?	"funcPtr <start> data <end> );
<start> data = dataBuffer <end> ;"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
funcPtr <start> data <end> );"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
funcPtr <start> data <end> );"	2
669edad7-6c15-11ed-81d4-94e6f77dd552	static int64_t CWE190_Integer_Overflow__int64_t_rand_postinc_45_badData; static int64_t CWE190_Integer_Overflow__int64_t_rand_postinc_45_goodG2BData; static int64_t CWE190_Integer_Overflow__int64_t_rand_postinc_45_goodB2GData; static void badSink() { int64_t data = CWE190_Integer_Overflow__int64_t_rand_postinc_45_badData; { data++; int64_t result = data; printLongLongLine(result); } } void CWE190_Integer_Overflow__int64_t_rand_postinc_45_bad() { int64_t data; data = 0LL; data = (int64_t)RAND64(); CWE190_Integer_Overflow__int64_t_rand_postinc_45_badData = data; badSink(); }	where is the vulnerable dataflow from data ?	"<start> data <end> ++;
data = (int64_t <start> RAND64() <end> ;
static int64_t <start> CWE190_Integer_Overflow__int64_t_rand_postinc_45_badData <end> ;
<start> CWE190_Integer_Overflow__int64_t_rand_postinc_45_badData = data <end> ;
int64_t data = <start> CWE190_Integer_Overflow__int64_t_rand_postinc_45_badData <end> ;"	"static int64_t <start> CWE190_Integer_Overflow__int64_t_rand_postinc_45_badData <end> ;
<start> CWE190_Integer_Overflow__int64_t_rand_postinc_45_badData = data <end> ;
data = (int64_t <start> RAND64() <end> ;"	"<start> CWE190_Integer_Overflow__int64_t_rand_postinc_45_badData = data <end> ;
static int64_t <start> CWE190_Integer_Overflow__int64_t_rand_postinc_45_badData <end> ;
data = (int64_t <start> RAND64() <end> ;
int64_t data = <start> CWE190_Integer_Overflow__int64_t_rand_postinc_45_badData <end> ;"	"data = (int64_t <start> RAND64() <end> ;
<start> CWE190_Integer_Overflow__int64_t_rand_postinc_45_badData = data <end> ;
static int64_t <start> CWE190_Integer_Overflow__int64_t_rand_postinc_45_badData <end> ;
int64_t data = <start> CWE190_Integer_Overflow__int64_t_rand_postinc_45_badData <end> ;
<start> data <end> ++;"	3
5133a753-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) extern int CWE190_Integer_Overflow__int_connect_socket_preinc_68_badData; extern int CWE190_Integer_Overflow__int_connect_socket_preinc_68_goodG2BData; extern int CWE190_Integer_Overflow__int_connect_socket_preinc_68_goodB2GData; void CWE190_Integer_Overflow__int_connect_socket_preinc_68b_badSink() { int data = CWE190_Integer_Overflow__int_connect_socket_preinc_68_badData; { ++data; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
int data = <start> CWE190_Integer_Overflow__int_connect_socket_preinc_68_badData <end> ;"	"int data = <start> CWE190_Integer_Overflow__int_connect_socket_preinc_68_badData <end> ;
int <start> result = data <end> ;"	"int data = <start> CWE190_Integer_Overflow__int_connect_socket_preinc_68_badData <end> ;
+ <start> data <end> ;"	"<start> printIntLine(result) <end> ;
+ <start> data <end> ;"	2
8cc3a68d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(count) + 2) #ifdef _WIN32 #define SLEEP Sleep #else #define SLEEP usleep #endif static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } void CWE400_Resource_Exhaustion__listen_socket_sleep_08_bad() { int count; count = -1; if(staticReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; count = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticReturnsTrue()) { SLEEP(count); printLine(""Sleep time possibly too long""); } }"	where is the vulnerable dataflow from count to SLEEP ?	"SLEEP <start> count <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
SLEEP <start> count <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> SLEEP(count) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
count = <start> atoi(inputBuffer) <end> ;"	1
73bc8138-6c15-11ed-81d4-94e6f77dd552	namespace CWE194_Unexpected_Sign_Extension__connect_socket_malloc_81 { void CWE194_Unexpected_Sign_Extension__connect_socket_malloc_81_bad::action(short data) const { if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } } }	where is the vulnerable dataflow from data to malloc ?	"void CWE194_Unexpected_Sign_Extension__connect_socket_malloc_81_bad::action(short <start> data <end> ) const;
memset(dataBuffer, 'A', <start> data-1 <end> );"	"void CWE194_Unexpected_Sign_Extension__connect_socket_malloc_81_bad::action(short <start> data <end> ) const;
char * dataBuffer = (char *)malloc <start> data <end> );"	"if  <start> dataBuffer == NULL <end> ) {exit(-1);};
void CWE194_Unexpected_Sign_Extension__connect_socket_malloc_81_bad::action(short <start> data <end> ) const;"	"<start> printLine(dataBuffer) <end> ;
char * dataBuffer = (char *)malloc <start> data <end> );"	1
73bc8155-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" void CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_51b_badSink(short data) { { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"void CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_51b_badSink(short <start> data <end> );
printLine <start> dest <end> );"	"if  <start> data < 100 <end> );
void CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_51b_badSink(short <start> data <end> );"	"printLine <start> dest <end> );
<start> printLine(dest) <end> ;"	"void CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_51b_badSink(short <start> data <end> );
char <start> dest[100] = """" <end> ;"	0
bb49c594-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #define EXECL _execl #else #define EXECL execl #endif static char * CWE78_OS_Command_Injection__char_console_execl_45_badData; static char * CWE78_OS_Command_Injection__char_console_execl_45_goodG2BData; static void badSink() { char * data = CWE78_OS_Command_Injection__char_console_execl_45_badData; EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL); } void CWE78_OS_Command_Injection__char_console_execl_45_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } CWE78_OS_Command_Injection__char_console_execl_45_badData = data; badSink(); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECL ?	"<start> CWE78_OS_Command_Injection__char_console_execl_45_badData = data <end> ;
char * data = <start> CWE78_OS_Command_Injection__char_console_execl_45_badData <end> ;
static char * <start> CWE78_OS_Command_Injection__char_console_execl_45_badData <end> ;
size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
<start> CWE78_OS_Command_Injection__char_console_execl_45_badData = data <end> ;
static char * <start> CWE78_OS_Command_Injection__char_console_execl_45_badData <end> ;
char * data = <start> CWE78_OS_Command_Injection__char_console_execl_45_badData <end> ;
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"static char * <start> CWE78_OS_Command_Injection__char_console_execl_45_badData <end> ;
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
char * data = <start> CWE78_OS_Command_Injection__char_console_execl_45_badData <end> ;"	"char <start> dataBuffer[100] = COMMAND_ARG2 <end> ;
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
static char * <start> CWE78_OS_Command_Injection__char_console_execl_45_badData <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
char * data = <start> CWE78_OS_Command_Injection__char_console_execl_45_badData <end> ;"	1
cf87508b-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_environment_open_18 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; goto source; source: { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
<start> data = dataBuffer <end> ;"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"size_t <start> dataLen = strlen(data) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	1
80d98737-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_console_open_52 { void badSink_c(char * data) { { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"void badSink_c(char * <start> data <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"void badSink_c(char * <start> data <end> );
fileDesc = OPEN(data, O_RDWR|O_CREAT, <start> S_IREAD|S_IWRITE <end> );"	"void badSink_c(char * <start> data <end> );
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	1
93ece2e4-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING ""hello"" typedef union { size_t unionFirst; size_t unionSecond; } CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_34_unionType; void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_34_bad() { size_t data; CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_34_unionType myUnion; data = 0; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = strtoul(inputBuffer, NULL, 0); } else { printLine(""fgets() failed.""); } } myUnion.unionFirst = data; { size_t data = myUnion.unionSecond; { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); } else { printLine(""Input is less than the length of the source string""); } } } }"	where is the vulnerable dataflow from data to malloc ?	"<start> strcpy(myString, HELLO_STRING) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
myString = (char *)malloc <start> data*sizeof(char) <end> );"	"<start> strcpy(myString, HELLO_STRING) <end> ;
myString = (char *)malloc <start> data*sizeof(char) <end> );"	"if  <start> data > strlen(HELLO_STRING) <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	1
7fa68e41-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif extern char * CWE23_Relative_Path_Traversal__char_connect_socket_fopen_68_badData; extern char * CWE23_Relative_Path_Traversal__char_connect_socket_fopen_68_goodG2BData; namespace CWE23_Relative_Path_Traversal__char_connect_socket_fopen_68 { void badSink() { char * data = CWE23_Relative_Path_Traversal__char_connect_socket_fopen_68_badData; { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"char <start> * data = CWE23_Relative_Path_Traversal__char_connect_socket_fopen_68_badData <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"char * data = <start> CWE23_Relative_Path_Traversal__char_connect_socket_fopen_68_badData <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
char * data = <start> CWE23_Relative_Path_Traversal__char_connect_socket_fopen_68_badData <end> ;"	"char * data = <start> CWE23_Relative_Path_Traversal__char_connect_socket_fopen_68_badData <end> ;
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	1
a830bf96-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_FIVE = 5; void CWE191_Integer_Underflow__int_connect_socket_sub_06_bad() { int data; data = 0; if(STATIC_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(STATIC_CONST_FIVE==5) { { int result = data - 1; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"int <start> result = data - 1 <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"printIntLine <start> result <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	1
b2ea8df7-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 8 namespace CWE197_Numeric_Truncation_Error__short_listen_socket_43 { static void badSource(short &data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = (short)atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } void bad() { short data; data = -1; badSource(data); { char charData = (char)data; printHexCharLine(charData); } }"	where is the vulnerable dataflow from charData to printHexCharLine ?	"badSource <start> data <end> );
printHexCharLine <start> charData <end> );
if  <start> acceptSocket == SOCKET_ERROR <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
char <start> charData = (char)data <end> ;
badSource <start> data <end> );"	"printHexCharLine <start> charData <end> );
badSource <start> data <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSource <start> data <end> );
printHexCharLine <start> charData <end> );"	3
b68484da-6c15-11ed-81d4-94e6f77dd552	"namespace CWE36_Absolute_Path_Traversal__char_console_ofstream_81 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } const CWE36_Absolute_Path_Traversal__char_console_ofstream_81_base& baseObject = CWE36_Absolute_Path_Traversal__char_console_ofstream_81_bad(); baseObject.action(data); }"	where is the vulnerable dataflow from data to action ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
baseObject.action <start> data <end> );"	"baseObject.action <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	"baseObject.action <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"baseObject.action <start> data <end> );
<start> data = dataBuffer <end> ;"	0
ce547d21-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_environment_fopen_18 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; goto source; source: { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"<start> data = dataBuffer <end> ;
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
strncat(data+dataLen, environment, <start> FILENAME_MAX-dataLen-1 <end> );"	"char <start> dataBuffer[FILENAME_MAX] = """" <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	1
ce547d2f-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_environment_fopen_61 { char * badSource(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; data = badSource(data); { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"<start> data = badSource(data) <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
data = <start> badSource <end> (data);"	"data = <start> badSource <end> (data);
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	2
7fa68e3c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_connect_socket_fopen_45 { static char * badData; static char * goodG2BData; static void badSink() { char * data = badData; { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } } void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badData = data; badSink(); }"	where is the vulnerable dataflow from data to FOPEN ?	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
static char * <start> badData <end> ;
replace = <start> strchr(data, '\n') <end> ;
<start> badData = data <end> ;
char * data = <start> badData <end> ;"	"<start> badData = data <end> ;
recvResult = recv(connectSocket, (char *)(data + dataLen), <start> sizeof(char) * (FILENAME_MAX - dataLen - 1) <end> , 0);
pFile = FOPEN <start> data <end> , ""wb+"");
char * data = <start> badData <end> ;
static char * <start> badData <end> ;"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
char * data = <start> badData <end> ;
<start> data = dataBuffer <end> ;
static char * <start> badData <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
<start> badData = data <end> ;
static char * <start> badData <end> ;
char * data = <start> badData <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	3
7c127593-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_31_bad() { int data; data = -1; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } { int dataCopy = data; int data = dataCopy; { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } } }"	where is the vulnerable dataflow from dest to printLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printLine <start> dest <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> printLine(dest) <end> ;"	"data = <start> atoi(inputBuffer) <end> ;
printLine <start> dest <end> );"	"printLine <start> dest <end> );
char <start> dest[100] = """" <end> ;"	0
cd228167-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_console_open_41 { void badSink(char * data) { { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } } void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } badSink(data); }"	where is the vulnerable dataflow from data to badSink ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
size_t dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
badSink <start> data <end> );"	"dataLen = <start> strlen(data) <end> ;
badSink <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
if (dataLen > 0 && <start> data[dataLen-1] == '\n' <end> );"	1
656cd411-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__int_rand_square_13_bad() { int data; data = 0; if(GLOBAL_CONST_FIVE==5) { data = RAND32(); } if(GLOBAL_CONST_FIVE==5) { { int result = data * data; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"data = <start> RAND32() <end> ;
int result = <start> data <end>  * data;"	"int <start> result = data * data <end> ;
data = <start> RAND32() <end> ;"	"<start> printIntLine(result) <end> ;
data = <start> RAND32() <end> ;"	"int result = <start> data * data <end> ;
data = <start> RAND32() <end> ;"	0
d1e9da10-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_file_open_21 { static int badStatic = 0; static char * badSource(char * data) { if(badStatic) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } return data; } void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; badStatic = 1; data = badSource(data); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } ; }"	where is the vulnerable dataflow from data to OPEN ?	"data = <start> badSource <end> (data);
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
static char * <start> badSource <end> (char * data);"	"data = <start> badSource <end> (data);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"static char * <start> badSource <end> (char * data);
data = <start> badSource(data) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	2
c5fc2361-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif namespace CWE23_Relative_Path_Traversal__char_file_ofstream_44 { static void badSink(char * data) { { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } } void bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } funcPtr(data); }"	where is the vulnerable dataflow from data to funcPtr ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
funcPtr <start> data <end> );"	"<start> funcPtr(data) <end> ;
funcPtr <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
size_t dataLen = <start> strlen(data) <end> ;"	"<start> data = dataBuffer <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	0
7c127580-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_02_bad() { int data; data = -1; if(1) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"data = <start> atoi(inputBuffer) <end> ;
printLine <start> dest <end> );"	"<start> data = atoi(inputBuffer) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"<start> memcpy(dest, source, data) <end> ;
printLine <start> dest <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printLine <start> dest <end> );"	3
b08640c8-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE197_Numeric_Truncation_Error__int_fgets_to_char_64b_badSink(void * dataVoidPtr) { int * dataPtr = (int *)dataVoidPtr; int data = (*dataPtr); { char charData = (char)data; printHexCharLine(charData); } }	where is the vulnerable dataflow from charData to printHexCharLine ?	"printHexCharLine <start> charData <end> );
void CWE197_Numeric_Truncation_Error__int_fgets_to_char_64b_badSink(void * <start> dataVoidPtr <end> );"	"printHexCharLine <start> charData <end> );
char charData = <start> (char)data <end> ;"	"void CWE197_Numeric_Truncation_Error__int_fgets_to_char_64b_badSink(void * <start> dataVoidPtr <end> );
printHexCharLine <start> charData <end> );"	"char charData = <start> (char)data <end> ;
void CWE197_Numeric_Truncation_Error__int_fgets_to_char_64b_badSink(void * <start> dataVoidPtr <end> );"	2
656cd3ee-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__int_rand_multiply_31_bad() { int data; data = 0; data = RAND32(); { int dataCopy = data; int data = dataCopy; if(data > 0) { int result = data * 2; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"data = <start> RAND32() <end> ;
int result = <start> data <end>  * 2;"	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  * 2;"	"data = <start> RAND32() <end> ;
<start> printIntLine(result) <end> ;"	"data = <start> RAND32() <end> ;
int <start> result = data * 2 <end> ;"	0
7c127598-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink(int data) { { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } } void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_44_bad() { int data; void (*funcPtr) (int) = badSink; data = -1; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } funcPtr(data); }"	where is the vulnerable dataflow from dest to printLine ?	"static void badSink(int <start> data <end> );
funcPtr <start> data <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printLine <start> dest <end> );"	"if  <start> data < 100 <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
funcPtr <start> data <end> );
static void badSink(int <start> data <end> );"	"printLine <start> dest <end> );
static void badSink(int <start> data <end> );
funcPtr <start> data <end> );
<start> memcpy(dest, source, data) <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
funcPtr <start> data <end> );
static void badSink(int <start> data <end> );
printLine <start> dest <end> );"	3
bb49c579-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" namespace CWE78_OS_Command_Injection__char_connect_socket_system_81 { void bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } const CWE78_OS_Command_Injection__char_connect_socket_system_81_base& baseObject = CWE78_OS_Command_Injection__char_connect_socket_system_81_bad(); baseObject.action(data); }"	where is the vulnerable dataflow from data to action ?	"baseObject.action <start> data <end> );
replace = <start> strchr(data, '\n') <end> ;"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
size_t dataLen = <start> strlen(data) <end> ;"	"baseObject.action <start> data <end> );
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
baseObject.action <start> data <end> );"	3
55ef4c9f-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_fgets_multiply_11_bad() { int data; data = 0; if(globalReturnsTrue()) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(globalReturnsTrue()) { if(data < 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"if <start> data < 0 <end> ) ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"int result = <start> data <end>  * 2;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> printIntLine(result) <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
int result = <start> data <end>  * 2;"	3
656cd40a-6c15-11ed-81d4-94e6f77dd552	static const int STATIC_CONST_FIVE = 5; void CWE190_Integer_Overflow__int_rand_square_06_bad() { int data; data = 0; if(STATIC_CONST_FIVE==5) { data = RAND32(); } if(STATIC_CONST_FIVE==5) { { int result = data * data; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  * data;"	"int <start> result = data * data <end> ;
data = <start> RAND32() <end> ;"	"int result = <start> data <end>  * data;
data = <start> RAND32() <end> ;"	"data = <start> RAND32() <end> ;
int result = <start> data <end>  * data;"	3
ba102b88-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define EXECL _execl #else #define EXECL execl #endif static int badStatic = 0; static char * badSource(char * data) { if(badStatic) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } return data; } void CWE78_OS_Command_Injection__char_connect_socket_execl_21_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; badStatic = 1; data = badSource(data); EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECL ?	"data = <start> badSource <end> (data);
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (100 - dataLen - 1), 0);
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
static char * <start> badSource <end> (char * data);"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (100 - dataLen - 1), 0);
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
data = <start> badSource <end> (data);"	"recvResult = <start> recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0) <end> ;
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	1
c26a7e58-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_console_open_64 { void badSink(void * dataVoidPtr) { char * * dataPtr = (char * *)dataVoidPtr; char * data = (*dataPtr); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"void badSink(void * <start> dataVoidPtr <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
void badSink(void * <start> dataVoidPtr <end> );"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
void badSink(void * <start> dataVoidPtr <end> );"	0
774f5843-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 8 void CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_18_bad() { short data; data = 0; goto source; source: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
char <start> dest[100] = """" <end> ;"	"printLine <start> dest <end> );
<start> memcpy(dest, source, data) <end> ;"	"printLine <start> dest <end> );
if (tempInt > SHRT_MAX || <start> tempInt < SHRT_MIN <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	3
d0b64ee4-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } namespace CWE36_Absolute_Path_Traversal__char_file_ofstream_08 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(staticReturnsTrue()) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
outputFile.open((char * <start> data <end> );"	"<start> data = dataBuffer <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"outputFile.open((char * <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	1
c72d5d84-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 namespace CWE23_Relative_Path_Traversal__char_listen_socket_ifstream_34 { typedef union { char * unionFirst; char * unionSecond; } unionType; void bad() { char * data; unionType myUnion; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } } }"	where is the vulnerable dataflow from data to open ?	"inputFile.open((char * <start> data <end> );
recvResult = recv(acceptSocket, (char *)(data + dataLen), <start> sizeof(char) * (FILENAME_MAX - dataLen - 1) <end> , 0);"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(acceptSocket, (char *)(data + dataLen), <start> sizeof(char) * (FILENAME_MAX - dataLen - 1) <end> , 0);
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
inputFile.open((char * <start> data <end> );"	3
a36a790c-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__int_listen_socket_add_82 { void CWE190_Integer_Overflow__int_listen_socket_add_82_bad::action(int data) { { int result = data + 1; printIntLine(result); } } }	where is the vulnerable dataflow from result to printIntLine ?	"int <start> result = data + 1 <end> ;
printIntLine <start> result <end> );"	"void CWE190_Integer_Overflow__int_listen_socket_add_82_bad::action(int <start> data <end> );
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
void CWE190_Integer_Overflow__int_listen_socket_add_82_bad::action(int <start> data <end> );"	"<start> printIntLine(result) <end> ;
void CWE190_Integer_Overflow__int_listen_socket_add_82_bad::action(int <start> data <end> );"	1
61da66e0-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__char_rand_square_10_bad() { char data; data = ' '; if(globalTrue) { data = (char)RAND32(); } if(globalTrue) { { char result = data * data; printHexCharLine(result); } } }	where is the vulnerable dataflow from data ?	"data = (char <start> RAND32() <end> ;
<start> printHexCharLine(result) <end> ;"	"char result = <start> data * data <end> ;
data = (char <start> RAND32() <end> ;"	"data = (char <start> RAND32() <end> ;
char result = <start> data <end>  * data;"	"char result = <start> data <end>  * data;
data = (char <start> RAND32() <end> ;"	2
5e44fc93-6c15-11ed-81d4-94e6f77dd552	"static const int STATIC_CONST_FIVE = 5; void CWE191_Integer_Underflow__int_fscanf_predec_06_bad() { int data; data = 0; if(STATIC_CONST_FIVE==5) { fscanf(stdin, ""%d"", &data); } if(STATIC_CONST_FIVE==5) { { --data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"- <start> data <end> ;
int <start> result = data <end> ;"	"fscanf(stdin, ""%d"", <start> &data <end> );
<start> printIntLine(result) <end> ;"	"- <start> data <end> ;
fscanf(stdin, ""%d"", <start> &data <end> );"	"fscanf(stdin, ""%d"", <start> &data <end> );
- <start> data <end> ;"	3
9059f3b6-6c15-11ed-81d4-94e6f77dd552	namespace CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_73 { void badSink(list<int> dataList) { int data = dataList.back(); { size_t i; int *intPointer; intPointer = (int*)malloc(data * sizeof(int)); if (intPointer == NULL) {exit(-1);} for (i = 0; i < (size_t)data; i++) { intPointer[i] = 0; } printIntLine(intPointer[0]); free(intPointer); } }	where is the vulnerable dataflow from data to malloc ?	"intPointer = (int*)malloc <start> data * sizeof(int) <end> );
void badSink(list<int> <start> dataList <end> );"	"intPointer = (int* <start> malloc(data * sizeof(int)) <end> ;
void badSink(list<int> <start> dataList <end> );"	"void badSink(list<int> <start> dataList <end> );
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	"intPointer = (int*)malloc <start> data * sizeof(int) <end> );
intPointer = (int* <start> malloc(data * sizeof(int)) <end> ;"	2
92bb8a28-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING ""hello"" static int badStatic = 0; static void badSink(size_t data) { if(badStatic) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); } else { printLine(""Input is less than the length of the source string""); } } } } void CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_21_bad() { size_t data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = strtoul(inputBuffer, NULL, 0); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badStatic = 1; badSink(data); }"	where is the vulnerable dataflow from data to malloc ?	"myString = (char *)malloc <start> data*sizeof(char) <end> );
<start> printLine(myString) <end> ;
static void badSink(size_t <start> data <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"myString = (char *)malloc <start> data*sizeof(char) <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
badSink <start> data <end> );
static void badSink(size_t <start> data <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSink <start> data <end> );
static void badSink(size_t <start> data <end> );
myString = (char *)malloc <start> data*sizeof(char) <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
myString = (char *)malloc <start> data*sizeof(char) <end> );
badSink <start> data <end> );
static void badSink(size_t <start> data <end> );"	2
93ece317-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #define HELLO_STRING ""hello"" namespace CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_62 { void badSource(size_t &data); void bad() { size_t data; data = 0; badSource(data); { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); } else { printLine(""Input is less than the length of the source string""); } } }"	where is the vulnerable dataflow from data to malloc ?	"myString = (char *)malloc <start> data*sizeof(char) <end> );
<start> printLine(myString) <end> ;"	"<start> printLine(myString) <end> ;
badSource <start> data <end> );"	"myString = (char *)malloc <start> data*sizeof(char) <end> );
badSource <start> data <end> );"	"badSource <start> data <end> );
myString = (char *)malloc <start> data*sizeof(char) <end> );"	3
93ece30d-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING ""hello"" typedef union { size_t unionFirst; size_t unionSecond; } CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_34_unionType; void CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_34_bad() { size_t data; CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_34_unionType myUnion; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = strtoul(inputBuffer, NULL, 0); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } myUnion.unionFirst = data; { size_t data = myUnion.unionSecond; { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); } else { printLine(""Input is less than the length of the source string""); } } } }"	where is the vulnerable dataflow from data to malloc ?	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
myString = (char *)malloc <start> data*sizeof(char) <end> );"	"data = <start> strtoul(inputBuffer, NULL, 0) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
myString = (char *)malloc <start> data*sizeof(char) <end> );"	"acceptSocket = <start> accept(listenSocket, NULL, NULL) <end> ;
myString = (char *)malloc <start> data*sizeof(char) <end> );"	2
bb49c58f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #define EXECL _execl #else #define EXECL execl #endif typedef union { char * unionFirst; char * unionSecond; } CWE78_OS_Command_Injection__char_console_execl_34_unionType; void CWE78_OS_Command_Injection__char_console_execl_34_bad() { char * data; CWE78_OS_Command_Injection__char_console_execl_34_unionType myUnion; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } myUnion.unionFirst = data; { char * data = myUnion.unionSecond; EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL); } }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECL ?	"char <start> dataBuffer[100] = COMMAND_ARG2 <end> ;
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
<start> EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
size_t dataLen = <start> strlen(data) <end> ;"	2
846ad343-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) typedef union { int unionFirst; int unionSecond; } CWE369_Divide_by_Zero__int_connect_socket_divide_34_unionType; void CWE369_Divide_by_Zero__int_connect_socket_divide_34_bad() { int data; CWE369_Divide_by_Zero__int_connect_socket_divide_34_unionType myUnion; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } myUnion.unionFirst = data; { int data = myUnion.unionSecond; printIntLine(100 / data); } }"	where is the vulnerable dataflow from data to printIntLine ?	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> 100 / data <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> 100 / data <end> );"	"printIntLine <start> 100 / data <end> );
recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);"	"printIntLine <start> 100 / data <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	1
8df421e0-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define PATH_SZ 100 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define PATH_SZ PATH_MAX #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 void CWE605_Multiple_Binds_Same_Port__basic_15_bad() { switch(6) { case 6: { char data[100] = """"; #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); #ifdef _WIN32 BOOL bOptVal = TRUE; int bOptLen = sizeof(BOOL); #else int bOptVal = 1; int bOptLen = sizeof(int); #endif do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } if (setsockopt(listenSocket, SOL_SOCKET, SO_REUSEADDR, (char*)&bOptVal, bOptLen) != 0) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, data+dataLen, (int)(100-dataLen-1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[recvResult] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif printLine(data); } break; default: printLine(""Benign, fixed string""); break; } }"	where is the vulnerable dataflow from data to printLine ?	"size_t dataLen = <start> strlen(data) <end> ;
recvResult = recv(acceptSocket, <start> data+dataLen <end> , (int)(100-dataLen-1), 0);"	"printLine <start> data <end> );
char <start> data[100] = """" <end> ;"	"printLine <start> data <end> );
recvResult = recv(acceptSocket, <start> data+dataLen <end> , (int)(100-dataLen-1), 0);"	"recvResult = recv(acceptSocket, <start> data+dataLen <end> , (int)(100-dataLen-1), 0);
printLine <start> data <end> );"	3
8a6310db-6c15-11ed-81d4-94e6f77dd552	#ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_file_open_82 { void CWE36_Absolute_Path_Traversal__char_file_open_82_bad::action(char * data) { { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } } }	where is the vulnerable dataflow from data to OPEN ?	"void CWE36_Absolute_Path_Traversal__char_file_open_82_bad::action(char * <start> data <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
void CWE36_Absolute_Path_Traversal__char_file_open_82_bad::action(char * <start> data <end> );"	"void CWE36_Absolute_Path_Traversal__char_file_open_82_bad::action(char * <start> data <end> );
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	0
5133a755-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_preinc_02_bad() { int data; data = 0; if(1) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(1) { { ++data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
int <start> result = data <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
+ <start> data <end> ;"	"<start> printIntLine(result) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"<start> ++data <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	1
c01af8f1-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif static int staticTrue = 1; static int staticFalse = 0; namespace CWE23_Relative_Path_Traversal__char_console_fopen_05 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(staticTrue) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
dataLen = <start> strlen(data) <end> ;"	"pFile = FOPEN <start> data <end> , ""wb+"");
<start> data = dataBuffer <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	2
c26a7e4b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_console_open_34 { typedef union { char * unionFirst; char * unionSecond; } unionType; void bad() { char * data; unionType myUnion; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } } }"	where is the vulnerable dataflow from data to OPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"char <start> * data = myUnion.unionSecond <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"<start> data = dataBuffer <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	1
73bc8132-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" void CWE194_Unexpected_Sign_Extension__connect_socket_malloc_66b_badSink(short dataArray[]) { short data = dataArray[2]; if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }"	where is the vulnerable dataflow from data to malloc ?	"void CWE194_Unexpected_Sign_Extension__connect_socket_malloc_66b_badSink(short <start> dataArray <end> []);
char * dataBuffer = (char *)malloc <start> data <end> );"	"char * dataBuffer = (char *)malloc <start> data <end> );
if  <start> data < 100 <end> );"	"memset(dataBuffer, 'A', <start> data-1 <end> );
void CWE194_Unexpected_Sign_Extension__connect_socket_malloc_66b_badSink(short <start> dataArray <end> []);"	"char * dataBuffer = (char *)malloc <start> data <end> );
memset(dataBuffer, 'A', <start> data-1 <end> );"	0
964cdc00-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define EXECL _execl #else #define EXECL execl #endif void CWE78_OS_Command_Injection__char_listen_socket_execl_17_bad() { int i; char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; for(i = 0; i < 1; i++) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from data to sizeof ?	recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);	size_t <start> dataLen = strlen(data) <end> ;	size_t dataLen = <start> strlen(data) <end> ;	recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (100 - dataLen - 1), 0);	0
ba102b87-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define EXECL _execl #else #define EXECL execl #endif void CWE78_OS_Command_Injection__char_connect_socket_execl_18_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; goto source; source: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECL ?	"size_t <start> dataLen = strlen(data) <end> ;
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
replace = <start> strchr(data, '\n') <end> ;"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"size_t dataLen = <start> strlen(data) <end> ;
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	2
4ec5d065-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_postinc_64b_badSink(void * dataVoidPtr) { int * dataPtr = (int *)dataVoidPtr; int data = (*dataPtr); { data++; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"<start> data <end> ++;
void CWE190_Integer_Overflow__int_connect_socket_postinc_64b_badSink(void * <start> dataVoidPtr <end> );"	"void CWE190_Integer_Overflow__int_connect_socket_postinc_64b_badSink(void * <start> dataVoidPtr <end> );
<start> printIntLine(result) <end> ;"	"int <start> result = data <end> ;
<start> data <end> ++;"	"void CWE190_Integer_Overflow__int_connect_socket_postinc_64b_badSink(void * <start> dataVoidPtr <end> );
<start> data <end> ++;"	3
c9919809-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" namespace CWE36_Absolute_Path_Traversal__char_connect_socket_ifstream_12 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(globalReturnsTrueOrFalse()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } else { #ifdef _WIN32 strcat(data, ""c:\\temp\\file.txt""); #else strcat(data, ""/tmp/file.txt""); #endif } { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - <start> dataLen - 1 <end> ), 0);
inputFile.open((char * <start> data <end> );"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
inputFile.open((char * <start> data <end> );"	"inputFile.open((char * <start> data <end> );
replace = <start> strchr(data, '\n') <end> ;"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
replace = <start> strchr(data, '\n') <end> ;"	1
9b124d9e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE124_Buffer_Underwrite__CWE839_listen_socket_09_bad() { int data; data = -1; if(GLOBAL_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(GLOBAL_CONST_TRUE) { { int i; int buffer[10] = { 0 }; if (data < 10) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } } } }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
if  <start> acceptSocket == SOCKET_ERROR <end> );"	"if  <start> acceptSocket == SOCKET_ERROR <end> );
printIntLine <start> buffer[i] <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[i] <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
data = <start> atoi(inputBuffer) <end> ;"	2
79b2753e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) typedef struct _CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_67_structType { int structFirst; } CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_67_structType; void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_67b_badSink(CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_67_structType myStruct) { int data = myStruct.structFirst; if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }"	where is the vulnerable dataflow from data to malloc ?	"char * dataBuffer = (char *)malloc <start> data <end> );
void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_67b_badSink(CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_67_structType <start> myStruct <end> );
int data = <start> myStruct <end> .structFirst;"	"void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_67b_badSink(CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_67_structType <start> myStruct <end> );
<start> printLine(dataBuffer) <end> ;
int data = <start> myStruct <end> .structFirst;"	"<start> memset(dataBuffer, 'A', data-1) <end> ;
char * dataBuffer = (char *)malloc <start> data <end> );
void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_67b_badSink(CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_67_structType <start> myStruct <end> );"	"void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_67b_badSink(CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_67_structType <start> myStruct <end> );
int data = <start> myStruct <end> .structFirst;
char * dataBuffer = (char *)malloc <start> data <end> );"	3
a95fd834-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink(int data) { if(data < 0) { int result = data * 2; printIntLine(result); } } void CWE191_Integer_Underflow__int_fgets_multiply_41_bad() { int data; data = 0; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } badSink(data); }"	where is the vulnerable dataflow from result to printIntLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );
badSink <start> data <end> );
<start> badSink(data) <end> ;"	"<start> badSink(data) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
static void badSink(int <start> data <end> );
badSink <start> data <end> );"	"badSink <start> data <end> );
<start> printIntLine(result) <end> ;
static void badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
badSink <start> data <end> );
static void badSink(int <start> data <end> );
printIntLine <start> result <end> );"	3
893217ea-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_console_open_17 { void bad() { int i; char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; for(i = 0; i < 1; i++) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
size_t dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = OPEN(data, O_RDWR|O_CREAT, <start> S_IREAD|S_IWRITE <end> );"	1
9187cbfa-6c15-11ed-81d4-94e6f77dd552	"#define SEARCH_CHAR 'S' void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_console_11_bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\0'; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } if(globalReturnsTrue()) { for (; *data != '\0'; data++) { if (*data == SEARCH_CHAR) { printLine(""We have a match!""); break; } } free(data); } }"	where is the vulnerable dataflow from data to free ?	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
if  <start> data == NULL <end> ) {exit(-1);};"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
free <start> data <end> );"	"if (dataLen > 0 && <start> data[dataLen-1] == '\n' <end> );
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	2
73bc816e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" void CWE194_Unexpected_Sign_Extension__connect_socket_memmove_09_bad() { short data; data = 0; if(GLOBAL_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printLine(dest) <end> ;"	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printLine <start> dest <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> memmove(dest, source, data) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	3
c72d5d4c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif static int staticTrue = 1; static int staticFalse = 0; namespace CWE23_Relative_Path_Traversal__char_listen_socket_fopen_05 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(staticTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = FOPEN <start> data <end> , ""wb+"");
<start> recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0) <end> ;"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
<start> recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0) <end> ;"	1
b6848509-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define NEW_PATH ""%SystemRoot%\\system32"" #define PUTENV _putenv #else #define NEW_PATH ""/bin"" #define PUTENV putenv #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" static int badStatic = 0; static char * badSource(char * data) { if(badStatic) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (250 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } return data; } void CWE427_Uncontrolled_Search_Path_Element__char_connect_socket_21_bad() { char * data; char dataBuffer[250] = ""PATH=""; data = dataBuffer; badStatic = 1; data = badSource(data); PUTENV(data); }"	where is the vulnerable dataflow from data to PUTENV ?	"size_t dataLen = <start> strlen(data) <end> ;
PUTENV <start> data <end> );
data = <start> badSource <end> (data);
static char * <start> badSource <end> (char * data);"	"PUTENV <start> data <end> );
data = <start> badSource <end> (data);
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (250 - dataLen - 1), 0);
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (250 - dataLen - 1), 0);"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (250 - dataLen - 1), 0);
PUTENV <start> data <end> );
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (250 - dataLen - 1), 0);
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
PUTENV <start> data <end> );"	3
7c12759c-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_53d_badSink(int data) { { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"printLine <start> dest <end> );
<start> printLine(dest) <end> ;"	"void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_53d_badSink(int <start> data <end> );
printLine <start> dest <end> );"	"if  <start> data < 100 <end> );
void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_53d_badSink(int <start> data <end> );"	"printLine <start> dest <end> );
char <start> dest[100] = """" <end> ;"	1
820a46c6-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_file_fopen_44 { static void badSink(char * data) { { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } } void bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } funcPtr(data); }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = FOPEN <start> data <end> , ""wb+"");
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
static void badSink(char * <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
funcPtr <start> data <end> );
static void badSink(char * <start> data <end> );
pFile = FOPEN <start> data <end> , ""wb+"");"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
<start> data = dataBuffer <end> ;
funcPtr <start> data <end> );
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
funcPtr <start> data <end> );
pFile = <start> FOPEN(data, ""wb+"") <end> ;
static void badSink(char * <start> data <end> );"	1
9fe7ad34-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 namespace CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_82 { void bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_82_base* baseObject = new CWE134_Uncontrolled_Format_String__char_listen_socket_fprintf_82_bad; baseObject->action(data); delete baseObject; }"	where is the vulnerable dataflow from data to action ?	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
baseObject->action <start> data <end> );"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
char <start> dataBuffer[100] = """" <end> ;"	"if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"baseObject->action <start> data <end> );
char <start> dataBuffer[100] = """" <end> ;"	0
598370c2-6c15-11ed-81d4-94e6f77dd552	"void CWE191_Integer_Underflow__short_fscanf_sub_14_bad() { short data; data = 0; if(globalFive==5) { fscanf (stdin, ""%hd"", &data); } if(globalFive==5) { { short result = data - 1; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"fscanf (stdin, ""%hd"", <start> &data <end> );
short result = <start> data <end>  - 1;"	"short result = <start> data - 1 <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );"	"short result = <start> data <end>  - 1;
<start> data = 0 <end> ;"	"<start> printIntLine(result) <end> ;
short result = <start> data <end>  - 1;"	0
b08640fd-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE197_Numeric_Truncation_Error__int_listen_socket_to_char_01_bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { char charData = (char)data; printHexCharLine(charData); } }"	where is the vulnerable dataflow from charData to printHexCharLine ?	"printHexCharLine <start> charData <end> );
<start> printHexCharLine(charData) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printHexCharLine <start> charData <end> );"	"printHexCharLine <start> charData <end> );
char charData = <start> (char)data <end> ;"	"char <start> charData = (char)data <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	1
c991980c-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" namespace CWE36_Absolute_Path_Traversal__char_connect_socket_ifstream_15 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; switch(6) { case 6: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; default: printLine(""Benign, fixed string""); break; } { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"recvResult = <start> recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0) <end> ;
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"replace = <start> strchr(data, '\r') <end> ;
inputFile.open((char * <start> data <end> );"	"inputFile.open((char * <start> data <end> );
<start> data = dataBuffer <end> ;"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
inputFile.open((char * <start> data <end> );"	3
a36a78f7-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) typedef union { int unionFirst; int unionSecond; } CWE190_Integer_Overflow__int_listen_socket_add_34_unionType; void CWE190_Integer_Overflow__int_listen_socket_add_34_bad() { int data; CWE190_Integer_Overflow__int_listen_socket_add_34_unionType myUnion; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } myUnion.unionFirst = data; { int data = myUnion.unionSecond; { int result = data + 1; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"int <start> result = data + 1 <end> ;
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
if  <start> recvResult == SOCKET_ERROR <end>  || recvResult == 0);"	0
8a6310a1-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_file_fopen_31 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } { char * dataCopy = data; char * data = dataCopy; { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } } }"	where is the vulnerable dataflow from data to FOPEN ?	"char <start> * data = dataCopy <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
size_t dataLen = <start> strlen(data) <end> ;"	"size_t dataLen = <start> strlen(data) <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
pFile = FOPEN <start> data <end> , ""wb+"");"	3
b1b8082f-6c15-11ed-81d4-94e6f77dd552	int CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_22_badGlobal = 0; int CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_22_badSource(int data); void CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_22_bad() { int data; data = -1; CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_22_badGlobal = 1; data = CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_22_badSource(data); { short shortData = (short)data; printShortLine(shortData); } }	where is the vulnerable dataflow from shortData to printShortLine ?	"short <start> shortData = (short)data <end> ;
printShortLine <start> shortData <end> );"	"data = <start> CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_22_badSource <end> (data);
printShortLine <start> shortData <end> );"	"data = <start> CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_22_badSource <end> (data);
<start> printShortLine(shortData) <end> ;"	"printShortLine <start> shortData <end> );
data = <start> CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_22_badSource <end> (data);"	1
cbf237aa-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_console_fopen_13 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(GLOBAL_CONST_FIVE==5) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
dataLen = <start> strlen(data) <end> ;"	"pFile = FOPEN <start> data <end> , ""wb+"");
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
pFile = FOPEN <start> data <end> , ""wb+"");"	3
b7b09a6b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define NEW_PATH ""%SystemRoot%\\system32"" #define PUTENV _putenv #else #define NEW_PATH ""/bin"" #define PUTENV putenv #endif namespace CWE427_Uncontrolled_Search_Path_Element__char_file_62 { void badSource(char * &data); void bad() { char * data; char dataBuffer[250] = ""PATH=""; data = dataBuffer; badSource(data); PUTENV(data); }"	where is the vulnerable dataflow from data to PUTENV ?	"PUTENV <start> data <end> );
<start> data = dataBuffer <end> ;"	"PUTENV <start> data <end> );
badSource <start> data <end> );"	"PUTENV <start> data <end> );
<start> badSource(data) <end> ;"	"badSource <start> data <end> );
PUTENV <start> data <end> );"	3
78800fb7-6c15-11ed-81d4-94e6f77dd552	"int CWE194_Unexpected_Sign_Extension__listen_socket_memmove_22_badGlobal = 0; short CWE194_Unexpected_Sign_Extension__listen_socket_memmove_22_badSource(short data); void CWE194_Unexpected_Sign_Extension__listen_socket_memmove_22_bad() { short data; data = 0; CWE194_Unexpected_Sign_Extension__listen_socket_memmove_22_badGlobal = 1; data = CWE194_Unexpected_Sign_Extension__listen_socket_memmove_22_badSource(data); { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"data = <start> CWE194_Unexpected_Sign_Extension__listen_socket_memmove_22_badSource <end> (data);
printLine <start> dest <end> );"	"<start> memmove(dest, source, data) <end> ;
printLine <start> dest <end> );"	"data = <start> CWE194_Unexpected_Sign_Extension__listen_socket_memmove_22_badSource <end> (data);
if  <start> data < 100 <end> );"	"<start> data = CWE194_Unexpected_Sign_Extension__listen_socket_memmove_22_badSource(data) <end> ;
printLine <start> dest <end> );"	0
cbf237e0-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif namespace CWE36_Absolute_Path_Traversal__char_console_ifstream_51 { void badSink(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } badSink(data); }"	where is the vulnerable dataflow from data to badSink ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
<start> badSink(data) <end> ;"	"badSink <start> data <end> );
dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
badSink <start> data <end> );"	"badSink <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	2
a36a78da-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_square_65b_badSink(int data) { { int result = data * data; printIntLine(result); } }	where is the vulnerable dataflow from result to printIntLine ?	"<start> printIntLine(result) <end> ;
void CWE190_Integer_Overflow__int_fgets_square_65b_badSink(int <start> data <end> );"	"int <start> result = data * data <end> ;
void CWE190_Integer_Overflow__int_fgets_square_65b_badSink(int <start> data <end> );"	"printIntLine <start> result <end> );
int <start> result = data * data <end> ;"	"void CWE190_Integer_Overflow__int_fgets_square_65b_badSink(int <start> data <end> );
printIntLine <start> result <end> );"	3
92bb8a23-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING ""hello"" void CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_14_bad() { size_t data; data = 0; if(globalFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = strtoul(inputBuffer, NULL, 0); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalFive==5) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); } else { printLine(""Input is less than the length of the source string""); } } } }"	where is the vulnerable dataflow from data to malloc ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
myString = (char *)malloc <start> data*sizeof(char) <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
if  <start> data > strlen(HELLO_STRING) <end> );"	"<start> data = strtoul(inputBuffer, NULL, 0) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"myString = (char *)malloc <start> data*sizeof(char) <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	0
9187cbfb-6c15-11ed-81d4-94e6f77dd552	"#define SEARCH_CHAR 'S' void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_console_12_bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\0'; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } if(globalReturnsTrueOrFalse()) { for (; *data != '\0'; data++) { if (*data == SEARCH_CHAR) { printLine(""We have a match!""); break; } } free(data); } else { { size_t i; for (i=0; i < strlen(data); i++) { if (data[i] == SEARCH_CHAR) { printLine(""We have a match!""); break; } } free(data); } } }"	where is the vulnerable dataflow from data to free ?	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
free <start> data <end> );"	"<start> data = (char *)malloc(100*sizeof(char)) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	"for (i=0; i < <start> strlen(data) <end> ; i++);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	1
525b6483-6c15-11ed-81d4-94e6f77dd552	"void CWE190_Integer_Overflow__short_fscanf_preinc_15_bad() { short data; data = 0; switch(6) { case 6: fscanf (stdin, ""%hd"", &data); break; default: printLine(""Benign, fixed string""); break; } switch(7) { case 7: { ++data; short result = data; printIntLine(result); } break; default: printLine(""Benign, fixed string""); break; } }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );"	"fscanf (stdin, ""%hd"", <start> &data <end> );
+ <start> data <end> ;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
<start> ++data <end> ;"	"+ <start> data <end> ;
<start> printIntLine(result) <end> ;"	1
a830bf92-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_connect_socket_sub_02_bad() { int data; data = 0; if(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(1) { { int result = data - 1; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"data = <start> atoi(inputBuffer) <end> ;
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
int <start> result = data - 1 <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data - 1 <end> ;"	2
a36a78d7-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__int_fgets_square_62 { void badSource(int &data); void bad() { int data; data = 0; badSource(data); { int result = data * data; printIntLine(result); } }	where is the vulnerable dataflow from result to printIntLine ?	"badSource <start> data <end> );
printIntLine <start> result <end> );"	"<start> printIntLine(result) <end> ;
badSource <start> data <end> );"	"<start> badSource(data) <end> ;
printIntLine <start> result <end> );"	"badSource <start> data <end> );
<start> badSource(data) <end> ;"	0
73bc8163-6c15-11ed-81d4-94e6f77dd552	"namespace CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_74 { void badSink(map<int, short> dataMap) { short data = dataMap[2]; { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"void badSink(map<int, short> <start> dataMap <end> );
printLine <start> dest <end> );"	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	"printLine <start> dest <end> );
void badSink(map<int, short> <start> dataMap <end> );"	"void badSink(map<int, short> <start> dataMap <end> );
<start> memcpy(dest, source, data) <end> ;"	0
78800fca-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 8 extern short CWE194_Unexpected_Sign_Extension__listen_socket_memmove_68_badData; extern short CWE194_Unexpected_Sign_Extension__listen_socket_memmove_68_goodG2BData; void CWE194_Unexpected_Sign_Extension__listen_socket_memmove_68b_badSink() { short data = CWE194_Unexpected_Sign_Extension__listen_socket_memmove_68_badData; { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> memmove(dest, source, data) <end> ;
printLine <start> dest <end> );"	"<start> printLine(dest) <end> ;
short data = <start> CWE194_Unexpected_Sign_Extension__listen_socket_memmove_68_badData <end> ;"	"short data = <start> CWE194_Unexpected_Sign_Extension__listen_socket_memmove_68_badData <end> ;
printLine <start> dest <end> );"	"short data = <start> CWE194_Unexpected_Sign_Extension__listen_socket_memmove_68_badData <end> ;
<start> memmove(dest, source, data) <end> ;"	2
93ece2c8-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING ""hello"" void CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_66b_badSink(size_t dataArray[]) { size_t data = dataArray[2]; { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); } else { printLine(""Input is less than the length of the source string""); } } }"	where is the vulnerable dataflow from data to malloc ?	"void CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_66b_badSink(size_t <start> dataArray <end> []);
myString = (char *)malloc <start> data*sizeof(char) <end> );"	"myString = <start> (char *)malloc(data*sizeof(char)) <end> ;
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_66b_badSink(size_t <start> dataArray <end> []);"	"myString = <start> (char *)malloc(data*sizeof(char)) <end> ;
myString = (char *)malloc <start> data*sizeof(char) <end> );"	"myString = (char *)malloc <start> data*sizeof(char) <end> );
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_66b_badSink(size_t <start> dataArray <end> []);"	0
a49c4f50-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_multiply_53d_badSink(int data) { if(data > 0) { int result = data * 2; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"void CWE190_Integer_Overflow__int_listen_socket_multiply_53d_badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
int <start> result = data * 2 <end> ;"	"void CWE190_Integer_Overflow__int_listen_socket_multiply_53d_badSink(int <start> data <end> );
int <start> result = data * 2 <end> ;"	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	0
b8e2bd9e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define NEW_PATH ""%SystemRoot%\\system32"" #define PUTENV _putenv #else #define NEW_PATH ""/bin"" #define PUTENV putenv #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 void CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_13_bad() { char * data; char dataBuffer[250] = ""PATH=""; data = dataBuffer; if(GLOBAL_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (250 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } PUTENV(data); }"	where is the vulnerable dataflow from data to PUTENV ?	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (250 - dataLen - 1), 0);
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (250 - dataLen - 1), 0);"	"size_t dataLen = <start> strlen(data) <end> ;
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (250 - dataLen - 1), 0);"	"PUTENV <start> data <end> );
<start> data = dataBuffer <end> ;"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (250 - dataLen - 1), 0);
PUTENV <start> data <end> );"	3
9187cc0e-6c15-11ed-81d4-94e6f77dd552	"#define SEARCH_CHAR 'S' void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_console_66b_badSink(char * dataArray[]) { char * data = dataArray[2]; for (; *data != '\0'; data++) { if (*data == SEARCH_CHAR) { printLine(""We have a match!""); break; } } free(data); }"	where is the vulnerable dataflow from data to free ?	"<start> free(data) <end> ;
void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_console_66b_badSink(char * <start> dataArray <end> []);"	"void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_console_66b_badSink(char * <start> dataArray <end> []);
free <start> data <end> );"	"for (; *data != '\0'; <start> data++ <end> );
free <start> data <end> );"	"free <start> data <end> );
void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_console_66b_badSink(char * <start> dataArray <end> []);"	1
7fa68e17-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_63b_badSink(int * dataPtr) { int data = *dataPtr; { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> strncpy(dest, source, data) <end> ;
printLine <start> dest <end> );"	"void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_63b_badSink(int * <start> dataPtr <end> );
<start> strncpy(dest, source, data) <end> ;"	"<start> printLine(dest) <end> ;
void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_63b_badSink(int * <start> dataPtr <end> );"	"void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_63b_badSink(int * <start> dataPtr <end> );
printLine <start> dest <end> );"	3
b7b09a55-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define NEW_PATH ""%SystemRoot%\\system32"" #define PUTENV _putenv #else #define NEW_PATH ""/bin"" #define PUTENV putenv #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif static int staticFive = 5; void CWE427_Uncontrolled_Search_Path_Element__char_file_07_bad() { char * data; char dataBuffer[250] = ""PATH=""; data = dataBuffer; if(staticFive==5) { { size_t dataLen = strlen(data); FILE * pFile; if (250-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(250-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } PUTENV(data); }"	where is the vulnerable dataflow from data to PUTENV ?	"char <start> dataBuffer[250] = ""PATH="" <end> ;
PUTENV <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(250-dataLen), pFile) == NULL);
PUTENV <start> data <end> );"	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(250-dataLen), pFile) == NULL);"	"<start> PUTENV(data) <end> ;
PUTENV <start> data <end> );"	1
9ebc76dd-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE127_Buffer_Underread__CWE839_listen_socket_31_bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { int dataCopy = data; int data = dataCopy; { int buffer[10] = { 0 }; if (data < 10) { printIntLine(buffer[data]); } else { printLine(""ERROR: Array index is too big.""); } } } }"	where is the vulnerable dataflow from buffer[data] to printIntLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
data = <start> atoi(inputBuffer) <end> ;"	"<start> printIntLine(buffer[data]) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[data] <end> );"	3
b8e2bd9d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define NEW_PATH ""%SystemRoot%\\system32"" #define PUTENV _putenv #else #define NEW_PATH ""/bin"" #define PUTENV putenv #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 void CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_12_bad() { char * data; char dataBuffer[250] = ""PATH=""; data = dataBuffer; if(globalReturnsTrueOrFalse()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (250 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } else { strcat(data, NEW_PATH); } PUTENV(data); }"	where is the vulnerable dataflow from data to PUTENV ?	"PUTENV <start> data <end> );
<start> data = dataBuffer <end> ;"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (250 - dataLen - 1), 0);
PUTENV <start> data <end> );"	"PUTENV <start> data <end> );
<start> strcat(data, NEW_PATH) <end> ;"	"size_t dataLen = <start> strlen(data) <end> ;
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (250 - dataLen - 1), 0);"	1
c72d5d3d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_file_open_62 { void badSource(char * &data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; badSource(data); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
badSource <start> data <end> );"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"badSource <start> data <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
char <start> dataBuffer[FILENAME_MAX] = BASEPATH <end> ;"	2
466e7ec6-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_add_66b_badSink(int dataArray[]) { int data = dataArray[2]; { int result = data + 1; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  + 1;
void CWE190_Integer_Overflow__int_fgets_add_66b_badSink(int <start> dataArray <end> []);"	"int <start> result = data + 1 <end> ;
void CWE190_Integer_Overflow__int_fgets_add_66b_badSink(int <start> dataArray <end> []);"	"void CWE190_Integer_Overflow__int_fgets_add_66b_badSink(int <start> dataArray <end> []);
int result = <start> data <end>  + 1;"	"<start> printIntLine(result) <end> ;
void CWE190_Integer_Overflow__int_fgets_add_66b_badSink(int <start> dataArray <end> []);"	2
86cea140-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE369_Divide_by_Zero__int_fgets_modulo_43 { static void badSource(int &data) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } void bad() { int data; data = -1; badSource(data); printIntLine(100 % data); }"	where is the vulnerable dataflow from data to printIntLine ?	"badSource <start> data <end> );
<start> badSource(data) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
badSource <start> data <end> );
printIntLine <start> 100 % data <end> );"	"<start> badSource(data) <end> ;
printIntLine <start> 100 % data <end> );
badSource <start> data <end> );"	"printIntLine <start> 100 % data <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
badSource <start> data <end> );"	1
b54bcf1f-6c15-11ed-81d4-94e6f77dd552	namespace CWE369_Divide_by_Zero__float_fgets_82 { void CWE369_Divide_by_Zero__float_fgets_82_bad::action(float data) { { int result = (int)(100.0 / data); printIntLine(result); } } }	where is the vulnerable dataflow from result to printIntLine ?	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	"void CWE369_Divide_by_Zero__float_fgets_82_bad::action(float <start> data <end> );
<start> printIntLine(result) <end> ;"	"void CWE369_Divide_by_Zero__float_fgets_82_bad::action(float <start> data <end> );
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
void CWE369_Divide_by_Zero__float_fgets_82_bad::action(float <start> data <end> );"	2
9d745378-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE126_Buffer_Overread__CWE129_listen_socket_15_bad() { int data; data = -1; switch(6) { case 6: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; default: printLine(""Benign, fixed string""); break; } switch(7) { case 7: { int buffer[10] = { 0 }; if (data >= 0) { printIntLine(buffer[data]); } else { printLine(""ERROR: Array index is negative""); } } break; default: printLine(""Benign, fixed string""); break; } }"	where is the vulnerable dataflow from buffer[data] to printIntLine ?	"if  <start> listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR <end> );
printIntLine <start> buffer[data] <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
data = <start> atoi(inputBuffer) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[data] <end> );"	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> buffer[data] <end> );"	2
d31a252d-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_listen_socket_open_54 { void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badSink_b(data); }"	where is the vulnerable dataflow from data to badSink_b ?	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
badSink_b <start> data <end> );"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
if  <start> recvResult == SOCKET_ERROR <end>  || recvResult == 0);"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
replace = <start> strchr(data, '\r') <end> ;"	"badSink_b <start> data <end> );
replace = <start> strchr(data, '\r') <end> ;"	0
774f57ff-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 8 typedef struct _CWE194_Unexpected_Sign_Extension__fgets_strncpy_67_structType { short structFirst; } CWE194_Unexpected_Sign_Extension__fgets_strncpy_67_structType; void CWE194_Unexpected_Sign_Extension__fgets_strncpy_67b_badSink(CWE194_Unexpected_Sign_Extension__fgets_strncpy_67_structType myStruct) { short data = myStruct.structFirst; { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"char <start> dest[100] = """" <end> ;
short data = <start> myStruct <end> .structFirst;
printLine <start> dest <end> );"	"short data = <start> myStruct <end> .structFirst;
<start> strncpy(dest, source, data) <end> ;
printLine <start> dest <end> );"	"void CWE194_Unexpected_Sign_Extension__fgets_strncpy_67b_badSink(CWE194_Unexpected_Sign_Extension__fgets_strncpy_67_structType <start> myStruct <end> );
short data = <start> myStruct <end> .structFirst;
printLine <start> dest <end> );"	"<start> printLine(dest) <end> ;
void CWE194_Unexpected_Sign_Extension__fgets_strncpy_67b_badSink(CWE194_Unexpected_Sign_Extension__fgets_strncpy_67_structType <start> myStruct <end> );
short data = <start> myStruct <end> .structFirst;"	2
cf875085-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_environment_open_12 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(globalReturnsTrueOrFalse()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } } else { #ifdef _WIN32 strcat(data, ""c:\\temp\\file.txt""); #else strcat(data, ""/tmp/file.txt""); #endif } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
size_t <start> dataLen = strlen(data) <end> ;"	"size_t dataLen = <start> strlen(data) <end> ;
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);"	2
c4cd6f4b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_environment_open_52 { void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } badSink_b(data); }"	where is the vulnerable dataflow from data to badSink_b ?	"strncat(data+dataLen, environment, <start> FILENAME_MAX-dataLen-1 <end> );
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
char <start> dataBuffer[FILENAME_MAX] = BASEPATH <end> ;"	"size_t dataLen = <start> strlen(data) <end> ;
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
badSink_b <start> data <end> );"	3
9059f3b8-6c15-11ed-81d4-94e6f77dd552	namespace CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_81 { void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_81_bad::action(int data) const { { size_t i; int *intPointer; intPointer = (int*)malloc(data * sizeof(int)); if (intPointer == NULL) {exit(-1);} for (i = 0; i < (size_t)data; i++) { intPointer[i] = 0; } printIntLine(intPointer[0]); free(intPointer); } } }	where is the vulnerable dataflow from data to malloc ?	"intPointer = (int*)malloc <start> data * sizeof(int) <end> );
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_81_bad::action(int <start> data <end> ) const;"	"void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_81_bad::action(int <start> data <end> ) const;
intPointer = <start> (int*)malloc(data * sizeof(int)) <end> ;"	"intPointer = <start> (int*)malloc(data * sizeof(int)) <end> ;
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	"void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_81_bad::action(int <start> data <end> ) const;
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	3
79b27521-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_09_bad() { int data; data = -1; if(GLOBAL_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }"	where is the vulnerable dataflow from data to malloc ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
char * dataBuffer = (char *)malloc <start> data <end> );"	"memset(dataBuffer, 'A', <start> data-1 <end> );
char * dataBuffer = (char *)malloc <start> data <end> );"	"char * dataBuffer = (char *)malloc <start> data <end> );
char * dataBuffer = (char * <start> malloc(data) <end> ;"	"char * dataBuffer = (char *)malloc <start> data <end> );
<start> data = atoi(inputBuffer) <end> ;"	0
54c58218-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_connect_socket_sub_17_bad() { int i,j; int data; data = 0; for(i = 0; i < 1; i++) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } for(j = 0; j < 1; j++) { { int result = data - 1; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  - 1;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  - 1;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printIntLine(result) <end> ;"	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
int result = <start> data <end>  - 1;"	1
9d745395-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE127_Buffer_Underread__CWE839_connect_socket_16_bad() { int data; data = -1; while(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; } while(1) { { int buffer[10] = { 0 }; if (data < 10) { printIntLine(buffer[data]); } else { printLine(""ERROR: Array index is too big.""); } } break; } }"	where is the vulnerable dataflow from buffer[data] to printIntLine ?	"int <start> buffer[10] = { 0 } <end> ;
printIntLine <start> buffer[data] <end> );"	"data = <start> atoi(inputBuffer) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[data] <end> );"	"recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);
printIntLine <start> buffer[data] <end> );"	2
99e16a80-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_listen_socket_10 { void bad() { int data; data = -1; if(globalTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalTrue) { { int i; int * buffer = new int[10]; for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } delete[] buffer; } } }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"<start> printIntLine(buffer[i]) <end> ;
printIntLine <start> buffer[i] <end> );"	"printIntLine <start> buffer[i] <end> );
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"printIntLine <start> buffer[i] <end> );
data = <start> atoi(inputBuffer) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[i] <end> );"	3
6ef7685b-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif static int badStatic = 0; static void badVaSink(char * data, ...) { if(badStatic) { { va_list args; va_start(args, data); vprintf(data, args); va_end(args); } } } void CWE134_Uncontrolled_Format_String__char_console_vprintf_21_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } badStatic = 1; badVaSink(data, data); }"	where is the vulnerable dataflow from data to vprintf ?	"<start> vprintf(data, args) <end> ;
vprintf <start> data <end> , args);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
badVaSink <start> data <end> , data);"	"size_t dataLen = <start> strlen(data) <end> ;
vprintf <start> data <end> , args);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
badVaSink <start> data <end> , data);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
vprintf <start> data <end> , args);"	"badVaSink <start> data <end> , data);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
<start> vprintf(data, args) <end> ;
static void badVaSink(char * <start> data <end> , ...);"	2
79b2752e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) typedef union { int unionFirst; int unionSecond; } CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_34_unionType; void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_34_bad() { int data; CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_34_unionType myUnion; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } myUnion.unionFirst = data; { int data = myUnion.unionSecond; if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } } }"	where is the vulnerable dataflow from data to malloc ?	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
char * dataBuffer = (char *)malloc <start> data <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
char * dataBuffer = (char *)malloc <start> data <end> );"	"memset(dataBuffer, 'A', <start> data-1 <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"char * dataBuffer = (char *)malloc <start> data <end> );
int <start> data = myUnion.unionSecond <end> ;"	1
774f5830-6c15-11ed-81d4-94e6f77dd552	namespace CWE194_Unexpected_Sign_Extension__listen_socket_malloc_81 { void CWE194_Unexpected_Sign_Extension__listen_socket_malloc_81_bad::action(short data) const { if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } } }	where is the vulnerable dataflow from data to malloc ?	"memset(dataBuffer, 'A', <start> data-1 <end> );
char * dataBuffer = (char *)malloc <start> data <end> );"	"<start> memset(dataBuffer, 'A', data-1) <end> ;
void CWE194_Unexpected_Sign_Extension__listen_socket_malloc_81_bad::action(short <start> data <end> ) const;"	"void CWE194_Unexpected_Sign_Extension__listen_socket_malloc_81_bad::action(short <start> data <end> ) const;
char * dataBuffer = (char *)malloc <start> data <end> );"	"char <start> * dataBuffer = (char *)malloc(data) <end> ;
char * dataBuffer = (char *)malloc <start> data <end> );"	2
833ac958-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif void CWE252_Unchecked_Return_Value__char_fgets_02_bad() { if(1) { { char dataBuffer[100] = """"; char * data = dataBuffer; printLine(""Please enter a string: ""); fgets(data, 100, stdin); printLine(data); } } }"	where is the vulnerable dataflow from data to printLine ?	"fgets <start> data <end> , 100, stdin);
printLine <start> data <end> );"	"fgets <start> data <end> , 100, stdin);
char <start> dataBuffer[100] = """" <end> ;"	"<start> printLine(data) <end> ;
printLine <start> data <end> );"	"fgets <start> data <end> , 100, stdin);
<start> printLine(data) <end> ;"	0
47a2a7ff-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__int_fgets_square_73 { void badSink(list<int> dataList) { int data = dataList.back(); { int result = data * data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  * data;
<start> printIntLine(result) <end> ;"	"void badSink(list<int> <start> dataList <end> );
<start> printIntLine(result) <end> ;"	"void badSink(list<int> <start> dataList <end> );
int result = <start> data <end>  * data;"	"int result = <start> data <end>  * data;
void badSink(list<int> <start> dataList <end> );"	2
846ad2f0-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif void CWE252_Unchecked_Return_Value__char_fgets_09_bad() { if(GLOBAL_CONST_TRUE) { { char dataBuffer[100] = """"; char * data = dataBuffer; printLine(""Please enter a string: ""); fgets(data, 100, stdin); printLine(data); } } }"	where is the vulnerable dataflow from data to printLine ?	"fgets <start> data <end> , 100, stdin);
<start> fgets(data, 100, stdin) <end> ;"	"printLine <start> data <end> );
<start> fgets(data, 100, stdin) <end> ;"	"fgets <start> data <end> , 100, stdin);
printLine <start> data <end> );"	"<start> printLine(data) <end> ;
fgets <start> data <end> , 100, stdin);"	2
d0b64ee9-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif namespace CWE36_Absolute_Path_Traversal__char_file_ofstream_14 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(globalFive==5) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"<start> data = dataBuffer <end> ;
outputFile.open((char * <start> data <end> );"	"outputFile.open((char * <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
outputFile.open((char * <start> data <end> );"	3
b08640cc-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) extern int CWE197_Numeric_Truncation_Error__int_fgets_to_char_68_badData; extern int CWE197_Numeric_Truncation_Error__int_fgets_to_char_68_goodG2BData; void CWE197_Numeric_Truncation_Error__int_fgets_to_char_68b_badSink() { int data = CWE197_Numeric_Truncation_Error__int_fgets_to_char_68_badData; { char charData = (char)data; printHexCharLine(charData); } }	where is the vulnerable dataflow from charData to printHexCharLine ?	"printHexCharLine <start> charData <end> );
int data = <start> CWE197_Numeric_Truncation_Error__int_fgets_to_char_68_badData <end> ;"	"int data = <start> CWE197_Numeric_Truncation_Error__int_fgets_to_char_68_badData <end> ;
printHexCharLine <start> charData <end> );"	"printHexCharLine <start> charData <end> );
char charData = <start> (char)data <end> ;"	"printHexCharLine <start> charData <end> );
<start> printHexCharLine(charData) <end> ;"	1
93ece31d-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING ""hello"" extern size_t CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_68_badData; extern size_t CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_68_goodG2BData; extern size_t CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_68_goodB2GData; void CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_68b_badSink() { size_t data = CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_68_badData; { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); } else { printLine(""Input is less than the length of the source string""); } } }"	where is the vulnerable dataflow from data to malloc ?	"<start> printLine(myString) <end> ;
myString = (char *)malloc <start> data*sizeof(char) <end> );"	"if  <start> data > strlen(HELLO_STRING) <end> );
myString = (char *)malloc <start> data*sizeof(char) <end> );"	"size_t data = <start> CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_68_badData <end> ;
myString = (char *)malloc <start> data*sizeof(char) <end> );"	"myString = (char *)malloc <start> data*sizeof(char) <end> );
size_t data = <start> CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_68_badData <end> ;"	2
d44c3fc1-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_listen_socket_open_66 { void badSink(char * dataArray[]) { char * data = dataArray[2]; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
void badSink(char * <start> dataArray <end> []);"	"void badSink(char * <start> dataArray <end> []);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
void badSink(char * <start> dataArray <end> []);"	2
cd228141-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif namespace CWE36_Absolute_Path_Traversal__char_console_ofstream_16 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; while(1) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } break; } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
outputFile.open((char * <start> data <end> );"	"size_t dataLen = <start> strlen(data) <end> ;
outputFile.open((char * <start> data <end> );"	"outputFile.open((char * <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"dataLen = <start> strlen(data) <end> ;
outputFile.open((char * <start> data <end> );"	0
73bc8172-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" void CWE194_Unexpected_Sign_Extension__connect_socket_memmove_13_bad() { short data; data = 0; if(GLOBAL_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> printLine(dest) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"<start> memmove(dest, source, data) <end> ;
printLine <start> dest <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"char <start> dest[100] = """" <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	2
6b862460-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_45_badData; static int CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_45_goodG2BData; static int CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_45_goodB2GData; static void badSink() { int data = CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_45_badData; { int i; int * buffer = (int *)malloc(10 * sizeof(int)); if (buffer == NULL) {exit(-1);} for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } free(buffer); } } void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_45_bad() { int data; data = -1; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_45_badData = data; badSink(); }"	where is the vulnerable dataflow from buffer to free ?	"int data = <start> CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_45_badData <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_45_badData = data <end> ;
free <start> buffer <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
int data = <start> CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_45_badData <end> ;
free <start> buffer <end> );
<start> CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_45_badData = data <end> ;
static int <start> CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_45_badData <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_45_badData = data <end> ;
static int <start> CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_45_badData <end> ;
int data = <start> CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_45_badData <end> ;
free <start> buffer <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
int data = <start> CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_45_badData <end> ;
free <start> buffer <end> );
<start> free(buffer) <end> ;
static int <start> CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_45_badData <end> ;"	2
6ef76815-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif void CWE134_Uncontrolled_Format_String__char_console_snprintf_64b_badSink(void * dataVoidPtr) { char * * dataPtr = (char * *)dataVoidPtr; char * data = (*dataPtr); { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"printLine <start> dest <end> );
<start> printLine(dest) <end> ;"	"void CWE134_Uncontrolled_Format_String__char_console_snprintf_64b_badSink(void * <start> dataVoidPtr <end> );
SNPRINTF(dest, <start> 100-1 <end> , data);"	"void CWE134_Uncontrolled_Format_String__char_console_snprintf_64b_badSink(void * <start> dataVoidPtr <end> );
printLine <start> dest <end> );"	"SNPRINTF(dest, <start> 100-1 <end> , data);
printLine <start> dest <end> );"	2
7fa68e26-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif static int staticTrue = 1; static int staticFalse = 0; namespace CWE23_Relative_Path_Traversal__char_connect_socket_fopen_05 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(staticTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	"<start> data = dataBuffer <end> ;
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
replace = <start> strchr(data, '\n') <end> ;"	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	0
a49c4f69-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_square_09_bad() { int data; data = 0; if(GLOBAL_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(GLOBAL_CONST_TRUE) { { int result = data * data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"data = <start> atoi(inputBuffer) <end> ;
printIntLine <start> result <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"<start> data = atoi(inputBuffer) <end> ;
printIntLine <start> result <end> );"	1
a1094922-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_square_64b_badSink(void * dataVoidPtr) { int * dataPtr = (int *)dataVoidPtr; int data = (*dataPtr); { int result = data * data; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"void CWE190_Integer_Overflow__int_connect_socket_square_64b_badSink(void * <start> dataVoidPtr <end> );
<start> printIntLine(result) <end> ;"	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;"	"void CWE190_Integer_Overflow__int_connect_socket_square_64b_badSink(void * <start> dataVoidPtr <end> );
int <start> result = data * data <end> ;"	"void CWE190_Integer_Overflow__int_connect_socket_square_64b_badSink(void * <start> dataVoidPtr <end> );
printIntLine <start> result <end> );"	3
7e74f342-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_08_bad() { int data; data = -1; if(staticReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"printLine <start> dest <end> );
<start> memmove(dest, source, data) <end> ;"	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printLine <start> dest <end> );"	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	0
571e9853-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_listen_socket_multiply_10_bad() { int data; data = 0; if(globalTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalTrue) { if(data < 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  * 2;"	"int result = <start> data * 2 <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"int result = <start> data <end>  * 2;
<start> printIntLine(result) <end> ;"	"int result = <start> data <end>  * 2;
data = <start> atoi(inputBuffer) <end> ;"	0
5be3a9d9-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_listen_socket_postdec_16_bad() { int data; data = 0; while(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; } while(1) { { data--; int result = data; printIntLine(result); } break; } }"	where is the vulnerable dataflow from data ?	"data = <start> atoi(inputBuffer) <end> ;
<start> data <end> --;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data <end> --;"	"data = <start> atoi(inputBuffer) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"<start> data <end> --;
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	1
6b86244b-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_FIVE = 5; void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_06_bad() { int data; data = -1; if(STATIC_CONST_FIVE==5) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(STATIC_CONST_FIVE==5) { { int i; int * buffer = (int *)malloc(10 * sizeof(int)); if (buffer == NULL) {exit(-1);} for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } free(buffer); } } }"	where is the vulnerable dataflow from buffer to free ?	"free <start> buffer <end> );
if  <start> fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
free <start> buffer <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
if  <start> buffer == NULL <end> ) {exit(-1);};"	"free <start> buffer <end> );
char <start> inputBuffer[CHAR_ARRAY_SIZE] = """" <end> ;"	1
70279bee-6c15-11ed-81d4-94e6f77dd552	#ifndef _WIN32 #endif namespace CWE134_Uncontrolled_Format_String__char_console_vprintf_74 { static void badVaSink(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); va_end(args); } } void badSink(map<int, char *> dataMap) { char * data = dataMap[2]; badVaSink(data, data); }	where is the vulnerable dataflow from data to vprintf ?	"badVaSink <start> data <end> , data);
void badSink(map<int, char *> <start> dataMap <end> );
static void badVaSink(char * <start> data <end> , ...);"	"badVaSink <start> data <end> , data);
<start> va_start(args, data) <end> ;
void badSink(map<int, char *> <start> dataMap <end> );
static void badVaSink(char * <start> data <end> , ...);"	"vprintf <start> data <end> , args);
<start> vprintf(data, args) <end> ;
badVaSink <start> data <end> , data);
void badSink(map<int, char *> <start> dataMap <end> );"	"void badSink(map<int, char *> <start> dataMap <end> );
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
vprintf <start> data <end> , args);"	3
7fa68e29-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } namespace CWE23_Relative_Path_Traversal__char_connect_socket_fopen_08 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(staticReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
size_t <start> dataLen = strlen(data) <end> ;"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
replace = <start> strchr(data, '\n') <end> ;"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
size_t <start> dataLen = strlen(data) <end> ;"	0
d1e9da15-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_file_open_42 { static char * badSource(char * data) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } return data; } void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; data = badSource(data); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
data = <start> badSource <end> (data);
static char * <start> badSource <end> (char * data);"	"static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"data = <start> badSource <end> (data);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
static char * <start> badSource <end> (char * data);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	3
a36a78dc-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) typedef struct _CWE190_Integer_Overflow__int_fgets_square_67_structType { int structFirst; } CWE190_Integer_Overflow__int_fgets_square_67_structType; void CWE190_Integer_Overflow__int_fgets_square_67b_badSink(CWE190_Integer_Overflow__int_fgets_square_67_structType myStruct) { int data = myStruct.structFirst; { int result = data * data; printIntLine(result); } }	where is the vulnerable dataflow from result to printIntLine ?	"int data = <start> myStruct <end> .structFirst;
printIntLine <start> result <end> );"	"void CWE190_Integer_Overflow__int_fgets_square_67b_badSink(CWE190_Integer_Overflow__int_fgets_square_67_structType <start> myStruct <end> );
int data = <start> myStruct <end> .structFirst;
printIntLine <start> result <end> );"	"<start> printIntLine(result) <end> ;
int data = <start> myStruct <end> .structFirst;
printIntLine <start> result <end> );"	"void CWE190_Integer_Overflow__int_fgets_square_67b_badSink(CWE190_Integer_Overflow__int_fgets_square_67_structType <start> myStruct <end> );
<start> printIntLine(result) <end> ;
int data = <start> myStruct <end> .structFirst;"	1
b2ea8de9-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 8 void CWE197_Numeric_Truncation_Error__short_listen_socket_11_bad() { short data; data = -1; if(globalReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = (short)atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { char charData = (char)data; printHexCharLine(charData); } }"	where is the vulnerable dataflow from charData to printHexCharLine ?	"if  <start> listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
data = (short <start> atoi(inputBuffer) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data = -1 <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printHexCharLine <start> charData <end> );"	3
5133a77a-6c15-11ed-81d4-94e6f77dd552	"void CWE190_Integer_Overflow__int_fscanf_preinc_03_bad() { int data; data = 0; if(5==5) { fscanf(stdin, ""%d"", &data); } if(5==5) { { ++data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"int <start> result = data <end> ;
fscanf(stdin, ""%d"", <start> &data <end> );"	"<start> data = 0 <end> ;
+ <start> data <end> ;"	"+ <start> data <end> ;
<start> ++data <end> ;"	"fscanf(stdin, ""%d"", <start> &data <end> );
+ <start> data <end> ;"	3
74ee23c9-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" void CWE194_Unexpected_Sign_Extension__connect_socket_strncpy_02_bad() { short data; data = 0; if(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
if (tempInt > SHRT_MAX || <start> tempInt < SHRT_MIN <end> );"	"printLine <start> dest <end> );
tempInt = <start> atoi(inputBuffer) <end> ;"	"printLine <start> dest <end> );
if (tempInt > SHRT_MAX || <start> tempInt < SHRT_MIN <end> );"	0
c99197eb-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_connect_socket_fopen_34 { typedef union { char * unionFirst; char * unionSecond; } unionType; void bad() { char * data; unionType myUnion; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } } }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = FOPEN <start> data <end> , ""wb+"");
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	"recvResult = recv(connectSocket, (char *)(data + dataLen), <start> sizeof(char) * (FILENAME_MAX - dataLen - 1) <end> , 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
size_t dataLen = <start> strlen(data) <end> ;"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	3
a95fd867-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_fgets_sub_54e_badSink(int data) { { int result = data - 1; printIntLine(result); } }	where is the vulnerable dataflow from result to printIntLine ?	"int <start> result = data - 1 <end> ;
void CWE191_Integer_Underflow__int_fgets_sub_54e_badSink(int <start> data <end> );"	"void CWE191_Integer_Underflow__int_fgets_sub_54e_badSink(int <start> data <end> );
<start> printIntLine(result) <end> ;"	"int <start> result = data - 1 <end> ;
printIntLine <start> result <end> );"	"void CWE191_Integer_Underflow__int_fgets_sub_54e_badSink(int <start> data <end> );
printIntLine <start> result <end> );"	3
a95fd859-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_fgets_sub_17_bad() { int i,j; int data; data = 0; for(i = 0; i < 1; i++) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } for(j = 0; j < 1; j++) { { int result = data - 1; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
int result = <start> data - 1 <end> ;"	"<start> data = atoi(inputBuffer) <end> ;
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	0
73bc8131-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" void CWE194_Unexpected_Sign_Extension__connect_socket_malloc_65b_badSink(short data) { if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }"	where is the vulnerable dataflow from data to malloc ?	"void CWE194_Unexpected_Sign_Extension__connect_socket_malloc_65b_badSink(short <start> data <end> );
char * dataBuffer = (char *)malloc <start> data <end> );"	"char * dataBuffer = (char * <start> malloc(data) <end> ;
void CWE194_Unexpected_Sign_Extension__connect_socket_malloc_65b_badSink(short <start> data <end> );"	"void CWE194_Unexpected_Sign_Extension__connect_socket_malloc_65b_badSink(short <start> data <end> );
if  <start> data < 100 <end> );"	"if  <start> data < 100 <end> );
char * dataBuffer = (char *)malloc <start> data <end> );"	0
a5ce1c44-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_postinc_54e_badSink(int data) { { data++; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	"void CWE190_Integer_Overflow__int_connect_socket_postinc_54e_badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"int <start> result = data <end> ;
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
void CWE190_Integer_Overflow__int_connect_socket_postinc_54e_badSink(int <start> data <end> );"	1
cf8750a0-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif extern char * CWE36_Absolute_Path_Traversal__char_environment_open_68_badData; extern char * CWE36_Absolute_Path_Traversal__char_environment_open_68_goodG2BData; namespace CWE36_Absolute_Path_Traversal__char_environment_open_68 { void badSink() { char * data = CWE36_Absolute_Path_Traversal__char_environment_open_68_badData; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"char * data = <start> CWE36_Absolute_Path_Traversal__char_environment_open_68_badData <end> ;
fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
char <start> * data = CWE36_Absolute_Path_Traversal__char_environment_open_68_badData <end> ;"	"char * data = <start> CWE36_Absolute_Path_Traversal__char_environment_open_68_badData <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	2
a36a7918-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_multiply_11_bad() { int data; data = 0; if(globalReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalReturnsTrue()) { if(data > 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"<start> recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"int <start> result = data * 2 <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	0
5133a752-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) typedef struct _CWE190_Integer_Overflow__int_connect_socket_preinc_67_structType { int structFirst; } CWE190_Integer_Overflow__int_connect_socket_preinc_67_structType; void CWE190_Integer_Overflow__int_connect_socket_preinc_67b_badSink(CWE190_Integer_Overflow__int_connect_socket_preinc_67_structType myStruct) { int data = myStruct.structFirst; { ++data; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"void CWE190_Integer_Overflow__int_connect_socket_preinc_67b_badSink(CWE190_Integer_Overflow__int_connect_socket_preinc_67_structType <start> myStruct <end> );
int data = <start> myStruct <end> .structFirst;
+ <start> data <end> ;"	"int <start> result = data <end> ;
void CWE190_Integer_Overflow__int_connect_socket_preinc_67b_badSink(CWE190_Integer_Overflow__int_connect_socket_preinc_67_structType <start> myStruct <end> );
+ <start> data <end> ;"	"void CWE190_Integer_Overflow__int_connect_socket_preinc_67b_badSink(CWE190_Integer_Overflow__int_connect_socket_preinc_67_structType <start> myStruct <end> );
int <start> result = data <end> ;
int data = <start> myStruct <end> .structFirst;"	"int data = <start> myStruct <end> .structFirst;
void CWE190_Integer_Overflow__int_connect_socket_preinc_67b_badSink(CWE190_Integer_Overflow__int_connect_socket_preinc_67_structType <start> myStruct <end> );
+ <start> data <end> ;"	0
ba102b6c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #define SEARCH_CHAR 'S' namespace CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_file_81 { void bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\0'; { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } const CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_file_81_base& baseObject = CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_file_81_bad(); baseObject.action(data); }"	where is the vulnerable dataflow from data to action ?	"<start> data = (char *)malloc(100*sizeof(char)) <end> ;
baseObject.action <start> data <end> );"	"baseObject.action <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	"baseObject.action <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
baseObject.action <start> data <end> );"	3
893217b4-6c15-11ed-81d4-94e6f77dd552	#ifndef _WIN32 #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_connect_socket_open_74 { void badSink(map<int, char *> dataMap) { char * data = dataMap[2]; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }	where is the vulnerable dataflow from data to OPEN ?	"void badSink(map<int, char *> <start> dataMap <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
void badSink(map<int, char *> <start> dataMap <end> );"	"void badSink(map<int, char *> <start> dataMap <end> );
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	0
761e29a6-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 8 void CWE194_Unexpected_Sign_Extension__fgets_strncpy_10_bad() { short data; data = 0; if(globalTrue) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = (short)atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> strncpy(dest, source, data) <end> ;
printLine <start> dest <end> );"	"printLine <start> dest <end> );
<start> printLine(dest) <end> ;"	"if  <start> data < 100 <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printLine <start> dest <end> );"	3
b7b09a2e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define NEW_PATH ""%SystemRoot%\\system32"" #define PUTENV _putenv #else #define NEW_PATH ""/bin"" #define PUTENV putenv #endif static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; void CWE427_Uncontrolled_Search_Path_Element__char_console_04_bad() { char * data; char dataBuffer[250] = ""PATH=""; data = dataBuffer; if(STATIC_CONST_TRUE) { { size_t dataLen = strlen(data); if (250-dataLen > 1) { if (fgets(data+dataLen, (int)(250-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } PUTENV(data); }"	where is the vulnerable dataflow from data to PUTENV ?	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(250-dataLen), stdin) != NULL);"	"PUTENV <start> data <end> );
<start> PUTENV(data) <end> ;"	"size_t dataLen = <start> strlen(data) <end> ;
PUTENV <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(250-dataLen), stdin) != NULL);
PUTENV <start> data <end> );"	3
cbf2379e-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_console_fopen_01 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = FOPEN <start> data <end> , ""wb+"");
size_t dataLen = <start> strlen(data) <end> ;"	"pFile = FOPEN <start> data <end> , ""wb+"");
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	2
a5ce1c77-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticFive = 5; void CWE190_Integer_Overflow__int_listen_socket_postinc_07_bad() { int data; data = 0; if(staticFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticFive==5) { { data++; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"<start> printIntLine(result) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	1
a95fd82c-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_fgets_multiply_15_bad() { int data; data = 0; switch(6) { case 6: { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } break; default: printLine(""Benign, fixed string""); break; } switch(7) { case 7: if(data < 0) { int result = data * 2; printIntLine(result); } break; default: printLine(""Benign, fixed string""); break; } }"	where is the vulnerable dataflow from result to printIntLine ?	"if  <start> fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) <end>  != NULL);
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
int <start> result = data * 2 <end> ;"	2
a49c4f9d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_postinc_15_bad() { int data; data = 0; switch(6) { case 6: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; default: printLine(""Benign, fixed string""); break; } switch(7) { case 7: { data++; int result = data; printIntLine(result); } break; default: printLine(""Benign, fixed string""); break; } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;"	"<start> printIntLine(result) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"data = <start> atoi(inputBuffer) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	2
a830bf63-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) extern int CWE190_Integer_Overflow__int_listen_socket_preinc_68_badData; extern int CWE190_Integer_Overflow__int_listen_socket_preinc_68_goodG2BData; extern int CWE190_Integer_Overflow__int_listen_socket_preinc_68_goodB2GData; void CWE190_Integer_Overflow__int_listen_socket_preinc_68b_badSink() { int data = CWE190_Integer_Overflow__int_listen_socket_preinc_68_badData; { ++data; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;"	"int <start> result = data <end> ;
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
int data = <start> CWE190_Integer_Overflow__int_listen_socket_preinc_68_badData <end> ;"	"int data = <start> CWE190_Integer_Overflow__int_listen_socket_preinc_68_badData <end> ;
printIntLine <start> result <end> );"	3
466e7ecd-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__int_fgets_add_82 { void CWE190_Integer_Overflow__int_fgets_add_82_bad::action(int data) { { int result = data + 1; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"void CWE190_Integer_Overflow__int_fgets_add_82_bad::action(int <start> data <end> );
int <start> result = data + 1 <end> ;"	"<start> printIntLine(result) <end> ;
void CWE190_Integer_Overflow__int_fgets_add_82_bad::action(int <start> data <end> );"	"int result = <start> data <end>  + 1;
void CWE190_Integer_Overflow__int_fgets_add_82_bad::action(int <start> data <end> );"	"void CWE190_Integer_Overflow__int_fgets_add_82_bad::action(int <start> data <end> );
int result = <start> data <end>  + 1;"	3
48d25d80-6c15-11ed-81d4-94e6f77dd552	"void CWE190_Integer_Overflow__int_fscanf_square_14_bad() { int data; data = 0; if(globalFive==5) { fscanf(stdin, ""%d"", &data); } if(globalFive==5) { { int result = data * data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"fscanf(stdin, ""%d"", <start> &data <end> );
int <start> result = data * data <end> ;"	"fscanf(stdin, ""%d"", <start> &data <end> );
int result = <start> data <end>  * data;"	"int result = <start> data <end>  * data;
fscanf(stdin, ""%d"", <start> &data <end> );"	"int result = <start> data <end>  * data;
<start> printIntLine(result) <end> ;"	1
a5ce1c39-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int badStatic = 0; static void badSink(int data) { if(badStatic) { { data++; int result = data; printIntLine(result); } } } void CWE190_Integer_Overflow__int_connect_socket_postinc_21_bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badStatic = 1; badSink(data); }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSink <start> data <end> );
static void badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"data = <start> atoi(inputBuffer) <end> ;
printIntLine <start> result <end> );
badSink <start> data <end> );
static void badSink(int <start> data <end> );"	"printIntLine <start> result <end> );
static void badSink(int <start> data <end> );
badSink <start> data <end> );
recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);"	"<start> badSink(data) <end> ;
static void badSink(int <start> data <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSink <start> data <end> );"	0
761e2954-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 8 void CWE194_Unexpected_Sign_Extension__fgets_memcpy_16_bad() { short data; data = 0; while(1) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = (short)atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } break; } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"char <start> dest[100] = """" <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"printLine <start> dest <end> );
<start> printLine(dest) <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printLine <start> dest <end> );"	"<start> data = (short)atoi(inputBuffer) <end> ;
printLine <start> dest <end> );"	2
445c1210-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_multiply_03_bad() { int data; data = 0; if(5==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(5==5) { if(data > 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data * 2 <end> ;"	"int result = <start> data <end>  * 2;
<start> data = atoi(inputBuffer) <end> ;"	"int result = <start> data <end>  * 2;
recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  * 2;"	3
99e16a84-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_listen_socket_14 { void bad() { int data; data = -1; if(globalFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalFive==5) { { int i; int * buffer = new int[10]; for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } delete[] buffer; } } }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"printIntLine <start> buffer[i] <end> );
int <start> * buffer = new int[10] <end> ;"	"printIntLine <start> buffer[i] <end> );
<start> recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> buffer[i] <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[i] <end> );"	3
5e44fc6d-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; void CWE191_Integer_Underflow__int_fgets_predec_04_bad() { int data; data = 0; if(STATIC_CONST_TRUE) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(STATIC_CONST_TRUE) { { --data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
- <start> data <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> data = 0 <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
int <start> result = data <end> ;"	"- <start> data <end> ;
int <start> result = data <end> ;"	0
761e2953-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 8 void CWE194_Unexpected_Sign_Extension__fgets_memcpy_15_bad() { short data; data = 0; switch(6) { case 6: { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = (short)atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } break; default: printLine(""Benign, fixed string""); break; } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printLine <start> dest <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
data = (short <start> atoi(inputBuffer) <end> ;"	"printLine <start> dest <end> );
data = (short <start> atoi(inputBuffer) <end> ;"	"<start> data = (short)atoi(inputBuffer) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	0
abc374f9-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_connect_socket_postdec_11_bad() { int data; data = 0; if(globalReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalReturnsTrue()) { { data--; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);"	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;"	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> result <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	3
8f278a82-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_31_bad() { int data; data = -1; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } { int dataCopy = data; int data = dataCopy; { size_t i; int *intPointer; intPointer = (int*)malloc(data * sizeof(int)); if (intPointer == NULL) {exit(-1);} for (i = 0; i < (size_t)data; i++) { intPointer[i] = 0; } printIntLine(intPointer[0]); free(intPointer); } } }"	where is the vulnerable dataflow from data to malloc ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	"intPointer = (int*)malloc <start> data * sizeof(int) <end> );
if  <start> fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) <end>  != NULL);"	"<start> data = -1 <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"intPointer = (int*)malloc <start> data * sizeof(int) <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	0
4ff78281-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__short_fscanf_postinc_65b_badSink(short data) { { data++; short result = data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"short <start> result = data <end> ;
<start> data <end> ++;"	"void CWE190_Integer_Overflow__short_fscanf_postinc_65b_badSink(short <start> data <end> );
<start> data++ <end> ;"	"void CWE190_Integer_Overflow__short_fscanf_postinc_65b_badSink(short <start> data <end> );
<start> data <end> ++;"	"<start> data <end> ++;
void CWE190_Integer_Overflow__short_fscanf_postinc_65b_badSink(short <start> data <end> );"	2
820a46f5-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_file_open_67 { typedef struct _structType { char * structFirst; } structType; void badSink(structType myStruct) { char * data = myStruct.structFirst; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"void badSink(structType <start> myStruct <end> );
char * data = <start> myStruct <end> .structFirst;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
void badSink(structType <start> myStruct <end> );"	"void badSink(structType <start> myStruct <end> );
char * data = <start> myStruct <end> .structFirst;
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"void badSink(structType <start> myStruct <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	0
c99197db-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif static const int STATIC_CONST_FIVE = 5; namespace CWE36_Absolute_Path_Traversal__char_connect_socket_fopen_06 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(STATIC_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = FOPEN <start> data <end> , ""wb+"");
recvResult = recv(connectSocket, (char *)(data + dataLen), <start> sizeof(char) * (FILENAME_MAX - dataLen - 1) <end> , 0);"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
replace = <start> strchr(data, '\n') <end> ;"	1
6b862438-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_connect_socket_54e_badSink(int data) { { int i; int * buffer = (int *)malloc(10 * sizeof(int)); if (buffer == NULL) {exit(-1);} for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } free(buffer); } }"	where is the vulnerable dataflow from buffer to free ?	"free <start> buffer <end> );
void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_connect_socket_54e_badSink(int <start> data <end> );"	"<start> free(buffer) <end> ;
free <start> buffer <end> );"	"void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_connect_socket_54e_badSink(int <start> data <end> );
free <start> buffer <end> );"	"void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_connect_socket_54e_badSink(int <start> data <end> );
<start> printIntLine(buffer[i]) <end> ;"	2
aa91a16d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int badSource(int data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } return data; } void CWE191_Integer_Underflow__int_listen_socket_multiply_42_bad() { int data; data = 0; data = badSource(data); if(data < 0) { int result = data * 2; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"data = <start> atoi(inputBuffer) <end> ;
static int <start> badSource <end> (int data);
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"data = <start> badSource <end> (data);
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static int <start> badSource <end> (int data);
printIntLine <start> result <end> );"	"int <start> result = data * 2 <end> ;
data = <start> badSource <end> (data);
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static int <start> badSource <end> (int data);
data = <start> badSource <end> (data);
printIntLine <start> result <end> );"	3
964cdbec-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FULL_COMMAND ""dir "" #else #define FULL_COMMAND ""ls "" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define POPEN _popen #define PCLOSE _pclose #else #define POPEN popen #define PCLOSE pclose #endif void CWE78_OS_Command_Injection__char_file_popen_15_bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; switch(6) { case 6: { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } break; default: printLine(""Benign, fixed string""); break; } { FILE *pipe; pipe = POPEN(data, ""w""); if (pipe != NULL) { PCLOSE(pipe); } } }"	where is the vulnerable dataflow from data to POPEN ?	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
pipe = POPEN <start> data <end> , ""w"");"	"pipe = POPEN <start> data <end> , ""w"");
<start> data = data_buf <end> ;"	"pipe = <start> POPEN(data, ""w"") <end> ;
pipe = POPEN <start> data <end> , ""w"");"	"pipe = <start> POPEN(data, ""w"") <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	0
47a2a81b-6c15-11ed-81d4-94e6f77dd552	"static int CWE190_Integer_Overflow__int_fscanf_add_45_badData; static int CWE190_Integer_Overflow__int_fscanf_add_45_goodG2BData; static int CWE190_Integer_Overflow__int_fscanf_add_45_goodB2GData; static void badSink() { int data = CWE190_Integer_Overflow__int_fscanf_add_45_badData; { int result = data + 1; printIntLine(result); } } void CWE190_Integer_Overflow__int_fscanf_add_45_bad() { int data; data = 0; fscanf(stdin, ""%d"", &data); CWE190_Integer_Overflow__int_fscanf_add_45_badData = data; badSink(); }"	where is the vulnerable dataflow from data ?	"fscanf(stdin, ""%d"", <start> &data <end> );
<start> CWE190_Integer_Overflow__int_fscanf_add_45_badData = data <end> ;
static int <start> CWE190_Integer_Overflow__int_fscanf_add_45_badData <end> ;
int data = <start> CWE190_Integer_Overflow__int_fscanf_add_45_badData <end> ;
int result = <start> data <end>  + 1;"	"<start> CWE190_Integer_Overflow__int_fscanf_add_45_badData = data <end> ;
static int <start> CWE190_Integer_Overflow__int_fscanf_add_45_badData <end> ;
int data = <start> CWE190_Integer_Overflow__int_fscanf_add_45_badData <end> ;
int <start> result = data + 1 <end> ;
fscanf(stdin, ""%d"", <start> &data <end> );"	"fscanf(stdin, ""%d"", <start> &data <end> );
static int <start> CWE190_Integer_Overflow__int_fscanf_add_45_badData <end> ;"	"int result = <start> data <end>  + 1;
fscanf(stdin, ""%d"", <start> &data <end> );
static int <start> CWE190_Integer_Overflow__int_fscanf_add_45_badData <end> ;
<start> CWE190_Integer_Overflow__int_fscanf_add_45_badData = data <end> ;
int data = <start> CWE190_Integer_Overflow__int_fscanf_add_45_badData <end> ;"	0
6ef7681e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif namespace CWE134_Uncontrolled_Format_String__char_console_snprintf_82 { void CWE134_Uncontrolled_Format_String__char_console_snprintf_82_bad::action(char * data) { { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } } }"	where is the vulnerable dataflow from dest to printLine ?	"void CWE134_Uncontrolled_Format_String__char_console_snprintf_82_bad::action(char * <start> data <end> );
printLine <start> dest <end> );"	"void CWE134_Uncontrolled_Format_String__char_console_snprintf_82_bad::action(char * <start> data <end> );
<start> printLine(dest) <end> ;"	"printLine <start> dest <end> );
<start> SNPRINTF(dest, 100-1, data) <end> ;"	"printLine <start> dest <end> );
void CWE134_Uncontrolled_Format_String__char_console_snprintf_82_bad::action(char * <start> data <end> );"	0
c39a65a2-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif namespace CWE23_Relative_Path_Traversal__char_environment_ifstream_54 { void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } badSink_b(data); }"	where is the vulnerable dataflow from data to badSink_b ?	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
badSink_b <start> data <end> );"	"<start> strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1) <end> ;
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"<start> badSink_b(data) <end> ;
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"<start> data = dataBuffer <end> ;
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	0
5be3a9f2-6c15-11ed-81d4-94e6f77dd552	"static const int STATIC_CONST_FIVE = 5; void CWE191_Integer_Underflow__short_fscanf_postdec_06_bad() { short data; data = 0; if(STATIC_CONST_FIVE==5) { fscanf (stdin, ""%hd"", &data); } if(STATIC_CONST_FIVE==5) { { data--; short result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );"	"fscanf (stdin, ""%hd"", <start> &data <end> );
<start> data <end> --;"	"<start> data <end> --;
<start> printIntLine(result) <end> ;"	"<start> data <end> --;
fscanf (stdin, ""%hd"", <start> &data <end> );"	1
a23a3e1d-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_multiply_09_bad() { int data; data = 0; if(GLOBAL_CONST_TRUE) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(GLOBAL_CONST_TRUE) { if(data > 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
int result = <start> data * 2 <end> ;"	"if <start> data > 0 <end> ) ;
printIntLine <start> result <end> );"	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );"	3
b68484ea-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 namespace CWE36_Absolute_Path_Traversal__char_listen_socket_ofstream_82 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE36_Absolute_Path_Traversal__char_listen_socket_ofstream_82_base* baseObject = new CWE36_Absolute_Path_Traversal__char_listen_socket_ofstream_82_bad; baseObject->action(data); delete baseObject; }"	where is the vulnerable dataflow from data to action ?	"baseObject->action <start> data <end> );
char <start> dataBuffer[FILENAME_MAX] = """" <end> ;"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
baseObject->action <start> data <end> );"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"baseObject->action <start> data <end> );
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	1
ba102b71-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_81 { void bad() { size_t data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = strtoul(inputBuffer, NULL, 0); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } const CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_81_base& baseObject = CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_81_bad(); baseObject.action(data); }"	where is the vulnerable dataflow from data to action ?	"data = <start> strtoul(inputBuffer, NULL, 0) <end> ;
baseObject.action <start> data <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
baseObject.action <start> data <end> );"	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
baseObject.action <start> data <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
data = <start> strtoul(inputBuffer, NULL, 0) <end> ;"	1
a6fd8264-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_preinc_10_bad() { int data; data = 0; if(globalTrue) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(globalTrue) { { ++data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
<start> data = 0 <end> ;"	"int <start> result = data <end> ;
printIntLine <start> result <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	2
6ef7685f-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif static void badVaSink(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); va_end(args); } } static void badSink(char * data) { badVaSink(data, data); } void CWE134_Uncontrolled_Format_String__char_console_vprintf_41_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } badSink(data); }"	where is the vulnerable dataflow from data to vprintf ?	"<start> badSink(data) <end> ;
badVaSink <start> data <end> , data);
static void badSink(char * <start> data <end> );
static void badVaSink(char * <start> data <end> , ...);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
vprintf <start> data <end> , args);"	"static void badSink(char * <start> data <end> );
static void badVaSink(char * <start> data <end> , ...);
badVaSink <start> data <end> , data);
vprintf <start> data <end> , args);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
badSink <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
badSink <start> data <end> );
static void badSink(char * <start> data <end> );
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
vprintf <start> data <end> , args);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
vprintf <start> data <end> , args);
badVaSink <start> data <end> , data);
size_t dataLen = <start> strlen(data) <end> ;
badSink <start> data <end> );
static void badSink(char * <start> data <end> );"	2
964cdc15-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FULL_COMMAND ""dir "" #else #define FULL_COMMAND ""ls "" #endif #ifdef _WIN32 #define POPEN _popen #define PCLOSE _pclose #else #define POPEN popen #define PCLOSE pclose #endif int CWE78_OS_Command_Injection__char_listen_socket_popen_22_badGlobal = 0; char * CWE78_OS_Command_Injection__char_listen_socket_popen_22_badSource(char * data); void CWE78_OS_Command_Injection__char_listen_socket_popen_22_bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; CWE78_OS_Command_Injection__char_listen_socket_popen_22_badGlobal = 1; data = CWE78_OS_Command_Injection__char_listen_socket_popen_22_badSource(data); { FILE *pipe; pipe = POPEN(data, ""w""); if (pipe != NULL) { PCLOSE(pipe); } } }"	where is the vulnerable dataflow from data to POPEN ?	"pipe = <start> POPEN(data, ""w"") <end> ;
data = <start> CWE78_OS_Command_Injection__char_listen_socket_popen_22_badSource <end> (data);"	"pipe = <start> POPEN(data, ""w"") <end> ;
pipe = POPEN <start> data <end> , ""w"");"	"pipe = POPEN <start> data <end> , ""w"");
data = <start> CWE78_OS_Command_Injection__char_listen_socket_popen_22_badSource <end> (data);"	"data = <start> CWE78_OS_Command_Injection__char_listen_socket_popen_22_badSource <end> (data);
pipe = POPEN <start> data <end> , ""w"");"	3
761e2948-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 8 static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; void CWE194_Unexpected_Sign_Extension__fgets_memcpy_04_bad() { short data; data = 0; if(STATIC_CONST_TRUE) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = (short)atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> printLine(dest) <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printLine <start> dest <end> );"	"printLine <start> dest <end> );
<start> memcpy(dest, source, data) <end> ;"	"<start> memcpy(dest, source, data) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	1
9c455199-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE126_Buffer_Overread__CWE129_connect_socket_02_bad() { int data; data = -1; if(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(1) { { int buffer[10] = { 0 }; if (data >= 0) { printIntLine(buffer[data]); } else { printLine(""ERROR: Array index is negative""); } } } }"	where is the vulnerable dataflow from buffer[data] to printIntLine ?	"printIntLine <start> buffer[data] <end> );
recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);"	"data = <start> atoi(inputBuffer) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[data] <end> );"	"printIntLine <start> buffer[data] <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	2
a830bf60-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_preinc_65b_badSink(int data) { { ++data; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"int <start> result = data <end> ;
printIntLine <start> result <end> );"	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
void CWE190_Integer_Overflow__int_listen_socket_preinc_65b_badSink(int <start> data <end> );"	"void CWE190_Integer_Overflow__int_listen_socket_preinc_65b_badSink(int <start> data <end> );
printIntLine <start> result <end> );"	3
bda4e41f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define EXECL _execl #else #define EXECL execl #endif void CWE78_OS_Command_Injection__char_listen_socket_execl_18_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; goto source; source: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECL ?	"size_t dataLen = <start> strlen(data) <end> ;
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	1
4b34afc5-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__short_fscanf_add_66b_badSink(short dataArray[]) { short data = dataArray[2]; { short result = data + 1; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"void CWE190_Integer_Overflow__short_fscanf_add_66b_badSink(short <start> dataArray <end> []);
short result = <start> data <end>  + 1;"	"short result = <start> data <end>  + 1;
short <start> data = dataArray[2] <end> ;"	"<start> printIntLine(result) <end> ;
short result = <start> data <end>  + 1;"	"short result = <start> data <end>  + 1;
void CWE190_Integer_Overflow__short_fscanf_add_66b_badSink(short <start> dataArray <end> []);"	0
6c938c24-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" static void badVaSinkB(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_11_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; if(globalReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalReturnsTrue()) { badVaSinkB(data, data); } }"	where is the vulnerable dataflow from data to vfprintf ?	"recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - <start> dataLen - 1 <end> ), 0);
vfprintf(stdout, <start> data <end> , args);
badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);"	"vfprintf(stdout, <start> data <end> , args);
static void badVaSinkB(char * <start> data <end> , ...);
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
badVaSinkB <start> data <end> , data);"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (100 - dataLen - 1), 0);
badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);"	2
b8e2bdca-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 256 static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; void CWE681_Incorrect_Conversion_Between_Numeric_Types__doubleNaN2int_04_bad() { if(STATIC_CONST_TRUE) { { char inputBuffer[CHAR_ARRAY_SIZE]; double doubleNumber = 0; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { doubleNumber = atof(inputBuffer); } else { printLine(""fgets() failed.""); } printIntLine((int)(sqrt(doubleNumber))); } } }"	where is the vulnerable dataflow from doubleNumber to printIntLine ?	"doubleNumber = <start> atof(inputBuffer) <end> ;
printIntLine((int)(sqrt <start> doubleNumber <end> )));"	"double <start> doubleNumber = 0 <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"printIntLine((int) <start> sqrt(doubleNumber) <end> ));
printIntLine((int)(sqrt <start> doubleNumber <end> )));"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine((int)(sqrt <start> doubleNumber <end> )));"	3
47a2a807-6c15-11ed-81d4-94e6f77dd552	"static int staticTrue = 1; static int staticFalse = 0; void CWE190_Integer_Overflow__int_fscanf_add_05_bad() { int data; data = 0; if(staticTrue) { fscanf(stdin, ""%d"", &data); } if(staticTrue) { { int result = data + 1; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"int <start> result = data + 1 <end> ;
fscanf(stdin, ""%d"", <start> &data <end> );"	"fscanf(stdin, ""%d"", <start> &data <end> );
int result = <start> data <end>  + 1;"	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  + 1;"	"fscanf(stdin, ""%d"", <start> &data <end> );
<start> data = 0 <end> ;"	1
a830bf97-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticFive = 5; void CWE191_Integer_Underflow__int_connect_socket_sub_07_bad() { int data; data = 0; if(staticFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticFive==5) { { int result = data - 1; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
int result = <start> data - 1 <end> ;"	"int result = <start> data - 1 <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printIntLine(result) <end> ;"	2
820a46ec-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_file_open_45 { static char * badData; static char * goodG2BData; static void badSink() { char * data = badData; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } } void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } badData = data; badSink(); }"	where is the vulnerable dataflow from data to OPEN ?	"char * data = <start> badData <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
static char * <start> badData <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"<start> badData = data <end> ;
size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
static char * <start> badData <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
<start> badData = data <end> ;
static char * <start> badData <end> ;
char * data = <start> badData <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"<start> badData = data <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
static char * <start> badData <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
char * data = <start> badData <end> ;"	2
c1366279-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif namespace CWE23_Relative_Path_Traversal__char_console_ifstream_65 { void badSink(char * data); void bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } funcPtr(data); }"	where is the vulnerable dataflow from data to funcPtr ?	"dataLen = <start> strlen(data) <end> ;
funcPtr <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
funcPtr <start> data <end> );"	"<start> data = dataBuffer <end> ;
funcPtr <start> data <end> );"	2
85b15ee6-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE369_Divide_by_Zero__int_fgets_divide_01_bad() { int data; data = -1; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } printIntLine(100 / data); }"	where is the vulnerable dataflow from data to printIntLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> 100 / data <end> );"	"if  <start> fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) <end>  != NULL);
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"printIntLine <start> 100 / data <end> );
if  <start> fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) <end>  != NULL);"	"printIntLine <start> 100 / data <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	0
6c938c0a-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif void CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_52c_badSink(char * data) { { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"void CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_52c_badSink(char * <start> data <end> );
printLine <start> dest <end> );"	"void CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_52c_badSink(char * <start> data <end> );
<start> printLine(dest) <end> ;"	"<start> SNPRINTF(dest, 100-1, data) <end> ;
printLine <start> dest <end> );"	"SNPRINTF(dest, <start> 100-1 <end> , data);
void CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_52c_badSink(char * <start> data <end> );"	0
61da6715-6c15-11ed-81d4-94e6f77dd552	static void badSink(short data) { { short result = data + 1; printIntLine(result); } } void CWE190_Integer_Overflow__short_rand_add_41_bad() { short data; data = 0; data = (short)RAND32(); badSink(data); }	where is the vulnerable dataflow from data ?	"<start> badSink(data) <end> ;
short result = <start> data <end>  + 1;
static void badSink(short <start> data <end> );
data = (short <start> RAND32() <end> ;"	"<start> printIntLine(result) <end> ;
short result = <start> data <end>  + 1;
data = (short <start> RAND32() <end> ;
badSink <start> data <end> );"	"data = (short <start> RAND32() <end> ;
static void badSink(short <start> data <end> );
short result = <start> data <end>  + 1;
badSink <start> data <end> );"	"data = (short <start> RAND32() <end> ;
badSink <start> data <end> );
static void badSink(short <start> data <end> );
short result = <start> data <end>  + 1;"	3
c72d5d37-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_file_open_45 { static char * badData; static char * goodG2BData; static void badSink() { char * data = badData; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } } void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } badData = data; badSink(); }"	where is the vulnerable dataflow from data to OPEN ?	"<start> badData = data <end> ;
char <start> * data = badData <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
static char * <start> badData <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
<start> badData = data <end> ;
static char * <start> badData <end> ;
char * data = <start> badData <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"<start> badData = data <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
static char * <start> badData <end> ;
char * data = <start> badData <end> ;"	"char * data = <start> badData <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
<start> badData = data <end> ;
static char * <start> badData <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	1
7d44fcb1-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_FIVE = 5; void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_06_bad() { int data; data = -1; if(STATIC_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }"	where is the vulnerable dataflow from data to malloc ?	"memset(dataBuffer, 'A', <start> data-1 <end> );
char * dataBuffer = (char *)malloc <start> data <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> memset(dataBuffer, 'A', data-1) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
char * dataBuffer = (char *)malloc <start> data <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printLine(dataBuffer) <end> ;"	2
8f278a30-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define PATH_SZ 100 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define PATH_SZ PATH_MAX #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 void CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__listen_accept_bind_10_bad() { if(globalTrue) { { char data[100] = """"; #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[recvResult] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif printLine(data); } } }"	where is the vulnerable dataflow from data to printLine ?	"recvResult = <start> recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0) <end> ;
printLine <start> data <end> );"	"recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);
printLine <start> data <end> );"	"size_t dataLen = <start> strlen(data) <end> ;
printLine <start> data <end> );"	"printLine <start> data <end> );
<start> printLine(data) <end> ;"	1
774f57f6-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 8 void CWE194_Unexpected_Sign_Extension__fgets_strncpy_52c_badSink(short data) { { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"if  <start> data < 100 <end> );
printLine <start> dest <end> );"	"void CWE194_Unexpected_Sign_Extension__fgets_strncpy_52c_badSink(short <start> data <end> );
printLine <start> dest <end> );"	"printLine <start> dest <end> );
char <start> dest[100] = """" <end> ;"	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	1
70279c09-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif namespace CWE134_Uncontrolled_Format_String__char_file_snprintf_43 { static void badSource(char * &data) { { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } void bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; badSource(data); { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"badSource <start> data <end> );
<start> printLine(dest) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	"<start> SNPRINTF(dest, 100-1, data) <end> ;
badSource <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	"printLine <start> dest <end> );
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
badSource <start> data <end> );
printLine <start> dest <end> );"	3
656cd3c3-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__int_rand_add_17_bad() { int i,j; int data; data = 0; for(i = 0; i < 1; i++) { data = RAND32(); } for(j = 0; j < 1; j++) { { int result = data + 1; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"data = <start> RAND32() <end> ;
<start> printIntLine(result) <end> ;"	"int <start> result = data + 1 <end> ;
data = <start> RAND32() <end> ;"	"data = <start> RAND32() <end> ;
int result = <start> data <end>  + 1;"	"int result = <start> data <end>  + 1;
data = <start> RAND32() <end> ;"	2
cbf237d6-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif namespace CWE36_Absolute_Path_Traversal__char_console_ifstream_17 { void bad() { int i; char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; for(i = 0; i < 1; i++) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"inputFile.open((char * <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
inputFile.open((char * <start> data <end> );"	"inputFile.open((char * <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"inputFile.open((char * <start> data <end> );
if (dataLen > 0 && <start> data[dataLen-1] == '\n' <end> );"	1
7d44fc6c-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_43 { static void badSource(int &data) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } void bad() { int data; data = -1; badSource(data); { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"printLine <start> dest <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
badSource <start> data <end> );"	"badSource <start> data <end> );
printLine <start> dest <end> );
<start> memmove(dest, source, data) <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
badSource <start> data <end> );
printLine <start> dest <end> );"	"<start> memmove(dest, source, data) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
badSource <start> data <end> );"	2
8a6310ca-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_file_open_44 { static void badSink(char * data) { { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } } void bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } funcPtr(data); }"	where is the vulnerable dataflow from data to OPEN ?	"<start> funcPtr(data) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
funcPtr <start> data <end> );"	"<start> funcPtr(data) <end> ;
funcPtr <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
static void badSink(char * <start> data <end> );"	"static void badSink(char * <start> data <end> );
funcPtr <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
funcPtr <start> data <end> );
static void badSink(char * <start> data <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	3
70279c2d-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif static void badVaSinkB(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_file_vfprintf_18_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; goto source; source: { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } goto sink; sink: badVaSinkB(data, data); }"	where is the vulnerable dataflow from data to vfprintf ?	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
vfprintf(stdout, <start> data <end> , args);
badVaSinkB <start> data <end> , data);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
static void badVaSinkB(char * <start> data <end> , ...);
badVaSinkB <start> data <end> , data);
<start> vfprintf(stdout, data, args) <end> ;"	"badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);"	3
98b0153b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink(int data) { { int i; int buffer[10] = { 0 }; if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } } } void CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_44_bad() { int data; void (*funcPtr) (int) = badSink; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } funcPtr(data); }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"printIntLine <start> buffer[i] <end> );
funcPtr <start> data <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
if  <start> listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR <end> );"	"<start> funcPtr(data) <end> ;
static void badSink(int <start> data <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[i] <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
funcPtr <start> data <end> );
static void badSink(int <start> data <end> );
printIntLine <start> buffer[i] <end> );"	"printIntLine <start> buffer[i] <end> );
if  <start> listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR <end> );
static void badSink(int <start> data <end> );
funcPtr <start> data <end> );"	2
8df4220c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define PATH_SZ 100 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define PATH_SZ PATH_MAX #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 void CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__bind_accept_listen_03_bad() { if(5==5) { { char data[100] = """"; #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[recvResult] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif printLine(data); } } }"	where is the vulnerable dataflow from data to printLine ?	"recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);
printLine <start> data <end> );"	"if  <start> acceptSocket == SOCKET_ERROR <end> );
recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);"	"size_t <start> dataLen = strlen(data) <end> ;
recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);"	"printLine <start> data <end> );
recvResult = recv(acceptSocket, <start> (char *)data <end> +dataLen, (int)(100-dataLen-1), 0);"	0
5af03e16-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticFive = 5; void CWE191_Integer_Underflow__int_fgets_postdec_07_bad() { int data; data = 0; if(staticFive==5) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(staticFive==5) { { data--; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> data <end> --;"	"<start> data = atoi(inputBuffer) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if  <start> fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) <end>  != NULL);
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"<start> data <end> --;
<start> printIntLine(result) <end> ;"	0
93ece2e8-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING ""hello"" static void badSink(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); } else { printLine(""Input is less than the length of the source string""); } } } void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_44_bad() { size_t data; void (*funcPtr) (size_t) = badSink; data = 0; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = strtoul(inputBuffer, NULL, 0); } else { printLine(""fgets() failed.""); } } funcPtr(data); }"	where is the vulnerable dataflow from data to malloc ?	"myString = (char * <start> malloc(data*sizeof(char)) <end> ;
static void badSink(size_t <start> data <end> );
funcPtr <start> data <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
funcPtr <start> data <end> );
static void badSink(size_t <start> data <end> );
myString = (char *)malloc <start> data*sizeof(char) <end> );"	"static void badSink(size_t <start> data <end> );
myString = (char *)malloc <start> data*sizeof(char) <end> );
funcPtr <start> data <end> );
myString = (char * <start> malloc(data*sizeof(char)) <end> ;"	"static void badSink(size_t <start> data <end> );
funcPtr <start> data <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	1
c39a6580-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_environment_fopen_67 { typedef struct _structType { char * structFirst; } structType; void badSink(structType myStruct) { char * data = myStruct.structFirst; { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"char * data = <start> myStruct <end> .structFirst;
pFile = <start> FOPEN(data, ""wb+"") <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"void badSink(structType <start> myStruct <end> );
pFile = FOPEN <start> data <end> , ""wb+"");
char <start> * data = myStruct.structFirst <end> ;"	"char * data = <start> myStruct <end> .structFirst;
pFile = FOPEN <start> data <end> , ""wb+"");"	"void badSink(structType <start> myStruct <end> );
char * data = <start> myStruct <end> .structFirst;
pFile = FOPEN <start> data <end> , ""wb+"");"	3
c39a6578-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_environment_fopen_53 { void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } badSink_b(data); }"	where is the vulnerable dataflow from data to badSink_b ?	"<start> data = dataBuffer <end> ;
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
badSink_b <start> data <end> );"	"badSink_b <start> data <end> );
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"badSink_b <start> data <end> );
strncat(data+dataLen, environment, <start> FILENAME_MAX-dataLen-1 <end> );"	1
6c938c15-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif namespace CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_72 { void badSink(vector<char *> dataVector) { char * data = dataVector[2]; { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"void badSink(vector<char *> <start> dataVector <end> );
<start> printLine(dest) <end> ;"	"printLine <start> dest <end> );
void badSink(vector<char *> <start> dataVector <end> );"	"printLine <start> dest <end> );
<start> printLine(dest) <end> ;"	"void badSink(vector<char *> <start> dataVector <end> );
printLine <start> dest <end> );"	3
466e7f03-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_square_13_bad() { int data; data = 0; if(GLOBAL_CONST_FIVE==5) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(GLOBAL_CONST_FIVE==5) { { int result = data * data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  * data;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
if  <start> fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) <end>  != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
int result = <start> data <end>  * data;"	"int result = <start> data <end>  * data;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	2
cf875076-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif namespace CWE36_Absolute_Path_Traversal__char_environment_ofstream_52 { void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } badSink_b(data); }"	where is the vulnerable dataflow from data to badSink_b ?	"size_t dataLen = <start> strlen(data) <end> ;
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
badSink_b <start> data <end> );"	"badSink_b <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
<start> badSink_b(data) <end> ;"	1
cd228144-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif namespace CWE36_Absolute_Path_Traversal__char_console_ofstream_21 { static int badStatic = 0; static char * badSource(char * data) { if(badStatic) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } return data; } void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; badStatic = 1; data = badSource(data); { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } ; }"	where is the vulnerable dataflow from data to open ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
data = <start> badSource <end> (data);
outputFile.open((char * <start> data <end> );
static char * <start> badSource <end> (char * data);"	"size_t dataLen = <start> strlen(data) <end> ;
data = <start> badSource <end> (data);
outputFile.open((char * <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
outputFile.open((char * <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
outputFile.open((char * <start> data <end> );
data = <start> badSource <end> (data);
dataLen = <start> strlen(data) <end> ;"	2
78800fb4-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 8 void CWE194_Unexpected_Sign_Extension__listen_socket_memmove_17_bad() { int i; short data; data = 0; for(i = 0; i < 1; i++) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"printLine <start> dest <end> );
<start> printLine(dest) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
if  <start> tempInt > SHRT_MAX <end>  || tempInt < SHRT_MIN);"	"if  <start> data < 100 <end> );
printLine <start> dest <end> );"	1
c9919804-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" static int staticFive = 5; namespace CWE36_Absolute_Path_Traversal__char_connect_socket_ifstream_07 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(staticFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
replace = <start> strchr(data, '\r') <end> ;"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
inputFile.open((char * <start> data <end> );"	"inputFile.open((char * <start> data <end> );
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) *  <start> FILENAME_MAX - dataLen - 1 <end> ), 0);
inputFile.open((char * <start> data <end> );"	1
acf67e48-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_fgets_predec_15_bad() { int data; data = 0; switch(6) { case 6: { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } break; default: printLine(""Benign, fixed string""); break; } switch(7) { case 7: { --data; int result = data; printIntLine(result); } break; default: printLine(""Benign, fixed string""); break; } }"	where is the vulnerable dataflow from result to printIntLine ?	"<start> --data <end> ;
printIntLine <start> result <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
int <start> result = data <end> ;"	1
ba102b6e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define SEARCH_CHAR 'S' namespace CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_81 { void bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\0'; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } const CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_81_base& baseObject = CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_81_bad(); baseObject.action(data); }"	where is the vulnerable dataflow from data to action ?	"baseObject.action <start> data <end> );
replace = <start> strchr(data, '\r') <end> ;"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (100 - dataLen - 1), 0);
baseObject.action <start> data <end> );"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
baseObject.action <start> data <end> );"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
size_t dataLen = <start> strlen(data) <end> ;"	2
525b6489-6c15-11ed-81d4-94e6f77dd552	"void CWE190_Integer_Overflow__short_fscanf_preinc_31_bad() { short data; data = 0; fscanf (stdin, ""%hd"", &data); { short dataCopy = data; short data = dataCopy; { ++data; short result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"fscanf (stdin, ""%hd"", <start> &data <end> );
+ <start> data <end> ;"	"short <start> result = data <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );"	"<start> printIntLine(result) <end> ;
+ <start> data <end> ;"	"+ <start> data <end> ;
short <start> result = data <end> ;"	0
6b86246c-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) extern int CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_68_badData; extern int CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_68_goodG2BData; extern int CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_68_goodB2GData; void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_68b_badSink() { int data = CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_68_badData; { int i; int * buffer = (int *)malloc(10 * sizeof(int)); if (buffer == NULL) {exit(-1);} for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } free(buffer); } }"	where is the vulnerable dataflow from buffer to free ?	"<start> printIntLine(buffer[i]) <end> ;
free <start> buffer <end> );"	"free <start> buffer <end> );
int <start> * buffer = (int *)malloc(10 * sizeof(int)) <end> ;"	"int data = <start> CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_68_badData <end> ;
free <start> buffer <end> );"	"int data = <start> CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_68_badData <end> ;
<start> printIntLine(buffer[i]) <end> ;"	2
a5ce1c86-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink(int data) { { data++; int result = data; printIntLine(result); } } void CWE190_Integer_Overflow__int_listen_socket_postinc_41_bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badSink(data); }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
badSink <start> data <end> );
static void badSink(int <start> data <end> );"	"<start> printIntLine(result) <end> ;
static void badSink(int <start> data <end> );
printIntLine <start> result <end> );
badSink <start> data <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSink <start> data <end> );
static void badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"if  <start> listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR <end> );
static void badSink(int <start> data <end> );
printIntLine <start> result <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	2
d31a2521-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_listen_socket_open_21 { static int badStatic = 0; static char * badSource(char * data) { if(badStatic) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } return data; } void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; badStatic = 1; data = badSource(data); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } ; }"	where is the vulnerable dataflow from data to OPEN ?	"data = <start> badSource <end> (data);
static char * <start> badSource <end> (char * data);
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
char <start> dataBuffer[FILENAME_MAX] = """" <end> ;"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"static char * <start> badSource <end> (char * data);
<start> data = badSource(data) <end> ;
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	1
7fa68e2b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_connect_socket_fopen_10 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(globalTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = FOPEN <start> data <end> , ""wb+"");
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) *  <start> FILENAME_MAX - dataLen - 1 <end> ), 0);
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	3
669edad5-6c15-11ed-81d4-94e6f77dd552	static int64_t badSource(int64_t data) { data = (int64_t)RAND64(); return data; } void CWE190_Integer_Overflow__int64_t_rand_postinc_42_bad() { int64_t data; data = 0LL; data = badSource(data); { data++; int64_t result = data; printLongLongLine(result); } }	where is the vulnerable dataflow from data ?	"data = (int64_t <start> RAND64() <end> ;
static int64_t <start> badSource <end> (int64_t data);"	"data = (int64_t <start> RAND64() <end> ;
static int64_t <start> badSource <end> (int64_t data);
data = <start> badSource <end> (data);
<start> data <end> ++;"	"static int64_t <start> badSource <end> (int64_t data);
data = <start> badSource <end> (data);
data = (int64_t <start> RAND64() <end> ;"	"data = (int64_t <start> RAND64() <end> ;
<start> data <end> ++;
static int64_t <start> badSource <end> (int64_t data);
data = <start> badSource <end> (data);"	1
74ee23f5-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 8 void CWE194_Unexpected_Sign_Extension__fgets_malloc_02_bad() { short data; data = 0; if(1) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = (short)atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }"	where is the vulnerable dataflow from data to malloc ?	"char * dataBuffer = (char *)malloc <start> data <end> );
<start> data = 0 <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> data = (short)atoi(inputBuffer) <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
char * dataBuffer = (char *)malloc <start> data <end> );"	"char * dataBuffer = (char *)malloc <start> data <end> );
<start> free(dataBuffer) <end> ;"	2
8932180b-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif static const int STATIC_CONST_FIVE = 5; namespace CWE36_Absolute_Path_Traversal__char_file_fopen_06 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(STATIC_CONST_FIVE==5) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
pFile = FOPEN <start> data <end> , ""wb+"");"	"size_t dataLen = <start> strlen(data) <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
size_t dataLen = <start> strlen(data) <end> ;"	"pFile = FOPEN <start> data <end> , ""wb+"");
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	0
9d74538c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_FIVE = 5; void CWE127_Buffer_Underread__CWE839_connect_socket_06_bad() { int data; data = -1; if(STATIC_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(STATIC_CONST_FIVE==5) { { int buffer[10] = { 0 }; if (data < 10) { printIntLine(buffer[data]); } else { printLine(""ERROR: Array index is too big.""); } } } }"	where is the vulnerable dataflow from buffer[data] to printIntLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[data] <end> );"	"int <start> buffer[10] = { 0 } <end> ;
printIntLine <start> buffer[data] <end> );"	"printIntLine <start> buffer[data] <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"printIntLine <start> buffer[data] <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	0
630ae7fb-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__short_rand_multiply_82 { void CWE190_Integer_Overflow__short_rand_multiply_82_bad::action(short data) { if(data > 0) { short result = data * 2; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
void CWE190_Integer_Overflow__short_rand_multiply_82_bad::action(short <start> data <end> );"	"short result = <start> data * 2 <end> ;
void CWE190_Integer_Overflow__short_rand_multiply_82_bad::action(short <start> data <end> );"	"void CWE190_Integer_Overflow__short_rand_multiply_82_bad::action(short <start> data <end> );
short result = <start> data <end>  * 2;"	"short result = <start> data <end>  * 2;
<start> printIntLine(result) <end> ;"	2
715a3bfb-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif void CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_63b_badSink(char * * dataPtr) { char * data = *dataPtr; { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	"void CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_63b_badSink(char * * <start> dataPtr <end> );
printLine <start> dest <end> );"	"printLine <start> dest <end> );
<start> SNPRINTF(dest, 100-1, data) <end> ;"	"char <start> dest[100] = """" <end> ;
printLine <start> dest <end> );"	1
d1e9da39-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_listen_socket_fopen_16 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; while(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = FOPEN <start> data <end> , ""wb+"");
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"<start> data = dataBuffer <end> ;
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
replace = <start> strchr(data, '\n') <end> ;"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	3
656cd400-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__int_rand_multiply_72 { void badSink(vector<int> dataVector) { int data = dataVector[2]; if(data > 0) { int result = data * 2; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"int result = <start> data * 2 <end> ;
void badSink(vector<int> <start> dataVector <end> );"	"int result = <start> data <end>  * 2;
<start> printIntLine(result) <end> ;"	"void badSink(vector<int> <start> dataVector <end> );
int result = <start> data <end>  * 2;"	"void badSink(vector<int> <start> dataVector <end> );
<start> printIntLine(result) <end> ;"	2
78800f9e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 8 extern short CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_68_badData; extern short CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_68_goodG2BData; void CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_68b_badSink() { short data = CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_68_badData; { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> memcpy(dest, source, data) <end> ;
printLine <start> dest <end> );"	"short data = <start> CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_68_badData <end> ;
<start> memcpy(dest, source, data) <end> ;"	"short data = <start> CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_68_badData <end> ;
char <start> dest[100] = """" <end> ;"	"short data = <start> CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_68_badData <end> ;
printLine <start> dest <end> );"	3
4a02112a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_square_15_bad() { int data; data = 0; switch(6) { case 6: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; default: printLine(""Benign, fixed string""); break; } switch(7) { case 7: { int result = data * data; printIntLine(result); } break; default: printLine(""Benign, fixed string""); break; } }"	where is the vulnerable dataflow from data ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  * data;"	"int result = <start> data <end>  * data;
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printIntLine(result) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int <start> result = data * data <end> ;"	0
a5ce1c3a-6c15-11ed-81d4-94e6f77dd552	extern int CWE190_Integer_Overflow__int_connect_socket_postinc_22_badGlobal; void CWE190_Integer_Overflow__int_connect_socket_postinc_22_badSink(int data) { if(CWE190_Integer_Overflow__int_connect_socket_postinc_22_badGlobal) { { data++; int result = data; printIntLine(result); } } }	where is the vulnerable dataflow from result to printIntLine ?	"void CWE190_Integer_Overflow__int_connect_socket_postinc_22_badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
void CWE190_Integer_Overflow__int_connect_socket_postinc_22_badSink(int <start> data <end> );"	"void CWE190_Integer_Overflow__int_connect_socket_postinc_22_badSink(int <start> data <end> );
<start> printIntLine(result) <end> ;"	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;"	0
9187cc1d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #define SEARCH_CHAR 'S' void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_file_10_bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\0'; { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } if(globalTrue) { for (; *data != '\0'; data++) { if (*data == SEARCH_CHAR) { printLine(""We have a match!""); break; } } free(data); } }"	where is the vulnerable dataflow from data to free ?	"for (; *data != '\0'; <start> data++ <end> );
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
free <start> data <end> );"	"size_t dataLen = <start> strlen(data) <end> ;
free <start> data <end> );"	"<start> free(data) <end> ;
free <start> data <end> );"	1
b41b879d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 20 #define IP_ADDRESS ""127.0.0.1"" void CWE369_Divide_by_Zero__float_connect_socket_15_bad() { float data; data = 0.0F; switch(6) { case 6: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = (float)atof(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; default: printLine(""Benign, fixed string""); break; } switch(7) { case 7: { int result = (int)(100.0 / data); printIntLine(result); } break; default: printLine(""Benign, fixed string""); break; } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
int <start> result = (int)(100.0 / data) <end> ;"	"printIntLine <start> result <end> );
int result = (int) <start> 100.0 / data <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"int result = (int) <start> 100.0 / data <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	2
9059f384-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) int CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_61b_badSource(int data); void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_61_bad() { int data; data = -1; data = CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_61b_badSource(data); { size_t i; int *intPointer; intPointer = (int*)malloc(data * sizeof(int)); if (intPointer == NULL) {exit(-1);} for (i = 0; i < (size_t)data; i++) { intPointer[i] = 0; } printIntLine(intPointer[0]); free(intPointer); } }	where is the vulnerable dataflow from data to malloc ?	"data = <start> CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_61b_badSource <end> (data);
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	"intPointer = (int*)malloc <start> data * sizeof(int) <end> );
data = <start> CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_61b_badSource <end> (data);"	"if  <start> intPointer == NULL <end> ) {exit(-1);};
data = <start> CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_61b_badSource <end> (data);"	"if  <start> intPointer == NULL <end> ) {exit(-1);};
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	0
8f278a5c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_18_bad() { int data; data = -1; goto source; source: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { size_t i; int *intPointer; intPointer = (int*)malloc(data * sizeof(int)); if (intPointer == NULL) {exit(-1);} for (i = 0; i < (size_t)data; i++) { intPointer[i] = 0; } printIntLine(intPointer[0]); free(intPointer); } }"	where is the vulnerable dataflow from data to malloc ?	"if  <start> intPointer == NULL <end> ) {exit(-1);};
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"data = <start> atoi(inputBuffer) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> intPointer = (int*)malloc(data * sizeof(int)) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	3
c72d5d65-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_listen_socket_fopen_53 { void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badSink_b(data); }"	where is the vulnerable dataflow from data to badSink_b ?	"<start> badSink_b(data) <end> ;
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"if  <start> recvResult == SOCKET_ERROR <end>  || recvResult == 0);
badSink_b <start> data <end> );"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
badSink_b <start> data <end> );"	"replace = <start> strchr(data, '\n') <end> ;
badSink_b <start> data <end> );"	2
525b6474-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) typedef struct _CWE190_Integer_Overflow__int_listen_socket_preinc_67_structType { int structFirst; } CWE190_Integer_Overflow__int_listen_socket_preinc_67_structType; void CWE190_Integer_Overflow__int_listen_socket_preinc_67b_badSink(CWE190_Integer_Overflow__int_listen_socket_preinc_67_structType myStruct) { int data = myStruct.structFirst; { ++data; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"+ <start> data <end> ;
int data = <start> myStruct <end> .structFirst;
int <start> result = data <end> ;"	"int data = <start> myStruct <end> .structFirst;
<start> ++data <end> ;
+ <start> data <end> ;"	"<start> ++data <end> ;
+ <start> data <end> ;
void CWE190_Integer_Overflow__int_listen_socket_preinc_67b_badSink(CWE190_Integer_Overflow__int_listen_socket_preinc_67_structType <start> myStruct <end> );"	"void CWE190_Integer_Overflow__int_listen_socket_preinc_67b_badSink(CWE190_Integer_Overflow__int_listen_socket_preinc_67_structType <start> myStruct <end> );
int data = <start> myStruct <end> .structFirst;
+ <start> data <end> ;"	3
af58096d-6c15-11ed-81d4-94e6f77dd552	namespace CWE197_Numeric_Truncation_Error__int_connect_socket_to_short_81 { void CWE197_Numeric_Truncation_Error__int_connect_socket_to_short_81_bad::action(int data) const { { short shortData = (short)data; printShortLine(shortData); } } }	where is the vulnerable dataflow from shortData to printShortLine ?	"void CWE197_Numeric_Truncation_Error__int_connect_socket_to_short_81_bad::action(int <start> data <end> ) const;
printShortLine <start> shortData <end> );"	"short <start> shortData = (short)data <end> ;
void CWE197_Numeric_Truncation_Error__int_connect_socket_to_short_81_bad::action(int <start> data <end> ) const;"	"printShortLine <start> shortData <end> );
void CWE197_Numeric_Truncation_Error__int_connect_socket_to_short_81_bad::action(int <start> data <end> ) const;"	"printShortLine <start> shortData <end> );
<start> printShortLine(shortData) <end> ;"	0
6a52beea-6c15-11ed-81d4-94e6f77dd552	static unsigned int CWE191_Integer_Underflow__unsigned_int_rand_sub_45_badData; static unsigned int CWE191_Integer_Underflow__unsigned_int_rand_sub_45_goodG2BData; static unsigned int CWE191_Integer_Underflow__unsigned_int_rand_sub_45_goodB2GData; static void badSink() { unsigned int data = CWE191_Integer_Underflow__unsigned_int_rand_sub_45_badData; { unsigned int result = data - 1; printUnsignedLine(result); } } void CWE191_Integer_Underflow__unsigned_int_rand_sub_45_bad() { unsigned int data; data = 0; data = (unsigned int)RAND32(); CWE191_Integer_Underflow__unsigned_int_rand_sub_45_badData = data; badSink(); }	where is the vulnerable dataflow from data ?	"data = (unsigned int <start> RAND32() <end> ;
<start> CWE191_Integer_Underflow__unsigned_int_rand_sub_45_badData = data <end> ;
static unsigned int <start> CWE191_Integer_Underflow__unsigned_int_rand_sub_45_badData <end> ;"	"data = (unsigned int <start> RAND32() <end> ;
<start> CWE191_Integer_Underflow__unsigned_int_rand_sub_45_badData = data <end> ;
static unsigned int <start> CWE191_Integer_Underflow__unsigned_int_rand_sub_45_badData <end> ;
unsigned int data = <start> CWE191_Integer_Underflow__unsigned_int_rand_sub_45_badData <end> ;
unsigned int result = <start> data <end>  - 1;"	"data = (unsigned int <start> RAND32() <end> ;
unsigned int data = <start> CWE191_Integer_Underflow__unsigned_int_rand_sub_45_badData <end> ;
static unsigned int <start> CWE191_Integer_Underflow__unsigned_int_rand_sub_45_badData <end> ;
<start> CWE191_Integer_Underflow__unsigned_int_rand_sub_45_badData = data <end> ;"	"data = (unsigned int <start> RAND32() <end> ;
<start> CWE191_Integer_Underflow__unsigned_int_rand_sub_45_badData = data <end> ;"	1
cbf237a1-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; namespace CWE36_Absolute_Path_Traversal__char_console_fopen_04 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(STATIC_CONST_TRUE) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
char <start> dataBuffer[FILENAME_MAX] = """" <end> ;"	"dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"<start> data = dataBuffer <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	0
6a52bef4-6c15-11ed-81d4-94e6f77dd552	static unsigned int CWE191_Integer_Underflow__unsigned_int_rand_predec_45_badData; static unsigned int CWE191_Integer_Underflow__unsigned_int_rand_predec_45_goodG2BData; static unsigned int CWE191_Integer_Underflow__unsigned_int_rand_predec_45_goodB2GData; static void badSink() { unsigned int data = CWE191_Integer_Underflow__unsigned_int_rand_predec_45_badData; { --data; unsigned int result = data; printUnsignedLine(result); } } void CWE191_Integer_Underflow__unsigned_int_rand_predec_45_bad() { unsigned int data; data = 0; data = (unsigned int)RAND32(); CWE191_Integer_Underflow__unsigned_int_rand_predec_45_badData = data; badSink(); }	where is the vulnerable dataflow from data ?	"data = (unsigned int <start> RAND32() <end> ;
<start> CWE191_Integer_Underflow__unsigned_int_rand_predec_45_badData = data <end> ;
static unsigned int <start> CWE191_Integer_Underflow__unsigned_int_rand_predec_45_badData <end> ;
unsigned int data = <start> CWE191_Integer_Underflow__unsigned_int_rand_predec_45_badData <end> ;
- <start> data <end> ;"	"data = (unsigned int <start> RAND32() <end> ;
unsigned int data = <start> CWE191_Integer_Underflow__unsigned_int_rand_predec_45_badData <end> ;
static unsigned int <start> CWE191_Integer_Underflow__unsigned_int_rand_predec_45_badData <end> ;
<start> CWE191_Integer_Underflow__unsigned_int_rand_predec_45_badData = data <end> ;"	"static unsigned int <start> CWE191_Integer_Underflow__unsigned_int_rand_predec_45_badData <end> ;
- <start> data <end> ;
data = (unsigned int <start> RAND32() <end> ;
unsigned int data = <start> CWE191_Integer_Underflow__unsigned_int_rand_predec_45_badData <end> ;
<start> CWE191_Integer_Underflow__unsigned_int_rand_predec_45_badData = data <end> ;"	"data = (unsigned int <start> RAND32() <end> ;
<start> CWE191_Integer_Underflow__unsigned_int_rand_predec_45_badData = data <end> ;"	0
b08640eb-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink(int data) { { short shortData = (short)data; printShortLine(shortData); } } void CWE197_Numeric_Truncation_Error__int_fgets_to_short_44_bad() { int data; void (*funcPtr) (int) = badSink; data = -1; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } funcPtr(data); }"	where is the vulnerable dataflow from shortData to printShortLine ?	"<start> data = atoi(inputBuffer) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printShortLine <start> shortData <end> );
static void badSink(int <start> data <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
funcPtr <start> data <end> );
static void badSink(int <start> data <end> );
printShortLine <start> shortData <end> );"	"<start> printShortLine(shortData) <end> ;
static void badSink(int <start> data <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printShortLine <start> shortData <end> );"	"funcPtr <start> data <end> );
static void badSink(int <start> data <end> );
<start> funcPtr(data) <end> ;
printShortLine <start> shortData <end> );"	1
5e44fc73-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_fgets_predec_10_bad() { int data; data = 0; if(globalTrue) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(globalTrue) { { --data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"<start> --data <end> ;
- <start> data <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
- <start> data <end> ;"	"int <start> result = data <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	2
630ae810-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__short_rand_square_31_bad() { short data; data = 0; data = (short)RAND32(); { short dataCopy = data; short data = dataCopy; { short result = data * data; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"<start> data = (short)RAND32() <end> ;
short result = <start> data <end>  * data;"	"<start> printIntLine(result) <end> ;
data = (short <start> RAND32() <end> ;"	"data = (short <start> RAND32() <end> ;
short result = <start> data <end>  * data;"	"short result = <start> data <end>  * data;
<start> printIntLine(result) <end> ;"	2
584fa885-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_listen_socket_sub_53d_badSink(int data) { { int result = data - 1; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"int <start> result = data - 1 <end> ;
void CWE191_Integer_Underflow__int_listen_socket_sub_53d_badSink(int <start> data <end> );"	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  - 1;"	"int result = <start> data <end>  - 1;
void CWE191_Integer_Underflow__int_listen_socket_sub_53d_badSink(int <start> data <end> );"	"void CWE191_Integer_Underflow__int_listen_socket_sub_53d_badSink(int <start> data <end> );
int result = <start> data <end>  - 1;"	3
5be3a99f-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_fgets_postdec_53d_badSink(int data) { { data--; int result = data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"<start> data <end> --;
<start> printIntLine(result) <end> ;"	"void CWE191_Integer_Underflow__int_fgets_postdec_53d_badSink(int <start> data <end> );
<start> data <end> --;"	"<start> data <end> --;
void CWE191_Integer_Underflow__int_fgets_postdec_53d_badSink(int <start> data <end> );"	"void CWE191_Integer_Underflow__int_fgets_postdec_53d_badSink(int <start> data <end> );
<start> printIntLine(result) <end> ;"	1
4a02112b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_square_16_bad() { int data; data = 0; while(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; } while(1) { { int result = data * data; printIntLine(result); } break; } }"	where is the vulnerable dataflow from data ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int <start> result = data * data <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
if  <start> listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  * data;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data = atoi(inputBuffer) <end> ;"	2
a830bf98-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } void CWE191_Integer_Underflow__int_connect_socket_sub_08_bad() { int data; data = 0; if(staticReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticReturnsTrue()) { { int result = data - 1; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"<start> data = 0 <end> ;
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	3
584fa85c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_listen_socket_multiply_53d_badSink(int data) { if(data < 0) { int result = data * 2; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  * 2;
void CWE191_Integer_Underflow__int_listen_socket_multiply_53d_badSink(int <start> data <end> );"	"void CWE191_Integer_Underflow__int_listen_socket_multiply_53d_badSink(int <start> data <end> );
int result = <start> data <end>  * 2;"	"int <start> result = data * 2 <end> ;
void CWE191_Integer_Underflow__int_listen_socket_multiply_53d_badSink(int <start> data <end> );"	"int result = <start> data <end>  * 2;
<start> printIntLine(result) <end> ;"	1
728a502d-6c15-11ed-81d4-94e6f77dd552	#ifndef _WIN32 #endif namespace CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_72 { static void badVaSink(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); va_end(args); } } void badSink(vector<char *> dataVector) { char * data = dataVector[2]; badVaSink(data, data); }	where is the vulnerable dataflow from data to vprintf ?	"static void badVaSink(char * <start> data <end> , ...);
vprintf <start> data <end> , args);
<start> va_start(args, data) <end> ;
void badSink(vector<char *> <start> dataVector <end> );"	"void badSink(vector<char *> <start> dataVector <end> );
vprintf <start> data <end> , args);
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);"	"void badSink(vector<char *> <start> dataVector <end> );
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
vprintf <start> data <end> , args);"	"static void badVaSink(char * <start> data <end> , ...);
<start> vprintf(data, args) <end> ;
void badSink(vector<char *> <start> dataVector <end> );
badVaSink <start> data <end> , data);"	2
5f76fcbe-6c15-11ed-81d4-94e6f77dd552	typedef struct _CWE191_Integer_Underflow__short_fscanf_predec_67_structType { short structFirst; } CWE191_Integer_Underflow__short_fscanf_predec_67_structType; void CWE191_Integer_Underflow__short_fscanf_predec_67b_badSink(CWE191_Integer_Underflow__short_fscanf_predec_67_structType myStruct) { short data = myStruct.structFirst; { --data; short result = data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"void CWE191_Integer_Underflow__short_fscanf_predec_67b_badSink(CWE191_Integer_Underflow__short_fscanf_predec_67_structType <start> myStruct <end> );
short data = <start> myStruct <end> .structFirst;
- <start> data <end> ;"	"- <start> data <end> ;
short data = <start> myStruct <end> .structFirst;
short <start> result = data <end> ;"	"short data = <start> myStruct <end> .structFirst;
<start> printIntLine(result) <end> ;
- <start> data <end> ;"	"- <start> data <end> ;
<start> --data <end> ;
void CWE191_Integer_Underflow__short_fscanf_predec_67b_badSink(CWE191_Integer_Underflow__short_fscanf_predec_67_structType <start> myStruct <end> );"	0
47a2a829-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__int_fscanf_add_73 { void badSink(list<int> dataList) { int data = dataList.back(); { int result = data + 1; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"void badSink(list<int> <start> dataList <end> );
int result = <start> data <end>  + 1;"	"void badSink(list<int> <start> dataList <end> );
int <start> result = data + 1 <end> ;"	"int result = <start> data <end>  + 1;
int <start> data = dataList.back() <end> ;"	"int result = <start> data <end>  + 1;
<start> printIntLine(result) <end> ;"	0
cd22813b-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif namespace CWE36_Absolute_Path_Traversal__char_console_ofstream_10 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(globalTrue) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"outputFile.open((char * <start> data <end> );
dataLen = <start> strlen(data) <end> ;"	"outputFile.open((char * <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
outputFile.open((char * <start> data <end> );"	3
669edab7-6c15-11ed-81d4-94e6f77dd552	static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } void CWE190_Integer_Overflow__char_rand_postinc_08_bad() { char data; data = ' '; if(staticReturnsTrue()) { data = (char)RAND32(); } if(staticReturnsTrue()) { { data++; char result = data; printHexCharLine(result); } } }	where is the vulnerable dataflow from data ?	"data = (char <start> RAND32() <end> ;
<start> data <end> ++;"	"<start> data = (char)RAND32() <end> ;
<start> data <end> ++;"	"<start> data <end> ++;
char <start> result = data <end> ;"	"data = (char <start> RAND32() <end> ;
<start> data++ <end> ;"	0
78800fd1-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 8 void CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_02_bad() { short data; data = 0; if(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> strncpy(dest, source, data) <end> ;"	"printLine <start> dest <end> );
<start> printLine(dest) <end> ;"	"<start> data = -1 <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	3
8df421ed-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define PATH_SZ 100 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define PATH_SZ PATH_MAX #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } void CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__accept_bind_listen_08_bad() { if(staticReturnsTrue()) { { char data[100] = """"; #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[recvResult] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif printLine(data); } } }"	where is the vulnerable dataflow from data to printLine ?	"replace = <start> strchr(data, '\r') <end> ;
printLine <start> data <end> );"	"recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);
printLine <start> data <end> );"	"printLine <start> data <end> );
recvResult = <start> recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0) <end> ;"	"printLine <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	1
cf875099-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_environment_open_61 { char * badSource(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; data = badSource(data); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
data = <start> badSource(data) <end> ;"	"<start> data = badSource(data) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"data = <start> badSource <end> (data);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	3
86cea13d-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE369_Divide_by_Zero__int_fgets_modulo_31_bad() { int data; data = -1; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } { int dataCopy = data; int data = dataCopy; printIntLine(100 % data); } }"	where is the vulnerable dataflow from data to printIntLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> data = atoi(inputBuffer) <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> 100 % data <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
int <start> data = dataCopy <end> ;"	"<start> data = atoi(inputBuffer) <end> ;
printIntLine <start> 100 % data <end> );"	1
893217d6-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_console_fopen_67 { typedef struct _structType { char * structFirst; } structType; void badSink(structType myStruct) { char * data = myStruct.structFirst; { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = FOPEN <start> data <end> , ""wb+"");
void badSink(structType <start> myStruct <end> );
char * data = <start> myStruct <end> .structFirst;"	"void badSink(structType <start> myStruct <end> );
char * data = <start> myStruct <end> .structFirst;
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");
char * data = <start> myStruct <end> .structFirst;"	"void badSink(structType <start> myStruct <end> );
pFile = <start> FOPEN(data, ""wb+"") <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	1
cac216e0-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_connect_socket_open_34 { typedef union { char * unionFirst; char * unionSecond; } unionType; void bad() { char * data; unionType myUnion; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"replace = <start> strchr(data, '\r') <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);"	2
93ece2e7-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING ""hello"" namespace CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_43 { static void badSource(size_t &data) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = strtoul(inputBuffer, NULL, 0); } else { printLine(""fgets() failed.""); } } } void bad() { size_t data; data = 0; badSource(data); { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); } else { printLine(""Input is less than the length of the source string""); } } }"	where is the vulnerable dataflow from data to malloc ?	"badSource <start> data <end> );
<start> printLine(myString) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"badSource <start> data <end> );
myString = (char *)malloc <start> data*sizeof(char) <end> );
<start> printLine(myString) <end> ;"	"badSource <start> data <end> );
myString = (char *)malloc <start> data*sizeof(char) <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
badSource <start> data <end> );
myString = (char *)malloc <start> data*sizeof(char) <end> );"	3
a5ce1c66-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_postinc_51b_badSink(int data) { { data++; int result = data; printIntLine(result); } }	where is the vulnerable dataflow from result to printIntLine ?	"<start> printIntLine(result) <end> ;
void CWE190_Integer_Overflow__int_fgets_postinc_51b_badSink(int <start> data <end> );"	"void CWE190_Integer_Overflow__int_fgets_postinc_51b_badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	"int <start> result = data <end> ;
printIntLine <start> result <end> );"	1
b68484fb-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define NEW_PATH ""%SystemRoot%\\system32"" #define PUTENV _putenv #else #define NEW_PATH ""/bin"" #define PUTENV putenv #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; void CWE427_Uncontrolled_Search_Path_Element__char_connect_socket_04_bad() { char * data; char dataBuffer[250] = ""PATH=""; data = dataBuffer; if(STATIC_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (250 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } PUTENV(data); }"	where is the vulnerable dataflow from data to PUTENV ?	"<start> data = dataBuffer <end> ;
PUTENV <start> data <end> );"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (250 - dataLen - 1), 0);
PUTENV <start> data <end> );"	"replace = <start> strchr(data, '\n') <end> ;
PUTENV <start> data <end> );"	"<start> PUTENV(data) <end> ;
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (250 - dataLen - 1), 0);"	1
7c1275c0-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) typedef union { int unionFirst; int unionSecond; } CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_34_unionType; void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_34_bad() { int data; CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_34_unionType myUnion; data = -1; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } myUnion.unionFirst = data; { int data = myUnion.unionSecond; { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } } }"	where is the vulnerable dataflow from dest to printLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printLine <start> dest <end> );"	"<start> printLine(dest) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
if  <start> data < 100 <end> );"	"printLine <start> dest <end> );
<start> memmove(dest, source, data) <end> ;"	0
98b01546-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticFive = 5; namespace CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_connect_socket_07 { void bad() { int data; data = -1; if(staticFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticFive==5) { { int i; int * buffer = new int[10]; for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } delete[] buffer; } } }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"int <start> * buffer = new int[10] <end> ;
printIntLine <start> buffer[i] <end> );"	"printIntLine <start> buffer[i] <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"printIntLine <start> buffer[i] <end> );
data = <start> atoi(inputBuffer) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[i] <end> );"	3
4a02111a-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__int_listen_socket_multiply_74 { void badSink(map<int, int> dataMap) { int data = dataMap[2]; if(data > 0) { int result = data * 2; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
void badSink(map<int, int> <start> dataMap <end> );"	"int result = <start> data <end>  * 2;
void badSink(map<int, int> <start> dataMap <end> );"	"void badSink(map<int, int> <start> dataMap <end> );
int result = <start> data <end>  * 2;"	"int <start> result = data * 2 <end> ;
void badSink(map<int, int> <start> dataMap <end> );"	2
a830bf9a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_connect_socket_sub_10_bad() { int data; data = 0; if(globalTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalTrue) { { int result = data - 1; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printIntLine(result) <end> ;"	"data = <start> atoi(inputBuffer) <end> ;
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	0
b8e2bdac-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define NEW_PATH ""%SystemRoot%\\system32"" #define PUTENV _putenv #else #define NEW_PATH ""/bin"" #define PUTENV putenv #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 char * CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_61b_badSource(char * data); void CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_61_bad() { char * data; char dataBuffer[250] = ""PATH=""; data = dataBuffer; data = CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_61b_badSource(data); PUTENV(data); }"	where is the vulnerable dataflow from data to PUTENV ?	"PUTENV <start> data <end> );
data = <start> CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_61b_badSource <end> (data);"	"data = <start> CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_61b_badSource <end> (data);
<start> PUTENV(data) <end> ;"	"<start> PUTENV(data) <end> ;
PUTENV <start> data <end> );"	"data = <start> CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_61b_badSource <end> (data);
PUTENV <start> data <end> );"	3
c5fc2349-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif namespace CWE23_Relative_Path_Traversal__char_file_ofstream_01 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"outputFile.open((char * <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"outputFile.open((char * <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
outputFile.open((char * <start> data <end> );"	"<start> data = dataBuffer <end> ;
outputFile.open((char * <start> data <end> );"	2
c72d5d2f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_file_open_21 { static int badStatic = 0; static char * badSource(char * data) { if(badStatic) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } return data; } void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; badStatic = 1; data = badSource(data); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } ; }"	where is the vulnerable dataflow from data to OPEN ?	"static char * <start> badSource <end> (char * data);
size_t dataLen = <start> strlen(data) <end> ;
data = <start> badSource <end> (data);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
data = <start> badSource <end> (data);
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	1
bb49c59e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #define EXECLP _execlp #else #define EXECLP execlp #endif static int staticFive = 5; void CWE78_OS_Command_Injection__char_console_execlp_07_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(staticFive==5) { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECLP ?	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
if  <start> 100-dataLen <end>  > 1);"	"dataLen = <start> strlen(data) <end> ;
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
if  <start> 100-dataLen <end>  > 1);"	2
466e7f0d-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink(int data) { { int result = data * data; printIntLine(result); } } void CWE190_Integer_Overflow__int_fgets_square_41_bad() { int data; data = 0; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } badSink(data); }"	where is the vulnerable dataflow from data ?	"badSink <start> data <end> );
static void badSink(int <start> data <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"static void badSink(int <start> data <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
int result = <start> data <end>  * data;
badSink <start> data <end> );"	"static void badSink(int <start> data <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> badSink(data) <end> ;
badSink <start> data <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
badSink <start> data <end> );
static void badSink(int <start> data <end> );
int result = <start> data <end>  * data;"	3
728a5026-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 char * CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_61b_badSource(char * data); static void badVaSink(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_61_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; data = CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_61b_badSource(data); badVaSink(data, data); }"	where is the vulnerable dataflow from data to vprintf ?	"data = <start> CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_61b_badSource <end> (data);
vprintf <start> data <end> , args);
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);"	"<start> va_start(args, data) <end> ;
vprintf <start> data <end> , args);
static void badVaSink(char * <start> data <end> , ...);
badVaSink <start> data <end> , data);"	"data = <start> CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_61b_badSource <end> (data);
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
vprintf <start> data <end> , args);"	"data = <start> CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_61b_badSource <end> (data);
static void badVaSink(char * <start> data <end> , ...);
vprintf <start> data <end> , args);"	2
571e9810-6c15-11ed-81d4-94e6f77dd552	"static int CWE191_Integer_Underflow__int_fscanf_multiply_45_badData; static int CWE191_Integer_Underflow__int_fscanf_multiply_45_goodG2BData; static int CWE191_Integer_Underflow__int_fscanf_multiply_45_goodB2GData; static void badSink() { int data = CWE191_Integer_Underflow__int_fscanf_multiply_45_badData; if(data < 0) { int result = data * 2; printIntLine(result); } } void CWE191_Integer_Underflow__int_fscanf_multiply_45_bad() { int data; data = 0; fscanf(stdin, ""%d"", &data); CWE191_Integer_Underflow__int_fscanf_multiply_45_badData = data; badSink(); }"	where is the vulnerable dataflow from data ?	"int data = <start> CWE191_Integer_Underflow__int_fscanf_multiply_45_badData <end> ;
int <start> result = data * 2 <end> ;
<start> CWE191_Integer_Underflow__int_fscanf_multiply_45_badData = data <end> ;
fscanf(stdin, ""%d"", <start> &data <end> );
static int <start> CWE191_Integer_Underflow__int_fscanf_multiply_45_badData <end> ;"	"<start> printIntLine(result) <end> ;
static int <start> CWE191_Integer_Underflow__int_fscanf_multiply_45_badData <end> ;
fscanf(stdin, ""%d"", <start> &data <end> );
<start> CWE191_Integer_Underflow__int_fscanf_multiply_45_badData = data <end> ;
int result = <start> data <end>  * 2;"	"fscanf(stdin, ""%d"", <start> &data <end> );
<start> CWE191_Integer_Underflow__int_fscanf_multiply_45_badData = data <end> ;
static int <start> CWE191_Integer_Underflow__int_fscanf_multiply_45_badData <end> ;
int result = <start> data <end>  * 2;
int data = <start> CWE191_Integer_Underflow__int_fscanf_multiply_45_badData <end> ;"	"fscanf(stdin, ""%d"", <start> &data <end> );
<start> CWE191_Integer_Underflow__int_fscanf_multiply_45_badData = data <end> ;
static int <start> CWE191_Integer_Underflow__int_fscanf_multiply_45_badData <end> ;
int data = <start> CWE191_Integer_Underflow__int_fscanf_multiply_45_badData <end> ;
int result = <start> data <end>  * 2;"	3
9ebc76d7-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE127_Buffer_Underread__CWE839_listen_socket_14_bad() { int data; data = -1; if(globalFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalFive==5) { { int buffer[10] = { 0 }; if (data < 10) { printIntLine(buffer[data]); } else { printLine(""ERROR: Array index is too big.""); } } } }"	where is the vulnerable dataflow from buffer[data] to printIntLine ?	"printIntLine <start> buffer[data] <end> );
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"if  <start> acceptSocket == SOCKET_ERROR <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printIntLine(buffer[data]) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[data] <end> );"	3
a5ce1c69-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_postinc_54e_badSink(int data) { { data++; int result = data; printIntLine(result); } }	where is the vulnerable dataflow from result to printIntLine ?	"void CWE190_Integer_Overflow__int_fgets_postinc_54e_badSink(int <start> data <end> );
<start> printIntLine(result) <end> ;"	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;"	"printIntLine <start> result <end> );
void CWE190_Integer_Overflow__int_fgets_postinc_54e_badSink(int <start> data <end> );"	"void CWE190_Integer_Overflow__int_fgets_postinc_54e_badSink(int <start> data <end> );
printIntLine <start> result <end> );"	3
79b27539-6c15-11ed-81d4-94e6f77dd552	namespace CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_62 { void badSource(int &data); void bad() { int data; data = -1; badSource(data); if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }	where is the vulnerable dataflow from data to malloc ?	"badSource <start> data <end> );
if  <start> dataBuffer == NULL <end> ) {exit(-1);};"	"badSource <start> data <end> );
char * dataBuffer = (char *)malloc <start> data <end> );"	"char * dataBuffer = (char *)malloc <start> data <end> );
<start> data = -1 <end> ;"	"badSource <start> data <end> );
<start> memset(dataBuffer, 'A', data-1) <end> ;"	1
5e44fcaa-6c15-11ed-81d4-94e6f77dd552	void CWE191_Integer_Underflow__int_fscanf_predec_64b_badSink(void * dataVoidPtr) { int * dataPtr = (int *)dataVoidPtr; int data = (*dataPtr); { --data; int result = data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"int <start> result = data <end> ;
void CWE191_Integer_Underflow__int_fscanf_predec_64b_badSink(void * <start> dataVoidPtr <end> );"	"void CWE191_Integer_Underflow__int_fscanf_predec_64b_badSink(void * <start> dataVoidPtr <end> );
- <start> data <end> ;"	"<start> --data <end> ;
- <start> data <end> ;"	"<start> printIntLine(result) <end> ;
void CWE191_Integer_Underflow__int_fscanf_predec_64b_badSink(void * <start> dataVoidPtr <end> );"	1
61da6709-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__short_rand_add_11_bad() { short data; data = 0; if(globalReturnsTrue()) { data = (short)RAND32(); } if(globalReturnsTrue()) { { short result = data + 1; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"data = (short <start> RAND32() <end> ;
short result = <start> data + 1 <end> ;"	"short result = <start> data <end>  + 1;
data = (short <start> RAND32() <end> ;"	"data = (short <start> RAND32() <end> ;
<start> printIntLine(result) <end> ;"	"data = (short <start> RAND32() <end> ;
short result = <start> data <end>  + 1;"	3
7fa68e33-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_connect_socket_fopen_18 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; goto source; source: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	"replace = <start> strchr(data, '\r') <end> ;
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"pFile = FOPEN <start> data <end> , ""wb+"");
size_t <start> dataLen = strlen(data) <end> ;"	0
8f278a64-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink(int data) { { size_t i; int *intPointer; intPointer = (int*)malloc(data * sizeof(int)); if (intPointer == NULL) {exit(-1);} for (i = 0; i < (size_t)data; i++) { intPointer[i] = 0; } printIntLine(intPointer[0]); free(intPointer); } } void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_44_bad() { int data; void (*funcPtr) (int) = badSink; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } funcPtr(data); }"	where is the vulnerable dataflow from data to malloc ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
funcPtr <start> data <end> );
static void badSink(int <start> data <end> );
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
funcPtr <start> data <end> );
static void badSink(int <start> data <end> );
<start> funcPtr(data) <end> ;"	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
static void badSink(int <start> data <end> );
intPointer = (int*)malloc <start> data * sizeof(int) <end> );
funcPtr <start> data <end> );"	"recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);
static void badSink(int <start> data <end> );
funcPtr <start> data <end> );
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	0
cf875079-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif namespace CWE36_Absolute_Path_Traversal__char_environment_ofstream_65 { void badSink(char * data); void bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } funcPtr(data); }"	where is the vulnerable dataflow from data to funcPtr ?	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
char <start> dataBuffer[FILENAME_MAX] = """" <end> ;"	"size_t dataLen = <start> strlen(data) <end> ;
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"strncat(data+dataLen, environment, <start> FILENAME_MAX-dataLen-1 <end> );
funcPtr <start> data <end> );"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
funcPtr <start> data <end> );"	3
a23a3e36-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_multiply_63b_badSink(int * dataPtr) { int data = *dataPtr; if(data > 0) { int result = data * 2; printIntLine(result); } }	where is the vulnerable dataflow from result to printIntLine ?	"void CWE190_Integer_Overflow__int_fgets_multiply_63b_badSink(int * <start> dataPtr <end> );
if <start> data > 0 <end> ) ;"	"int <start> result = data * 2 <end> ;
printIntLine <start> result <end> );"	"void CWE190_Integer_Overflow__int_fgets_multiply_63b_badSink(int * <start> dataPtr <end> );
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
void CWE190_Integer_Overflow__int_fgets_multiply_63b_badSink(int * <start> dataPtr <end> );"	2
b1b80806-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int badSource(int data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } return data; } void CWE197_Numeric_Truncation_Error__int_listen_socket_to_char_42_bad() { int data; data = -1; data = badSource(data); { char charData = (char)data; printHexCharLine(charData); } }"	where is the vulnerable dataflow from charData to printHexCharLine ?	"<start> data = -1 <end> ;
static int <start> badSource <end> (int data);
printHexCharLine <start> charData <end> );
data = <start> badSource <end> (data);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static int <start> badSource <end> (int data);
data = <start> badSource <end> (data);
printHexCharLine <start> charData <end> );"	"data = <start> badSource <end> (data);
if  <start> listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printHexCharLine <start> charData <end> );"	"data = <start> badSource <end> (data);
static int <start> badSource <end> (int data);
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	1
9fe7ad2a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif namespace CWE134_Uncontrolled_Format_String__char_file_fprintf_81 { void bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } const CWE134_Uncontrolled_Format_String__char_file_fprintf_81_base& baseObject = CWE134_Uncontrolled_Format_String__char_file_fprintf_81_bad(); baseObject.action(data); }"	where is the vulnerable dataflow from data to action ?	"baseObject.action <start> data <end> );
char <start> dataBuffer[100] = """" <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
baseObject.action <start> data <end> );"	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	"baseObject.action <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	1
87ff983f-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif static int staticTrue = 1; static int staticFalse = 0; namespace CWE36_Absolute_Path_Traversal__char_connect_socket_fopen_05 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(staticTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = FOPEN <start> data <end> , ""wb+"");
replace = <start> strchr(data, '\r') <end> ;"	"char <start> dataBuffer[FILENAME_MAX] = """" <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
size_t dataLen = <start> strlen(data) <end> ;"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	3
5133a75e-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_preinc_11_bad() { int data; data = 0; if(globalReturnsTrue()) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(globalReturnsTrue()) { { ++data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
+ <start> data <end> ;"	"<start> printIntLine(result) <end> ;
+ <start> data <end> ;"	"+ <start> data <end> ;
<start> ++data <end> ;"	"<start> ++data <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	0
79b2753f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) extern int CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_68_badData; extern int CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_68_goodG2BData; void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_68b_badSink() { int data = CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_68_badData; if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }"	where is the vulnerable dataflow from data to malloc ?	"int data = <start> CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_68_badData <end> ;
char * dataBuffer = (char *)malloc <start> data <end> );"	"char * dataBuffer = (char *)malloc <start> data <end> );
if  <start> dataBuffer == NULL <end> ) {exit(-1);};"	"if  <start> dataBuffer == NULL <end> ) {exit(-1);};
int data = <start> CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_68_badData <end> ;"	"char * dataBuffer = (char *)malloc <start> data <end> );
memset(dataBuffer, 'A', <start> data-1 <end> );"	0
c4cd6f4d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_environment_open_54 { void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } badSink_b(data); }"	where is the vulnerable dataflow from data to badSink_b ?	"size_t dataLen = <start> strlen(data) <end> ;
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"badSink_b <start> data <end> );
strncat(data+dataLen, environment, FILENAME_MAX <start> dataLen-1 <end> );"	"badSink_b <start> data <end> );
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
badSink_b <start> data <end> );"	3
cd228175-6c15-11ed-81d4-94e6f77dd552	#ifndef _WIN32 #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_console_open_66 { void badSink(char * dataArray[]) { char * data = dataArray[2]; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);
void badSink(char * <start> dataArray <end> []);"	"void badSink(char * <start> dataArray <end> []);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
char <start> * data = dataArray[2] <end> ;"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = OPEN(data, O_RDWR|O_CREAT, <start> S_IREAD|S_IWRITE <end> );"	1
9187cbe9-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define SEARCH_CHAR 'S' void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_64b_badSink(void * dataVoidPtr) { char * * dataPtr = (char * *)dataVoidPtr; char * data = (*dataPtr); for (; *data != '\0'; data++) { if (*data == SEARCH_CHAR) { printLine(""We have a match!""); break; } } free(data); }"	where is the vulnerable dataflow from data to free ?	"for (; *data != '\0'; <start> data++ <end> );
free <start> data <end> );"	"free <start> data <end> );
void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_64b_badSink(void * <start> dataVoidPtr <end> );"	"void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_64b_badSink(void * <start> dataVoidPtr <end> );
free <start> data <end> );"	"void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_64b_badSink(void * <start> dataVoidPtr <end> );
<start> free(data) <end> ;"	2
c8600af2-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 namespace CWE23_Relative_Path_Traversal__char_listen_socket_ofstream_52 { void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badSink_b(data); }"	where is the vulnerable dataflow from data to badSink_b ?	"badSink_b <start> data <end> );
<start> badSink_b(data) <end> ;"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
badSink_b <start> data <end> );"	"badSink_b <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
replace = <start> strchr(data, '\n') <end> ;"	1
4db33f6a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_postinc_03_bad() { int data; data = 0; if(5==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(5==5) { { data++; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"int <start> result = data <end> ;
<start> data <end> ++;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data <end> ++;"	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
<start> data <end> ++;"	"<start> data++ <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	1
8a6310ee-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_listen_socket_fopen_21 { static int badStatic = 0; static char * badSource(char * data) { if(badStatic) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } return data; } void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; badStatic = 1; data = badSource(data); { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } ; }"	where is the vulnerable dataflow from data to FOPEN ?	"static char * <start> badSource <end> (char * data);
pFile = FOPEN <start> data <end> , ""wb+"");
data = <start> badSource <end> (data);"	"static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
replace = <start> strchr(data, '\n') <end> ;"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
size_t dataLen = <start> strlen(data) <end> ;
static char * <start> badSource <end> (char * data);
pFile = FOPEN <start> data <end> , ""wb+"");"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
pFile = FOPEN <start> data <end> , ""wb+"");"	3
7c12759f-6c15-11ed-81d4-94e6f77dd552	"namespace CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_62 { void badSource(int &data); void bad() { int data; data = -1; badSource(data); { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"badSource <start> data <end> );
<start> memcpy(dest, source, data) <end> ;"	"printLine <start> dest <end> );
<start> memcpy(dest, source, data) <end> ;"	"<start> badSource(data) <end> ;
printLine <start> dest <end> );"	"badSource <start> data <end> );
printLine <start> dest <end> );"	3
8b91e477-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_listen_socket_open_21 { static int badStatic = 0; static char * badSource(char * data) { if(badStatic) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } return data; } void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; badStatic = 1; data = badSource(data); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } ; }"	where is the vulnerable dataflow from data to OPEN ?	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
data = <start> badSource <end> (data);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
static char * <start> badSource <end> (char * data);"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
data = <start> badSource <end> (data);
static char * <start> badSource <end> (char * data);
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
static char * <start> badSource <end> (char * data);
<start> data = badSource(data) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	0
a49c4f95-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticFive = 5; void CWE190_Integer_Overflow__int_connect_socket_postinc_07_bad() { int data; data = 0; if(staticFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticFive==5) { { data++; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"data = <start> atoi(inputBuffer) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);
printIntLine <start> result <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"data = <start> atoi(inputBuffer) <end> ;
printIntLine <start> result <end> );"	2
977ea786-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_15_bad() { int data; data = -1; switch(6) { case 6: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; default: printLine(""Benign, fixed string""); break; } switch(7) { case 7: { int i; int buffer[10] = { 0 }; if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } } break; default: printLine(""Benign, fixed string""); break; } }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"printIntLine <start> buffer[i] <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[i] <end> );"	"printIntLine <start> buffer[i] <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);
printIntLine <start> buffer[i] <end> );"	1
b7b09a65-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define NEW_PATH ""%SystemRoot%\\system32"" #define PUTENV _putenv #else #define NEW_PATH ""/bin"" #define PUTENV putenv #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif void CWE427_Uncontrolled_Search_Path_Element__char_file_41_badSink(char * data) { PUTENV(data); } void CWE427_Uncontrolled_Search_Path_Element__char_file_41_bad() { char * data; char dataBuffer[250] = ""PATH=""; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (250-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(250-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } CWE427_Uncontrolled_Search_Path_Element__char_file_41_badSink(data); }"	where is the vulnerable dataflow from data to PUTENV ?	"if (fgets <start> data+dataLen <end> , (int)(250-dataLen), pFile) == NULL);
CWE427_Uncontrolled_Search_Path_Element__char_file_41_badSink <start> data <end> );
void CWE427_Uncontrolled_Search_Path_Element__char_file_41_badSink(char * <start> data <end> );
PUTENV <start> data <end> );"	"<start> CWE427_Uncontrolled_Search_Path_Element__char_file_41_badSink(data) <end> ;
PUTENV <start> data <end> );
void CWE427_Uncontrolled_Search_Path_Element__char_file_41_badSink(char * <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(250-dataLen), pFile) == NULL);"	"CWE427_Uncontrolled_Search_Path_Element__char_file_41_badSink <start> data <end> );
PUTENV <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(250-dataLen), pFile) == NULL);
void CWE427_Uncontrolled_Search_Path_Element__char_file_41_badSink(char * <start> data <end> );"	"PUTENV <start> data <end> );
CWE427_Uncontrolled_Search_Path_Element__char_file_41_badSink <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;
void CWE427_Uncontrolled_Search_Path_Element__char_file_41_badSink(char * <start> data <end> );"	0
ce547d63-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif namespace CWE36_Absolute_Path_Traversal__char_environment_ofstream_14 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(globalFive==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"size_t dataLen = <start> strlen(data) <end> ;
outputFile.open((char * <start> data <end> );"	"outputFile.open((char * <start> data <end> );
strncat(data+dataLen, environment, <start> FILENAME_MAX-dataLen-1 <end> );"	"<start> data = dataBuffer <end> ;
outputFile.open((char * <start> data <end> );"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
outputFile.open((char * <start> data <end> );"	3
bda4e426-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define EXECL _execl #else #define EXECL execl #endif static void badSink(char * data) { EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL); } void CWE78_OS_Command_Injection__char_listen_socket_execl_44_bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } funcPtr(data); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECL ?	"funcPtr <start> data <end> );
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
if  <start> listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR <end> );
static void badSink(char * <start> data <end> );"	"char <start> dataBuffer[100] = COMMAND_ARG2 <end> ;
static void badSink(char * <start> data <end> );
funcPtr <start> data <end> );
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
funcPtr <start> data <end> );
static void badSink(char * <start> data <end> );
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"size_t dataLen = <start> strlen(data) <end> ;
static void badSink(char * <start> data <end> );
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	2
bc721f96-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define EXECLP _execlp #else #define EXECLP execlp #endif void CWE78_OS_Command_Injection__char_file_execlp_15_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; switch(6) { case 6: { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } break; default: printLine(""Benign, fixed string""); break; } EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECLP ?	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
<start> EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL) <end> ;"	"char <start> dataBuffer[100] = COMMAND_ARG2 <end> ;
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
size_t dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	3
73bc8168-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" void CWE194_Unexpected_Sign_Extension__connect_socket_memmove_03_bad() { short data; data = 0; if(5==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"if (tempInt > SHRT_MAX || <start> tempInt < SHRT_MIN <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printLine <start> dest <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"printLine <start> dest <end> );
if (tempInt > SHRT_MAX || <start> tempInt < SHRT_MIN <end> );"	2
6ef7682f-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif static void badVaSinkB(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_console_vfprintf_17_bad() { int i,j; char * data; char dataBuffer[100] = """"; data = dataBuffer; for(i = 0; i < 1; i++) { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } for(j = 0; j < 1; j++) { badVaSinkB(data, data); } }"	where is the vulnerable dataflow from data to vfprintf ?	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
static void badVaSinkB(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);"	"<start> vfprintf(stdout, data, args) <end> ;
badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
vfprintf(stdout, <start> data <end> , args);
badVaSinkB <start> data <end> , data);
size_t dataLen = <start> strlen(data) <end> ;"	2
93ece319-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING ""hello"" void CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_64b_badSink(void * dataVoidPtr) { size_t * dataPtr = (size_t *)dataVoidPtr; size_t data = (*dataPtr); { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); } else { printLine(""Input is less than the length of the source string""); } } }"	where is the vulnerable dataflow from data to malloc ?	"myString = (char *)malloc <start> data*sizeof(char) <end> );
<start> strcpy(myString, HELLO_STRING) <end> ;"	"<start> free(myString) <end> ;
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_64b_badSink(void * <start> dataVoidPtr <end> );"	"void CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_64b_badSink(void * <start> dataVoidPtr <end> );
myString = (char *)malloc <start> data*sizeof(char) <end> );"	"if  <start> data > strlen(HELLO_STRING) <end> );
myString = (char *)malloc <start> data*sizeof(char) <end> );"	2
669edac8-6c15-11ed-81d4-94e6f77dd552	static void badSink(char data) { { data++; char result = data; printHexCharLine(result); } } void CWE190_Integer_Overflow__char_rand_postinc_44_bad() { char data; void (*funcPtr) (char) = badSink; data = ' '; data = (char)RAND32(); funcPtr(data); }	where is the vulnerable dataflow from data ?	"static void badSink(char <start> data <end> );
data = (char <start> RAND32() <end> ;
funcPtr <start> data <end> );
<start> data <end> ++;"	"data = (char <start> RAND32() <end> ;
funcPtr <start> data <end> );
static void badSink(char <start> data <end> );
<start> data <end> ++;"	"<start> data++ <end> ;
data = (char <start> RAND32() <end> ;
funcPtr <start> data <end> );
static void badSink(char <start> data <end> );"	"static void badSink(char <start> data <end> );
data = (char <start> RAND32() <end> ;
funcPtr <start> data <end> );"	1
c01af8b4-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" namespace CWE23_Relative_Path_Traversal__char_connect_socket_ofstream_21 { static int badStatic = 0; static char * badSource(char * data) { if(badStatic) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } return data; } void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; badStatic = 1; data = badSource(data); { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } ; }"	where is the vulnerable dataflow from data to open ?	"replace = <start> strchr(data, '\n') <end> ;
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"static char * <start> badSource <end> (char * data);
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
data = <start> badSource <end> (data);
outputFile.open((char * <start> data <end> );"	"data = <start> badSource <end> (data);
static char * <start> badSource <end> (char * data);
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
outputFile.open((char * <start> data <end> );"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
outputFile.open((char * <start> data <end> );"	3
b6848512-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define NEW_PATH ""%SystemRoot%\\system32"" #define PUTENV _putenv #else #define NEW_PATH ""/bin"" #define PUTENV putenv #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" char * CWE427_Uncontrolled_Search_Path_Element__char_connect_socket_61b_badSource(char * data); void CWE427_Uncontrolled_Search_Path_Element__char_connect_socket_61_bad() { char * data; char dataBuffer[250] = ""PATH=""; data = dataBuffer; data = CWE427_Uncontrolled_Search_Path_Element__char_connect_socket_61b_badSource(data); PUTENV(data); }"	where is the vulnerable dataflow from data to PUTENV ?	"PUTENV <start> data <end> );
<start> PUTENV(data) <end> ;"	"PUTENV <start> data <end> );
data = <start> CWE427_Uncontrolled_Search_Path_Element__char_connect_socket_61b_badSource(data) <end> ;"	"PUTENV <start> data <end> );
<start> data = CWE427_Uncontrolled_Search_Path_Element__char_connect_socket_61b_badSource(data) <end> ;"	"data = <start> CWE427_Uncontrolled_Search_Path_Element__char_connect_socket_61b_badSource <end> (data);
PUTENV <start> data <end> );"	3
833ac925-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_listen_socket_fopen_63 { void badSink(char * * dataPtr) { char * data = *dataPtr; { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"void badSink(char * * <start> dataPtr <end> );
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
void badSink(char * * <start> dataPtr <end> );"	"void badSink(char * * <start> dataPtr <end> );
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	"pFile = FOPEN <start> data <end> , ""wb+"");
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	0
ba102ba1-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define EXECLP _execlp #else #define EXECLP execlp #endif void CWE78_OS_Command_Injection__char_connect_socket_execlp_15_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; switch(6) { case 6: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; default: printLine(""Benign, fixed string""); break; } EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECLP ?	"EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
size_t dataLen = <start> strlen(data) <end> ;"	"EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
size_t dataLen = <start> strlen(data) <end> ;"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	3
a830bfa1-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_connect_socket_sub_17_bad() { int i,j; int data; data = 0; for(i = 0; i < 1; i++) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } for(j = 0; j < 1; j++) { { int result = data - 1; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;"	"printIntLine <start> result <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	3
c99197ce-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define STAT _stat #define OPEN _open #define WRITE _write #define O_RDWR _O_RDWR #define CLOSE _close #else #define STAT stat #define OPEN open #define WRITE write #define CLOSE close #endif #define BAD_SINK_STRING ""Bad Sink..."" #define GOOD_SINK_STRING ""Good Sink..."" void CWE367_TOC_TOU__stat_11_bad() { if(globalReturnsTrue()) { { char filename[100] = """"; struct STAT statBuffer; int fileDesc = -1; if (fgets(filename, 100, stdin) == NULL) { printLine(""fgets() failed""); filename[0] = '\0'; } if (strlen(filename) > 0) { filename[strlen(filename)-1] = '\0'; } if (STAT(filename, &statBuffer) == -1) { exit(1); } fileDesc  = OPEN(filename, O_RDWR); if (fileDesc == -1) { exit(1); } if (WRITE(fileDesc, BAD_SINK_STRING, strlen(BAD_SINK_STRING)) == -1) { exit(1); } if (fileDesc != -1) { CLOSE(fileDesc); } } } }"	where is the vulnerable dataflow from filename to OPEN ?	"if (fgets <start> filename <end> , 100, stdin) == NULL);
filename <start> strlen(filename) <end> -1] = '\0'; ;"	"if (fgets <start> filename <end> , 100, stdin) == NULL);
fileDesc  = OPEN <start> filename <end> , O_RDWR);"	"if (fgets <start> filename <end> , 100, stdin) == NULL);
fileDesc  = <start> OPEN(filename, O_RDWR) <end> ;"	"fileDesc  = <start> OPEN(filename, O_RDWR) <end> ;
fileDesc  = OPEN <start> filename <end> , O_RDWR);"	1
67d010de-6c15-11ed-81d4-94e6f77dd552	static void badSink(char data) { { ++data; char result = data; printHexCharLine(result); } } void CWE190_Integer_Overflow__char_rand_preinc_41_bad() { char data; data = ' '; data = (char)RAND32(); badSink(data); }	where is the vulnerable dataflow from data ?	"data = (char <start> RAND32() <end> ;
badSink <start> data <end> );
static void badSink(char <start> data <end> );
+ <start> data <end> ;"	"static void badSink(char <start> data <end> );
<start> printHexCharLine(result) <end> ;
+ <start> data <end> ;
data = (char <start> RAND32() <end> ;"	"badSink <start> data <end> );
data = (char <start> RAND32() <end> ;
char <start> result = data <end> ;
+ <start> data <end> ;"	"data = (char <start> RAND32() <end> ;
static void badSink(char <start> data <end> );
+ <start> data <end> ;
badSink <start> data <end> );"	0
c99197fe-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" namespace CWE36_Absolute_Path_Traversal__char_connect_socket_ifstream_01 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"inputFile.open((char * <start> data <end> );
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
inputFile.open((char * <start> data <end> );"	"recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - <start> dataLen - 1 <end> ), 0);
inputFile.open((char * <start> data <end> );"	"recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - <start> dataLen - 1 <end> ), 0);
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	1
7c12756d-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_45_badData; static int CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_45_goodG2BData; static void badSink() { int data = CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_45_badData; if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } } void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_45_bad() { int data; data = -1; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_45_badData = data; badSink(); }"	where is the vulnerable dataflow from data to malloc ?	"char * dataBuffer = (char * <start> malloc(data) <end> ;
<start> CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_45_badData = data <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
char * dataBuffer = (char *)malloc <start> data <end> );
int data = <start> CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_45_badData <end> ;"	"static int <start> CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_45_badData <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_45_badData = data <end> ;
char * dataBuffer = (char * <start> malloc(data) <end> ;
int data = <start> CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_45_badData <end> ;"	"char * dataBuffer = (char * <start> malloc(data) <end> ;
static int <start> CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_45_badData <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_45_badData = data <end> ;
char * dataBuffer = (char *)malloc <start> data <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_45_badData = data <end> ;
static int <start> CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_45_badData <end> ;
int data = <start> CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_45_badData <end> ;
char * dataBuffer = (char *)malloc <start> data <end> );"	3
cd22814a-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif namespace CWE36_Absolute_Path_Traversal__char_console_ofstream_44 { static void badSink(char * data) { { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } } void bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } funcPtr(data); }"	where is the vulnerable dataflow from data to funcPtr ?	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
funcPtr <start> data <end> );"	"<start> data = dataBuffer <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"funcPtr <start> data <end> );
<start> data = dataBuffer <end> ;"	1
893217e5-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_console_open_12 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(globalReturnsTrueOrFalse()) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } else { #ifdef _WIN32 strcat(data, ""c:\\temp\\file.txt""); #else strcat(data, ""/tmp/file.txt""); #endif } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
<start> strcat(data, ""c:\\temp\\file.txt"") <end> ;"	"<start> data = dataBuffer <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"if (dataLen > 0 && <start> data[dataLen-1] == '\n' <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	3
a36a78e2-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_add_01_bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { int result = data + 1; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
<start> data = 0 <end> ;"	"printIntLine <start> result <end> );
if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );"	"printIntLine <start> result <end> );
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	0
8df42201-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define PATH_SZ 100 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define PATH_SZ PATH_MAX #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 void CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__accept_listen_bind_10_bad() { if(globalTrue) { { char data[100] = """"; #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[recvResult] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif printLine(data); } } }"	where is the vulnerable dataflow from data to printLine ?	"size_t dataLen = <start> strlen(data) <end> ;
printLine <start> data <end> );"	"recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);
size_t <start> dataLen = strlen(data) <end> ;"	"recvResult = <start> recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0) <end> ;
printLine <start> data <end> );"	"recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);
printLine <start> data <end> );"	3
728a5003-6c15-11ed-81d4-94e6f77dd552	#ifndef _WIN32 #endif namespace CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_73 { static void badVaSink(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); va_end(args); } } void badSink(list<char *> dataList) { char * data = dataList.back(); badVaSink(data, data); }	where is the vulnerable dataflow from data to vfprintf ?	"void badSink(list<char *> <start> dataList <end> );
<start> vfprintf(stdout, data, args) <end> ;
static void badVaSink(char * <start> data <end> , ...);
badVaSink <start> data <end> , data);"	"vfprintf(stdout, <start> data <end> , args);
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);"	"void badSink(list<char *> <start> dataList <end> );
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);"	"vfprintf(stdout, <start> data <end> , args);
badVaSink <start> data <end> , data);"	2
af580956-6c15-11ed-81d4-94e6f77dd552	int CWE197_Numeric_Truncation_Error__int_connect_socket_to_short_22_badGlobal = 0; int CWE197_Numeric_Truncation_Error__int_connect_socket_to_short_22_badSource(int data); void CWE197_Numeric_Truncation_Error__int_connect_socket_to_short_22_bad() { int data; data = -1; CWE197_Numeric_Truncation_Error__int_connect_socket_to_short_22_badGlobal = 1; data = CWE197_Numeric_Truncation_Error__int_connect_socket_to_short_22_badSource(data); { short shortData = (short)data; printShortLine(shortData); } }	where is the vulnerable dataflow from shortData to printShortLine ?	"short <start> shortData = (short)data <end> ;
data = <start> CWE197_Numeric_Truncation_Error__int_connect_socket_to_short_22_badSource <end> (data);"	"short <start> shortData = (short)data <end> ;
printShortLine <start> shortData <end> );"	"data = <start> CWE197_Numeric_Truncation_Error__int_connect_socket_to_short_22_badSource <end> (data);
printShortLine <start> shortData <end> );"	"<start> printShortLine(shortData) <end> ;
printShortLine <start> shortData <end> );"	2
584fa857-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE191_Integer_Underflow__int_listen_socket_multiply_43 { static void badSource(int &data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } void bad() { int data; data = 0; badSource(data); if(data < 0) { int result = data * 2; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  * 2;
<start> printIntLine(result) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
int result = <start> data <end>  * 2;
badSource <start> data <end> );"	"if  <start> listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR <end> );
int result = <start> data <end>  * 2;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSource <start> data <end> );
int result = <start> data <end>  * 2;"	3
a36a7906-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) typedef struct _CWE190_Integer_Overflow__int_listen_socket_add_67_structType { int structFirst; } CWE190_Integer_Overflow__int_listen_socket_add_67_structType; void CWE190_Integer_Overflow__int_listen_socket_add_67b_badSink(CWE190_Integer_Overflow__int_listen_socket_add_67_structType myStruct) { int data = myStruct.structFirst; { int result = data + 1; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"int <start> result = data + 1 <end> ;
int data = <start> myStruct <end> .structFirst;
void CWE190_Integer_Overflow__int_listen_socket_add_67b_badSink(CWE190_Integer_Overflow__int_listen_socket_add_67_structType <start> myStruct <end> );"	"void CWE190_Integer_Overflow__int_listen_socket_add_67b_badSink(CWE190_Integer_Overflow__int_listen_socket_add_67_structType <start> myStruct <end> );
int data = <start> myStruct <end> .structFirst;
printIntLine <start> result <end> );"	"int data = <start> myStruct <end> .structFirst;
printIntLine <start> result <end> );
void CWE190_Integer_Overflow__int_listen_socket_add_67b_badSink(CWE190_Integer_Overflow__int_listen_socket_add_67_structType <start> myStruct <end> );"	"<start> printIntLine(result) <end> ;
void CWE190_Integer_Overflow__int_listen_socket_add_67b_badSink(CWE190_Integer_Overflow__int_listen_socket_add_67_structType <start> myStruct <end> );
int data = <start> myStruct <end> .structFirst;"	1
571e9801-6c15-11ed-81d4-94e6f77dd552	"void CWE191_Integer_Underflow__int_fscanf_multiply_11_bad() { int data; data = 0; if(globalReturnsTrue()) { fscanf(stdin, ""%d"", &data); } if(globalReturnsTrue()) { if(data < 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"fscanf(stdin, ""%d"", <start> &data <end> );
int result = <start> data <end>  * 2;"	"int result = <start> data <end>  * 2;
<start> printIntLine(result) <end> ;"	"int result = <start> data <end>  * 2;
if <start> data < 0 <end> ) ;"	"fscanf(stdin, ""%d"", <start> &data <end> );
<start> printIntLine(result) <end> ;"	0
a10948e0-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_multiply_13_bad() { int data; data = 0; if(GLOBAL_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(GLOBAL_CONST_FIVE==5) { if(data > 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;"	"printIntLine <start> result <end> );
int result = <start> data * 2 <end> ;"	"printIntLine <start> result <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	3
669edace-6c15-11ed-81d4-94e6f77dd552	char CWE190_Integer_Overflow__char_rand_postinc_61b_badSource(char data); void CWE190_Integer_Overflow__char_rand_postinc_61_bad() { char data; data = ' '; data = CWE190_Integer_Overflow__char_rand_postinc_61b_badSource(data); { data++; char result = data; printHexCharLine(result); } }	where is the vulnerable dataflow from data ?	"<start> printHexCharLine(result) <end> ;
<start> data <end> ++;"	"data = <start> CWE190_Integer_Overflow__char_rand_postinc_61b_badSource <end> (data);
<start> data <end> ++;"	"char <start> result = data <end> ;
<start> data <end> ++;"	"data = <start> CWE190_Integer_Overflow__char_rand_postinc_61b_badSource <end> (data);
char <start> result = data <end> ;"	1
5be3a9f0-6c15-11ed-81d4-94e6f77dd552	"static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; void CWE191_Integer_Underflow__short_fscanf_postdec_04_bad() { short data; data = 0; if(STATIC_CONST_TRUE) { fscanf (stdin, ""%hd"", &data); } if(STATIC_CONST_TRUE) { { data--; short result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"fscanf (stdin, ""%hd"", <start> &data <end> );
<start> printIntLine(result) <end> ;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
<start> data <end> --;"	"<start> data-- <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );"	"<start> data <end> --;
fscanf (stdin, ""%hd"", <start> &data <end> );"	1
893217fb-6c15-11ed-81d4-94e6f77dd552	#ifndef _WIN32 #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_console_open_63 { void badSink(char * * dataPtr) { char * data = *dataPtr; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }	where is the vulnerable dataflow from data to OPEN ?	"void badSink(char * * <start> dataPtr <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"void badSink(char * * <start> dataPtr <end> );
fileDesc = OPEN(data, O_RDWR|O_CREAT, <start> S_IREAD|S_IWRITE <end> );"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
void badSink(char * * <start> dataPtr <end> );"	"char <start> * data = *dataPtr <end> ;
void badSink(char * * <start> dataPtr <end> );"	0
9d74539a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) typedef union { int unionFirst; int unionSecond; } CWE127_Buffer_Underread__CWE839_connect_socket_34_unionType; void CWE127_Buffer_Underread__CWE839_connect_socket_34_bad() { int data; CWE127_Buffer_Underread__CWE839_connect_socket_34_unionType myUnion; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } myUnion.unionFirst = data; { int data = myUnion.unionSecond; { int buffer[10] = { 0 }; if (data < 10) { printIntLine(buffer[data]); } else { printLine(""ERROR: Array index is too big.""); } } } }"	where is the vulnerable dataflow from buffer[data] to printIntLine ?	"printIntLine <start> buffer[data] <end> );
data = <start> atoi(inputBuffer) <end> ;"	"data = <start> atoi(inputBuffer) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);
printIntLine <start> buffer[data] <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[data] <end> );"	3
70279c1a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif namespace CWE134_Uncontrolled_Format_String__char_file_snprintf_81 { void CWE134_Uncontrolled_Format_String__char_file_snprintf_81_bad::action(char * data) const { { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } } }"	where is the vulnerable dataflow from dest to printLine ?	"void CWE134_Uncontrolled_Format_String__char_file_snprintf_81_bad::action(char * <start> data <end> ) const;
printLine <start> dest <end> );"	"printLine <start> dest <end> );
<start> printLine(dest) <end> ;"	"<start> printLine(dest) <end> ;
void CWE134_Uncontrolled_Format_String__char_file_snprintf_81_bad::action(char * <start> data <end> ) const;"	"printLine <start> dest <end> );
void CWE134_Uncontrolled_Format_String__char_file_snprintf_81_bad::action(char * <start> data <end> ) const;"	0
bed4a8d0-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_connect_socket_fopen_53 { void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badSink_b(data); }"	where is the vulnerable dataflow from data to badSink_b ?	"size_t dataLen = <start> strlen(data) <end> ;
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
badSink_b <start> data <end> );"	"recvResult = <start> recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0) <end> ;
badSink_b <start> data <end> );"	"badSink_b <start> data <end> );
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	1
4b34b007-6c15-11ed-81d4-94e6f77dd552	"typedef union { short unionFirst; short unionSecond; } CWE190_Integer_Overflow__short_fscanf_square_34_unionType; void CWE190_Integer_Overflow__short_fscanf_square_34_bad() { short data; CWE190_Integer_Overflow__short_fscanf_square_34_unionType myUnion; data = 0; fscanf (stdin, ""%hd"", &data); myUnion.unionFirst = data; { short data = myUnion.unionSecond; { short result = data * data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"short result = <start> data * data <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );"	"short result = <start> data <end>  * data;
fscanf (stdin, ""%hd"", <start> &data <end> );"	"fscanf (stdin, ""%hd"", <start> &data <end> );
short result = <start> data <end>  * data;"	"<start> printIntLine(result) <end> ;
short result = <start> data <end>  * data;"	2
7ae3a753-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) typedef struct _CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_67_structType { int structFirst; } CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_67_structType; void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_67b_badSink(CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_67_structType myStruct) { int data = myStruct.structFirst; { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_67b_badSink(CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_67_structType <start> myStruct <end> );
int data = <start> myStruct <end> .structFirst;
printLine <start> dest <end> );"	"int data = <start> myStruct <end> .structFirst;
char <start> dest[100] = """" <end> ;
void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_67b_badSink(CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_67_structType <start> myStruct <end> );"	"printLine <start> dest <end> );
void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_67b_badSink(CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_67_structType <start> myStruct <end> );"	"<start> printLine(dest) <end> ;
void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_67b_badSink(CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_67_structType <start> myStruct <end> );
int data = <start> myStruct <end> .structFirst;"	0
a49c4f5c-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__int_listen_socket_multiply_74 { void badSink(map<int, int> dataMap) { int data = dataMap[2]; if(data > 0) { int result = data * 2; printIntLine(result); } }	where is the vulnerable dataflow from result to printIntLine ?	"void badSink(map<int, int> <start> dataMap <end> );
int <start> result = data * 2 <end> ;"	"printIntLine <start> result <end> );
void badSink(map<int, int> <start> dataMap <end> );"	"void badSink(map<int, int> <start> dataMap <end> );
printIntLine <start> result <end> );"	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	2
bb49c587-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #define EXECL _execl #else #define EXECL execl #endif void CWE78_OS_Command_Injection__char_console_execl_13_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(GLOBAL_CONST_FIVE==5) { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECL ?	"char <start> dataBuffer[100] = COMMAND_ARG2 <end> ;
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	"dataLen = <start> strlen(data) <end> ;
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	1
47a2a809-6c15-11ed-81d4-94e6f77dd552	"static int staticFive = 5; void CWE190_Integer_Overflow__int_fscanf_add_07_bad() { int data; data = 0; if(staticFive==5) { fscanf(stdin, ""%d"", &data); } if(staticFive==5) { { int result = data + 1; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"fscanf(stdin, ""%d"", <start> &data <end> );
int <start> result = data + 1 <end> ;"	"int result = <start> data <end>  + 1;
fscanf(stdin, ""%d"", <start> &data <end> );"	"fscanf(stdin, ""%d"", <start> &data <end> );
int result = <start> data <end>  + 1;"	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  + 1;"	2
d0b64efb-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_file_open_01 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"size_t dataLen = <start> strlen(data) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	2
571e9856-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_listen_socket_multiply_14_bad() { int data; data = 0; if(globalFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalFive==5) { if(data < 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  * 2;
if  <start> recvResult == SOCKET_ERROR <end>  || recvResult == 0);"	"data = <start> atoi(inputBuffer) <end> ;
int result = <start> data <end>  * 2;"	"int result = <start> data <end>  * 2;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  * 2;"	3
8b91e4a4-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(count) + 2) #ifdef _WIN32 #define SLEEP Sleep #else #define SLEEP usleep #endif static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; void CWE400_Resource_Exhaustion__connect_socket_sleep_04_bad() { int count; count = -1; if(STATIC_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; count = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(STATIC_CONST_TRUE) { SLEEP(count); printLine(""Sleep time possibly too long""); } }"	where is the vulnerable dataflow from count to SLEEP ?	"<start> SLEEP(count) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);
SLEEP <start> count <end> );"	"SLEEP <start> count <end> );
<start> count = atoi(inputBuffer) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
SLEEP <start> count <end> );"	3
a49c4f97-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_postinc_09_bad() { int data; data = 0; if(GLOBAL_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(GLOBAL_CONST_TRUE) { { data++; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"int <start> result = data <end> ;
printIntLine <start> result <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
<start> data++ <end> ;"	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> result <end> );"	1
5be3a9f3-6c15-11ed-81d4-94e6f77dd552	"static int staticFive = 5; void CWE191_Integer_Underflow__short_fscanf_postdec_07_bad() { short data; data = 0; if(staticFive==5) { fscanf (stdin, ""%hd"", &data); } if(staticFive==5) { { data--; short result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
<start> data <end> --;"	"<start> data = 0 <end> ;
<start> data <end> --;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
<start> printIntLine(result) <end> ;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
<start> data <end> --;"	3
525b6493-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__short_fscanf_preinc_63b_badSink(short * dataPtr) { short data = *dataPtr; { ++data; short result = data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"+ <start> data <end> ;
<start> printIntLine(result) <end> ;"	"void CWE190_Integer_Overflow__short_fscanf_preinc_63b_badSink(short * <start> dataPtr <end> );
+ <start> data <end> ;"	"short <start> data = *dataPtr <end> ;
void CWE190_Integer_Overflow__short_fscanf_preinc_63b_badSink(short * <start> dataPtr <end> );"	"<start> printIntLine(result) <end> ;
void CWE190_Integer_Overflow__short_fscanf_preinc_63b_badSink(short * <start> dataPtr <end> );"	1
598370c4-6c15-11ed-81d4-94e6f77dd552	"void CWE191_Integer_Underflow__short_fscanf_sub_16_bad() { short data; data = 0; while(1) { fscanf (stdin, ""%hd"", &data); break; } while(1) { { short result = data - 1; printIntLine(result); } break; } }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
short result = <start> data <end>  - 1;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
short result = <start> data <end>  - 1;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
<start> printIntLine(result) <end> ;"	"short result = <start> data <end>  - 1;
fscanf (stdin, ""%hd"", <start> &data <end> );"	1
73bc813e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" static int staticTrue = 1; static int staticFalse = 0; void CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_05_bad() { short data; data = 0; if(staticTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data = tempInt <end> ;"	"printLine <start> dest <end> );
<start> tempInt = atoi(inputBuffer) <end> ;"	"printLine <start> dest <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	3
a830bf99-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_connect_socket_sub_09_bad() { int data; data = 0; if(GLOBAL_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(GLOBAL_CONST_TRUE) { { int result = data - 1; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"printIntLine <start> result <end> );
int <start> result = data - 1 <end> ;"	"<start> data = 0 <end> ;
printIntLine <start> result <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	3
cbf237da-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif namespace CWE36_Absolute_Path_Traversal__char_console_ifstream_34 { typedef union { char * unionFirst; char * unionSecond; } unionType; void bad() { char * data; unionType myUnion; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } } }"	where is the vulnerable dataflow from data to open ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
inputFile.open((char * <start> data <end> );"	"inputFile.open((char * <start> data <end> );
<start> data = dataBuffer <end> ;"	"dataLen = <start> strlen(data) <end> ;
inputFile.open((char * <start> data <end> );"	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	0
b41b8779-6c15-11ed-81d4-94e6f77dd552	"namespace CWE23_Relative_Path_Traversal__char_console_fopen_81 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } const CWE23_Relative_Path_Traversal__char_console_fopen_81_base& baseObject = CWE23_Relative_Path_Traversal__char_console_fopen_81_bad(); baseObject.action(data); }"	where is the vulnerable dataflow from data to action ?	"size_t dataLen = <start> strlen(data) <end> ;
baseObject.action <start> data <end> );"	"baseObject.action <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"dataLen = <start> strlen(data) <end> ;
baseObject.action <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
baseObject.action <start> data <end> );"	3
74ee23cb-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; void CWE194_Unexpected_Sign_Extension__connect_socket_strncpy_04_bad() { short data; data = 0; if(STATIC_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"printLine <start> dest <end> );
recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);"	"printLine <start> dest <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> strncpy(dest, source, data) <end> ;"	2
b41b8789-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 namespace CWE23_Relative_Path_Traversal__char_listen_socket_fopen_82 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE23_Relative_Path_Traversal__char_listen_socket_fopen_82_base* baseObject = new CWE23_Relative_Path_Traversal__char_listen_socket_fopen_82_bad; baseObject->action(data); delete baseObject; }"	where is the vulnerable dataflow from data to action ?	"baseObject->action <start> data <end> );
<start> data = dataBuffer <end> ;"	"replace = <start> strchr(data, '\n') <end> ;
baseObject->action <start> data <end> );"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
baseObject->action <start> data <end> );"	3
7d44fcc7-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_51b_badSink(int data) { if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }"	where is the vulnerable dataflow from data to malloc ?	"<start> free(dataBuffer) <end> ;
void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_51b_badSink(int <start> data <end> );"	"void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_51b_badSink(int <start> data <end> );
<start> printLine(dataBuffer) <end> ;"	"void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_51b_badSink(int <start> data <end> );
char * dataBuffer = (char *)malloc <start> data <end> );"	"memset(dataBuffer, 'A', <start> data-1 <end> );
char * dataBuffer = (char *)malloc <start> data <end> );"	2
cf8750c7-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_file_fopen_63 { void badSink(char * * dataPtr) { char * data = *dataPtr; { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"char <start> * data = *dataPtr <end> ;
void badSink(char * * <start> dataPtr <end> );"	"pFile = FOPEN <start> data <end> , ""wb+"");
void badSink(char * * <start> dataPtr <end> );"	"void badSink(char * * <start> dataPtr <end> );
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	"void badSink(char * * <start> dataPtr <end> );
pFile = FOPEN <start> data <end> , ""wb+"");"	3
7ae3a716-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_31_bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { int dataCopy = data; int data = dataCopy; { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } } }"	where is the vulnerable dataflow from dest to printLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data = atoi(inputBuffer) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"<start> data = -1 <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"printLine <start> dest <end> );
<start> printLine(dest) <end> ;"	1
6ef76848-6c15-11ed-81d4-94e6f77dd552	namespace CWE134_Uncontrolled_Format_String__char_console_vfprintf_82 { static void badVaSink(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_console_vfprintf_82_bad::action(char * data) { badVaSink(data, data); } }	where is the vulnerable dataflow from data to vfprintf ?	"badVaSink <start> data <end> , data);
vfprintf(stdout, <start> data <end> , args);
void CWE134_Uncontrolled_Format_String__char_console_vfprintf_82_bad::action(char * <start> data <end> );"	"void CWE134_Uncontrolled_Format_String__char_console_vfprintf_82_bad::action(char * <start> data <end> );
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);"	"vfprintf(stdout, <start> data <end> , args);
badVaSink <start> data <end> , data);"	"void CWE134_Uncontrolled_Format_String__char_console_vfprintf_82_bad::action(char * <start> data <end> );
static void badVaSink(char * <start> data <end> , ...);
badVaSink <start> data <end> , data);
<start> vfprintf(stdout, data, args) <end> ;"	1
80d986ee-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_connect_socket_open_65 { void badSink(char * data) { { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN(data, O_RDWR|O_CREAT, <start> S_IREAD|S_IWRITE <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"void badSink(char * <start> data <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
void badSink(char * <start> data <end> );"	2
525b6446-6c15-11ed-81d4-94e6f77dd552	"void CWE190_Integer_Overflow__int_fscanf_preinc_31_bad() { int data; data = 0; fscanf(stdin, ""%d"", &data); { int dataCopy = data; int data = dataCopy; { ++data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"int <start> data = dataCopy <end> ;
+ <start> data <end> ;"	"int <start> result = data <end> ;
+ <start> data <end> ;"	"fscanf(stdin, ""%d"", <start> &data <end> );
+ <start> data <end> ;"	"fscanf(stdin, ""%d"", <start> &data <end> );
int <start> data = dataCopy <end> ;"	2
c5fc2330-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif static int staticFive = 5; namespace CWE23_Relative_Path_Traversal__char_file_ifstream_07 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(staticFive==5) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
char <start> dataBuffer[FILENAME_MAX] = BASEPATH <end> ;"	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
inputFile.open((char * <start> data <end> );"	"inputFile.open((char * <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	2
7e74f335-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) extern int CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_68_badData; extern int CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_68_goodG2BData; void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_68b_badSink() { int data = CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_68_badData; { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"if  <start> data < 100 <end> );
int data = <start> CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_68_badData <end> ;"	"printLine <start> dest <end> );
int data = <start> CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_68_badData <end> ;"	"int data = <start> CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_68_badData <end> ;
printLine <start> dest <end> );"	"printLine <start> dest <end> );
<start> printLine(dest) <end> ;"	2
6c938bd7-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int badSource(int data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } return data; } void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_42_bad() { int data; data = -1; data = badSource(data); { int i; int * buffer = (int *)malloc(10 * sizeof(int)); if (buffer == NULL) {exit(-1);} for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } free(buffer); } }"	where is the vulnerable dataflow from buffer to free ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
data = <start> badSource <end> (data);
free <start> buffer <end> );
if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );"	"if  <start> buffer == NULL <end> ) {exit(-1);};
free <start> buffer <end> );
data = <start> badSource <end> (data);
static int <start> badSource <end> (int data);"	"<start> free(buffer) <end> ;
data = <start> badSource <end> (data);
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static int <start> badSource <end> (int data);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static int <start> badSource <end> (int data);
data = <start> badSource <end> (data);
free <start> buffer <end> );"	3
73bc815c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" void CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_64b_badSink(void * dataVoidPtr) { short * dataPtr = (short *)dataVoidPtr; short data = (*dataPtr); { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"void CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_64b_badSink(void * <start> dataVoidPtr <end> );
printLine <start> dest <end> );"	"if  <start> data < 100 <end> );
printLine <start> dest <end> );"	"char <start> dest[100] = """" <end> ;
void CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_64b_badSink(void * <start> dataVoidPtr <end> );"	"<start> memcpy(dest, source, data) <end> ;
void CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_64b_badSink(void * <start> dataVoidPtr <end> );"	0
48d25da5-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_add_09_bad() { int data; data = 0; if(GLOBAL_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(GLOBAL_CONST_TRUE) { { int result = data + 1; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
int result = <start> data <end>  + 1;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  + 1;"	"int <start> result = data + 1 <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"<start> printIntLine(result) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	1
c1366257-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_console_fopen_65 { void badSink(char * data); void bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } funcPtr(data); }"	where is the vulnerable dataflow from data to funcPtr ?	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"dataLen = <start> strlen(data) <end> ;
funcPtr <start> data <end> );"	"dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
funcPtr <start> data <end> );"	3
8932180a-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif static int staticTrue = 1; static int staticFalse = 0; namespace CWE36_Absolute_Path_Traversal__char_file_fopen_05 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(staticTrue) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = FOPEN <start> data <end> , ""wb+"");
<start> data = dataBuffer <end> ;"	"size_t dataLen = <start> strlen(data) <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
size_t dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
pFile = FOPEN <start> data <end> , ""wb+"");"	3
4ff78284-6c15-11ed-81d4-94e6f77dd552	extern short CWE190_Integer_Overflow__short_fscanf_postinc_68_badData; extern short CWE190_Integer_Overflow__short_fscanf_postinc_68_goodG2BData; extern short CWE190_Integer_Overflow__short_fscanf_postinc_68_goodB2GData; void CWE190_Integer_Overflow__short_fscanf_postinc_68b_badSink() { short data = CWE190_Integer_Overflow__short_fscanf_postinc_68_badData; { data++; short result = data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"short data = <start> CWE190_Integer_Overflow__short_fscanf_postinc_68_badData <end> ;
<start> printIntLine(result) <end> ;"	"short data = <start> CWE190_Integer_Overflow__short_fscanf_postinc_68_badData <end> ;
<start> data <end> ++;"	"<start> data <end> ++;
short data = <start> CWE190_Integer_Overflow__short_fscanf_postinc_68_badData <end> ;"	"<start> data <end> ++;
<start> printIntLine(result) <end> ;"	1
a6fd825a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) extern int CWE190_Integer_Overflow__int_connect_socket_preinc_68_badData; extern int CWE190_Integer_Overflow__int_connect_socket_preinc_68_goodG2BData; extern int CWE190_Integer_Overflow__int_connect_socket_preinc_68_goodB2GData; void CWE190_Integer_Overflow__int_connect_socket_preinc_68b_badSink() { int data = CWE190_Integer_Overflow__int_connect_socket_preinc_68_badData; { ++data; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"<start> printIntLine(result) <end> ;
int data = <start> CWE190_Integer_Overflow__int_connect_socket_preinc_68_badData <end> ;"	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
int data = <start> CWE190_Integer_Overflow__int_connect_socket_preinc_68_badData <end> ;"	"int data = <start> CWE190_Integer_Overflow__int_connect_socket_preinc_68_badData <end> ;
printIntLine <start> result <end> );"	3
571e9807-6c15-11ed-81d4-94e6f77dd552	"void CWE191_Integer_Underflow__int_fscanf_multiply_18_bad() { int data; data = 0; goto source; source: fscanf(stdin, ""%d"", &data); goto sink; sink: if(data < 0) { int result = data * 2; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"fscanf(stdin, ""%d"", <start> &data <end> );
int <start> result = data * 2 <end> ;"	"int result = <start> data * 2 <end> ;
fscanf(stdin, ""%d"", <start> &data <end> );"	"fscanf(stdin, ""%d"", <start> &data <end> );
int result = <start> data <end>  * 2;"	"fscanf(stdin, ""%d"", <start> &data <end> );
<start> printIntLine(result) <end> ;"	2
c4cd6f78-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_file_fopen_53 { void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } badSink_b(data); }"	where is the vulnerable dataflow from data to badSink_b ?	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
char <start> dataBuffer[FILENAME_MAX] = BASEPATH <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
badSink_b <start> data <end> );"	"<start> badSink_b(data) <end> ;
badSink_b <start> data <end> );"	2
79b27550-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_12_bad() { int data; data = -1; if(globalReturnsTrueOrFalse()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } else { data = 100-1; } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"printLine <start> dest <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"data = <start> atoi(inputBuffer) <end> ;
printLine <start> dest <end> );"	"printLine <start> dest <end> );
recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);"	0
c5fc236d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif static const int STATIC_CONST_FIVE = 5; namespace CWE23_Relative_Path_Traversal__char_file_open_06 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(STATIC_CONST_FIVE==5) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
size_t dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	3
6c938bdf-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) int CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_61b_badSource(int data); void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_61_bad() { int data; data = -1; data = CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_61b_badSource(data); { int i; int * buffer = (int *)malloc(10 * sizeof(int)); if (buffer == NULL) {exit(-1);} for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } free(buffer); } }"	where is the vulnerable dataflow from buffer to free ?	"data = <start> CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_61b_badSource <end> (data);
free <start> buffer <end> );"	"data = <start> CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_61b_badSource <end> (data);
<start> free(buffer) <end> ;"	"if  <start> buffer == NULL <end> ) {exit(-1);};
data = <start> CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_61b_badSource <end> (data);"	"free <start> buffer <end> );
data = <start> CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_61b_badSource <end> (data);"	0
d0b64ef3-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif namespace CWE36_Absolute_Path_Traversal__char_file_ofstream_43 { void badSource(char * &data) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; badSource(data); { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"outputFile.open((char * <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
badSource <start> data <end> );"	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
badSource <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
badSource <start> data <end> );
outputFile.open((char * <start> data <end> );"	"badSource <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	2
a36a78f4-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int badStatic = 0; static void badSink(int data) { if(badStatic) { { int result = data + 1; printIntLine(result); } } } void CWE190_Integer_Overflow__int_listen_socket_add_21_bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badStatic = 1; badSink(data); }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSink <start> data <end> );
static void badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static void badSink(int <start> data <end> );
badSink <start> data <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSink <start> data <end> );
printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static void badSink(int <start> data <end> );
if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );
printIntLine <start> result <end> );"	0
87ff9862-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_connect_socket_open_02 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
replace = <start> strchr(data, '\n') <end> ;"	"replace = <start> strchr(data, '\n') <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN(data, O_RDWR|O_CREAT, <start> S_IREAD|S_IWRITE <end> );"	0
8df42211-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define PATH_SZ 100 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define PATH_SZ PATH_MAX #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } void CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__bind_accept_listen_08_bad() { if(staticReturnsTrue()) { { char data[100] = """"; #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[recvResult] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif printLine(data); } } }"	where is the vulnerable dataflow from data to printLine ?	"recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);
printLine <start> data <end> );"	"printLine <start> data <end> );
replace = <start> strchr(data, '\n') <end> ;"	"replace = <start> strchr(data, '\r') <end> ;
printLine <start> data <end> );"	"replace = <start> strchr(data, '\n') <end> ;
recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);"	0
a36a78f3-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_add_18_bad() { int data; data = 0; goto source; source: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } goto sink; sink: { int result = data + 1; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
int <start> result = data + 1 <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"int <start> result = data + 1 <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"printIntLine <start> result <end> );
if  <start> acceptSocket == SOCKET_ERROR <end> );"	1
964cdc0a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FULL_COMMAND ""dir "" #else #define FULL_COMMAND ""ls "" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define POPEN _popen #define PCLOSE _pclose #else #define POPEN popen #define PCLOSE pclose #endif void CWE78_OS_Command_Injection__char_listen_socket_popen_09_bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; if(GLOBAL_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { FILE *pipe; pipe = POPEN(data, ""w""); if (pipe != NULL) { PCLOSE(pipe); } } }"	where is the vulnerable dataflow from data to POPEN ?	"<start> recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0) <end> ;
pipe = POPEN <start> data <end> , ""w"");"	"size_t dataLen = <start> strlen(data) <end> ;
pipe = POPEN <start> data <end> , ""w"");"	"pipe = <start> POPEN(data, ""w"") <end> ;
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
pipe = POPEN <start> data <end> , ""w"");"	3
833ac937-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_listen_socket_open_11 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(globalReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN(data, O_RDWR|O_CREAT, <start> S_IREAD|S_IWRITE <end> );
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
replace = <start> strchr(data, '\n') <end> ;"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
replace = <start> strchr(data, '\n') <end> ;"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	3
6c938c17-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif namespace CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_74 { void badSink(map<int, char *> dataMap) { char * data = dataMap[2]; { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"SNPRINTF(dest, <start> 100-1 <end> , data);
printLine <start> dest <end> );"	"void badSink(map<int, char *> <start> dataMap <end> );
printLine <start> dest <end> );"	"<start> SNPRINTF(dest, 100-1, data) <end> ;
printLine <start> dest <end> );"	"<start> SNPRINTF(dest, 100-1, data) <end> ;
void badSink(map<int, char *> <start> dataMap <end> );"	1
aa91a19c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink(int data) { { int result = data - 1; printIntLine(result); } } void CWE191_Integer_Underflow__int_listen_socket_sub_44_bad() { int data; void (*funcPtr) (int) = badSink; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } funcPtr(data); }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
funcPtr <start> data <end> );
static void badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"data = <start> atoi(inputBuffer) <end> ;
funcPtr <start> data <end> );
printIntLine <start> result <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"<start> data = atoi(inputBuffer) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static void badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static void badSink(int <start> data <end> );"	0
cd228174-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_console_open_65 { void badSink(char * data); void bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } funcPtr(data); }"	where is the vulnerable dataflow from data to funcPtr ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
funcPtr <start> data <end> );"	"<start> data = dataBuffer <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
size_t dataLen = <start> strlen(data) <end> ;"	"funcPtr <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	0
c5fc232d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; namespace CWE23_Relative_Path_Traversal__char_file_ifstream_04 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(STATIC_CONST_TRUE) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"<start> data = dataBuffer <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
inputFile.open((char * <start> data <end> );"	"inputFile.open((char * <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"inputFile.open((char * <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	1
525b645e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_preinc_14_bad() { int data; data = 0; if(globalFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalFive==5) { { ++data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"+ <start> data <end> ;
data = <start> atoi(inputBuffer) <end> ;"	"int <start> result = data <end> ;
+ <start> data <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
+ <start> data <end> ;"	"int <start> result = data <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	2
8b91e4a7-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(count) + 2) #ifdef _WIN32 #define SLEEP Sleep #else #define SLEEP usleep #endif static int staticFive = 5; void CWE400_Resource_Exhaustion__connect_socket_sleep_07_bad() { int count; count = -1; if(staticFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; count = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticFive==5) { SLEEP(count); printLine(""Sleep time possibly too long""); } }"	where is the vulnerable dataflow from count to SLEEP ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
SLEEP <start> count <end> );"	"SLEEP <start> count <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
SLEEP <start> count <end> );"	"SLEEP <start> count <end> );
count = <start> atoi(inputBuffer) <end> ;"	0
598370ab-6c15-11ed-81d4-94e6f77dd552	namespace CWE191_Integer_Underflow__short_fscanf_multiply_62 { void badSource(short &data); void bad() { short data; data = 0; badSource(data); if(data < 0) { short result = data * 2; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"short result = <start> data * 2 <end> ;
badSource <start> data <end> );"	"badSource <start> data <end> );
short result = <start> data <end>  * 2;"	"short result = <start> data <end>  * 2;
<start> printIntLine(result) <end> ;"	"short result = <start> data <end>  * 2;
badSource <start> data <end> );"	1
4ff7825f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) typedef struct _CWE190_Integer_Overflow__int_listen_socket_postinc_67_structType { int structFirst; } CWE190_Integer_Overflow__int_listen_socket_postinc_67_structType; void CWE190_Integer_Overflow__int_listen_socket_postinc_67b_badSink(CWE190_Integer_Overflow__int_listen_socket_postinc_67_structType myStruct) { int data = myStruct.structFirst; { data++; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
void CWE190_Integer_Overflow__int_listen_socket_postinc_67b_badSink(CWE190_Integer_Overflow__int_listen_socket_postinc_67_structType <start> myStruct <end> );
<start> data <end> ++;"	"void CWE190_Integer_Overflow__int_listen_socket_postinc_67b_badSink(CWE190_Integer_Overflow__int_listen_socket_postinc_67_structType <start> myStruct <end> );
int data = <start> myStruct <end> .structFirst;
<start> data <end> ++;"	"<start> data <end> ++;
void CWE190_Integer_Overflow__int_listen_socket_postinc_67b_badSink(CWE190_Integer_Overflow__int_listen_socket_postinc_67_structType <start> myStruct <end> );
int data = <start> myStruct <end> .structFirst;"	"void CWE190_Integer_Overflow__int_listen_socket_postinc_67b_badSink(CWE190_Integer_Overflow__int_listen_socket_postinc_67_structType <start> myStruct <end> );
<start> data <end> ++;"	1
78800fed-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 8 void CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_53d_badSink(short data) { { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"void CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_53d_badSink(short <start> data <end> );
printLine <start> dest <end> );"	"printLine <start> dest <end> );
void CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_53d_badSink(short <start> data <end> );"	"<start> strncpy(dest, source, data) <end> ;
void CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_53d_badSink(short <start> data <end> );"	"char <start> dest[100] = """" <end> ;
void CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_53d_badSink(short <start> data <end> );"	0
a6fd8273-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink(int data) { { ++data; int result = data; printIntLine(result); } } void CWE190_Integer_Overflow__int_fgets_preinc_44_bad() { int data; void (*funcPtr) (int) = badSink; data = 0; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } funcPtr(data); }"	where is the vulnerable dataflow from result to printIntLine ?	"<start> data = atoi(inputBuffer) <end> ;
static void badSink(int <start> data <end> );
funcPtr <start> data <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
funcPtr <start> data <end> );
static void badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"<start> data = atoi(inputBuffer) <end> ;
printIntLine <start> result <end> );
funcPtr <start> data <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"<start> data = 0 <end> ;
static void badSink(int <start> data <end> );
printIntLine <start> result <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	1
a5ce1c42-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_postinc_52c_badSink(int data) { { data++; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"int <start> result = data <end> ;
void CWE190_Integer_Overflow__int_connect_socket_postinc_52c_badSink(int <start> data <end> );"	"printIntLine <start> result <end> );
void CWE190_Integer_Overflow__int_connect_socket_postinc_52c_badSink(int <start> data <end> );"	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;"	"void CWE190_Integer_Overflow__int_connect_socket_postinc_52c_badSink(int <start> data <end> );
printIntLine <start> result <end> );"	3
9059f3bf-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 256 static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } void CWE681_Incorrect_Conversion_Between_Numeric_Types__double2float_08_bad() { if(staticReturnsTrue()) { { char inputBuffer[CHAR_ARRAY_SIZE]; double doubleNumber = 0; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { doubleNumber = atof(inputBuffer); } else { printLine(""fgets() failed.""); } printFloatLine((float)doubleNumber); } } }"	where is the vulnerable dataflow from (float)doubleNumber to printFloatLine ?	"<start> doubleNumber = atof(inputBuffer) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"doubleNumber = <start> atof(inputBuffer) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printFloatLine <start> (float)doubleNumber <end> );"	"printFloatLine <start> (float)doubleNumber <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	2
820a46da-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_file_open_09 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(GLOBAL_CONST_TRUE) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"<start> data = dataBuffer <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	2
7e74f30b-6c15-11ed-81d4-94e6f77dd552	namespace CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_73 { void badSink(list<int> dataList) { int data = dataList.back(); if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }	where is the vulnerable dataflow from data to malloc ?	"void badSink(list<int> <start> dataList <end> );
char * dataBuffer = (char *)malloc <start> data <end> );"	"char * dataBuffer = (char *)malloc <start> data <end> );
int <start> data = dataList.back() <end> ;"	"<start> free(dataBuffer) <end> ;
void badSink(list<int> <start> dataList <end> );"	"<start> printLine(dataBuffer) <end> ;
void badSink(list<int> <start> dataList <end> );"	0
9187cc00-6c15-11ed-81d4-94e6f77dd552	"#define SEARCH_CHAR 'S' void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_console_17_bad() { int j; char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\0'; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } for(j = 0; j < 1; j++) { for (; *data != '\0'; data++) { if (*data == SEARCH_CHAR) { printLine(""We have a match!""); break; } } free(data); } }"	where is the vulnerable dataflow from data to free ?	"free <start> data <end> );
if (dataLen > 0 && <start> data[dataLen-1] == '\n' <end> );"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
free <start> data <end> );"	"free <start> data <end> );
dataLen = <start> strlen(data) <end> ;"	"<start> free(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	1
c26a7e39-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; namespace CWE23_Relative_Path_Traversal__char_console_open_04 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(STATIC_CONST_TRUE) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
size_t dataLen = <start> strlen(data) <end> ;"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	3
a23a3e3f-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__int_fgets_multiply_81 { void CWE190_Integer_Overflow__int_fgets_multiply_81_bad::action(int data) const { if(data > 0) { int result = data * 2; printIntLine(result); } } }	where is the vulnerable dataflow from result to printIntLine ?	"int result = <start> data * 2 <end> ;
void CWE190_Integer_Overflow__int_fgets_multiply_81_bad::action(int <start> data <end> ) const;"	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;"	"void CWE190_Integer_Overflow__int_fgets_multiply_81_bad::action(int <start> data <end> ) const;
<start> printIntLine(result) <end> ;"	"void CWE190_Integer_Overflow__int_fgets_multiply_81_bad::action(int <start> data <end> ) const;
printIntLine <start> result <end> );"	3
cac216a3-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" namespace CWE36_Absolute_Path_Traversal__char_connect_socket_ifstream_42 { static char * badSource(char * data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } return data; } void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; data = badSource(data); { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
inputFile.open((char * <start> data <end> );
data = <start> badSource <end> (data);
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(connectSocket, (char *)(data + dataLen), <start> sizeof(char) * (FILENAME_MAX - dataLen - 1) <end> , 0);
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
inputFile.open((char * <start> data <end> );
data = <start> badSource <end> (data);"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
inputFile.open((char * <start> data <end> );"	"static char * <start> badSource <end> (char * data);
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
inputFile.open((char * <start> data <end> );
recvResult = recv(connectSocket, (char *)(data + dataLen), <start> sizeof(char) * (FILENAME_MAX - dataLen - 1) <end> , 0);"	2
aa91a17c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) extern int CWE191_Integer_Underflow__int_listen_socket_multiply_68_badData; extern int CWE191_Integer_Underflow__int_listen_socket_multiply_68_goodG2BData; extern int CWE191_Integer_Underflow__int_listen_socket_multiply_68_goodB2GData; void CWE191_Integer_Underflow__int_listen_socket_multiply_68b_badSink() { int data = CWE191_Integer_Underflow__int_listen_socket_multiply_68_badData; if(data < 0) { int result = data * 2; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	"<start> printIntLine(result) <end> ;
int data = <start> CWE191_Integer_Underflow__int_listen_socket_multiply_68_badData <end> ;"	"printIntLine <start> result <end> );
int data = <start> CWE191_Integer_Underflow__int_listen_socket_multiply_68_badData <end> ;"	"int data = <start> CWE191_Integer_Underflow__int_listen_socket_multiply_68_badData <end> ;
printIntLine <start> result <end> );"	3
774f57ef-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 8 typedef union { short unionFirst; short unionSecond; } CWE194_Unexpected_Sign_Extension__fgets_strncpy_34_unionType; void CWE194_Unexpected_Sign_Extension__fgets_strncpy_34_bad() { short data; CWE194_Unexpected_Sign_Extension__fgets_strncpy_34_unionType myUnion; data = 0; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = (short)atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } myUnion.unionFirst = data; { short data = myUnion.unionSecond; { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } } }"	where is the vulnerable dataflow from dest to printLine ?	"printLine <start> dest <end> );
char <start> dest[100] = """" <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printLine <start> dest <end> );"	"printLine <start> dest <end> );
<start> strncpy(dest, source, data) <end> ;"	"<start> strncpy(dest, source, data) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	1
4db33f74-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_postinc_14_bad() { int data; data = 0; if(globalFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalFive==5) { { data++; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"int <start> result = data <end> ;
<start> data <end> ++;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data <end> ++;"	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
<start> data <end> ++;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int <start> result = data <end> ;"	1
525b6462-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_preinc_18_bad() { int data; data = 0; goto source; source: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } goto sink; sink: { ++data; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
+ <start> data <end> ;"	"<start> ++data <end> ;
+ <start> data <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
+ <start> data <end> ;"	"<start> ++data <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	2
cac216c2-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" namespace CWE36_Absolute_Path_Traversal__char_connect_socket_ofstream_42 { static char * badSource(char * data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } return data; } void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; data = badSource(data); { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
outputFile.open((char * <start> data <end> );"	"static char * <start> badSource <end> (char * data);
outputFile.open((char * <start> data <end> );
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"replace = <start> strchr(data, '\r') <end> ;
outputFile.open((char * <start> data <end> );
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	0
ae26ae5e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_82 { void bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_82_base* baseObject = new CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_82_bad; baseObject->action(data); delete baseObject; }"	where is the vulnerable dataflow from data to action ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
baseObject->action <start> data <end> );"	"baseObject->action <start> data <end> );
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"baseObject->action <start> data <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"baseObject->action <start> data <end> );
if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );"	0
728a5008-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 static void badVaSinkB(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_02_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; if(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(1) { badVaSinkB(data, data); } }"	where is the vulnerable dataflow from data to vprintf ?	"static void badVaSinkB(char * <start> data <end> , ...);
vprintf <start> data <end> , args);
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );"	"replace = <start> strchr(data, '\r') <end> ;
badVaSinkB <start> data <end> , data);
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
static void badVaSinkB(char * <start> data <end> , ...);"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
char <start> dataBuffer[100] = """" <end> ;
vprintf <start> data <end> , args);
badVaSinkB <start> data <end> , data);"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);
vprintf <start> data <end> , args);"	3
466e7f02-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_square_11_bad() { int data; data = 0; if(globalReturnsTrue()) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(globalReturnsTrue()) { { int result = data * data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"data = <start> atoi(inputBuffer) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"int result = <start> data <end>  * data;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
int result = <start> data <end>  * data;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> printIntLine(result) <end> ;"	2
4ec5d068-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) typedef struct _CWE190_Integer_Overflow__int_connect_socket_postinc_67_structType { int structFirst; } CWE190_Integer_Overflow__int_connect_socket_postinc_67_structType; void CWE190_Integer_Overflow__int_connect_socket_postinc_67b_badSink(CWE190_Integer_Overflow__int_connect_socket_postinc_67_structType myStruct) { int data = myStruct.structFirst; { data++; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"void CWE190_Integer_Overflow__int_connect_socket_postinc_67b_badSink(CWE190_Integer_Overflow__int_connect_socket_postinc_67_structType <start> myStruct <end> );
int data = <start> myStruct <end> .structFirst;
<start> data <end> ++;"	"<start> data <end> ++;
void CWE190_Integer_Overflow__int_connect_socket_postinc_67b_badSink(CWE190_Integer_Overflow__int_connect_socket_postinc_67_structType <start> myStruct <end> );"	"<start> printIntLine(result) <end> ;
<start> data <end> ++;
void CWE190_Integer_Overflow__int_connect_socket_postinc_67b_badSink(CWE190_Integer_Overflow__int_connect_socket_postinc_67_structType <start> myStruct <end> );"	"int <start> data = myStruct.structFirst <end> ;
<start> data <end> ++;
void CWE190_Integer_Overflow__int_connect_socket_postinc_67b_badSink(CWE190_Integer_Overflow__int_connect_socket_postinc_67_structType <start> myStruct <end> );"	0
c72d5d79-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 namespace CWE23_Relative_Path_Traversal__char_listen_socket_ifstream_10 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(globalTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
replace = <start> strchr(data, '\n') <end> ;"	"inputFile.open((char * <start> data <end> );
replace = <start> strchr(data, '\n') <end> ;"	"inputFile.open((char * <start> data <end> );
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
inputFile.open((char * <start> data <end> );"	3
74ee23dd-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" typedef union { short unionFirst; short unionSecond; } CWE194_Unexpected_Sign_Extension__connect_socket_strncpy_34_unionType; void CWE194_Unexpected_Sign_Extension__connect_socket_strncpy_34_bad() { short data; CWE194_Unexpected_Sign_Extension__connect_socket_strncpy_34_unionType myUnion; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } myUnion.unionFirst = data; { short data = myUnion.unionSecond; { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } } }"	where is the vulnerable dataflow from dest to printLine ?	"printLine <start> dest <end> );
char <start> dest[100] = """" <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"<start> strncpy(dest, source, data) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"tempInt = <start> atoi(inputBuffer) <end> ;
printLine <start> dest <end> );"	1
99e16a88-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_listen_socket_18 { void bad() { int data; data = -1; goto source; source: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } goto sink; sink: { int i; int * buffer = new int[10]; for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } delete[] buffer; } }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"if  <start> recvResult == SOCKET_ERROR <end>  || recvResult == 0);
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"printIntLine <start> buffer[i] <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"if  <start> recvResult == SOCKET_ERROR <end>  || recvResult == 0);
printIntLine <start> buffer[i] <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[i] <end> );"	3
b54bcf16-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE 20 void CWE369_Divide_by_Zero__float_fgets_64b_badSink(void * dataVoidPtr) { float * dataPtr = (float *)dataVoidPtr; float data = (*dataPtr); { int result = (int)(100.0 / data); printIntLine(result); } }	where is the vulnerable dataflow from result to printIntLine ?	"void CWE369_Divide_by_Zero__float_fgets_64b_badSink(void * <start> dataVoidPtr <end> );
printIntLine <start> result <end> );"	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	"void CWE369_Divide_by_Zero__float_fgets_64b_badSink(void * <start> dataVoidPtr <end> );
int result = <start> (int)(100.0 / data) <end> ;"	"printIntLine <start> result <end> );
void CWE369_Divide_by_Zero__float_fgets_64b_badSink(void * <start> dataVoidPtr <end> );"	0
c8600ad4-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 namespace CWE23_Relative_Path_Traversal__char_listen_socket_ifstream_53 { void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badSink_b(data); }"	where is the vulnerable dataflow from data to badSink_b ?	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"badSink_b <start> data <end> );
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
badSink_b <start> data <end> );"	"badSink_b <start> data <end> );
if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );"	2
cac216b0-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" static int staticTrue = 1; static int staticFalse = 0; namespace CWE36_Absolute_Path_Traversal__char_connect_socket_ofstream_05 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(staticTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
outputFile.open((char * <start> data <end> );"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
size_t <start> dataLen = strlen(data) <end> ;"	"outputFile.open((char * <start> data <end> );
size_t <start> dataLen = strlen(data) <end> ;"	"size_t dataLen = <start> strlen(data) <end> ;
outputFile.open((char * <start> data <end> );"	0
4b34afc2-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__short_fscanf_add_63b_badSink(short * dataPtr) { short data = *dataPtr; { short result = data + 1; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"short result = <start> data + 1 <end> ;
void CWE190_Integer_Overflow__short_fscanf_add_63b_badSink(short * <start> dataPtr <end> );"	"void CWE190_Integer_Overflow__short_fscanf_add_63b_badSink(short * <start> dataPtr <end> );
short result = <start> data <end>  + 1;"	"void CWE190_Integer_Overflow__short_fscanf_add_63b_badSink(short * <start> dataPtr <end> );
<start> printIntLine(result) <end> ;"	"short result = <start> data <end>  + 1;
void CWE190_Integer_Overflow__short_fscanf_add_63b_badSink(short * <start> dataPtr <end> );"	1
47a2a840-6c15-11ed-81d4-94e6f77dd552	"typedef union { int unionFirst; int unionSecond; } CWE190_Integer_Overflow__int_fscanf_multiply_34_unionType; void CWE190_Integer_Overflow__int_fscanf_multiply_34_bad() { int data; CWE190_Integer_Overflow__int_fscanf_multiply_34_unionType myUnion; data = 0; fscanf(stdin, ""%d"", &data); myUnion.unionFirst = data; { int data = myUnion.unionSecond; if(data > 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
fscanf(stdin, ""%d"", <start> &data <end> );"	"fscanf(stdin, ""%d"", <start> &data <end> );
int result = <start> data <end>  * 2;"	"int result = <start> data <end>  * 2;
fscanf(stdin, ""%d"", <start> &data <end> );"	"fscanf(stdin, ""%d"", <start> &data <end> );
int <start> result = data * 2 <end> ;"	1
5f76fcb1-6c15-11ed-81d4-94e6f77dd552	"static void badSink(short data) { { --data; short result = data; printIntLine(result); } } void CWE191_Integer_Underflow__short_fscanf_predec_41_bad() { short data; data = 0; fscanf (stdin, ""%hd"", &data); badSink(data); }"	where is the vulnerable dataflow from data ?	"fscanf (stdin, ""%hd"", <start> &data <end> );
badSink <start> data <end> );
static void badSink(short <start> data <end> );
- <start> data <end> ;"	"- <start> data <end> ;
badSink <start> data <end> );
static void badSink(short <start> data <end> );"	"short <start> result = data <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );
badSink <start> data <end> );
- <start> data <end> ;"	"short <start> result = data <end> ;
- <start> data <end> ;
static void badSink(short <start> data <end> );
fscanf (stdin, ""%hd"", <start> &data <end> );"	0
86cea172-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink(int data) { printIntLine(100 % data); } void CWE369_Divide_by_Zero__int_listen_socket_modulo_41_bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badSink(data); }"	where is the vulnerable dataflow from data to printIntLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSink <start> data <end> );
static void badSink(int <start> data <end> );
printIntLine <start> 100 % data <end> );"	"data = <start> atoi(inputBuffer) <end> ;
static void badSink(int <start> data <end> );
badSink <start> data <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"badSink <start> data <end> );
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
static void badSink(int <start> data <end> );
printIntLine <start> 100 % data <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static void badSink(int <start> data <end> );
<start> badSink(data) <end> ;
printIntLine <start> 100 % data <end> );"	0
846ad2ff-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif static const int STATIC_CONST_FIVE = 5; void CWE253_Incorrect_Check_of_Function_Return_Value__char_fgets_06_bad() { if(STATIC_CONST_FIVE==5) { { char dataBuffer[100] = """"; char * data = dataBuffer; printLine(""Please enter a string: ""); if (fgets(data, 100, stdin) < 0) { printLine(""fgets failed!""); exit(1); } printLine(data); } } }"	where is the vulnerable dataflow from data to printLine ?	"printLine <start> data <end> );
if  <start> fgets(data, 100, stdin) <end>  < 0);"	"if (fgets <start> data <end> , 100, stdin) < 0);
printLine <start> data <end> );"	"char <start> * data = dataBuffer <end> ;
printLine <start> data <end> );"	"char <start> dataBuffer[100] = """" <end> ;
if (fgets <start> data <end> , 100, stdin) < 0);"	1
a49c4f4b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE190_Integer_Overflow__int_listen_socket_multiply_43 { static void badSource(int &data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } void bad() { int data; data = 0; badSource(data); if(data > 0) { int result = data * 2; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"badSource <start> data <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"badSource <start> data <end> );
printIntLine <start> result <end> );
<start> recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSource <start> data <end> );
printIntLine <start> result <end> );"	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );
badSource <start> data <end> );"	2
61da672a-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__short_rand_multiply_02_bad() { short data; data = 0; if(1) { data = (short)RAND32(); } if(1) { if(data > 0) { short result = data * 2; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"short <start> result = data * 2 <end> ;
data = (short <start> RAND32() <end> ;"	"<start> printIntLine(result) <end> ;
data = (short <start> RAND32() <end> ;"	"data = (short <start> RAND32() <end> ;
short result = <start> data <end>  * 2;"	"data = (short <start> RAND32() <end> ;
if <start> data > 0 <end> ) ;"	2
acf67e3f-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_FIVE = 5; void CWE191_Integer_Underflow__int_fgets_predec_06_bad() { int data; data = 0; if(STATIC_CONST_FIVE==5) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(STATIC_CONST_FIVE==5) { { --data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
<start> data = 0 <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );"	"data = <start> atoi(inputBuffer) <end> ;
printIntLine <start> result <end> );"	"<start> printIntLine(result) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	1
728a4ff0-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 static void badVaSink(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_31_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { char * dataCopy = data; char * data = dataCopy; badVaSink(data, data); } }"	where is the vulnerable dataflow from data to vfprintf ?	"size_t dataLen = <start> strlen(data) <end> ;
static void badVaSink(char * <start> data <end> , ...);
badVaSink <start> data <end> , data);
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (100 - dataLen - 1), 0);
vfprintf(stdout, <start> data <end> , args);
static void badVaSink(char * <start> data <end> , ...);
badVaSink <start> data <end> , data);"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);"	"size_t dataLen = <start> strlen(data) <end> ;
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
badVaSink <start> data <end> , data);
vfprintf(stdout, <start> data <end> , args);"	2
48d25db9-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) int CWE190_Integer_Overflow__int_listen_socket_add_61b_badSource(int data); void CWE190_Integer_Overflow__int_listen_socket_add_61_bad() { int data; data = 0; data = CWE190_Integer_Overflow__int_listen_socket_add_61b_badSource(data); { int result = data + 1; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  + 1;
data = <start> CWE190_Integer_Overflow__int_listen_socket_add_61b_badSource <end> (data);"	"<start> printIntLine(result) <end> ;
data = <start> CWE190_Integer_Overflow__int_listen_socket_add_61b_badSource <end> (data);"	"int result = <start> data <end>  + 1;
<start> printIntLine(result) <end> ;"	"data = <start> CWE190_Integer_Overflow__int_listen_socket_add_61b_badSource <end> (data);
int result = <start> data <end>  + 1;"	3
a36a78d3-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_square_52c_badSink(int data) { { int result = data * data; printIntLine(result); } }	where is the vulnerable dataflow from result to printIntLine ?	"void CWE190_Integer_Overflow__int_fgets_square_52c_badSink(int <start> data <end> );
int <start> result = data * data <end> ;"	"void CWE190_Integer_Overflow__int_fgets_square_52c_badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
void CWE190_Integer_Overflow__int_fgets_square_52c_badSink(int <start> data <end> );"	"<start> printIntLine(result) <end> ;
void CWE190_Integer_Overflow__int_fgets_square_52c_badSink(int <start> data <end> );"	1
8f278a50-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_FIVE = 5; void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_06_bad() { int data; data = -1; if(STATIC_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { size_t i; int *intPointer; intPointer = (int*)malloc(data * sizeof(int)); if (intPointer == NULL) {exit(-1);} for (i = 0; i < (size_t)data; i++) { intPointer[i] = 0; } printIntLine(intPointer[0]); free(intPointer); } }"	where is the vulnerable dataflow from data to malloc ?	"<start> data = atoi(inputBuffer) <end> ;
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data = -1 <end> ;"	"data = <start> atoi(inputBuffer) <end> ;
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	3
a10948f7-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_multiply_66b_badSink(int dataArray[]) { int data = dataArray[2]; if(data > 0) { int result = data * 2; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"void CWE190_Integer_Overflow__int_connect_socket_multiply_66b_badSink(int <start> dataArray <end> []);
int <start> result = data * 2 <end> ;"	"printIntLine <start> result <end> );
void CWE190_Integer_Overflow__int_connect_socket_multiply_66b_badSink(int <start> dataArray <end> []);"	"printIntLine <start> result <end> );
int <start> result = data * 2 <end> ;"	"void CWE190_Integer_Overflow__int_connect_socket_multiply_66b_badSink(int <start> dataArray <end> []);
printIntLine <start> result <end> );"	3
48d25d88-6c15-11ed-81d4-94e6f77dd552	"static void badSink(int data) { { int result = data * data; printIntLine(result); } } void CWE190_Integer_Overflow__int_fscanf_square_41_bad() { int data; data = 0; fscanf(stdin, ""%d"", &data); badSink(data); }"	where is the vulnerable dataflow from data ?	"fscanf(stdin, ""%d"", <start> &data <end> );
badSink <start> data <end> );
static void badSink(int <start> data <end> );
<start> badSink(data) <end> ;"	"static void badSink(int <start> data <end> );
badSink <start> data <end> );
int result = <start> data <end>  * data;"	"fscanf(stdin, ""%d"", <start> &data <end> );
badSink <start> data <end> );
static void badSink(int <start> data <end> );
int result = <start> data <end>  * data;"	"badSink <start> data <end> );
<start> printIntLine(result) <end> ;
fscanf(stdin, ""%d"", <start> &data <end> );
int result = <start> data <end>  * data;"	2
bc721f94-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define EXECLP _execlp #else #define EXECLP execlp #endif void CWE78_OS_Command_Injection__char_file_execlp_13_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(GLOBAL_CONST_FIVE==5) { { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECLP ?	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
<start> EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL) <end> ;"	"EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
size_t dataLen = <start> strlen(data) <end> ;"	2
86cea15e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE369_Divide_by_Zero__int_listen_socket_modulo_02_bad() { int data; data = -1; if(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(1) { printIntLine(100 % data); } }"	where is the vulnerable dataflow from data to printIntLine ?	"data = <start> atoi(inputBuffer) <end> ;
printIntLine <start> 100 % data <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> 100 % data <end> );"	"printIntLine <start> 100 % data <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"<start> data = -1 <end> ;
printIntLine <start> 100 % data <end> );"	1
61da66f6-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__char_rand_square_63b_badSink(char * dataPtr) { char data = *dataPtr; { char result = data * data; printHexCharLine(result); } }	where is the vulnerable dataflow from data ?	"void CWE190_Integer_Overflow__char_rand_square_63b_badSink(char * <start> dataPtr <end> );
char <start> result = data * data <end> ;"	"void CWE190_Integer_Overflow__char_rand_square_63b_badSink(char * <start> dataPtr <end> );
<start> printHexCharLine(result) <end> ;"	"void CWE190_Integer_Overflow__char_rand_square_63b_badSink(char * <start> dataPtr <end> );
char result = <start> data * data <end> ;"	"void CWE190_Integer_Overflow__char_rand_square_63b_badSink(char * <start> dataPtr <end> );
char result = <start> data <end>  * data;"	3
893217c8-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_console_fopen_18 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; goto source; source: { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
pFile = FOPEN <start> data <end> , ""wb+"");"	"size_t dataLen = <start> strlen(data) <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"dataLen = <start> strlen(data) <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	0
761e2997-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 8 extern short CWE194_Unexpected_Sign_Extension__fgets_memmove_68_badData; extern short CWE194_Unexpected_Sign_Extension__fgets_memmove_68_goodG2BData; void CWE194_Unexpected_Sign_Extension__fgets_memmove_68b_badSink() { short data = CWE194_Unexpected_Sign_Extension__fgets_memmove_68_badData; { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> printLine(dest) <end> ;
short data = <start> CWE194_Unexpected_Sign_Extension__fgets_memmove_68_badData <end> ;"	"printLine <start> dest <end> );
short <start> data = CWE194_Unexpected_Sign_Extension__fgets_memmove_68_badData <end> ;"	"short data = <start> CWE194_Unexpected_Sign_Extension__fgets_memmove_68_badData <end> ;
printLine <start> dest <end> );"	"printLine <start> dest <end> );
<start> memmove(dest, source, data) <end> ;"	2
ba102b7f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define EXECL _execl #else #define EXECL execl #endif void CWE78_OS_Command_Injection__char_connect_socket_execl_09_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(GLOBAL_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECL ?	"<start> EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL) <end> ;
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"size_t dataLen = <start> strlen(data) <end> ;
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	2
ba102ba7-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define EXECLP _execlp #else #define EXECLP execlp #endif void CWE78_OS_Command_Injection__char_connect_socket_execlp_41_badSink(char * data) { EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL); } void CWE78_OS_Command_Injection__char_connect_socket_execlp_41_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE78_OS_Command_Injection__char_connect_socket_execlp_41_badSink(data); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECLP ?	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
CWE78_OS_Command_Injection__char_connect_socket_execlp_41_badSink <start> data <end> );
void CWE78_OS_Command_Injection__char_connect_socket_execlp_41_badSink(char * <start> data <end> );"	"EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
<start> data = dataBuffer <end> ;
void CWE78_OS_Command_Injection__char_connect_socket_execlp_41_badSink(char * <start> data <end> );
CWE78_OS_Command_Injection__char_connect_socket_execlp_41_badSink <start> data <end> );"	"replace = <start> strchr(data, '\n') <end> ;
void CWE78_OS_Command_Injection__char_connect_socket_execlp_41_badSink(char * <start> data <end> );
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
CWE78_OS_Command_Injection__char_connect_socket_execlp_41_badSink <start> data <end> );"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
CWE78_OS_Command_Injection__char_connect_socket_execlp_41_badSink <start> data <end> );
void CWE78_OS_Command_Injection__char_connect_socket_execlp_41_badSink(char * <start> data <end> );
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	3
8df421da-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define PATH_SZ 100 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define PATH_SZ PATH_MAX #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 void CWE605_Multiple_Binds_Same_Port__basic_09_bad() { if(GLOBAL_CONST_TRUE) { { char data[100] = """"; #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); #ifdef _WIN32 BOOL bOptVal = TRUE; int bOptLen = sizeof(BOOL); #else int bOptVal = 1; int bOptLen = sizeof(int); #endif do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } if (setsockopt(listenSocket, SOL_SOCKET, SO_REUSEADDR, (char*)&bOptVal, bOptLen) != 0) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, data+dataLen, (int)(100-dataLen-1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[recvResult] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif printLine(data); } } }"	where is the vulnerable dataflow from data to printLine ?	"printLine <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	"recvResult = recv(acceptSocket, <start> data+dataLen <end> , (int)(100-dataLen-1), 0);
size_t dataLen = <start> strlen(data) <end> ;"	"recvResult = recv(acceptSocket, <start> data+dataLen <end> , (int)(100-dataLen-1), 0);
printLine <start> data <end> );"	"size_t <start> dataLen = strlen(data) <end> ;
printLine <start> data <end> );"	2
bda4e41b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define EXECL _execl #else #define EXECL execl #endif void CWE78_OS_Command_Injection__char_listen_socket_execl_13_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(GLOBAL_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECL ?	"EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) *  <start> 100 - dataLen - 1 <end> ), 0);"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (100 - dataLen - 1), 0);"	"<start> data = dataBuffer <end> ;
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	1
c4cd6f5e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; namespace CWE23_Relative_Path_Traversal__char_file_fopen_04 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(STATIC_CONST_TRUE) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"pFile = FOPEN <start> data <end> , ""wb+"");
size_t dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	2
584fa853-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_listen_socket_multiply_31_bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { int dataCopy = data; int data = dataCopy; if(data < 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  * 2;
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"<start> printIntLine(result) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  * 2;"	"<start> recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
int result = <start> data <end>  * 2;"	2
70279c2c-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif static void badVaSinkB(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_file_vfprintf_17_bad() { int i,j; char * data; char dataBuffer[100] = """"; data = dataBuffer; for(i = 0; i < 1; i++) { { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } for(j = 0; j < 1; j++) { badVaSinkB(data, data); } }"	where is the vulnerable dataflow from data to vfprintf ?	"size_t dataLen = <start> strlen(data) <end> ;
vfprintf(stdout, <start> data <end> , args);
static void badVaSinkB(char * <start> data <end> , ...);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	"badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);
char <start> dataBuffer[100] = """" <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);"	"static void badVaSinkB(char * <start> data <end> , ...);
badVaSinkB <start> data <end> , data);"	2
b08640e5-6c15-11ed-81d4-94e6f77dd552	int CWE197_Numeric_Truncation_Error__int_fgets_to_short_22_badGlobal = 0; int CWE197_Numeric_Truncation_Error__int_fgets_to_short_22_badSource(int data); void CWE197_Numeric_Truncation_Error__int_fgets_to_short_22_bad() { int data; data = -1; CWE197_Numeric_Truncation_Error__int_fgets_to_short_22_badGlobal = 1; data = CWE197_Numeric_Truncation_Error__int_fgets_to_short_22_badSource(data); { short shortData = (short)data; printShortLine(shortData); } }	where is the vulnerable dataflow from shortData to printShortLine ?	"data = <start> CWE197_Numeric_Truncation_Error__int_fgets_to_short_22_badSource <end> (data);
printShortLine <start> shortData <end> );"	"short <start> shortData = (short)data <end> ;
printShortLine <start> shortData <end> );"	"printShortLine <start> shortData <end> );
data = <start> CWE197_Numeric_Truncation_Error__int_fgets_to_short_22_badSource <end> (data);"	"data = <start> CWE197_Numeric_Truncation_Error__int_fgets_to_short_22_badSource <end> (data);
short <start> shortData = (short)data <end> ;"	0
761e294b-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 8 static int staticFive = 5; void CWE194_Unexpected_Sign_Extension__fgets_memcpy_07_bad() { short data; data = 0; if(staticFive==5) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = (short)atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printLine <start> dest <end> );"	"<start> memcpy(dest, source, data) <end> ;
printLine <start> dest <end> );"	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	"<start> data = (short)atoi(inputBuffer) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	0
6dc614e2-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" static void badVaSinkB(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_11_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; if(globalReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalReturnsTrue()) { badVaSinkB(data, data); } }"	where is the vulnerable dataflow from data to vprintf ?	"<start> vprintf(data, args) <end> ;
vprintf <start> data <end> , args);
badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);"	"vprintf <start> data <end> , args);
badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);
recvResult = <start> recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0) <end> ;"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);
vprintf <start> data <end> , args);"	"size_t dataLen = <start> strlen(data) <end> ;
vprintf <start> data <end> , args);
static void badVaSinkB(char * <start> data <end> , ...);
badVaSinkB <start> data <end> , data);"	2
c8600ad6-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 namespace CWE23_Relative_Path_Traversal__char_listen_socket_ifstream_65 { void badSink(char * data); void bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } funcPtr(data); }"	where is the vulnerable dataflow from data to funcPtr ?	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"replace = <start> strchr(data, '\r') <end> ;
funcPtr <start> data <end> );"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
size_t dataLen = <start> strlen(data) <end> ;"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
funcPtr <start> data <end> );"	3
656cd3ca-6c15-11ed-81d4-94e6f77dd552	static int badSource(int data) { data = RAND32(); return data; } void CWE190_Integer_Overflow__int_rand_add_42_bad() { int data; data = 0; data = badSource(data); { int result = data + 1; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"data = <start> RAND32() <end> ;
data = <start> badSource <end> (data);
static int <start> badSource <end> (int data);"	"data = <start> RAND32() <end> ;
static int <start> badSource <end> (int data);
data = <start> badSource <end> (data);
int result = <start> data <end>  + 1;"	"data = <start> badSource <end> (data);
int result = <start> data <end>  + 1;
data = <start> RAND32() <end> ;
static int <start> badSource <end> (int data);"	"<start> printIntLine(result) <end> ;
data = <start> RAND32() <end> ;
int result = <start> data <end>  + 1;
static int <start> badSource <end> (int data);"	1
4a02113c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_square_63b_badSink(int * dataPtr) { int data = *dataPtr; { int result = data * data; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"void CWE190_Integer_Overflow__int_listen_socket_square_63b_badSink(int * <start> dataPtr <end> );
int result = <start> data <end>  * data;"	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  * data;"	"int result = <start> data <end>  * data;
void CWE190_Integer_Overflow__int_listen_socket_square_63b_badSink(int * <start> dataPtr <end> );"	"int <start> result = data * data <end> ;
void CWE190_Integer_Overflow__int_listen_socket_square_63b_badSink(int * <start> dataPtr <end> );"	0
5f76fc8b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_listen_socket_predec_31_bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { int dataCopy = data; int data = dataCopy; { --data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"int <start> dataCopy = data <end> ;
- <start> data <end> ;"	"- <start> data <end> ;
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
- <start> data <end> ;"	"- <start> data <end> ;
if  <start> listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR <end> );"	2
4ff7826e-6c15-11ed-81d4-94e6f77dd552	"void CWE190_Integer_Overflow__short_fscanf_postinc_15_bad() { short data; data = 0; switch(6) { case 6: fscanf (stdin, ""%hd"", &data); break; default: printLine(""Benign, fixed string""); break; } switch(7) { case 7: { data++; short result = data; printIntLine(result); } break; default: printLine(""Benign, fixed string""); break; } }"	where is the vulnerable dataflow from data ?	"<start> data <end> ++;
fscanf (stdin, ""%hd"", <start> &data <end> );"	"fscanf (stdin, ""%hd"", <start> &data <end> );
short <start> result = data <end> ;"	"short <start> result = data <end> ;
<start> data <end> ++;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
<start> data <end> ++;"	3
c136627d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; namespace CWE23_Relative_Path_Traversal__char_console_ofstream_04 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(STATIC_CONST_TRUE) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"dataLen = <start> strlen(data) <end> ;
outputFile.open((char * <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
outputFile.open((char * <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
<start> data = dataBuffer <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
dataLen = <start> strlen(data) <end> ;"	1
525b646a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int CWE190_Integer_Overflow__int_listen_socket_preinc_45_badData; static int CWE190_Integer_Overflow__int_listen_socket_preinc_45_goodG2BData; static int CWE190_Integer_Overflow__int_listen_socket_preinc_45_goodB2GData; static void badSink() { int data = CWE190_Integer_Overflow__int_listen_socket_preinc_45_badData; { ++data; int result = data; printIntLine(result); } } void CWE190_Integer_Overflow__int_listen_socket_preinc_45_bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE190_Integer_Overflow__int_listen_socket_preinc_45_badData = data; badSink(); }"	where is the vulnerable dataflow from data ?	"static int <start> CWE190_Integer_Overflow__int_listen_socket_preinc_45_badData <end> ;
+ <start> data <end> ;
int data = <start> CWE190_Integer_Overflow__int_listen_socket_preinc_45_badData <end> ;
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
<start> CWE190_Integer_Overflow__int_listen_socket_preinc_45_badData = data <end> ;"	"<start> CWE190_Integer_Overflow__int_listen_socket_preinc_45_badData = data <end> ;
if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );
int data = <start> CWE190_Integer_Overflow__int_listen_socket_preinc_45_badData <end> ;
static int <start> CWE190_Integer_Overflow__int_listen_socket_preinc_45_badData <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"<start> printIntLine(result) <end> ;
<start> CWE190_Integer_Overflow__int_listen_socket_preinc_45_badData = data <end> ;
static int <start> CWE190_Integer_Overflow__int_listen_socket_preinc_45_badData <end> ;
int data = <start> CWE190_Integer_Overflow__int_listen_socket_preinc_45_badData <end> ;
+ <start> data <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> CWE190_Integer_Overflow__int_listen_socket_preinc_45_badData = data <end> ;
static int <start> CWE190_Integer_Overflow__int_listen_socket_preinc_45_badData <end> ;
int data = <start> CWE190_Integer_Overflow__int_listen_socket_preinc_45_badData <end> ;
+ <start> data <end> ;"	3
453db06d-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int badStatic = 0; static void badSink(int data) { if(badStatic) { { int result = data + 1; printIntLine(result); } } } void CWE190_Integer_Overflow__int_fgets_add_21_bad() { int data; data = 0; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } badStatic = 1; badSink(data); }"	where is the vulnerable dataflow from data ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
int result = <start> data <end>  + 1;
badSink <start> data <end> );"	"int result = <start> data <end>  + 1;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
badSink <start> data <end> );
static void badSink(int <start> data <end> );
int result = <start> data <end>  + 1;"	"data = <start> atoi(inputBuffer) <end> ;
static void badSink(int <start> data <end> );
int result = <start> data <end>  + 1;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	2
7c127579-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) extern int CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_68_badData; extern int CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_68_goodG2BData; void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_68b_badSink() { int data = CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_68_badData; if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }	where is the vulnerable dataflow from data to malloc ?	"int data = <start> CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_68_badData <end> ;
char * dataBuffer = (char *)malloc <start> data <end> );"	"char <start> * dataBuffer = (char *)malloc(data) <end> ;
char * dataBuffer = (char *)malloc <start> data <end> );"	"int data = <start> CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_68_badData <end> ;
char * dataBuffer = (char * <start> malloc(data) <end> ;"	"int data = <start> CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_68_badData <end> ;
<start> printLine(dataBuffer) <end> ;"	0
c5fc2339-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif namespace CWE23_Relative_Path_Traversal__char_file_ifstream_16 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; while(1) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } break; } { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"inputFile.open((char * <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
<start> data = dataBuffer <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
size_t dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
inputFile.open((char * <start> data <end> );"	3
78800f8e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 8 void CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_41_badSink(short data) { { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } } void CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_41_bad() { short data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_41_badSink(data); }"	where is the vulnerable dataflow from dest to printLine ?	"<start> recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_41_badSink <start> data <end> );
void CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_41_badSink(short <start> data <end> );
printLine <start> dest <end> );"	"<start> data = 0 <end> ;
printLine <start> dest <end> );
CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_41_badSink <start> data <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_41_badSink <start> data <end> );
void CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_41_badSink(short <start> data <end> );
printLine <start> dest <end> );"	"CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_41_badSink <start> data <end> );
printLine <start> dest <end> );
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
void CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_41_badSink(short <start> data <end> );"	2
a36a78c7-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_square_17_bad() { int i,j; int data; data = 0; for(i = 0; i < 1; i++) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } for(j = 0; j < 1; j++) { { int result = data * data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;"	"int <start> result = data * data <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
int result = <start> data * data <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );"	3
b2ea8db1-6c15-11ed-81d4-94e6f77dd552	namespace CWE197_Numeric_Truncation_Error__short_connect_socket_81 { void CWE197_Numeric_Truncation_Error__short_connect_socket_81_bad::action(short data) const { { char charData = (char)data; printHexCharLine(charData); } } }	where is the vulnerable dataflow from charData to printHexCharLine ?	"<start> printHexCharLine(charData) <end> ;
void CWE197_Numeric_Truncation_Error__short_connect_socket_81_bad::action(short <start> data <end> ) const;"	"printHexCharLine <start> charData <end> );
char <start> charData = (char)data <end> ;"	"void CWE197_Numeric_Truncation_Error__short_connect_socket_81_bad::action(short <start> data <end> ) const;
printHexCharLine <start> charData <end> );"	"void CWE197_Numeric_Truncation_Error__short_connect_socket_81_bad::action(short <start> data <end> ) const;
char <start> charData = (char)data <end> ;"	2
571e9800-6c15-11ed-81d4-94e6f77dd552	"void CWE191_Integer_Underflow__int_fscanf_multiply_10_bad() { int data; data = 0; if(globalTrue) { fscanf(stdin, ""%d"", &data); } if(globalTrue) { if(data < 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  * 2;
fscanf(stdin, ""%d"", <start> &data <end> );"	"int result = <start> data <end>  * 2;
<start> printIntLine(result) <end> ;"	"fscanf(stdin, ""%d"", <start> &data <end> );
int result = <start> data <end>  * 2;"	"<start> printIntLine(result) <end> ;
fscanf(stdin, ""%d"", <start> &data <end> );"	2
d31a2513-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif static int staticTrue = 1; static int staticFalse = 0; namespace CWE36_Absolute_Path_Traversal__char_listen_socket_open_05 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(staticTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
replace = <start> strchr(data, '\n') <end> ;"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);"	1
79b27515-6c15-11ed-81d4-94e6f77dd552	"namespace CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_73 { void badSink(list<short> dataList) { short data = dataList.back(); { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"char <start> dest[100] = """" <end> ;
void badSink(list<short> <start> dataList <end> );"	"<start> strncpy(dest, source, data) <end> ;
void badSink(list<short> <start> dataList <end> );"	"void badSink(list<short> <start> dataList <end> );
printLine <start> dest <end> );"	"void badSink(list<short> <start> dataList <end> );
<start> printLine(dest) <end> ;"	2
584fa859-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int CWE191_Integer_Underflow__int_listen_socket_multiply_45_badData; static int CWE191_Integer_Underflow__int_listen_socket_multiply_45_goodG2BData; static int CWE191_Integer_Underflow__int_listen_socket_multiply_45_goodB2GData; static void badSink() { int data = CWE191_Integer_Underflow__int_listen_socket_multiply_45_badData; if(data < 0) { int result = data * 2; printIntLine(result); } } void CWE191_Integer_Underflow__int_listen_socket_multiply_45_bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE191_Integer_Underflow__int_listen_socket_multiply_45_badData = data; badSink(); }"	where is the vulnerable dataflow from data ?	"data = <start> atoi(inputBuffer) <end> ;
int result = <start> data <end>  * 2;
int data = <start> CWE191_Integer_Underflow__int_listen_socket_multiply_45_badData <end> ;
static int <start> CWE191_Integer_Underflow__int_listen_socket_multiply_45_badData <end> ;
<start> CWE191_Integer_Underflow__int_listen_socket_multiply_45_badData = data <end> ;"	"<start> CWE191_Integer_Underflow__int_listen_socket_multiply_45_badData = data <end> ;
static int <start> CWE191_Integer_Underflow__int_listen_socket_multiply_45_badData <end> ;
int data = <start> CWE191_Integer_Underflow__int_listen_socket_multiply_45_badData <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  * 2;"	"recvResult = recv(acceptSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);
int data = <start> CWE191_Integer_Underflow__int_listen_socket_multiply_45_badData <end> ;
static int <start> CWE191_Integer_Underflow__int_listen_socket_multiply_45_badData <end> ;
<start> CWE191_Integer_Underflow__int_listen_socket_multiply_45_badData = data <end> ;
int result = <start> data <end>  * 2;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> CWE191_Integer_Underflow__int_listen_socket_multiply_45_badData = data <end> ;
static int <start> CWE191_Integer_Underflow__int_listen_socket_multiply_45_badData <end> ;
int data = <start> CWE191_Integer_Underflow__int_listen_socket_multiply_45_badData <end> ;
int result = <start> data <end>  * 2;"	3
69161b3d-6c15-11ed-81d4-94e6f77dd552	static void badSink(int data) { { ++data; int result = data; printIntLine(result); } } void CWE190_Integer_Overflow__int_rand_preinc_41_bad() { int data; data = 0; data = RAND32(); badSink(data); }	where is the vulnerable dataflow from data ?	"badSink <start> data <end> );
+ <start> data <end> ;
data = <start> RAND32() <end> ;"	"data = <start> RAND32() <end> ;
badSink <start> data <end> );
static void badSink(int <start> data <end> );
+ <start> data <end> ;"	"data = <start> RAND32() <end> ;
badSink <start> data <end> );"	"badSink <start> data <end> );
data = <start> RAND32() <end> ;
+ <start> data <end> ;
static void badSink(int <start> data <end> );"	1
5af03e03-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int badSource(int data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } return data; } void CWE191_Integer_Underflow__int_connect_socket_postdec_42_bad() { int data; data = 0; data = badSource(data); { data--; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static int <start> badSource <end> (int data);
data = <start> badSource <end> (data);
<start> data <end> --;"	"int <start> result = data <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
data = <start> badSource <end> (data);
static int <start> badSource <end> (int data);"	"<start> data <end> --;
<start> printIntLine(result) <end> ;
static int <start> badSource <end> (int data);
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"static int <start> badSource <end> (int data);
<start> data <end> --;"	0
820a46f7-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_file_open_72 { void badSink(vector<char *> dataVector) { char * data = dataVector[2]; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"void badSink(vector<char *> <start> dataVector <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
void badSink(vector<char *> <start> dataVector <end> );"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
char <start> * data = dataVector[2] <end> ;"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	0
7ae3a74a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_52c_badSink(int data) { { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_52c_badSink(int <start> data <end> );
printLine <start> dest <end> );"	"<start> strncpy(dest, source, data) <end> ;
void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_52c_badSink(int <start> data <end> );"	"printLine <start> dest <end> );
<start> printLine(dest) <end> ;"	"void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_52c_badSink(int <start> data <end> );
if  <start> data < 100 <end> );"	0
9187cbe2-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define SEARCH_CHAR 'S' static char * badSource(char * data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } return data; } void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_42_bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\0'; data = badSource(data); for (; *data != '\0'; data++) { if (*data == SEARCH_CHAR) { printLine(""We have a match!""); break; } } free(data); }"	where is the vulnerable dataflow from data to free ?	"data = <start> badSource <end> (data);
for (; *data != '\0'; <start> data++ <end> );
free <start> data <end> );
static char * <start> badSource <end> (char * data);"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
free <start> data <end> );"	"<start> free(data) <end> ;
free <start> data <end> );
data = <start> badSource <end> (data);
static char * <start> badSource <end> (char * data);"	"recvResult = <start> recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0) <end> ;
static char * <start> badSource <end> (char * data);
free <start> data <end> );
data = <start> badSource <end> (data);"	1
79b2756b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) extern int CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_68_badData; extern int CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_68_goodG2BData; void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_68b_badSink() { int data = CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_68_badData; { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"printLine <start> dest <end> );
int data = <start> CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_68_badData <end> ;"	"<start> memcpy(dest, source, data) <end> ;
printLine <start> dest <end> );"	"int data = <start> CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_68_badData <end> ;
printLine <start> dest <end> );"	"<start> memcpy(dest, source, data) <end> ;
int data = <start> CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_68_badData <end> ;"	2
73bc8156-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" void CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_52c_badSink(short data) { { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"char <start> dest[100] = """" <end> ;
printLine <start> dest <end> );"	"<start> printLine(dest) <end> ;
void CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_52c_badSink(short <start> data <end> );"	"void CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_52c_badSink(short <start> data <end> );
printLine <start> dest <end> );"	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	2
9d745396-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE127_Buffer_Underread__CWE839_connect_socket_17_bad() { int i,j; int data; data = -1; for(i = 0; i < 1; i++) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } for(j = 0; j < 1; j++) { { int buffer[10] = { 0 }; if (data < 10) { printIntLine(buffer[data]); } else { printLine(""ERROR: Array index is too big.""); } } } }"	where is the vulnerable dataflow from buffer[data] to printIntLine ?	"int <start> buffer[10] = { 0 } <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"printIntLine <start> buffer[data] <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[data] <end> );"	"printIntLine <start> buffer[data] <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	2
9fe7ad42-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_FIVE = 5; void CWE190_Integer_Overflow__int_connect_socket_add_06_bad() { int data; data = 0; if(STATIC_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(STATIC_CONST_FIVE==5) { { int result = data + 1; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"data = <start> atoi(inputBuffer) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data = atoi(inputBuffer) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
data = <start> atoi(inputBuffer) <end> ;"	2
4ec5d0bb-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_postinc_11_bad() { int data; data = 0; if(globalReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalReturnsTrue()) { { data++; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
data = <start> atoi(inputBuffer) <end> ;"	"data = <start> atoi(inputBuffer) <end> ;
<start> data <end> ++;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data <end> ++;"	"<start> printIntLine(result) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	2
a95fd816-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) extern int CWE191_Integer_Underflow__int_connect_socket_sub_68_badData; extern int CWE191_Integer_Underflow__int_connect_socket_sub_68_goodG2BData; extern int CWE191_Integer_Underflow__int_connect_socket_sub_68_goodB2GData; void CWE191_Integer_Underflow__int_connect_socket_sub_68b_badSink() { int data = CWE191_Integer_Underflow__int_connect_socket_sub_68_badData; { int result = data - 1; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"int <start> data = CWE191_Integer_Underflow__int_connect_socket_sub_68_badData <end> ;
printIntLine <start> result <end> );"	"int data = <start> CWE191_Integer_Underflow__int_connect_socket_sub_68_badData <end> ;
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;"	"<start> printIntLine(result) <end> ;
int data = <start> CWE191_Integer_Underflow__int_connect_socket_sub_68_badData <end> ;"	1
60db83c9-6c15-11ed-81d4-94e6f77dd552	static char badSource(char data) { data = (char)RAND32(); return data; } void CWE190_Integer_Overflow__char_rand_multiply_42_bad() { char data; data = ' '; data = badSource(data); if(data > 0) { char result = data * 2; printHexCharLine(result); } }	where is the vulnerable dataflow from data ?	"data = (char <start> RAND32() <end> ;
static char <start> badSource <end> (char data);
data = <start> badSource <end> (data);
char result = <start> data <end>  * 2;"	"data = <start> badSource <end> (data);
data = (char <start> RAND32() <end> ;
static char <start> badSource <end> (char data);
char result = <start> data * 2 <end> ;"	"char result = <start> data <end>  * 2;
data = <start> badSource <end> (data);
<start> printHexCharLine(result) <end> ;
data = (char <start> RAND32() <end> ;"	"<start> data = ' ' <end> ;
static char <start> badSource <end> (char data);
data = (char <start> RAND32() <end> ;
char result = <start> data <end>  * 2;"	0
cac216d8-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_connect_socket_open_14 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(globalFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"size_t <start> dataLen = strlen(data) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
recvResult = recv(connectSocket, (char *)(data + dataLen), <start> sizeof(char) * (FILENAME_MAX - dataLen - 1) <end> , 0);"	0
846ad318-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define STAT _stat #define OPEN _open #define WRITE _write #define O_RDWR _O_RDWR #define CLOSE _close #else #define STAT stat #define OPEN open #define WRITE write #define CLOSE close #endif #define BAD_SINK_STRING ""Bad Sink..."" #define GOOD_SINK_STRING ""Good Sink..."" #ifdef _WIN32 #define ACCESS _access #define W_OK 02 #else #define ACCESS access #endif void CWE367_TOC_TOU__access_15_bad() { switch(6) { case 6: { char filename[100] = """"; int fileDesc = -1; if (fgets(filename, 100, stdin) == NULL) { printLine(""fgets() failed""); filename[0] = '\0'; } if (strlen(filename) > 0) { filename[strlen(filename)-1] = '\0'; } if (ACCESS(filename, W_OK) == -1) { exit(1); } fileDesc  = OPEN(filename, O_RDWR); if (fileDesc == -1) { exit(1); } if (WRITE(fileDesc, BAD_SINK_STRING, strlen(BAD_SINK_STRING)) == -1) { exit(1); } if (fileDesc != -1) { CLOSE(fileDesc); } } break; default: printLine(""Benign, fixed string""); break; } }"	where is the vulnerable dataflow from filename to OPEN ?	"if  <start> ACCESS(filename, W_OK) <end>  == -1);
if (fgets <start> filename <end> , 100, stdin) == NULL);"	"fileDesc  = OPEN <start> filename <end> , O_RDWR);
if  <start> strlen(filename) <end>  > 0);"	"if  <start> ACCESS(filename, W_OK) <end>  == -1);
fileDesc  = OPEN <start> filename <end> , O_RDWR);"	"if (fgets <start> filename <end> , 100, stdin) == NULL);
fileDesc  = OPEN <start> filename <end> , O_RDWR);"	3
c4cd6f5b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_file_fopen_01 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"<start> data = dataBuffer <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	1
8df421f6-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define PATH_SZ 100 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define PATH_SZ PATH_MAX #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 void CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__accept_bind_listen_17_bad() { int j; for(j = 0; j < 1; j++) { { char data[100] = """"; #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[recvResult] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif printLine(data); } } }"	where is the vulnerable dataflow from data to printLine ?	"size_t dataLen = <start> strlen(data) <end> ;
recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);"	"printLine <start> data <end> );
recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);"	"recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);
<start> printLine(data) <end> ;"	"recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);
printLine <start> data <end> );"	3
cd22814c-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif namespace CWE36_Absolute_Path_Traversal__char_console_ofstream_51 { void badSink(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } badSink(data); }"	where is the vulnerable dataflow from data to badSink ?	"if (dataLen > 0 && <start> data[dataLen-1] == '\n' <end> );
badSink <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
badSink <start> data <end> );"	"dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"badSink <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	1
61da66eb-6c15-11ed-81d4-94e6f77dd552	typedef union { char unionFirst; char unionSecond; } CWE190_Integer_Overflow__char_rand_square_34_unionType; void CWE190_Integer_Overflow__char_rand_square_34_bad() { char data; CWE190_Integer_Overflow__char_rand_square_34_unionType myUnion; data = ' '; data = (char)RAND32(); myUnion.unionFirst = data; { char data = myUnion.unionSecond; { char result = data * data; printHexCharLine(result); } } }	where is the vulnerable dataflow from data ?	"data = (char <start> RAND32() <end> ;
char result = <start> data * data <end> ;"	"data = (char <start> RAND32() <end> ;
char result = <start> data <end>  * data;"	"<start> printHexCharLine(result) <end> ;
char result = <start> data <end>  * data;"	"<start> printHexCharLine(result) <end> ;
data = (char <start> RAND32() <end> ;"	1
af58092a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) typedef union { int unionFirst; int unionSecond; } CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_34_unionType; void CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_34_bad() { int data; CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_34_unionType myUnion; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } myUnion.unionFirst = data; { int data = myUnion.unionSecond; { char charData = (char)data; printHexCharLine(charData); } } }"	where is the vulnerable dataflow from charData to printHexCharLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printHexCharLine(charData) <end> ;"	"printHexCharLine <start> charData <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"printHexCharLine <start> charData <end> );
data = <start> atoi(inputBuffer) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printHexCharLine <start> charData <end> );"	3
820a46a9-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_console_open_73 { void badSink(list<char *> dataList) { char * data = dataList.back(); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
void badSink(list<char *> <start> dataList <end> );"	"void badSink(list<char *> <start> dataList <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
void badSink(list<char *> <start> dataList <end> );"	1
bda4e442-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define EXECLP _execlp #else #define EXECLP execlp #endif static void badSink(char * data) { EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL); } void CWE78_OS_Command_Injection__char_listen_socket_execlp_44_bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } funcPtr(data); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECLP ?	"funcPtr <start> data <end> );
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
static void badSink(char * <start> data <end> );
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
funcPtr <start> data <end> );
static void badSink(char * <start> data <end> );
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
static void badSink(char * <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	"EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
replace = <start> strchr(data, '\n') <end> ;
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
static void badSink(char * <start> data <end> );"	1
54c581f6-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink(int data) { if(data < 0) { int result = data * 2; printIntLine(result); } } void CWE191_Integer_Underflow__int_connect_socket_multiply_44_bad() { int data; void (*funcPtr) (int) = badSink; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } funcPtr(data); }"	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  * 2;
funcPtr <start> data <end> );
static void badSink(int <start> data <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"int result = <start> data * 2 <end> ;
static void badSink(int <start> data <end> );
funcPtr <start> data <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
funcPtr <start> data <end> );
static void badSink(int <start> data <end> );
int result = <start> data <end>  * 2;"	"static void badSink(int <start> data <end> );
int result = <start> data <end>  * 2;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
funcPtr <start> data <end> );"	2
9c4551a8-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE126_Buffer_Overread__CWE129_connect_socket_17_bad() { int i,j; int data; data = -1; for(i = 0; i < 1; i++) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } for(j = 0; j < 1; j++) { { int buffer[10] = { 0 }; if (data >= 0) { printIntLine(buffer[data]); } else { printLine(""ERROR: Array index is negative""); } } } }"	where is the vulnerable dataflow from buffer[data] to printIntLine ?	"printIntLine <start> buffer[data] <end> );
recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);"	"int <start> buffer[10] = { 0 } <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"printIntLine <start> buffer[data] <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[data] <end> );"	3
74ee23d6-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" void CWE194_Unexpected_Sign_Extension__connect_socket_strncpy_15_bad() { short data; data = 0; switch(6) { case 6: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; default: printLine(""Benign, fixed string""); break; } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> printLine(dest) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"tempInt = <start> atoi(inputBuffer) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"if  <start> data < 100 <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	2
820a46b6-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_file_fopen_10 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(globalTrue) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
pFile = FOPEN <start> data <end> , ""wb+"");"	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	1
5be3a9c9-6c15-11ed-81d4-94e6f77dd552	typedef struct _CWE191_Integer_Underflow__int_fscanf_postdec_67_structType { int structFirst; } CWE191_Integer_Underflow__int_fscanf_postdec_67_structType; void CWE191_Integer_Underflow__int_fscanf_postdec_67b_badSink(CWE191_Integer_Underflow__int_fscanf_postdec_67_structType myStruct) { int data = myStruct.structFirst; { data--; int result = data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"void CWE191_Integer_Underflow__int_fscanf_postdec_67b_badSink(CWE191_Integer_Underflow__int_fscanf_postdec_67_structType <start> myStruct <end> );
int data = <start> myStruct <end> .structFirst;
<start> data <end> --;"	"<start> data <end> --;
int data = <start> myStruct <end> .structFirst;"	"int data = <start> myStruct <end> .structFirst;
<start> data <end> --;
void CWE191_Integer_Underflow__int_fscanf_postdec_67b_badSink(CWE191_Integer_Underflow__int_fscanf_postdec_67_structType <start> myStruct <end> );"	"int data = <start> myStruct <end> .structFirst;
<start> printIntLine(result) <end> ;
<start> data <end> --;"	0
a1094928-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__int_connect_socket_square_74 { void badSink(map<int, int> dataMap) { int data = dataMap[2]; { int result = data * data; printIntLine(result); } }	where is the vulnerable dataflow from result to printIntLine ?	"void badSink(map<int, int> <start> dataMap <end> );
printIntLine <start> result <end> );"	"int <start> result = data * data <end> ;
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
void badSink(map<int, int> <start> dataMap <end> );"	"<start> printIntLine(result) <end> ;
void badSink(map<int, int> <start> dataMap <end> );"	0
c26a7e5f-6c15-11ed-81d4-94e6f77dd552	#ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_console_open_81 { void CWE23_Relative_Path_Traversal__char_console_open_81_bad::action(char * data) const { { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } } }	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
void CWE23_Relative_Path_Traversal__char_console_open_81_bad::action(char * <start> data <end> ) const;"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
void CWE23_Relative_Path_Traversal__char_console_open_81_bad::action(char * <start> data <end> ) const;"	"void CWE23_Relative_Path_Traversal__char_console_open_81_bad::action(char * <start> data <end> ) const;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	3
c8600b1a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_listen_socket_open_66 { void badSink(char * dataArray[]) { char * data = dataArray[2]; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
void badSink(char * <start> dataArray <end> []);"	"void badSink(char * <start> dataArray <end> []);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"void badSink(char * <start> dataArray <end> []);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN(data, O_RDWR|O_CREAT, <start> S_IREAD|S_IWRITE <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	2
c26a7e30-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif namespace CWE23_Relative_Path_Traversal__char_console_ofstream_45 { static char * badData; static char * goodG2BData; static void badSink() { char * data = badData; { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } } void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } badData = data; badSink(); }"	where is the vulnerable dataflow from data to open ?	"char <start> dataBuffer[FILENAME_MAX] = BASEPATH <end> ;
<start> badData = data <end> ;
outputFile.open((char * <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
static char * <start> badData <end> ;"	"outputFile.open((char * <start> data <end> );
char * data = <start> badData <end> ;
static char * <start> badData <end> ;
size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
<start> badData = data <end> ;
static char * <start> badData <end> ;
char * data = <start> badData <end> ;
outputFile.open((char * <start> data <end> );"	"outputFile.open((char * <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
<start> badData = data <end> ;"	2
4b34afca-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__short_fscanf_add_82 { void CWE190_Integer_Overflow__short_fscanf_add_82_bad::action(short data) { { short result = data + 1; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
void CWE190_Integer_Overflow__short_fscanf_add_82_bad::action(short <start> data <end> );"	"void CWE190_Integer_Overflow__short_fscanf_add_82_bad::action(short <start> data <end> );
short result = <start> data <end>  + 1;"	"void CWE190_Integer_Overflow__short_fscanf_add_82_bad::action(short <start> data <end> );
short <start> result = data + 1 <end> ;"	"short result = <start> data <end>  + 1;
void CWE190_Integer_Overflow__short_fscanf_add_82_bad::action(short <start> data <end> );"	1
c39a65aa-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif static int staticFive = 5; namespace CWE23_Relative_Path_Traversal__char_environment_ofstream_07 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(staticFive==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
outputFile.open((char * <start> data <end> );"	"char <start> dataBuffer[FILENAME_MAX] = BASEPATH <end> ;
outputFile.open((char * <start> data <end> );"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
size_t dataLen = <start> strlen(data) <end> ;"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
<start> strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1) <end> ;"	0
d0b64edf-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif namespace CWE36_Absolute_Path_Traversal__char_file_ofstream_01 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
outputFile.open((char * <start> data <end> );"	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"<start> data = dataBuffer <end> ;
outputFile.open((char * <start> data <end> );"	"char <start> dataBuffer[FILENAME_MAX] = """" <end> ;
outputFile.open((char * <start> data <end> );"	0
4ec5d0ab-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__int_fscanf_postinc_63b_badSink(int * dataPtr) { int data = *dataPtr; { data++; int result = data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"void CWE190_Integer_Overflow__int_fscanf_postinc_63b_badSink(int * <start> dataPtr <end> );
int <start> result = data <end> ;"	"void CWE190_Integer_Overflow__int_fscanf_postinc_63b_badSink(int * <start> dataPtr <end> );
<start> data <end> ++;"	"void CWE190_Integer_Overflow__int_fscanf_postinc_63b_badSink(int * <start> dataPtr <end> );
<start> printIntLine(result) <end> ;"	"void CWE190_Integer_Overflow__int_fscanf_postinc_63b_badSink(int * <start> dataPtr <end> );
<start> data++ <end> ;"	1
8df421d9-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define PATH_SZ 100 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define PATH_SZ PATH_MAX #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } void CWE605_Multiple_Binds_Same_Port__basic_08_bad() { if(staticReturnsTrue()) { { char data[100] = """"; #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); #ifdef _WIN32 BOOL bOptVal = TRUE; int bOptLen = sizeof(BOOL); #else int bOptVal = 1; int bOptLen = sizeof(int); #endif do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } if (setsockopt(listenSocket, SOL_SOCKET, SO_REUSEADDR, (char*)&bOptVal, bOptLen) != 0) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, data+dataLen, (int)(100-dataLen-1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[recvResult] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif printLine(data); } } }"	where is the vulnerable dataflow from data to printLine ?	"recvResult = recv(acceptSocket, <start> data+dataLen <end> , (int)(100-dataLen-1), 0);
replace = <start> strchr(data, '\n') <end> ;"	"recvResult = recv(acceptSocket, <start> data+dataLen <end> , (int)(100-dataLen-1), 0);
printLine <start> data <end> );"	"size_t dataLen = <start> strlen(data) <end> ;
recvResult = recv(acceptSocket, <start> data+dataLen <end> , (int)(100-dataLen-1), 0);"	"<start> printLine(data) <end> ;
recvResult = recv(acceptSocket, <start> data+dataLen <end> , (int)(100-dataLen-1), 0);"	1
a830bf58-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink(int data) { { ++data; int result = data; printIntLine(result); } } void CWE190_Integer_Overflow__int_listen_socket_preinc_44_bad() { int data; void (*funcPtr) (int) = badSink; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } funcPtr(data); }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
funcPtr <start> data <end> );
printIntLine <start> result <end> );
static void badSink(int <start> data <end> );"	"funcPtr <start> data <end> );
data = <start> atoi(inputBuffer) <end> ;
static void badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
funcPtr <start> data <end> );
static void badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data = 0 <end> ;
printIntLine <start> result <end> );
funcPtr <start> data <end> );"	2
4ec5d0af-6c15-11ed-81d4-94e6f77dd552	typedef struct _CWE190_Integer_Overflow__int_fscanf_postinc_67_structType { int structFirst; } CWE190_Integer_Overflow__int_fscanf_postinc_67_structType; void CWE190_Integer_Overflow__int_fscanf_postinc_67b_badSink(CWE190_Integer_Overflow__int_fscanf_postinc_67_structType myStruct) { int data = myStruct.structFirst; { data++; int result = data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"void CWE190_Integer_Overflow__int_fscanf_postinc_67b_badSink(CWE190_Integer_Overflow__int_fscanf_postinc_67_structType <start> myStruct <end> );
<start> data <end> ++;"	"void CWE190_Integer_Overflow__int_fscanf_postinc_67b_badSink(CWE190_Integer_Overflow__int_fscanf_postinc_67_structType <start> myStruct <end> );
int data = <start> myStruct <end> .structFirst;
<start> data <end> ++;"	"<start> data <end> ++;
<start> printIntLine(result) <end> ;
void CWE190_Integer_Overflow__int_fscanf_postinc_67b_badSink(CWE190_Integer_Overflow__int_fscanf_postinc_67_structType <start> myStruct <end> );"	"<start> data <end> ++;
void CWE190_Integer_Overflow__int_fscanf_postinc_67b_badSink(CWE190_Integer_Overflow__int_fscanf_postinc_67_structType <start> myStruct <end> );
int data = <start> myStruct <end> .structFirst;"	1
951c5e6a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FULL_COMMAND ""dir "" #else #define FULL_COMMAND ""ls "" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define POPEN _popen #define PCLOSE _pclose #else #define POPEN popen #define PCLOSE pclose #endif void CWE78_OS_Command_Injection__char_connect_socket_popen_10_bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; if(globalTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { FILE *pipe; pipe = POPEN(data, ""w""); if (pipe != NULL) { PCLOSE(pipe); } } }"	where is the vulnerable dataflow from data to POPEN ?	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) *  <start> 100 - dataLen - 1 <end> ), 0);"	"size_t dataLen = <start> strlen(data) <end> ;
pipe = POPEN <start> data <end> , ""w"");"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
pipe = POPEN <start> data <end> , ""w"");"	"pipe = POPEN <start> data <end> , ""w"");
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	2
820a469e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_console_open_53 { void badSink_d(char * data) { { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"void badSink_d(char * <start> data <end> );
fileDesc = OPEN(data, O_RDWR|O_CREAT, <start> S_IREAD|S_IWRITE <end> );"	"void badSink_d(char * <start> data <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"void badSink_d(char * <start> data <end> );
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	2
a36a78e5-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; void CWE190_Integer_Overflow__int_listen_socket_add_04_bad() { int data; data = 0; if(STATIC_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(STATIC_CONST_TRUE) { { int result = data + 1; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int <start> result = data + 1 <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	3
73bc812a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" void CWE194_Unexpected_Sign_Extension__connect_socket_malloc_52c_badSink(short data) { if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }"	where is the vulnerable dataflow from data to malloc ?	"char <start> * dataBuffer = (char *)malloc(data) <end> ;
void CWE194_Unexpected_Sign_Extension__connect_socket_malloc_52c_badSink(short <start> data <end> );"	"void CWE194_Unexpected_Sign_Extension__connect_socket_malloc_52c_badSink(short <start> data <end> );
char * dataBuffer = (char *)malloc <start> data <end> );"	"char * dataBuffer = (char * <start> malloc(data) <end> ;
char * dataBuffer = (char *)malloc <start> data <end> );"	"void CWE194_Unexpected_Sign_Extension__connect_socket_malloc_52c_badSink(short <start> data <end> );
if  <start> data < 100 <end> );"	1
a23a3e25-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_multiply_17_bad() { int i,j; int data; data = 0; for(i = 0; i < 1; i++) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } for(j = 0; j < 1; j++) { if(data > 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
int <start> result = data * 2 <end> ;"	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );"	"int result = <start> data * 2 <end> ;
printIntLine <start> result <end> );"	2
7ae3a739-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_12_bad() { int data; data = -1; if(globalReturnsTrueOrFalse()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } else { data = 100-1; } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> strncpy(dest, source, data) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"printLine <start> dest <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"<start> strncpy(dest, source, data) <end> ;
printLine <start> dest <end> );"	1
761e2984-6c15-11ed-81d4-94e6f77dd552	"int CWE194_Unexpected_Sign_Extension__fgets_memmove_22_badGlobal = 0; short CWE194_Unexpected_Sign_Extension__fgets_memmove_22_badSource(short data); void CWE194_Unexpected_Sign_Extension__fgets_memmove_22_bad() { short data; data = 0; CWE194_Unexpected_Sign_Extension__fgets_memmove_22_badGlobal = 1; data = CWE194_Unexpected_Sign_Extension__fgets_memmove_22_badSource(data); { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"printLine <start> dest <end> );
data = <start> CWE194_Unexpected_Sign_Extension__fgets_memmove_22_badSource <end> (data);"	"printLine <start> dest <end> );
<start> data = CWE194_Unexpected_Sign_Extension__fgets_memmove_22_badSource(data) <end> ;"	"<start> memmove(dest, source, data) <end> ;
data = <start> CWE194_Unexpected_Sign_Extension__fgets_memmove_22_badSource <end> (data);"	"data = <start> CWE194_Unexpected_Sign_Extension__fgets_memmove_22_badSource <end> (data);
printLine <start> dest <end> );"	3
b8e2bda7-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define NEW_PATH ""%SystemRoot%\\system32"" #define PUTENV _putenv #else #define NEW_PATH ""/bin"" #define PUTENV putenv #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 void CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_41_badSink(char * data) { PUTENV(data); } void CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_41_bad() { char * data; char dataBuffer[250] = ""PATH=""; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (250 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_41_badSink(data); }"	where is the vulnerable dataflow from data to PUTENV ?	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (250 - dataLen - 1), 0);
CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_41_badSink <start> data <end> );
void CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_41_badSink(char * <start> data <end> );
PUTENV <start> data <end> );"	"CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_41_badSink <start> data <end> );
void CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_41_badSink(char * <start> data <end> );
<start> PUTENV(data) <end> ;
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (250 - dataLen - 1), 0);"	"if  <start> acceptSocket == SOCKET_ERROR <end> );
CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_41_badSink <start> data <end> );
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (250 - dataLen - 1), 0);
void CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_41_badSink(char * <start> data <end> );"	"if  <start> acceptSocket == SOCKET_ERROR <end> );
CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_41_badSink <start> data <end> );
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (250 - dataLen - 1), 0);
PUTENV <start> data <end> );"	0
a5ce1c81-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_postinc_17_bad() { int i,j; int data; data = 0; for(i = 0; i < 1; i++) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } for(j = 0; j < 1; j++) { { data++; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printIntLine(result) <end> ;"	"printIntLine <start> result <end> );
if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );"	0
d1e9da57-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 static const int STATIC_CONST_FIVE = 5; namespace CWE36_Absolute_Path_Traversal__char_listen_socket_ifstream_06 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(STATIC_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
inputFile.open((char * <start> data <end> );"	"<start> recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0) <end> ;
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
inputFile.open((char * <start> data <end> );"	"inputFile.open((char * <start> data <end> );
<start> recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0) <end> ;"	0
5133a730-6c15-11ed-81d4-94e6f77dd552	"static int64_t CWE190_Integer_Overflow__int64_t_fscanf_preinc_45_badData; static int64_t CWE190_Integer_Overflow__int64_t_fscanf_preinc_45_goodG2BData; static int64_t CWE190_Integer_Overflow__int64_t_fscanf_preinc_45_goodB2GData; static void badSink() { int64_t data = CWE190_Integer_Overflow__int64_t_fscanf_preinc_45_badData; { ++data; int64_t result = data; printLongLongLine(result); } } void CWE190_Integer_Overflow__int64_t_fscanf_preinc_45_bad() { int64_t data; data = 0LL; fscanf (stdin, ""%"" SCNd64, &data); CWE190_Integer_Overflow__int64_t_fscanf_preinc_45_badData = data; badSink(); }"	where is the vulnerable dataflow from data ?	"<start> CWE190_Integer_Overflow__int64_t_fscanf_preinc_45_badData = data <end> ;
static int64_t <start> CWE190_Integer_Overflow__int64_t_fscanf_preinc_45_badData <end> ;
fscanf (stdin, ""%"" SCNd64, <start> &data <end> );"	"int64_t data = <start> CWE190_Integer_Overflow__int64_t_fscanf_preinc_45_badData <end> ;
static int64_t <start> CWE190_Integer_Overflow__int64_t_fscanf_preinc_45_badData <end> ;
fscanf (stdin, ""%"" SCNd64, <start> &data <end> );
<start> CWE190_Integer_Overflow__int64_t_fscanf_preinc_45_badData = data <end> ;"	"fscanf (stdin, ""%"" SCNd64, <start> &data <end> );
<start> CWE190_Integer_Overflow__int64_t_fscanf_preinc_45_badData = data <end> ;"	"fscanf (stdin, ""%"" SCNd64, <start> &data <end> );
<start> CWE190_Integer_Overflow__int64_t_fscanf_preinc_45_badData = data <end> ;
static int64_t <start> CWE190_Integer_Overflow__int64_t_fscanf_preinc_45_badData <end> ;
int64_t data = <start> CWE190_Integer_Overflow__int64_t_fscanf_preinc_45_badData <end> ;
+ <start> data <end> ;"	3
abc37522-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_fgets_postdec_15_bad() { int data; data = 0; switch(6) { case 6: { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } break; default: printLine(""Benign, fixed string""); break; } switch(7) { case 7: { data--; int result = data; printIntLine(result); } break; default: printLine(""Benign, fixed string""); break; } }"	where is the vulnerable dataflow from result to printIntLine ?	"<start> printIntLine(result) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> data = atoi(inputBuffer) <end> ;"	2
761e2942-6c15-11ed-81d4-94e6f77dd552	namespace CWE194_Unexpected_Sign_Extension__fgets_malloc_74 { void badSink(map<int, short> dataMap) { short data = dataMap[2]; if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }	where is the vulnerable dataflow from data to malloc ?	"void badSink(map<int, short> <start> dataMap <end> );
<start> free(dataBuffer) <end> ;"	"void badSink(map<int, short> <start> dataMap <end> );
char * dataBuffer = (char *)malloc <start> data <end> );"	"void badSink(map<int, short> <start> dataMap <end> );
if  <start> data < 100 <end> );"	"char * dataBuffer = (char *)malloc <start> data <end> );
memset(dataBuffer, 'A', <start> data-1 <end> );"	1
a95fd825-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } void CWE191_Integer_Underflow__int_fgets_multiply_08_bad() { int data; data = 0; if(staticReturnsTrue()) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(staticReturnsTrue()) { if(data < 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
int <start> result = data * 2 <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
int result = <start> data * 2 <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );"	"char <start> inputBuffer[CHAR_ARRAY_SIZE] = """" <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	2
8df421fe-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define PATH_SZ 100 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define PATH_SZ PATH_MAX #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 static int staticFive = 5; void CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__accept_listen_bind_07_bad() { if(staticFive==5) { { char data[100] = """"; #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[recvResult] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif printLine(data); } } }"	where is the vulnerable dataflow from data to printLine ?	"size_t dataLen = <start> strlen(data) <end> ;
recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);"	"printLine <start> data <end> );
recvResult = <start> recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0) <end> ;"	"<start> printLine(data) <end> ;
recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);"	"recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);
printLine <start> data <end> );"	3
c5fc2371-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_file_open_10 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(globalTrue) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"<start> data = dataBuffer <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"size_t dataLen = <start> strlen(data) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	0
cbf2379c-6c15-11ed-81d4-94e6f77dd552	#ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_connect_socket_open_81 { void CWE36_Absolute_Path_Traversal__char_connect_socket_open_81_bad::action(char * data) const { { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } } }	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
void CWE36_Absolute_Path_Traversal__char_connect_socket_open_81_bad::action(char * <start> data <end> ) const;"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
void CWE36_Absolute_Path_Traversal__char_connect_socket_open_81_bad::action(char * <start> data <end> ) const;"	"void CWE36_Absolute_Path_Traversal__char_connect_socket_open_81_bad::action(char * <start> data <end> ) const;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	3
c26a7e6f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_environment_fopen_15 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; switch(6) { case 6: { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } break; default: printLine(""Benign, fixed string""); break; } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"char <start> dataBuffer[FILENAME_MAX] = BASEPATH <end> ;
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
strncat(data+dataLen, environment, FILENAME_MAX <start> dataLen-1 <end> );"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
pFile = FOPEN <start> data <end> , ""wb+"");"	"size_t dataLen = <start> strlen(data) <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	2
951c5ea5-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FULL_COMMAND ""dir "" #else #define FULL_COMMAND ""ls "" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define POPEN _popen #define PCLOSE _pclose #else #define POPEN popen #define PCLOSE pclose #endif void CWE78_OS_Command_Injection__char_file_popen_03_bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; if(5==5) { { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } { FILE *pipe; pipe = POPEN(data, ""w""); if (pipe != NULL) { PCLOSE(pipe); } } }"	where is the vulnerable dataflow from data to POPEN ?	"pipe = POPEN <start> data <end> , ""w"");
<start> data = data_buf <end> ;"	"pipe = POPEN <start> data <end> , ""w"");
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	"pipe = <start> POPEN(data, ""w"") <end> ;
pipe = POPEN <start> data <end> , ""w"");"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
pipe = POPEN <start> data <end> , ""w"");"	3
93ece301-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING ""hello"" void CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_10_bad() { size_t data; data = 0; if(globalTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = strtoul(inputBuffer, NULL, 0); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalTrue) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); } else { printLine(""Input is less than the length of the source string""); } } } }"	where is the vulnerable dataflow from data to malloc ?	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
myString = (char *)malloc <start> data*sizeof(char) <end> );"	"myString = (char *)malloc <start> data*sizeof(char) <end> );
if  <start> data > strlen(HELLO_STRING) <end> );"	"<start> data = 0 <end> ;
myString = (char *)malloc <start> data*sizeof(char) <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
myString = (char *)malloc <start> data*sizeof(char) <end> );"	3
964cdc20-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FULL_COMMAND ""dir "" #else #define FULL_COMMAND ""ls "" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define POPEN _popen #define PCLOSE _pclose #else #define POPEN popen #define PCLOSE pclose #endif void CWE78_OS_Command_Injection__char_listen_socket_popen_66b_badSink(char * dataArray[]) { char * data = dataArray[2]; { FILE *pipe; pipe = POPEN(data, ""w""); if (pipe != NULL) { PCLOSE(pipe); } } }"	where is the vulnerable dataflow from data to POPEN ?	"pipe = POPEN <start> data <end> , ""w"");
void CWE78_OS_Command_Injection__char_listen_socket_popen_66b_badSink(char * <start> dataArray <end> []);"	"pipe = POPEN <start> data <end> , ""w"");
char <start> * data = dataArray[2] <end> ;"	"void CWE78_OS_Command_Injection__char_listen_socket_popen_66b_badSink(char * <start> dataArray <end> []);
pipe = POPEN <start> data <end> , ""w"");"	"void CWE78_OS_Command_Injection__char_listen_socket_popen_66b_badSink(char * <start> dataArray <end> []);
pipe = <start> POPEN(data, ""w"") <end> ;"	2
bb49c575-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" namespace CWE78_OS_Command_Injection__char_connect_socket_execlp_81 { void bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } const CWE78_OS_Command_Injection__char_connect_socket_execlp_81_base& baseObject = CWE78_OS_Command_Injection__char_connect_socket_execlp_81_bad(); baseObject.action(data); }"	where is the vulnerable dataflow from data to action ?	"size_t <start> dataLen = strlen(data) <end> ;
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"baseObject.action <start> data <end> );
<start> data = dataBuffer <end> ;"	"size_t <start> dataLen = strlen(data) <end> ;
baseObject.action <start> data <end> );"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
baseObject.action <start> data <end> );"	3
8a6310dc-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_listen_socket_fopen_01 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );
pFile = FOPEN <start> data <end> , ""wb+"");"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	"replace = <start> strchr(data, '\n') <end> ;
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"pFile = FOPEN <start> data <end> , ""wb+"");
if  <start> recvResult == SOCKET_ERROR <end>  || recvResult == 0);"	1
571e9817-6c15-11ed-81d4-94e6f77dd552	void CWE191_Integer_Underflow__int_fscanf_multiply_63b_badSink(int * dataPtr) { int data = *dataPtr; if(data < 0) { int result = data * 2; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
void CWE191_Integer_Underflow__int_fscanf_multiply_63b_badSink(int * <start> dataPtr <end> );"	"int <start> result = data * 2 <end> ;
void CWE191_Integer_Underflow__int_fscanf_multiply_63b_badSink(int * <start> dataPtr <end> );"	"void CWE191_Integer_Underflow__int_fscanf_multiply_63b_badSink(int * <start> dataPtr <end> );
int result = <start> data <end>  * 2;"	"int result = <start> data <end>  * 2;
<start> printIntLine(result) <end> ;"	2
a5ce1c7e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_postinc_14_bad() { int data; data = 0; if(globalFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalFive==5) { { data++; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
data = <start> atoi(inputBuffer) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data = atoi(inputBuffer) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printIntLine(result) <end> ;"	2
7d44fc76-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_64b_badSink(void * dataVoidPtr) { int * dataPtr = (int *)dataVoidPtr; int data = (*dataPtr); { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_64b_badSink(void * <start> dataVoidPtr <end> );
printLine <start> dest <end> );"	"<start> memmove(dest, source, data) <end> ;
printLine <start> dest <end> );"	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	"int <start> data = (*dataPtr) <end> ;
void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_64b_badSink(void * <start> dataVoidPtr <end> );"	0
bda4e41d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define EXECL _execl #else #define EXECL execl #endif void CWE78_OS_Command_Injection__char_listen_socket_execl_15_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; switch(6) { case 6: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; default: printLine(""Benign, fixed string""); break; } EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECL ?	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"replace = <start> strchr(data, '\r') <end> ;
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"<start> data = dataBuffer <end> ;
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
<start> recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0) <end> ;"	0
7e74f35a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) int CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_61b_badSource(int data); void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_61_bad() { int data; data = -1; data = CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_61b_badSource(data); { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"char <start> dest[100] = """" <end> ;
printLine <start> dest <end> );"	"if  <start> data < 100 <end> );
printLine <start> dest <end> );"	"data = <start> CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_61b_badSource <end> (data);
<start> memmove(dest, source, data) <end> ;"	"data = <start> CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_61b_badSource <end> (data);
printLine <start> dest <end> );"	3
a5ce1c65-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int CWE190_Integer_Overflow__int_fgets_postinc_45_badData; static int CWE190_Integer_Overflow__int_fgets_postinc_45_goodG2BData; static int CWE190_Integer_Overflow__int_fgets_postinc_45_goodB2GData; static void badSink() { int data = CWE190_Integer_Overflow__int_fgets_postinc_45_badData; { data++; int result = data; printIntLine(result); } } void CWE190_Integer_Overflow__int_fgets_postinc_45_bad() { int data; data = 0; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } CWE190_Integer_Overflow__int_fgets_postinc_45_badData = data; badSink(); }"	where is the vulnerable dataflow from result to printIntLine ?	"int <start> data = CWE190_Integer_Overflow__int_fgets_postinc_45_badData <end> ;
<start> CWE190_Integer_Overflow__int_fgets_postinc_45_badData = data <end> ;
static int <start> CWE190_Integer_Overflow__int_fgets_postinc_45_badData <end> ;
printIntLine <start> result <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"static int <start> CWE190_Integer_Overflow__int_fgets_postinc_45_badData <end> ;
printIntLine <start> result <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> CWE190_Integer_Overflow__int_fgets_postinc_45_badData = data <end> ;
int data = <start> CWE190_Integer_Overflow__int_fgets_postinc_45_badData <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> CWE190_Integer_Overflow__int_fgets_postinc_45_badData = data <end> ;
static int <start> CWE190_Integer_Overflow__int_fgets_postinc_45_badData <end> ;
int data = <start> CWE190_Integer_Overflow__int_fgets_postinc_45_badData <end> ;
printIntLine <start> result <end> );"	"int data = <start> CWE190_Integer_Overflow__int_fgets_postinc_45_badData <end> ;
<start> CWE190_Integer_Overflow__int_fgets_postinc_45_badData = data <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> printIntLine(result) <end> ;
static int <start> CWE190_Integer_Overflow__int_fgets_postinc_45_badData <end> ;"	2
55ef4cda-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_fgets_sub_51b_badSink(int data) { { int result = data - 1; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  - 1;
void CWE191_Integer_Underflow__int_fgets_sub_51b_badSink(int <start> data <end> );"	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  - 1;"	"void CWE191_Integer_Underflow__int_fgets_sub_51b_badSink(int <start> data <end> );
int result = <start> data <end>  - 1;"	"void CWE191_Integer_Underflow__int_fgets_sub_51b_badSink(int <start> data <end> );
<start> printIntLine(result) <end> ;"	2
73bc812c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" void CWE194_Unexpected_Sign_Extension__connect_socket_malloc_54e_badSink(short data) { if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }"	where is the vulnerable dataflow from data to malloc ?	"void CWE194_Unexpected_Sign_Extension__connect_socket_malloc_54e_badSink(short <start> data <end> );
if  <start> dataBuffer == NULL <end> ) {exit(-1);};"	"<start> memset(dataBuffer, 'A', data-1) <end> ;
char * dataBuffer = (char *)malloc <start> data <end> );"	"void CWE194_Unexpected_Sign_Extension__connect_socket_malloc_54e_badSink(short <start> data <end> );
char * dataBuffer = (char *)malloc <start> data <end> );"	"char * dataBuffer = (char *)malloc <start> data <end> );
<start> free(dataBuffer) <end> ;"	2
55ef4c8c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_connect_socket_sub_65b_badSink(int data) { { int result = data - 1; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  - 1;
<start> printIntLine(result) <end> ;"	"void CWE191_Integer_Underflow__int_connect_socket_sub_65b_badSink(int <start> data <end> );
int result = <start> data <end>  - 1;"	"void CWE191_Integer_Underflow__int_connect_socket_sub_65b_badSink(int <start> data <end> );
int <start> result = data - 1 <end> ;"	"int result = <start> data <end>  - 1;
void CWE191_Integer_Underflow__int_connect_socket_sub_65b_badSink(int <start> data <end> );"	1
761e2958-6c15-11ed-81d4-94e6f77dd552	"int CWE194_Unexpected_Sign_Extension__fgets_memcpy_22_badGlobal = 0; short CWE194_Unexpected_Sign_Extension__fgets_memcpy_22_badSource(short data); void CWE194_Unexpected_Sign_Extension__fgets_memcpy_22_bad() { short data; data = 0; CWE194_Unexpected_Sign_Extension__fgets_memcpy_22_badGlobal = 1; data = CWE194_Unexpected_Sign_Extension__fgets_memcpy_22_badSource(data); { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> memcpy(dest, source, data) <end> ;
printLine <start> dest <end> );"	"<start> memcpy(dest, source, data) <end> ;
data = <start> CWE194_Unexpected_Sign_Extension__fgets_memcpy_22_badSource <end> (data);"	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	"data = <start> CWE194_Unexpected_Sign_Extension__fgets_memcpy_22_badSource <end> (data);
printLine <start> dest <end> );"	3
656cd40e-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__int_rand_square_10_bad() { int data; data = 0; if(globalTrue) { data = RAND32(); } if(globalTrue) { { int result = data * data; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
data = <start> RAND32() <end> ;"	"int result = <start> data <end>  * data;
data = <start> RAND32() <end> ;"	"int <start> result = data * data <end> ;
data = <start> RAND32() <end> ;"	"data = <start> RAND32() <end> ;
int result = <start> data <end>  * data;"	3
60db838e-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__char_rand_add_02_bad() { char data; data = ' '; if(1) { data = (char)RAND32(); } if(1) { { char result = data + 1; printHexCharLine(result); } } }	where is the vulnerable dataflow from data ?	"char result = <start> data + 1 <end> ;
data = (char <start> RAND32() <end> ;"	"<start> printHexCharLine(result) <end> ;
char result = <start> data <end>  + 1;"	"data = (char <start> RAND32() <end> ;
<start> printHexCharLine(result) <end> ;"	"data = (char <start> RAND32() <end> ;
char result = <start> data <end>  + 1;"	3
525b6455-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; void CWE190_Integer_Overflow__int_listen_socket_preinc_04_bad() { int data; data = 0; if(STATIC_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(STATIC_CONST_TRUE) { { ++data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
+ <start> data <end> ;"	"+ <start> data <end> ;
int <start> result = data <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );"	"<start> data = atoi(inputBuffer) <end> ;
+ <start> data <end> ;"	0
d31a24eb-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 namespace CWE36_Absolute_Path_Traversal__char_listen_socket_ifstream_51 { void badSink(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badSink(data); }"	where is the vulnerable dataflow from data to badSink ?	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
badSink <start> data <end> );"	"<start> badSink(data) <end> ;
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"replace = <start> strchr(data, '\n') <end> ;
badSink <start> data <end> );"	"badSink <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	0
466e7f12-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_square_51b_badSink(int data) { { int result = data * data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
void CWE190_Integer_Overflow__int_fgets_square_51b_badSink(int <start> data <end> );"	"void CWE190_Integer_Overflow__int_fgets_square_51b_badSink(int <start> data <end> );
int result = <start> data * data <end> ;"	"void CWE190_Integer_Overflow__int_fgets_square_51b_badSink(int <start> data <end> );
int result = <start> data <end>  * data;"	"int result = <start> data <end>  * data;
void CWE190_Integer_Overflow__int_fgets_square_51b_badSink(int <start> data <end> );"	2
c99197cb-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define STAT _stat #define OPEN _open #define WRITE _write #define O_RDWR _O_RDWR #define CLOSE _close #else #define STAT stat #define OPEN open #define WRITE write #define CLOSE close #endif #define BAD_SINK_STRING ""Bad Sink..."" #define GOOD_SINK_STRING ""Good Sink..."" static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } void CWE367_TOC_TOU__stat_08_bad() { if(staticReturnsTrue()) { { char filename[100] = """"; struct STAT statBuffer; int fileDesc = -1; if (fgets(filename, 100, stdin) == NULL) { printLine(""fgets() failed""); filename[0] = '\0'; } if (strlen(filename) > 0) { filename[strlen(filename)-1] = '\0'; } if (STAT(filename, &statBuffer) == -1) { exit(1); } fileDesc  = OPEN(filename, O_RDWR); if (fileDesc == -1) { exit(1); } if (WRITE(fileDesc, BAD_SINK_STRING, strlen(BAD_SINK_STRING)) == -1) { exit(1); } if (fileDesc != -1) { CLOSE(fileDesc); } } } }"	where is the vulnerable dataflow from filename to OPEN ?	"fileDesc  = OPEN <start> filename <end> , O_RDWR);
fileDesc  = <start> OPEN(filename, O_RDWR) <end> ;"	"if (fgets <start> filename <end> , 100, stdin) == NULL);
fileDesc  = OPEN <start> filename <end> , O_RDWR);"	"fileDesc  = OPEN <start> filename <end> , O_RDWR);
if (fgets <start> filename <end> , 100, stdin) == NULL);"	"if  <start> strlen(filename) <end>  > 0);
fileDesc  = OPEN <start> filename <end> , O_RDWR);"	1
af580960-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE197_Numeric_Truncation_Error__int_connect_socket_to_short_53d_badSink(int data) { { short shortData = (short)data; printShortLine(shortData); } }"	where is the vulnerable dataflow from shortData to printShortLine ?	"void CWE197_Numeric_Truncation_Error__int_connect_socket_to_short_53d_badSink(int <start> data <end> );
printShortLine <start> shortData <end> );"	"short <start> shortData = (short)data <end> ;
printShortLine <start> shortData <end> );"	"void CWE197_Numeric_Truncation_Error__int_connect_socket_to_short_53d_badSink(int <start> data <end> );
<start> printShortLine(shortData) <end> ;"	"printShortLine <start> shortData <end> );
void CWE197_Numeric_Truncation_Error__int_connect_socket_to_short_53d_badSink(int <start> data <end> );"	0
648a9bfa-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__int_rand_add_01_bad() { int data; data = 0; data = RAND32(); { int result = data + 1; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
data = <start> RAND32() <end> ;"	"data = <start> RAND32() <end> ;
int result = <start> data <end>  + 1;"	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  + 1;"	"int result = <start> data <end>  + 1;
data = <start> RAND32() <end> ;"	1
c4cd6f53-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_environment_open_66 { void badSink(char * dataArray[]) { char * data = dataArray[2]; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);"	"void badSink(char * <start> dataArray <end> []);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
void badSink(char * <start> dataArray <end> []);"	1
466e7edb-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_multiply_15_bad() { int data; data = 0; switch(6) { case 6: { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } break; default: printLine(""Benign, fixed string""); break; } switch(7) { case 7: if(data > 0) { int result = data * 2; printIntLine(result); } break; default: printLine(""Benign, fixed string""); break; } }"	where is the vulnerable dataflow from data ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
if  <start> fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) <end>  != NULL);"	"int result = <start> data <end>  * 2;
if  <start> fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) <end>  != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
int result = <start> data <end>  * 2;"	"<start> printIntLine(result) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	2
5be3a9ef-6c15-11ed-81d4-94e6f77dd552	"void CWE191_Integer_Underflow__short_fscanf_postdec_02_bad() { short data; data = 0; if(1) { fscanf (stdin, ""%hd"", &data); } if(1) { { data--; short result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"fscanf (stdin, ""%hd"", <start> &data <end> );
<start> printIntLine(result) <end> ;"	"<start> printIntLine(result) <end> ;
<start> data <end> --;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
<start> data <end> --;"	"<start> data <end> --;
fscanf (stdin, ""%hd"", <start> &data <end> );"	2
54c581fe-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_connect_socket_multiply_63b_badSink(int * dataPtr) { int data = *dataPtr; if(data < 0) { int result = data * 2; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  * 2;
if <start> data < 0 <end> ) ;"	"void CWE191_Integer_Underflow__int_connect_socket_multiply_63b_badSink(int * <start> dataPtr <end> );
int result = <start> data <end>  * 2;"	"int result = <start> data <end>  * 2;
void CWE191_Integer_Underflow__int_connect_socket_multiply_63b_badSink(int * <start> dataPtr <end> );"	"<start> printIntLine(result) <end> ;
void CWE191_Integer_Underflow__int_connect_socket_multiply_63b_badSink(int * <start> dataPtr <end> );"	1
73bc8158-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" void CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_54e_badSink(short data) { { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"void CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_54e_badSink(short <start> data <end> );
printLine <start> dest <end> );"	"printLine <start> dest <end> );
<start> memcpy(dest, source, data) <end> ;"	"void CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_54e_badSink(short <start> data <end> );
<start> memcpy(dest, source, data) <end> ;"	"printLine <start> dest <end> );
void CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_54e_badSink(short <start> data <end> );"	0
93ece2c3-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING ""hello"" void CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_54e_badSink(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); } else { printLine(""Input is less than the length of the source string""); } } }"	where is the vulnerable dataflow from data to malloc ?	"if  <start> data > strlen(HELLO_STRING) <end> );
myString = (char *)malloc <start> data*sizeof(char) <end> );"	"void CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_54e_badSink(size_t <start> data <end> );
myString = (char *)malloc <start> data*sizeof(char) <end> );"	"myString = (char *)malloc <start> data*sizeof(char) <end> );
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_54e_badSink(size_t <start> data <end> );"	"if  <start> myString == NULL <end> ) {exit(-1);};
myString = (char *)malloc <start> data*sizeof(char) <end> );"	1
a10948ee-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int CWE190_Integer_Overflow__int_connect_socket_multiply_45_badData; static int CWE190_Integer_Overflow__int_connect_socket_multiply_45_goodG2BData; static int CWE190_Integer_Overflow__int_connect_socket_multiply_45_goodB2GData; static void badSink() { int data = CWE190_Integer_Overflow__int_connect_socket_multiply_45_badData; if(data > 0) { int result = data * 2; printIntLine(result); } } void CWE190_Integer_Overflow__int_connect_socket_multiply_45_bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE190_Integer_Overflow__int_connect_socket_multiply_45_badData = data; badSink(); }"	where is the vulnerable dataflow from result to printIntLine ?	"int <start> result = data * 2 <end> ;
static int <start> CWE190_Integer_Overflow__int_connect_socket_multiply_45_badData <end> ;
int data = <start> CWE190_Integer_Overflow__int_connect_socket_multiply_45_badData <end> ;
printIntLine <start> result <end> );
<start> CWE190_Integer_Overflow__int_connect_socket_multiply_45_badData = data <end> ;"	"printIntLine <start> result <end> );
<start> CWE190_Integer_Overflow__int_connect_socket_multiply_45_badData = data <end> ;
int data = <start> CWE190_Integer_Overflow__int_connect_socket_multiply_45_badData <end> ;
static int <start> CWE190_Integer_Overflow__int_connect_socket_multiply_45_badData <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
static int <start> CWE190_Integer_Overflow__int_connect_socket_multiply_45_badData <end> ;
printIntLine <start> result <end> );
int data = <start> CWE190_Integer_Overflow__int_connect_socket_multiply_45_badData <end> ;
<start> CWE190_Integer_Overflow__int_connect_socket_multiply_45_badData = data <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> CWE190_Integer_Overflow__int_connect_socket_multiply_45_badData = data <end> ;
static int <start> CWE190_Integer_Overflow__int_connect_socket_multiply_45_badData <end> ;
int data = <start> CWE190_Integer_Overflow__int_connect_socket_multiply_45_badData <end> ;
printIntLine <start> result <end> );"	3
d0b64ec5-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif static const int STATIC_CONST_FIVE = 5; namespace CWE36_Absolute_Path_Traversal__char_file_ifstream_06 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(STATIC_CONST_FIVE==5) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
size_t dataLen = <start> strlen(data) <end> ;"	"inputFile.open((char * <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"inputFile.open((char * <start> data <end> );
<start> data = dataBuffer <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
inputFile.open((char * <start> data <end> );"	3
820a46d5-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; namespace CWE23_Relative_Path_Traversal__char_file_open_04 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(STATIC_CONST_TRUE) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
size_t dataLen = <start> strlen(data) <end> ;"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	2
9c45519b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; void CWE126_Buffer_Overread__CWE129_connect_socket_04_bad() { int data; data = -1; if(STATIC_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(STATIC_CONST_TRUE) { { int buffer[10] = { 0 }; if (data >= 0) { printIntLine(buffer[data]); } else { printLine(""ERROR: Array index is negative""); } } } }"	where is the vulnerable dataflow from buffer[data] to printIntLine ?	"printIntLine <start> buffer[data] <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"printIntLine <start> buffer[data] <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[data] <end> );"	"int <start> buffer[10] = { 0 } <end> ;
printIntLine <start> buffer[data] <end> );"	2
d31a251f-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_listen_socket_open_17 { void bad() { int i; char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; for(i = 0; i < 1; i++) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
char <start> dataBuffer[FILENAME_MAX] = """" <end> ;"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"size_t dataLen = <start> strlen(data) <end> ;
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	2
cd228173-6c15-11ed-81d4-94e6f77dd552	#ifndef _WIN32 #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_console_open_64 { void badSink(void * dataVoidPtr) { char * * dataPtr = (char * *)dataVoidPtr; char * data = (*dataPtr); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"void badSink(void * <start> dataVoidPtr <end> );
fileDesc = OPEN(data, O_RDWR|O_CREAT, <start> S_IREAD|S_IWRITE <end> );"	"void badSink(void * <start> dataVoidPtr <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = OPEN(data, O_RDWR|O_CREAT, <start> S_IREAD|S_IWRITE <end> );"	2
8df4221a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define PATH_SZ 100 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define PATH_SZ PATH_MAX #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 void CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__bind_accept_listen_17_bad() { int j; for(j = 0; j < 1; j++) { { char data[100] = """"; #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[recvResult] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif printLine(data); } } }"	where is the vulnerable dataflow from data to printLine ?	"char <start> data[100] = """" <end> ;
printLine <start> data <end> );"	"size_t dataLen = <start> strlen(data) <end> ;
recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);"	"printLine <start> data <end> );
if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );"	"recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);
printLine <start> data <end> );"	3
b2ea8def-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 8 void CWE197_Numeric_Truncation_Error__short_listen_socket_17_bad() { int i; short data; data = -1; for(i = 0; i < 1; i++) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = (short)atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { char charData = (char)data; printHexCharLine(charData); } }"	where is the vulnerable dataflow from charData to printHexCharLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printHexCharLine <start> charData <end> );"	"<start> data = (short)atoi(inputBuffer) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"char charData = <start> (char)data <end> ;
printHexCharLine <start> charData <end> );"	"printHexCharLine <start> charData <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	0
b2ea8ddd-6c15-11ed-81d4-94e6f77dd552	namespace CWE197_Numeric_Truncation_Error__short_fgets_81 { void CWE197_Numeric_Truncation_Error__short_fgets_81_bad::action(short data) const { { char charData = (char)data; printHexCharLine(charData); } } }	where is the vulnerable dataflow from charData to printHexCharLine ?	"char charData = <start> (char)data <end> ;
void CWE197_Numeric_Truncation_Error__short_fgets_81_bad::action(short <start> data <end> ) const;"	"<start> printHexCharLine(charData) <end> ;
void CWE197_Numeric_Truncation_Error__short_fgets_81_bad::action(short <start> data <end> ) const;"	"void CWE197_Numeric_Truncation_Error__short_fgets_81_bad::action(short <start> data <end> ) const;
printHexCharLine <start> charData <end> );"	"char <start> charData = (char)data <end> ;
void CWE197_Numeric_Truncation_Error__short_fgets_81_bad::action(short <start> data <end> ) const;"	2
78800f9a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 8 void CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_64b_badSink(void * dataVoidPtr) { short * dataPtr = (short *)dataVoidPtr; short data = (*dataPtr); { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"if  <start> data < 100 <end> );
void CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_64b_badSink(void * <start> dataVoidPtr <end> );"	"void CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_64b_badSink(void * <start> dataVoidPtr <end> );
printLine <start> dest <end> );"	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	"printLine <start> dest <end> );
void CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_64b_badSink(void * <start> dataVoidPtr <end> );"	1
ae26ae58-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_82 { void bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_82_base* baseObject = new CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_82_bad; baseObject->action(data); delete baseObject; }"	where is the vulnerable dataflow from data to action ?	"baseObject->action <start> data <end> );
data = <start> atoi(inputBuffer) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
baseObject->action <start> data <end> );"	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
baseObject->action <start> data <end> );"	"data = <start> atoi(inputBuffer) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	1
598370d9-6c15-11ed-81d4-94e6f77dd552	void CWE191_Integer_Underflow__short_fscanf_sub_66b_badSink(short dataArray[]) { short data = dataArray[2]; { short result = data - 1; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"void CWE191_Integer_Underflow__short_fscanf_sub_66b_badSink(short <start> dataArray <end> []);
short result = <start> data <end>  - 1;"	"void CWE191_Integer_Underflow__short_fscanf_sub_66b_badSink(short <start> dataArray <end> []);
<start> printIntLine(result) <end> ;"	"short result = <start> data <end>  - 1;
void CWE191_Integer_Underflow__short_fscanf_sub_66b_badSink(short <start> dataArray <end> []);"	"void CWE191_Integer_Underflow__short_fscanf_sub_66b_badSink(short <start> dataArray <end> []);
short result = <start> data - 1 <end> ;"	0
820a46eb-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_file_open_44 { static void badSink(char * data) { { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } } void bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } funcPtr(data); }"	where is the vulnerable dataflow from data to OPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
<start> funcPtr(data) <end> ;
static void badSink(char * <start> data <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"size_t dataLen = <start> strlen(data) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
static void badSink(char * <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
funcPtr <start> data <end> );
static void badSink(char * <start> data <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
static void badSink(char * <start> data <end> );
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	2
ae26ae62-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_82 { void bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_82_base* baseObject = new CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_82_bad; baseObject->action(data); delete baseObject; }"	where is the vulnerable dataflow from data to action ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
data = <start> atoi(inputBuffer) <end> ;"	"if  <start> listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"if  <start> listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR <end> );
baseObject->action <start> data <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
baseObject->action <start> data <end> );"	3
7e74f33e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_04_bad() { int data; data = -1; if(STATIC_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"printLine <start> dest <end> );
<start> printLine(dest) <end> ;"	"if  <start> data < 100 <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"<start> memmove(dest, source, data) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	0
79b2755a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) typedef union { int unionFirst; int unionSecond; } CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_34_unionType; void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_34_bad() { int data; CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_34_unionType myUnion; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } myUnion.unionFirst = data; { int data = myUnion.unionSecond; { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } } }"	where is the vulnerable dataflow from dest to printLine ?	"data = <start> atoi(inputBuffer) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"<start> printLine(dest) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> memcpy(dest, source, data) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	3
73bc8136-6c15-11ed-81d4-94e6f77dd552	namespace CWE194_Unexpected_Sign_Extension__connect_socket_malloc_73 { void badSink(list<short> dataList) { short data = dataList.back(); if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }	where is the vulnerable dataflow from data to malloc ?	"void badSink(list<short> <start> dataList <end> );
char * dataBuffer = (char *)malloc <start> data <end> );"	"char * dataBuffer = (char *)malloc <start> data <end> );
if  <start> dataBuffer == NULL <end> ) {exit(-1);};"	"memset(dataBuffer, 'A', <start> data-1 <end> );
char * dataBuffer = (char *)malloc <start> data <end> );"	"char * dataBuffer = (char * <start> malloc(data) <end> ;
void badSink(list<short> <start> dataList <end> );"	0
9d745382-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink(int data) { { int buffer[10] = { 0 }; if (data >= 0) { printIntLine(buffer[data]); } else { printLine(""ERROR: Array index is negative""); } } } void CWE126_Buffer_Overread__CWE129_listen_socket_44_bad() { int data; void (*funcPtr) (int) = badSink; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } funcPtr(data); }"	where is the vulnerable dataflow from buffer[data] to printIntLine ?	"if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );
funcPtr <start> data <end> );
static void badSink(int <start> data <end> );
printIntLine <start> buffer[data] <end> );"	"funcPtr <start> data <end> );
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> buffer[data] <end> );
static void badSink(int <start> data <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
funcPtr <start> data <end> );
static void badSink(int <start> data <end> );
printIntLine <start> buffer[data] <end> );"	"printIntLine <start> buffer[data] <end> );
funcPtr <start> data <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static void badSink(int <start> data <end> );"	2
9d74537b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE126_Buffer_Overread__CWE129_listen_socket_18_bad() { int data; data = -1; goto source; source: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } goto sink; sink: { int buffer[10] = { 0 }; if (data >= 0) { printIntLine(buffer[data]); } else { printLine(""ERROR: Array index is negative""); } } }"	where is the vulnerable dataflow from buffer[data] to printIntLine ?	"printIntLine <start> buffer[data] <end> );
int <start> buffer[10] = { 0 } <end> ;"	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> buffer[data] <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[data] <end> );"	"data = <start> atoi(inputBuffer) <end> ;
printIntLine <start> buffer[data] <end> );"	2
820a46c8-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_file_fopen_61 { char * badSource(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; data = badSource(data); { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"data = <start> badSource <end> (data);
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
data = <start> badSource <end> (data);"	"pFile = FOPEN <start> data <end> , ""wb+"");
<start> data = badSource(data) <end> ;"	"pFile = FOPEN <start> data <end> , ""wb+"");
char <start> dataBuffer[FILENAME_MAX] = BASEPATH <end> ;"	0
453db04a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink(int data) { { int result = data * data; printIntLine(result); } } void CWE190_Integer_Overflow__int_connect_socket_square_44_bad() { int data; void (*funcPtr) (int) = badSink; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } funcPtr(data); }"	where is the vulnerable dataflow from data ?	"funcPtr <start> data <end> );
<start> data = atoi(inputBuffer) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static void badSink(int <start> data <end> );"	"data = <start> atoi(inputBuffer) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static void badSink(int <start> data <end> );
funcPtr <start> data <end> );"	"int result = <start> data <end>  * data;
recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);
static void badSink(int <start> data <end> );
funcPtr <start> data <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
funcPtr <start> data <end> );
static void badSink(int <start> data <end> );
int result = <start> data <end>  * data;"	3
4ec5d0c2-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int badStatic = 0; static void badSink(int data) { if(badStatic) { { data++; int result = data; printIntLine(result); } } } void CWE190_Integer_Overflow__int_listen_socket_postinc_21_bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badStatic = 1; badSink(data); }"	where is the vulnerable dataflow from data ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSink <start> data <end> );
static void badSink(int <start> data <end> );
<start> data <end> ++;"	"static void badSink(int <start> data <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data <end> ++;
<start> printIntLine(result) <end> ;"	"<start> data <end> ++;
badSink <start> data <end> );
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
static void badSink(int <start> data <end> );"	"if  <start> listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR <end> );
badSink <start> data <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static void badSink(int <start> data <end> );"	0
c5fc234c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; namespace CWE23_Relative_Path_Traversal__char_file_ofstream_04 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(STATIC_CONST_TRUE) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
outputFile.open((char * <start> data <end> );"	"size_t dataLen = <start> strlen(data) <end> ;
outputFile.open((char * <start> data <end> );"	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"outputFile.open((char * <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	0
466e7ee5-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink(int data) { if(data > 0) { int result = data * 2; printIntLine(result); } } void CWE190_Integer_Overflow__int_fgets_multiply_44_bad() { int data; void (*funcPtr) (int) = badSink; data = 0; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } funcPtr(data); }"	where is the vulnerable dataflow from data ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
funcPtr <start> data <end> );
int result = <start> data * 2 <end> ;
static void badSink(int <start> data <end> );"	"<start> funcPtr(data) <end> ;
static void badSink(int <start> data <end> );
int result = <start> data <end>  * 2;
funcPtr <start> data <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
funcPtr <start> data <end> );
static void badSink(int <start> data <end> );
int result = <start> data <end>  * 2;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
int result = <start> data <end>  * 2;
funcPtr <start> data <end> );
static void badSink(int <start> data <end> );"	2
c72d5d40-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_file_open_65 { void badSink(char * data); void bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } funcPtr(data); }"	where is the vulnerable dataflow from data to funcPtr ?	"funcPtr <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"size_t dataLen = <start> strlen(data) <end> ;
funcPtr <start> data <end> );"	"funcPtr <start> data <end> );
<start> funcPtr(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
funcPtr <start> data <end> );"	3
656cd3dc-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__int_rand_multiply_03_bad() { int data; data = 0; if(5==5) { data = RAND32(); } if(5==5) { if(data > 0) { int result = data * 2; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  * 2;"	"data = <start> RAND32() <end> ;
int result = <start> data <end>  * 2;"	"int result = <start> data <end>  * 2;
<start> data = 0 <end> ;"	"int result = <start> data <end>  * 2;
data = <start> RAND32() <end> ;"	1
69161b3f-6c15-11ed-81d4-94e6f77dd552	static void badSink(int data) { { ++data; int result = data; printIntLine(result); } } void CWE190_Integer_Overflow__int_rand_preinc_44_bad() { int data; void (*funcPtr) (int) = badSink; data = 0; data = RAND32(); funcPtr(data); }	where is the vulnerable dataflow from data ?	"static void badSink(int <start> data <end> );
funcPtr <start> data <end> );
+ <start> data <end> ;
data = <start> RAND32() <end> ;"	"static void badSink(int <start> data <end> );
+ <start> data <end> ;
<start> data = RAND32() <end> ;
funcPtr <start> data <end> );"	"static void badSink(int <start> data <end> );
funcPtr <start> data <end> );
data = <start> RAND32() <end> ;"	"data = <start> RAND32() <end> ;
funcPtr <start> data <end> );
static void badSink(int <start> data <end> );
+ <start> data <end> ;"	3
774f5801-6c15-11ed-81d4-94e6f77dd552	"namespace CWE194_Unexpected_Sign_Extension__fgets_strncpy_72 { void badSink(vector<short> dataVector) { short data = dataVector[2]; { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"void badSink(vector<short> <start> dataVector <end> );
short <start> data = dataVector[2] <end> ;"	"void badSink(vector<short> <start> dataVector <end> );
printLine <start> dest <end> );"	"<start> printLine(dest) <end> ;
void badSink(vector<short> <start> dataVector <end> );"	"printLine <start> dest <end> );
<start> printLine(dest) <end> ;"	1
af58095e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE197_Numeric_Truncation_Error__int_connect_socket_to_short_51b_badSink(int data) { { short shortData = (short)data; printShortLine(shortData); } }"	where is the vulnerable dataflow from shortData to printShortLine ?	"printShortLine <start> shortData <end> );
void CWE197_Numeric_Truncation_Error__int_connect_socket_to_short_51b_badSink(int <start> data <end> );"	"<start> printShortLine(shortData) <end> ;
void CWE197_Numeric_Truncation_Error__int_connect_socket_to_short_51b_badSink(int <start> data <end> );"	"printShortLine <start> shortData <end> );
<start> printShortLine(shortData) <end> ;"	"void CWE197_Numeric_Truncation_Error__int_connect_socket_to_short_51b_badSink(int <start> data <end> );
printShortLine <start> shortData <end> );"	3
6dc614fa-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" void CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_65b_badVaSink(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); va_end(args); } }"	where is the vulnerable dataflow from data to vprintf ?	"vprintf <start> data <end> , args);
void CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_65b_badVaSink(char * <start> data <end> , ...);"	"vprintf <start> data <end> , args);
<start> va_start(args, data) <end> ;"	"void CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_65b_badVaSink(char * <start> data <end> , ...);
vprintf <start> data <end> , args);"	"void CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_65b_badVaSink(char * <start> data <end> , ...);
<start> vprintf(data, args) <end> ;"	2
761e2972-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 8 void CWE194_Unexpected_Sign_Extension__fgets_memmove_02_bad() { short data; data = 0; if(1) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = (short)atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"printLine <start> dest <end> );
if  <start> data < 100 <end> );"	"printLine <start> dest <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> data = (short)atoi(inputBuffer) <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printLine <start> dest <end> );"	3
4ff78270-6c15-11ed-81d4-94e6f77dd552	"void CWE190_Integer_Overflow__short_fscanf_postinc_17_bad() { int i,j; short data; data = 0; for(i = 0; i < 1; i++) { fscanf (stdin, ""%hd"", &data); } for(j = 0; j < 1; j++) { { data++; short result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"fscanf (stdin, ""%hd"", <start> &data <end> );
<start> data <end> ++;"	"<start> data <end> ++;
fscanf (stdin, ""%hd"", <start> &data <end> );"	"short <start> result = data <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );"	"<start> data <end> ++;
<start> printIntLine(result) <end> ;"	0
4b34afcb-6c15-11ed-81d4-94e6f77dd552	"void CWE190_Integer_Overflow__short_fscanf_multiply_01_bad() { short data; data = 0; fscanf (stdin, ""%hd"", &data); if(data > 0) { short result = data * 2; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"fscanf (stdin, ""%hd"", <start> &data <end> );
<start> printIntLine(result) <end> ;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
short result = <start> data <end>  * 2;"	"short result = <start> data <end>  * 2;
<start> printIntLine(result) <end> ;"	"short <start> result = data * 2 <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );"	1
48d25dc4-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__int_listen_socket_add_81 { void CWE190_Integer_Overflow__int_listen_socket_add_81_bad::action(int data) const { { int result = data + 1; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  + 1;
void CWE190_Integer_Overflow__int_listen_socket_add_81_bad::action(int <start> data <end> ) const;"	"int result = <start> data <end>  + 1;
<start> printIntLine(result) <end> ;"	"void CWE190_Integer_Overflow__int_listen_socket_add_81_bad::action(int <start> data <end> ) const;
int result = <start> data <end>  + 1;"	"<start> printIntLine(result) <end> ;
void CWE190_Integer_Overflow__int_listen_socket_add_81_bad::action(int <start> data <end> ) const;"	2
833ac94e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_listen_socket_open_65 { void badSink(char * data) { { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"void badSink(char * <start> data <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
void badSink(char * <start> data <end> );"	2
93ece2d9-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING ""hello"" void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_11_bad() { size_t data; data = 0; if(globalReturnsTrue()) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = strtoul(inputBuffer, NULL, 0); } else { printLine(""fgets() failed.""); } } } if(globalReturnsTrue()) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); } else { printLine(""Input is less than the length of the source string""); } } } }"	where is the vulnerable dataflow from data to malloc ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> myString = (char *)malloc(data*sizeof(char)) <end> ;"	"if  <start> data > strlen(HELLO_STRING) <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
myString = (char *)malloc <start> data*sizeof(char) <end> );"	"myString = (char * <start> malloc(data*sizeof(char)) <end> ;
myString = (char *)malloc <start> data*sizeof(char) <end> );"	2
c99197d6-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_connect_socket_fopen_01 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
char <start> dataBuffer[FILENAME_MAX] = """" <end> ;"	"pFile = FOPEN <start> data <end> , ""wb+"");
recvResult = <start> recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0) <end> ;"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
<start> data = dataBuffer <end> ;"	0
abc37521-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_fgets_postdec_14_bad() { int data; data = 0; if(globalFive==5) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(globalFive==5) { { data--; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> data = atoi(inputBuffer) <end> ;"	"<start> printIntLine(result) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"printIntLine <start> result <end> );
<start> data = atoi(inputBuffer) <end> ;"	0
cf8750cb-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_file_fopen_67 { typedef struct _structType { char * structFirst; } structType; void badSink(structType myStruct) { char * data = myStruct.structFirst; { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = FOPEN <start> data <end> , ""wb+"");
void badSink(structType <start> myStruct <end> );
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	"pFile = FOPEN <start> data <end> , ""wb+"");
void badSink(structType <start> myStruct <end> );"	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
char * data = <start> myStruct <end> .structFirst;
pFile = FOPEN <start> data <end> , ""wb+"");"	"void badSink(structType <start> myStruct <end> );
char * data = <start> myStruct <end> .structFirst;
pFile = FOPEN <start> data <end> , ""wb+"");"	3
60db83d7-6c15-11ed-81d4-94e6f77dd552	extern char CWE190_Integer_Overflow__char_rand_multiply_68_badData; extern char CWE190_Integer_Overflow__char_rand_multiply_68_goodG2BData; extern char CWE190_Integer_Overflow__char_rand_multiply_68_goodB2GData; void CWE190_Integer_Overflow__char_rand_multiply_68b_badSink() { char data = CWE190_Integer_Overflow__char_rand_multiply_68_badData; if(data > 0) { char result = data * 2; printHexCharLine(result); } }	where is the vulnerable dataflow from data ?	"char data = <start> CWE190_Integer_Overflow__char_rand_multiply_68_badData <end> ;
char result = <start> data <end>  * 2;"	"char result = <start> data * 2 <end> ;
char data = <start> CWE190_Integer_Overflow__char_rand_multiply_68_badData <end> ;"	"<start> printHexCharLine(result) <end> ;
char data = <start> CWE190_Integer_Overflow__char_rand_multiply_68_badData <end> ;"	"char result = <start> data <end>  * 2;
char data = <start> CWE190_Integer_Overflow__char_rand_multiply_68_badData <end> ;"	0
4ec5d09a-6c15-11ed-81d4-94e6f77dd552	"void CWE190_Integer_Overflow__int_fscanf_postinc_15_bad() { int data; data = 0; switch(6) { case 6: fscanf(stdin, ""%d"", &data); break; default: printLine(""Benign, fixed string""); break; } switch(7) { case 7: { data++; int result = data; printIntLine(result); } break; default: printLine(""Benign, fixed string""); break; } }"	where is the vulnerable dataflow from data ?	"int <start> result = data <end> ;
fscanf(stdin, ""%d"", <start> &data <end> );"	"fscanf(stdin, ""%d"", <start> &data <end> );
<start> data++ <end> ;"	"<start> data <end> ++;
fscanf(stdin, ""%d"", <start> &data <end> );"	"fscanf(stdin, ""%d"", <start> &data <end> );
<start> data <end> ++;"	3
78800fcd-6c15-11ed-81d4-94e6f77dd552	"namespace CWE194_Unexpected_Sign_Extension__listen_socket_memmove_74 { void badSink(map<int, short> dataMap) { short data = dataMap[2]; { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> printLine(dest) <end> ;
void badSink(map<int, short> <start> dataMap <end> );"	"void badSink(map<int, short> <start> dataMap <end> );
printLine <start> dest <end> );"	"<start> memmove(dest, source, data) <end> ;
printLine <start> dest <end> );"	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	1
cac216dc-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_connect_socket_open_18 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; goto source; source: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
replace = <start> strchr(data, '\r') <end> ;"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
recvResult = recv(connectSocket, (char *)(data + dataLen), <start> sizeof(char) * (FILENAME_MAX - dataLen - 1) <end> , 0);"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	3
833ac923-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_listen_socket_fopen_61 { char * badSource(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; data = badSource(data); { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
data = <start> badSource <end> (data);"	"<start> data = badSource(data) <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"data = <start> badSource <end> (data);
pFile = FOPEN <start> data <end> , ""wb+"");"	3
5e44fc63-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) int CWE191_Integer_Underflow__int_connect_socket_predec_61b_badSource(int data); void CWE191_Integer_Underflow__int_connect_socket_predec_61_bad() { int data; data = 0; data = CWE191_Integer_Underflow__int_connect_socket_predec_61b_badSource(data); { --data; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"- <start> data <end> ;
data = <start> CWE191_Integer_Underflow__int_connect_socket_predec_61b_badSource <end> (data);"	"int <start> result = data <end> ;
- <start> data <end> ;"	"<start> printIntLine(result) <end> ;
- <start> data <end> ;"	"data = <start> CWE191_Integer_Underflow__int_connect_socket_predec_61b_badSource <end> (data);
- <start> data <end> ;"	3
ce547d29-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_environment_fopen_44 { static void badSink(char * data) { { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } } void bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } funcPtr(data); }"	where is the vulnerable dataflow from data to funcPtr ?	"size_t dataLen = <start> strlen(data) <end> ;
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
funcPtr <start> data <end> );"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
<start> data = dataBuffer <end> ;"	2
8b91e468-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; namespace CWE36_Absolute_Path_Traversal__char_listen_socket_open_04 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(STATIC_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
replace = <start> strchr(data, '\n') <end> ;"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"size_t dataLen = <start> strlen(data) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	2
7c1275b3-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_09_bad() { int data; data = -1; if(GLOBAL_CONST_TRUE) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"printLine <start> dest <end> );
if  <start> data < 100 <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printLine <start> dest <end> );"	"<start> printLine(dest) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"char <start> dest[100] = """" <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	1
7e74f339-6c15-11ed-81d4-94e6f77dd552	"namespace CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_81 { void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_81_bad::action(int data) const { { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> memcpy(dest, source, data) <end> ;
printLine <start> dest <end> );"	"<start> memcpy(dest, source, data) <end> ;
void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_81_bad::action(int <start> data <end> ) const;"	"void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_81_bad::action(int <start> data <end> ) const;
printLine <start> dest <end> );"	"void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_81_bad::action(int <start> data <end> ) const;
<start> printLine(dest) <end> ;"	2
74ee23bf-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" void CWE194_Unexpected_Sign_Extension__connect_socket_memmove_65b_badSink(short data) { { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"char <start> dest[100] = """" <end> ;
void CWE194_Unexpected_Sign_Extension__connect_socket_memmove_65b_badSink(short <start> data <end> );"	"void CWE194_Unexpected_Sign_Extension__connect_socket_memmove_65b_badSink(short <start> data <end> );
printLine <start> dest <end> );"	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	"printLine <start> dest <end> );
<start> memmove(dest, source, data) <end> ;"	1
c39a658b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif static int staticFive = 5; namespace CWE23_Relative_Path_Traversal__char_environment_ifstream_07 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(staticFive==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } } { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
inputFile.open((char * <start> data <end> );"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
strncat(data+dataLen, environment, <start> FILENAME_MAX-dataLen-1 <end> );"	"inputFile.open((char * <start> data <end> );
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"inputFile.open((char * <start> data <end> );
strncat <start> data+dataLen <end> , environment, FILENAME_MAX-dataLen-1);"	0
453db01f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink(int data) { if(data > 0) { int result = data * 2; printIntLine(result); } } void CWE190_Integer_Overflow__int_connect_socket_multiply_44_bad() { int data; void (*funcPtr) (int) = badSink; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } funcPtr(data); }"	where is the vulnerable dataflow from data ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
funcPtr <start> data <end> );
static void badSink(int <start> data <end> );
int <start> result = data * 2 <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
funcPtr <start> data <end> );
static void badSink(int <start> data <end> );
int result = <start> data <end>  * 2;"	"int result = <start> data <end>  * 2;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
funcPtr <start> data <end> );
static void badSink(int <start> data <end> );"	"funcPtr <start> data <end> );
int result = <start> data <end>  * 2;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	1
6dc614cf-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" void CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_65b_badVaSink(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); va_end(args); } }"	where is the vulnerable dataflow from data to vfprintf ?	"<start> vfprintf(stdout, data, args) <end> ;
void CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_65b_badVaSink(char * <start> data <end> , ...);"	"<start> va_start(args, data) <end> ;
void CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_65b_badVaSink(char * <start> data <end> , ...);"	"void CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_65b_badVaSink(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);"	"vfprintf(stdout, <start> data <end> , args);
void CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_65b_badVaSink(char * <start> data <end> , ...);"	2
a5ce1c88-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink(int data) { { data++; int result = data; printIntLine(result); } } void CWE190_Integer_Overflow__int_listen_socket_postinc_44_bad() { int data; void (*funcPtr) (int) = badSink; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } funcPtr(data); }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
funcPtr <start> data <end> );
static void badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"static void badSink(int <start> data <end> );
int <start> result = data <end> ;
printIntLine <start> result <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"funcPtr <start> data <end> );
static void badSink(int <start> data <end> );
if  <start> acceptSocket == SOCKET_ERROR <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"printIntLine <start> result <end> );
funcPtr <start> data <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static void badSink(int <start> data <end> );"	0
466e7ef7-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__int_fgets_multiply_82 { void CWE190_Integer_Overflow__int_fgets_multiply_82_bad::action(int data) { if(data > 0) { int result = data * 2; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  * 2;"	"int result = <start> data <end>  * 2;
void CWE190_Integer_Overflow__int_fgets_multiply_82_bad::action(int <start> data <end> );"	"void CWE190_Integer_Overflow__int_fgets_multiply_82_bad::action(int <start> data <end> );
int result = <start> data <end>  * 2;"	"<start> printIntLine(result) <end> ;
void CWE190_Integer_Overflow__int_fgets_multiply_82_bad::action(int <start> data <end> );"	2
453db035-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; void CWE190_Integer_Overflow__int_connect_socket_square_04_bad() { int data; data = 0; if(STATIC_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(STATIC_CONST_TRUE) { { int result = data * data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printIntLine(result) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  * data;"	"int result = <start> data <end>  * data;
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);
int result = <start> data <end>  * data;"	1
977ea793-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_81 { void bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } const CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_81_base& baseObject = CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_81_bad(); baseObject.action(data); }"	where is the vulnerable dataflow from data to action ?	"baseObject.action <start> data <end> );
data = <start> atoi(inputBuffer) <end> ;"	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
baseObject.action <start> data <end> );"	"baseObject.action <start> data <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
baseObject.action <start> data <end> );"	3
5be3a9f4-6c15-11ed-81d4-94e6f77dd552	"static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } void CWE191_Integer_Underflow__short_fscanf_postdec_08_bad() { short data; data = 0; if(staticReturnsTrue()) { fscanf (stdin, ""%hd"", &data); } if(staticReturnsTrue()) { { data--; short result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"fscanf (stdin, ""%hd"", <start> &data <end> );
<start> data <end> --;"	"<start> printIntLine(result) <end> ;
<start> data <end> --;"	"<start> printIntLine(result) <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );"	"<start> data <end> --;
fscanf (stdin, ""%hd"", <start> &data <end> );"	0
9c4551a1-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE126_Buffer_Overread__CWE129_connect_socket_10_bad() { int data; data = -1; if(globalTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalTrue) { { int buffer[10] = { 0 }; if (data >= 0) { printIntLine(buffer[data]); } else { printLine(""ERROR: Array index is negative""); } } } }"	where is the vulnerable dataflow from buffer[data] to printIntLine ?	"data = <start> atoi(inputBuffer) <end> ;
printIntLine <start> buffer[data] <end> );"	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> buffer[data] <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printIntLine(buffer[data]) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[data] <end> );"	3
6c938bca-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_11_bad() { int data; data = -1; if(globalReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalReturnsTrue()) { { int i; int * buffer = (int *)malloc(10 * sizeof(int)); if (buffer == NULL) {exit(-1);} for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } free(buffer); } } }"	where is the vulnerable dataflow from buffer to free ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
free <start> buffer <end> );"	"if  <start> recvResult == SOCKET_ERROR <end>  || recvResult == 0);
free <start> buffer <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int <start> * buffer = (int *)malloc(10 * sizeof(int)) <end> ;"	"free <start> buffer <end> );
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	0
774f57e9-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 8 void CWE194_Unexpected_Sign_Extension__fgets_strncpy_16_bad() { short data; data = 0; while(1) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = (short)atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } break; } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printLine <start> dest <end> );"	"<start> printLine(dest) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"data = <start> (short)atoi(inputBuffer) <end> ;
printLine <start> dest <end> );"	"printLine <start> dest <end> );
<start> data = 0 <end> ;"	0
70279c07-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif static void badSink(char * data) { { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } } void CWE134_Uncontrolled_Format_String__char_file_snprintf_41_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } badSink(data); }"	where is the vulnerable dataflow from dest to printLine ?	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );
static void badSink(char * <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	"static void badSink(char * <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	"printLine <start> dest <end> );
badSink <start> data <end> );
static void badSink(char * <start> data <end> );
char <start> dataBuffer[100] = """" <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
badSink <start> data <end> );
static void badSink(char * <start> data <end> );
printLine <start> dest <end> );"	3
571e9829-6c15-11ed-81d4-94e6f77dd552	"void CWE191_Integer_Underflow__int_fscanf_sub_09_bad() { int data; data = 0; if(GLOBAL_CONST_TRUE) { fscanf(stdin, ""%d"", &data); } if(GLOBAL_CONST_TRUE) { { int result = data - 1; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"fscanf(stdin, ""%d"", <start> &data <end> );
int result = <start> data <end>  - 1;"	"fscanf(stdin, ""%d"", <start> &data <end> );
int result = <start> data - 1 <end> ;"	"int result = <start> data <end>  - 1;
fscanf(stdin, ""%d"", <start> &data <end> );"	"fscanf(stdin, ""%d"", <start> &data <end> );
int <start> result = data - 1 <end> ;"	0
99e16a8f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_listen_socket_44 { static void badSink(int data) { { int i; int * buffer = new int[10]; for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } delete[] buffer; } } void bad() { int data; void (*funcPtr) (int) = badSink; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } funcPtr(data); }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
funcPtr <start> data <end> );
static void badSink(int <start> data <end> );
printIntLine <start> buffer[i] <end> );"	"printIntLine <start> buffer[i] <end> );
funcPtr <start> data <end> );
data = <start> atoi(inputBuffer) <end> ;
static void badSink(int <start> data <end> );"	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
funcPtr <start> data <end> );
printIntLine <start> buffer[i] <end> );
static void badSink(int <start> data <end> );"	"static void badSink(int <start> data <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[i] <end> );
<start> data = atoi(inputBuffer) <end> ;"	0
b2ea8dc5-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 8 void CWE197_Numeric_Truncation_Error__short_fgets_17_bad() { int i; short data; data = -1; for(i = 0; i < 1; i++) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = (short)atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } { char charData = (char)data; printHexCharLine(charData); } }"	where is the vulnerable dataflow from charData to printHexCharLine ?	"char charData = <start> (char)data <end> ;
printHexCharLine <start> charData <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printHexCharLine <start> charData <end> );"	"char <start> charData = (char)data <end> ;
printHexCharLine <start> charData <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> data = (short)atoi(inputBuffer) <end> ;"	1
69161b60-6c15-11ed-81d4-94e6f77dd552	typedef union { short unionFirst; short unionSecond; } CWE190_Integer_Overflow__short_rand_preinc_34_unionType; void CWE190_Integer_Overflow__short_rand_preinc_34_bad() { short data; CWE190_Integer_Overflow__short_rand_preinc_34_unionType myUnion; data = 0; data = (short)RAND32(); myUnion.unionFirst = data; { short data = myUnion.unionSecond; { ++data; short result = data; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
data = (short <start> RAND32() <end> ;"	"+ <start> data <end> ;
<start> printIntLine(result) <end> ;"	"+ <start> data <end> ;
short <start> result = data <end> ;"	"data = (short <start> RAND32() <end> ;
+ <start> data <end> ;"	3
b0864110-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE197_Numeric_Truncation_Error__int_listen_socket_to_char_31_bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { int dataCopy = data; int data = dataCopy; { char charData = (char)data; printHexCharLine(charData); } } }"	where is the vulnerable dataflow from charData to printHexCharLine ?	"if  <start> acceptSocket == SOCKET_ERROR <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printHexCharLine <start> charData <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printHexCharLine(charData) <end> ;"	"int <start> data = dataCopy <end> ;
printHexCharLine <start> charData <end> );"	1
584fa8a3-6c15-11ed-81d4-94e6f77dd552	"static int badStatic = 0; static void badSink(short data) { if(badStatic) { if(data < 0) { short result = data * 2; printIntLine(result); } } } void CWE191_Integer_Underflow__short_fscanf_multiply_21_bad() { short data; data = 0; fscanf (stdin, ""%hd"", &data); badStatic = 1; badSink(data); }"	where is the vulnerable dataflow from data ?	"short result = <start> data <end>  * 2;
static void badSink(short <start> data <end> );
fscanf (stdin, ""%hd"", <start> &data <end> );
<start> badSink(data) <end> ;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
badSink <start> data <end> );
static void badSink(short <start> data <end> );
short result = <start> data <end>  * 2;"	"<start> badSink(data) <end> ;
badSink <start> data <end> );
static void badSink(short <start> data <end> );
short result = <start> data <end>  * 2;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
badSink <start> data <end> );
static void badSink(short <start> data <end> );"	1
48d25d9b-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__int_fscanf_square_81 { void CWE190_Integer_Overflow__int_fscanf_square_81_bad::action(int data) const { { int result = data * data; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  * data;
<start> printIntLine(result) <end> ;"	"int result = <start> data <end>  * data;
void CWE190_Integer_Overflow__int_fscanf_square_81_bad::action(int <start> data <end> ) const;"	"int result = <start> data * data <end> ;
void CWE190_Integer_Overflow__int_fscanf_square_81_bad::action(int <start> data <end> ) const;"	"void CWE190_Integer_Overflow__int_fscanf_square_81_bad::action(int <start> data <end> ) const;
int result = <start> data <end>  * data;"	3
c5fc2354-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif namespace CWE23_Relative_Path_Traversal__char_file_ofstream_12 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(globalReturnsTrueOrFalse()) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } else { strcat(data, ""file.txt""); } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"size_t dataLen = <start> strlen(data) <end> ;
outputFile.open((char * <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
outputFile.open((char * <start> data <end> );"	"outputFile.open((char * <start> data <end> );
<start> data = dataBuffer <end> ;"	"char <start> dataBuffer[FILENAME_MAX] = BASEPATH <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	1
951c5e7d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FULL_COMMAND ""dir "" #else #define FULL_COMMAND ""ls "" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define POPEN _popen #define PCLOSE _pclose #else #define POPEN popen #define PCLOSE pclose #endif void CWE78_OS_Command_Injection__char_connect_socket_popen_63b_badSink(char * * dataPtr) { char * data = *dataPtr; { FILE *pipe; pipe = POPEN(data, ""w""); if (pipe != NULL) { PCLOSE(pipe); } } }"	where is the vulnerable dataflow from data to POPEN ?	"pipe = <start> POPEN(data, ""w"") <end> ;
pipe = POPEN <start> data <end> , ""w"");"	"void CWE78_OS_Command_Injection__char_connect_socket_popen_63b_badSink(char * * <start> dataPtr <end> );
pipe = <start> POPEN(data, ""w"") <end> ;"	"void CWE78_OS_Command_Injection__char_connect_socket_popen_63b_badSink(char * * <start> dataPtr <end> );
pipe = POPEN <start> data <end> , ""w"");"	"pipe = POPEN <start> data <end> , ""w"");
void CWE78_OS_Command_Injection__char_connect_socket_popen_63b_badSink(char * * <start> dataPtr <end> );"	2
73bc8180-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" static short CWE194_Unexpected_Sign_Extension__connect_socket_memmove_45_badData; static short CWE194_Unexpected_Sign_Extension__connect_socket_memmove_45_goodG2BData; static void badSink() { short data = CWE194_Unexpected_Sign_Extension__connect_socket_memmove_45_badData; { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } } void CWE194_Unexpected_Sign_Extension__connect_socket_memmove_45_bad() { short data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE194_Unexpected_Sign_Extension__connect_socket_memmove_45_badData = data; badSink(); }"	where is the vulnerable dataflow from dest to printLine ?	"short data = <start> CWE194_Unexpected_Sign_Extension__connect_socket_memmove_45_badData <end> ;
static short <start> CWE194_Unexpected_Sign_Extension__connect_socket_memmove_45_badData <end> ;
printLine <start> dest <end> );
<start> CWE194_Unexpected_Sign_Extension__connect_socket_memmove_45_badData = data <end> ;
<start> memmove(dest, source, data) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> CWE194_Unexpected_Sign_Extension__connect_socket_memmove_45_badData = data <end> ;
static short <start> CWE194_Unexpected_Sign_Extension__connect_socket_memmove_45_badData <end> ;
short data = <start> CWE194_Unexpected_Sign_Extension__connect_socket_memmove_45_badData <end> ;
printLine <start> dest <end> );"	"if  <start> data < 100 <end> );
short data = <start> CWE194_Unexpected_Sign_Extension__connect_socket_memmove_45_badData <end> ;
static short <start> CWE194_Unexpected_Sign_Extension__connect_socket_memmove_45_badData <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> CWE194_Unexpected_Sign_Extension__connect_socket_memmove_45_badData = data <end> ;"	"<start> memmove(dest, source, data) <end> ;
printLine <start> dest <end> );
short data = <start> CWE194_Unexpected_Sign_Extension__connect_socket_memmove_45_badData <end> ;
<start> CWE194_Unexpected_Sign_Extension__connect_socket_memmove_45_badData = data <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	1
93ece2f0-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING ""hello"" void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_64b_badSink(void * dataVoidPtr) { size_t * dataPtr = (size_t *)dataVoidPtr; size_t data = (*dataPtr); { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); } else { printLine(""Input is less than the length of the source string""); } } }"	where is the vulnerable dataflow from data to malloc ?	"void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_64b_badSink(void * <start> dataVoidPtr <end> );
<start> strcpy(myString, HELLO_STRING) <end> ;"	"<start> strcpy(myString, HELLO_STRING) <end> ;
myString = (char *)malloc <start> data*sizeof(char) <end> );"	"myString = (char *)malloc <start> data*sizeof(char) <end> );
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_64b_badSink(void * <start> dataVoidPtr <end> );"	"void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_64b_badSink(void * <start> dataVoidPtr <end> );
myString = (char *)malloc <start> data*sizeof(char) <end> );"	3
b7b09a4e-6c15-11ed-81d4-94e6f77dd552	"namespace CWE427_Uncontrolled_Search_Path_Element__char_console_82 { void bad() { char * data; char dataBuffer[250] = ""PATH=""; data = dataBuffer; { size_t dataLen = strlen(data); if (250-dataLen > 1) { if (fgets(data+dataLen, (int)(250-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } CWE427_Uncontrolled_Search_Path_Element__char_console_82_base* baseObject = new CWE427_Uncontrolled_Search_Path_Element__char_console_82_bad; baseObject->action(data); delete baseObject; }"	where is the vulnerable dataflow from data to action ?	"size_t dataLen = <start> strlen(data) <end> ;
baseObject->action <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(250-dataLen), stdin) != NULL);
baseObject->action <start> data <end> );"	"dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(250-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(250-dataLen), stdin) != NULL);
size_t dataLen = <start> strlen(data) <end> ;"	1
a1094924-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) typedef struct _CWE190_Integer_Overflow__int_connect_socket_square_67_structType { int structFirst; } CWE190_Integer_Overflow__int_connect_socket_square_67_structType; void CWE190_Integer_Overflow__int_connect_socket_square_67b_badSink(CWE190_Integer_Overflow__int_connect_socket_square_67_structType myStruct) { int data = myStruct.structFirst; { int result = data * data; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"void CWE190_Integer_Overflow__int_connect_socket_square_67b_badSink(CWE190_Integer_Overflow__int_connect_socket_square_67_structType <start> myStruct <end> );
<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;
int data = <start> myStruct <end> .structFirst;"	"void CWE190_Integer_Overflow__int_connect_socket_square_67b_badSink(CWE190_Integer_Overflow__int_connect_socket_square_67_structType <start> myStruct <end> );
printIntLine <start> result <end> );"	"void CWE190_Integer_Overflow__int_connect_socket_square_67b_badSink(CWE190_Integer_Overflow__int_connect_socket_square_67_structType <start> myStruct <end> );
int data = <start> myStruct <end> .structFirst;
printIntLine <start> result <end> );"	3
cf8750a1-6c15-11ed-81d4-94e6f77dd552	#ifndef _WIN32 #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_environment_open_72 { void badSink(vector<char *> dataVector) { char * data = dataVector[2]; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }	where is the vulnerable dataflow from data to OPEN ?	"void badSink(vector<char *> <start> dataVector <end> );
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"void badSink(vector<char *> <start> dataVector <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
void badSink(vector<char *> <start> dataVector <end> );"	"fileDesc = OPEN(data, O_RDWR|O_CREAT, <start> S_IREAD|S_IWRITE <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	1
598370b6-6c15-11ed-81d4-94e6f77dd552	namespace CWE191_Integer_Underflow__short_fscanf_multiply_82 { void CWE191_Integer_Underflow__short_fscanf_multiply_82_bad::action(short data) { if(data < 0) { short result = data * 2; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"short result = <start> data * 2 <end> ;
void CWE191_Integer_Underflow__short_fscanf_multiply_82_bad::action(short <start> data <end> );"	"short <start> result = data * 2 <end> ;
void CWE191_Integer_Underflow__short_fscanf_multiply_82_bad::action(short <start> data <end> );"	"<start> printIntLine(result) <end> ;
void CWE191_Integer_Underflow__short_fscanf_multiply_82_bad::action(short <start> data <end> );"	"void CWE191_Integer_Underflow__short_fscanf_multiply_82_bad::action(short <start> data <end> );
short result = <start> data <end>  * 2;"	3
728a5027-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif namespace CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_62 { void badSource(char * &data); static void badVaSink(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); va_end(args); } } void bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; badSource(data); badVaSink(data, data); }"	where is the vulnerable dataflow from data to vprintf ?	"static void badVaSink(char * <start> data <end> , ...);
vprintf <start> data <end> , args);
badSource <start> data <end> );
badVaSink <start> data <end> , data);"	"badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
badSource <start> data <end> );"	"badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
badSource <start> data <end> );
<start> vprintf(data, args) <end> ;"	"badSource <start> data <end> );
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
vprintf <start> data <end> , args);"	3
598370d6-6c15-11ed-81d4-94e6f77dd552	void CWE191_Integer_Underflow__short_fscanf_sub_63b_badSink(short * dataPtr) { short data = *dataPtr; { short result = data - 1; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"void CWE191_Integer_Underflow__short_fscanf_sub_63b_badSink(short * <start> dataPtr <end> );
short <start> result = data - 1 <end> ;"	"short result = <start> data - 1 <end> ;
void CWE191_Integer_Underflow__short_fscanf_sub_63b_badSink(short * <start> dataPtr <end> );"	"void CWE191_Integer_Underflow__short_fscanf_sub_63b_badSink(short * <start> dataPtr <end> );
short result = <start> data <end>  - 1;"	"void CWE191_Integer_Underflow__short_fscanf_sub_63b_badSink(short * <start> dataPtr <end> );
<start> printIntLine(result) <end> ;"	2
abc374ec-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE191_Integer_Underflow__int_listen_socket_sub_81 { void bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } const CWE191_Integer_Underflow__int_listen_socket_sub_81_base& baseObject = CWE191_Integer_Underflow__int_listen_socket_sub_81_bad(); baseObject.action(data); }"	where is the vulnerable dataflow from data to action ?	"baseObject.action <start> data <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
baseObject.action <start> data <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );"	"if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );
baseObject.action <start> data <end> );"	1
cbf237c5-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_console_fopen_74 { void badSink(map<int, char *> dataMap) { char * data = dataMap[2]; { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
void badSink(map<int, char *> <start> dataMap <end> );"	"void badSink(map<int, char *> <start> dataMap <end> );
char <start> * data = dataMap[2] <end> ;"	"void badSink(map<int, char *> <start> dataMap <end> );
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
void badSink(map<int, char *> <start> dataMap <end> );"	2
a23a3e31-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_multiply_52c_badSink(int data) { if(data > 0) { int result = data * 2; printIntLine(result); } }	where is the vulnerable dataflow from result to printIntLine ?	"void CWE190_Integer_Overflow__int_fgets_multiply_52c_badSink(int <start> data <end> );
int <start> result = data * 2 <end> ;"	"void CWE190_Integer_Overflow__int_fgets_multiply_52c_badSink(int <start> data <end> );
<start> printIntLine(result) <end> ;"	"void CWE190_Integer_Overflow__int_fgets_multiply_52c_badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
void CWE190_Integer_Overflow__int_fgets_multiply_52c_badSink(int <start> data <end> );"	2
5f76fcaf-6c15-11ed-81d4-94e6f77dd552	"void CWE191_Integer_Underflow__short_fscanf_predec_31_bad() { short data; data = 0; fscanf (stdin, ""%hd"", &data); { short dataCopy = data; short data = dataCopy; { --data; short result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"short <start> data = dataCopy <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );"	"- <start> data <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );"	"fscanf (stdin, ""%hd"", <start> &data <end> );
- <start> data <end> ;"	"<start> printIntLine(result) <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );"	2
c991980f-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" namespace CWE36_Absolute_Path_Traversal__char_connect_socket_ifstream_18 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; goto source; source: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - <start> dataLen - 1 <end> ), 0);
inputFile.open((char * <start> data <end> );"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
inputFile.open((char * <start> data <end> );"	"inputFile.open((char * <start> data <end> );
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
recvResult = <start> recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0) <end> ;"	1
a5ce1c56-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_postinc_11_bad() { int data; data = 0; if(globalReturnsTrue()) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(globalReturnsTrue()) { { data++; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"<start> data++ <end> ;
printIntLine <start> result <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> printIntLine(result) <end> ;"	"<start> data++ <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	1
61da6711-6c15-11ed-81d4-94e6f77dd552	static int badStatic = 0; static void badSink(short data) { if(badStatic) { { short result = data + 1; printIntLine(result); } } } void CWE190_Integer_Overflow__short_rand_add_21_bad() { short data; data = 0; data = (short)RAND32(); badStatic = 1; badSink(data); }	where is the vulnerable dataflow from data ?	"badSink <start> data <end> );
static void badSink(short <start> data <end> );
short result = <start> data <end>  + 1;
data = (short <start> RAND32() <end> ;"	"short <start> result = data + 1 <end> ;
static void badSink(short <start> data <end> );
badSink <start> data <end> );
data = (short <start> RAND32() <end> ;"	"data = (short <start> RAND32() <end> ;
badSink <start> data <end> );
static void badSink(short <start> data <end> );
short result = <start> data <end>  + 1;"	"badSink <start> data <end> );
static void badSink(short <start> data <end> );
short result = <start> data <end>  + 1;"	2
acf67e33-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) int CWE191_Integer_Underflow__int_connect_socket_predec_61b_badSource(int data); void CWE191_Integer_Underflow__int_connect_socket_predec_61_bad() { int data; data = 0; data = CWE191_Integer_Underflow__int_connect_socket_predec_61b_badSource(data); { --data; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"data = <start> CWE191_Integer_Underflow__int_connect_socket_predec_61b_badSource <end> (data);
int <start> result = data <end> ;"	"data = <start> CWE191_Integer_Underflow__int_connect_socket_predec_61b_badSource <end> (data);
<start> printIntLine(result) <end> ;"	"data = <start> CWE191_Integer_Underflow__int_connect_socket_predec_61b_badSource <end> (data);
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
data = <start> CWE191_Integer_Underflow__int_connect_socket_predec_61b_badSource <end> (data);"	2
c136623f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_console_fopen_11 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(globalReturnsTrue()) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
pFile = FOPEN <start> data <end> , ""wb+"");"	"dataLen = <start> strlen(data) <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
if (dataLen > 0 && <start> data[dataLen-1] == '\n' <end> );"	1
b68484d7-6c15-11ed-81d4-94e6f77dd552	"namespace CWE36_Absolute_Path_Traversal__char_console_fopen_82 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } CWE36_Absolute_Path_Traversal__char_console_fopen_82_base* baseObject = new CWE36_Absolute_Path_Traversal__char_console_fopen_82_bad; baseObject->action(data); delete baseObject; }"	where is the vulnerable dataflow from data to action ?	"size_t dataLen = <start> strlen(data) <end> ;
baseObject->action <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
baseObject->action <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
<start> data = dataBuffer <end> ;"	"baseObject->action <start> data <end> );
<start> data = dataBuffer <end> ;"	1
a95fd826-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_fgets_multiply_09_bad() { int data; data = 0; if(GLOBAL_CONST_TRUE) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(GLOBAL_CONST_TRUE) { if(data < 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"int result = <start> data * 2 <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
data = <start> atoi(inputBuffer) <end> ;"	"int <start> result = data * 2 <end> ;
printIntLine <start> result <end> );"	1
cbf237ac-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_console_fopen_15 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; switch(6) { case 6: { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } break; default: printLine(""Benign, fixed string""); break; } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
size_t dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
char <start> dataBuffer[FILENAME_MAX] = """" <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
pFile = FOPEN <start> data <end> , ""wb+"");"	"if (dataLen > 0 && <start> data[dataLen-1] == '\n' <end> );
pFile = FOPEN <start> data <end> , ""wb+"");"	2
6dc6151b-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif namespace CWE134_Uncontrolled_Format_String__char_console_snprintf_43 { static void badSource(char * &data) { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } void bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; badSource(data); { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
badSource <start> data <end> );
printLine <start> dest <end> );"	"<start> printLine(dest) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
printLine <start> dest <end> );"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
printLine <start> dest <end> );"	"printLine <start> dest <end> );
badSource <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	0
5f76fcb0-6c15-11ed-81d4-94e6f77dd552	"typedef union { short unionFirst; short unionSecond; } CWE191_Integer_Underflow__short_fscanf_predec_34_unionType; void CWE191_Integer_Underflow__short_fscanf_predec_34_bad() { short data; CWE191_Integer_Underflow__short_fscanf_predec_34_unionType myUnion; data = 0; fscanf (stdin, ""%hd"", &data); myUnion.unionFirst = data; { short data = myUnion.unionSecond; { --data; short result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"- <start> data <end> ;
short <start> data = myUnion.unionSecond <end> ;"	"- <start> data <end> ;
<start> printIntLine(result) <end> ;"	"<start> printIntLine(result) <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );"	"fscanf (stdin, ""%hd"", <start> &data <end> );
- <start> data <end> ;"	3
85b15ef5-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE369_Divide_by_Zero__int_fgets_divide_18_bad() { int data; data = -1; goto source; source: { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } goto sink; sink: printIntLine(100 / data); }"	where is the vulnerable dataflow from data to printIntLine ?	"if  <start> fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) <end>  != NULL);
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"printIntLine <start> 100 / data <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"printIntLine <start> 100 / data <end> );
data = <start> atoi(inputBuffer) <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> 100 / data <end> );"	3
a830bfa3-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int badStatic = 0; static void badSink(int data) { if(badStatic) { { int result = data - 1; printIntLine(result); } } } void CWE191_Integer_Underflow__int_connect_socket_sub_21_bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badStatic = 1; badSink(data); }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSink <start> data <end> );
static void badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> result <end> );
static void badSink(int <start> data <end> );
badSink <start> data <end> );"	"<start> badSink(data) <end> ;
badSink <start> data <end> );
static void badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"int <start> result = data - 1 <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static void badSink(int <start> data <end> );
badSink <start> data <end> );"	0
728a4ffe-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 static void badVaSink(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_64b_badSink(void * dataVoidPtr) { char * * dataPtr = (char * *)dataVoidPtr; char * data = (*dataPtr); badVaSink(data, data); }"	where is the vulnerable dataflow from data to vfprintf ?	"void CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_64b_badSink(void * <start> dataVoidPtr <end> );
<start> vfprintf(stdout, data, args) <end> ;
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);"	"void CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_64b_badSink(void * <start> dataVoidPtr <end> );
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);"	"vfprintf(stdout, <start> data <end> , args);
void CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_64b_badSink(void * <start> dataVoidPtr <end> );"	"vfprintf(stdout, <start> data <end> , args);
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
void CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_64b_badSink(void * <start> dataVoidPtr <end> );"	1
8b91e47a-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_listen_socket_open_34 { typedef union { char * unionFirst; char * unionSecond; } unionType; void bad() { char * data; unionType myUnion; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"<start> data = dataBuffer <end> ;
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	3
87ff9873-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_connect_socket_open_21 { static int badStatic = 0; static char * badSource(char * data) { if(badStatic) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } return data; } void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; badStatic = 1; data = badSource(data); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } ; }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
size_t <start> dataLen = strlen(data) <end> ;
data = <start> badSource <end> (data);
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
static char * <start> badSource <end> (char * data);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);"	1
584fa854-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) typedef union { int unionFirst; int unionSecond; } CWE191_Integer_Underflow__int_listen_socket_multiply_34_unionType; void CWE191_Integer_Underflow__int_listen_socket_multiply_34_bad() { int data; CWE191_Integer_Underflow__int_listen_socket_multiply_34_unionType myUnion; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } myUnion.unionFirst = data; { int data = myUnion.unionSecond; if(data < 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"data = <start> atoi(inputBuffer) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"int result = <start> data <end>  * 2;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  * 2;"	"int result = <start> data <end>  * 2;
if  <start> acceptSocket == SOCKET_ERROR <end> );"	2
48d25dcf-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_multiply_10_bad() { int data; data = 0; if(globalTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalTrue) { if(data > 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  * 2;
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  * 2;"	"<start> printIntLine(result) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"int <start> result = data * 2 <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	1
6ef7683c-6c15-11ed-81d4-94e6f77dd552	#ifndef _WIN32 #endif static void badVaSink(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_console_vfprintf_54e_badSink(char * data) { badVaSink(data, data); }	where is the vulnerable dataflow from data to vfprintf ?	"<start> va_start(args, data) <end> ;
vfprintf(stdout, <start> data <end> , args);
static void badVaSink(char * <start> data <end> , ...);
void CWE134_Uncontrolled_Format_String__char_console_vfprintf_54e_badSink(char * <start> data <end> );"	"void CWE134_Uncontrolled_Format_String__char_console_vfprintf_54e_badSink(char * <start> data <end> );
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);"	"badVaSink <start> data <end> , data);
void CWE134_Uncontrolled_Format_String__char_console_vfprintf_54e_badSink(char * <start> data <end> );
vfprintf(stdout, <start> data <end> , args);"	"vfprintf(stdout, <start> data <end> , args);
void CWE134_Uncontrolled_Format_String__char_console_vfprintf_54e_badSink(char * <start> data <end> );"	1
a830bf9c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_connect_socket_sub_12_bad() { int data; data = 0; if(globalReturnsTrueOrFalse()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } else { data = -2; } if(globalReturnsTrueOrFalse()) { { int result = data - 1; printIntLine(result); } } else { if (data > INT_MIN) { int result = data - 1; printIntLine(result); } else { printLine(""data value is too large to perform subtraction.""); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"<start> data = 0 <end> ;
printIntLine <start> result <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int <start> result = data - 1 <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	3
c1366275-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif namespace CWE23_Relative_Path_Traversal__char_console_ifstream_51 { void badSink(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } badSink(data); }"	where is the vulnerable dataflow from data to badSink ?	"<start> data = dataBuffer <end> ;
badSink <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
badSink <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
<start> badSink(data) <end> ;"	2
aa91a19d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int CWE191_Integer_Underflow__int_listen_socket_sub_45_badData; static int CWE191_Integer_Underflow__int_listen_socket_sub_45_goodG2BData; static int CWE191_Integer_Underflow__int_listen_socket_sub_45_goodB2GData; static void badSink() { int data = CWE191_Integer_Underflow__int_listen_socket_sub_45_badData; { int result = data - 1; printIntLine(result); } } void CWE191_Integer_Underflow__int_listen_socket_sub_45_bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE191_Integer_Underflow__int_listen_socket_sub_45_badData = data; badSink(); }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int data = <start> CWE191_Integer_Underflow__int_listen_socket_sub_45_badData <end> ;
printIntLine <start> result <end> );
static int <start> CWE191_Integer_Underflow__int_listen_socket_sub_45_badData <end> ;
<start> printIntLine(result) <end> ;"	"<start> CWE191_Integer_Underflow__int_listen_socket_sub_45_badData = data <end> ;
printIntLine <start> result <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"<start> CWE191_Integer_Underflow__int_listen_socket_sub_45_badData = data <end> ;
int data = <start> CWE191_Integer_Underflow__int_listen_socket_sub_45_badData <end> ;
data = <start> atoi(inputBuffer) <end> ;
printIntLine <start> result <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> CWE191_Integer_Underflow__int_listen_socket_sub_45_badData = data <end> ;
static int <start> CWE191_Integer_Underflow__int_listen_socket_sub_45_badData <end> ;
int data = <start> CWE191_Integer_Underflow__int_listen_socket_sub_45_badData <end> ;
printIntLine <start> result <end> );"	3
5be3a9a9-6c15-11ed-81d4-94e6f77dd552	"void CWE191_Integer_Underflow__int_fscanf_postdec_02_bad() { int data; data = 0; if(1) { fscanf(stdin, ""%d"", &data); } if(1) { { data--; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"fscanf(stdin, ""%d"", <start> &data <end> );
<start> printIntLine(result) <end> ;"	"<start> data-- <end> ;
fscanf(stdin, ""%d"", <start> &data <end> );"	"<start> data <end> --;
fscanf(stdin, ""%d"", <start> &data <end> );"	"fscanf(stdin, ""%d"", <start> &data <end> );
<start> data <end> --;"	3
92bb89ef-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #define SEARCH_CHAR 'S' void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_file_64b_badSink(void * dataVoidPtr) { char * * dataPtr = (char * *)dataVoidPtr; char * data = (*dataPtr); for (; *data != '\0'; data++) { if (*data == SEARCH_CHAR) { printLine(""We have a match!""); break; } } free(data); }"	where is the vulnerable dataflow from data to free ?	"void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_file_64b_badSink(void * <start> dataVoidPtr <end> );
char <start> * data = (*dataPtr) <end> ;"	"void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_file_64b_badSink(void * <start> dataVoidPtr <end> );
<start> free(data) <end> ;"	"void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_file_64b_badSink(void * <start> dataVoidPtr <end> );
free <start> data <end> );"	"free <start> data <end> );
<start> free(data) <end> ;"	2
7fa68e2a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_connect_socket_fopen_09 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(GLOBAL_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = FOPEN <start> data <end> , ""wb+"");
size_t dataLen = <start> strlen(data) <end> ;"	"pFile = FOPEN <start> data <end> , ""wb+"");
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	"<start> data = dataBuffer <end> ;
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	3
9187cc24-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #define SEARCH_CHAR 'S' void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_file_17_bad() { int j; char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\0'; { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } for(j = 0; j < 1; j++) { for (; *data != '\0'; data++) { if (*data == SEARCH_CHAR) { printLine(""We have a match!""); break; } } free(data); } }"	where is the vulnerable dataflow from data to free ?	"for (; *data != '\0'; <start> data++ <end> );
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	"free <start> data <end> );
for (; *data != '\0'; <start> data++ <end> );"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
free <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
size_t dataLen = <start> strlen(data) <end> ;"	2
9187cbd7-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define SEARCH_CHAR 'S' void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_13_bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\0'; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } if(GLOBAL_CONST_FIVE==5) { for (; *data != '\0'; data++) { if (*data == SEARCH_CHAR) { printLine(""We have a match!""); break; } } free(data); } }"	where is the vulnerable dataflow from data to free ?	"size_t dataLen = <start> strlen(data) <end> ;
free <start> data <end> );"	"free <start> data <end> );
for (; *data != '\0'; <start> data++ <end> );"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (100 - dataLen - 1), 0);"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
free <start> data <end> );"	3
73bc812f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" void CWE194_Unexpected_Sign_Extension__connect_socket_malloc_63b_badSink(short * dataPtr) { short data = *dataPtr; if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }"	where is the vulnerable dataflow from data to malloc ?	"char * dataBuffer = (char *)malloc <start> data <end> );
<start> printLine(dataBuffer) <end> ;"	"void CWE194_Unexpected_Sign_Extension__connect_socket_malloc_63b_badSink(short * <start> dataPtr <end> );
char * dataBuffer = (char *)malloc <start> data <end> );"	"short <start> data = *dataPtr <end> ;
void CWE194_Unexpected_Sign_Extension__connect_socket_malloc_63b_badSink(short * <start> dataPtr <end> );"	"char * dataBuffer = (char *)malloc <start> data <end> );
void CWE194_Unexpected_Sign_Extension__connect_socket_malloc_63b_badSink(short * <start> dataPtr <end> );"	1
7d44fc7f-6c15-11ed-81d4-94e6f77dd552	"namespace CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_82 { void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_82_bad::action(int data) { { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } } }"	where is the vulnerable dataflow from dest to printLine ?	"void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_82_bad::action(int <start> data <end> );
printLine <start> dest <end> );"	"printLine <start> dest <end> );
void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_82_bad::action(int <start> data <end> );"	"<start> memmove(dest, source, data) <end> ;
void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_82_bad::action(int <start> data <end> );"	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	0
964cdbf1-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FULL_COMMAND ""dir "" #else #define FULL_COMMAND ""ls "" #endif #ifdef _WIN32 #define POPEN _popen #define PCLOSE _pclose #else #define POPEN popen #define PCLOSE pclose #endif int CWE78_OS_Command_Injection__char_file_popen_22_badGlobal = 0; char * CWE78_OS_Command_Injection__char_file_popen_22_badSource(char * data); void CWE78_OS_Command_Injection__char_file_popen_22_bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; CWE78_OS_Command_Injection__char_file_popen_22_badGlobal = 1; data = CWE78_OS_Command_Injection__char_file_popen_22_badSource(data); { FILE *pipe; pipe = POPEN(data, ""w""); if (pipe != NULL) { PCLOSE(pipe); } } }"	where is the vulnerable dataflow from data to POPEN ?	"data = <start> CWE78_OS_Command_Injection__char_file_popen_22_badSource <end> (data);
pipe = <start> POPEN(data, ""w"") <end> ;"	"pipe = <start> POPEN(data, ""w"") <end> ;
pipe = POPEN <start> data <end> , ""w"");"	"data = <start> CWE78_OS_Command_Injection__char_file_popen_22_badSource <end> (data);
pipe = POPEN <start> data <end> , ""w"");"	"pipe = POPEN <start> data <end> , ""w"");
data = <start> CWE78_OS_Command_Injection__char_file_popen_22_badSource(data) <end> ;"	2
8df421e6-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define PATH_SZ 100 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define PATH_SZ PATH_MAX #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 void CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__accept_bind_listen_01_bad() { { char data[100] = """"; #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[recvResult] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif printLine(data); } }"	where is the vulnerable dataflow from data to printLine ?	"printLine <start> data <end> );
recvResult = <start> recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0) <end> ;"	"recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);
replace = <start> strchr(data, '\r') <end> ;"	"recvResult = recv(acceptSocket, (char *)data+dataLen, <start> (int)(100-dataLen-1) <end> , 0);
printLine <start> data <end> );"	"recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);
printLine <start> data <end> );"	3
7e74f30c-6c15-11ed-81d4-94e6f77dd552	namespace CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_74 { void badSink(map<int, int> dataMap) { int data = dataMap[2]; if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }	where is the vulnerable dataflow from data to malloc ?	"void badSink(map<int, int> <start> dataMap <end> );
char <start> * dataBuffer = (char *)malloc(data) <end> ;"	"void badSink(map<int, int> <start> dataMap <end> );
char * dataBuffer = (char *)malloc <start> data <end> );"	"void badSink(map<int, int> <start> dataMap <end> );
<start> free(dataBuffer) <end> ;"	"char * dataBuffer = (char *)malloc <start> data <end> );
void badSink(map<int, int> <start> dataMap <end> );"	1
b68484e1-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif namespace CWE36_Absolute_Path_Traversal__char_file_ifstream_82 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } CWE36_Absolute_Path_Traversal__char_file_ifstream_82_base* baseObject = new CWE36_Absolute_Path_Traversal__char_file_ifstream_82_bad; baseObject->action(data); delete baseObject; }"	where is the vulnerable dataflow from data to action ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
size_t dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
baseObject->action <start> data <end> );"	"<start> data = dataBuffer <end> ;
baseObject->action <start> data <end> );"	"baseObject->action <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	1
bda4e42d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define EXECLP _execlp #else #define EXECLP execlp #endif void CWE78_OS_Command_Injection__char_listen_socket_execlp_03_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(5==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECLP ?	"EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
size_t dataLen = <start> strlen(data) <end> ;"	"EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
char <start> dataBuffer[100] = COMMAND_ARG2 <end> ;"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
replace = <start> strchr(data, '\n') <end> ;"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	3
761e2963-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 8 void CWE194_Unexpected_Sign_Extension__fgets_memcpy_54e_badSink(short data) { { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> printLine(dest) <end> ;
void CWE194_Unexpected_Sign_Extension__fgets_memcpy_54e_badSink(short <start> data <end> );"	"void CWE194_Unexpected_Sign_Extension__fgets_memcpy_54e_badSink(short <start> data <end> );
printLine <start> dest <end> );"	"char <start> dest[100] = """" <end> ;
printLine <start> dest <end> );"	"void CWE194_Unexpected_Sign_Extension__fgets_memcpy_54e_badSink(short <start> data <end> );
<start> memcpy(dest, source, data) <end> ;"	1
c72d5d6d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif extern char * CWE23_Relative_Path_Traversal__char_listen_socket_fopen_68_badData; extern char * CWE23_Relative_Path_Traversal__char_listen_socket_fopen_68_goodG2BData; namespace CWE23_Relative_Path_Traversal__char_listen_socket_fopen_68 { void badSink() { char * data = CWE23_Relative_Path_Traversal__char_listen_socket_fopen_68_badData; { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = FOPEN <start> data <end> , ""wb+"");
char * data = <start> CWE23_Relative_Path_Traversal__char_listen_socket_fopen_68_badData <end> ;"	"char * data = <start> CWE23_Relative_Path_Traversal__char_listen_socket_fopen_68_badData <end> ;
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	"char * data = <start> CWE23_Relative_Path_Traversal__char_listen_socket_fopen_68_badData <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	2
453db05e-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_add_03_bad() { int data; data = 0; if(5==5) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(5==5) { { int result = data + 1; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  + 1;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
int result = <start> data <end>  + 1;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> data = atoi(inputBuffer) <end> ;"	"int <start> result = data + 1 <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	1
54c581fd-6c15-11ed-81d4-94e6f77dd552	namespace CWE191_Integer_Underflow__int_connect_socket_multiply_62 { void badSource(int &data); void bad() { int data; data = 0; badSource(data); if(data < 0) { int result = data * 2; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  * 2;"	"badSource <start> data <end> );
int result = <start> data <end>  * 2;"	"badSource <start> data <end> );
int <start> result = data * 2 <end> ;"	"int result = <start> data <end>  * 2;
badSource <start> data <end> );"	1
598370af-6c15-11ed-81d4-94e6f77dd552	void CWE191_Integer_Underflow__short_fscanf_multiply_66b_badSink(short dataArray[]) { short data = dataArray[2]; if(data < 0) { short result = data * 2; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"void CWE191_Integer_Underflow__short_fscanf_multiply_66b_badSink(short <start> dataArray <end> []);
short result = <start> data <end>  * 2;"	"short result = <start> data * 2 <end> ;
void CWE191_Integer_Underflow__short_fscanf_multiply_66b_badSink(short <start> dataArray <end> []);"	"void CWE191_Integer_Underflow__short_fscanf_multiply_66b_badSink(short <start> dataArray <end> []);
<start> printIntLine(result) <end> ;"	"short result = <start> data <end>  * 2;
void CWE191_Integer_Underflow__short_fscanf_multiply_66b_badSink(short <start> dataArray <end> []);"	0
aa91a172-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_listen_socket_multiply_52c_badSink(int data) { if(data < 0) { int result = data * 2; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"int <start> result = data * 2 <end> ;
printIntLine <start> result <end> );"	"void CWE191_Integer_Underflow__int_listen_socket_multiply_52c_badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;"	"int <start> result = data * 2 <end> ;
void CWE191_Integer_Underflow__int_listen_socket_multiply_52c_badSink(int <start> data <end> );"	1
5133a72d-6c15-11ed-81d4-94e6f77dd552	"static void badSink(int64_t data) { { ++data; int64_t result = data; printLongLongLine(result); } } void CWE190_Integer_Overflow__int64_t_fscanf_preinc_41_bad() { int64_t data; data = 0LL; fscanf (stdin, ""%"" SCNd64, &data); badSink(data); }"	where is the vulnerable dataflow from data ?	"static void badSink(int64_t <start> data <end> );
badSink <start> data <end> );"	"<start> badSink(data) <end> ;
fscanf (stdin, ""%"" SCNd64, <start> &data <end> );
static void badSink(int64_t <start> data <end> );
badSink <start> data <end> );"	"fscanf (stdin, ""%"" SCNd64, <start> &data <end> );
badSink <start> data <end> );
static void badSink(int64_t <start> data <end> );
+ <start> data <end> ;"	"badSink <start> data <end> );
fscanf (stdin, ""%"" SCNd64, <start> &data <end> );
static void badSink(int64_t <start> data <end> );"	2
80d986fe-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } namespace CWE23_Relative_Path_Traversal__char_console_fopen_08 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(staticReturnsTrue()) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"<start> data = dataBuffer <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
pFile = FOPEN <start> data <end> , ""wb+"");"	3
c8600b00-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_listen_socket_open_11 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(globalReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"<start> data = dataBuffer <end> ;
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = OPEN(data, O_RDWR|O_CREAT, <start> S_IREAD|S_IWRITE <end> );"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	0
b1b80813-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE197_Numeric_Truncation_Error__int_listen_socket_to_char_66b_badSink(int dataArray[]) { int data = dataArray[2]; { char charData = (char)data; printHexCharLine(charData); } }"	where is the vulnerable dataflow from charData to printHexCharLine ?	"void CWE197_Numeric_Truncation_Error__int_listen_socket_to_char_66b_badSink(int <start> dataArray <end> []);
printHexCharLine <start> charData <end> );"	"printHexCharLine <start> charData <end> );
char <start> charData = (char)data <end> ;"	"printHexCharLine <start> charData <end> );
<start> printHexCharLine(charData) <end> ;"	"printHexCharLine <start> charData <end> );
void CWE197_Numeric_Truncation_Error__int_listen_socket_to_char_66b_badSink(int <start> dataArray <end> []);"	0
9059f3b2-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_66b_badSink(int dataArray[]) { int data = dataArray[2]; { size_t i; int *intPointer; intPointer = (int*)malloc(data * sizeof(int)); if (intPointer == NULL) {exit(-1);} for (i = 0; i < (size_t)data; i++) { intPointer[i] = 0; } printIntLine(intPointer[0]); free(intPointer); } }"	where is the vulnerable dataflow from data to malloc ?	"intPointer = <start> (int*)malloc(data * sizeof(int)) <end> ;
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_66b_badSink(int <start> dataArray <end> []);"	"void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_66b_badSink(int <start> dataArray <end> []);
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	"intPointer = (int*)malloc <start> data * sizeof(int) <end> );
intPointer = <start> (int*)malloc(data * sizeof(int)) <end> ;"	"intPointer = (int*)malloc <start> data * sizeof(int) <end> );
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_66b_badSink(int <start> dataArray <end> []);"	1
47a2a80e-6c15-11ed-81d4-94e6f77dd552	"void CWE190_Integer_Overflow__int_fscanf_add_13_bad() { int data; data = 0; if(GLOBAL_CONST_FIVE==5) { fscanf(stdin, ""%d"", &data); } if(GLOBAL_CONST_FIVE==5) { { int result = data + 1; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"fscanf(stdin, ""%d"", <start> &data <end> );
int result = <start> data <end>  + 1;"	"<start> data = 0 <end> ;
int result = <start> data <end>  + 1;"	"<start> printIntLine(result) <end> ;
fscanf(stdin, ""%d"", <start> &data <end> );"	"int result = <start> data <end>  + 1;
fscanf(stdin, ""%d"", <start> &data <end> );"	0
61da6718-6c15-11ed-81d4-94e6f77dd552	static void badSink(short data) { { short result = data + 1; printIntLine(result); } } void CWE190_Integer_Overflow__short_rand_add_44_bad() { short data; void (*funcPtr) (short) = badSink; data = 0; data = (short)RAND32(); funcPtr(data); }	where is the vulnerable dataflow from data ?	"funcPtr <start> data <end> );
data = (short <start> RAND32() <end> ;
static void badSink(short <start> data <end> );
<start> printIntLine(result) <end> ;"	"data = (short <start> RAND32() <end> ;
funcPtr <start> data <end> );
static void badSink(short <start> data <end> );
short result = <start> data <end>  + 1;"	"data = (short <start> RAND32() <end> ;
static void badSink(short <start> data <end> );"	"data = (short <start> RAND32() <end> ;
static void badSink(short <start> data <end> );
funcPtr <start> data <end> );
short <start> result = data + 1 <end> ;"	1
a109490f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_square_16_bad() { int data; data = 0; while(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; } while(1) { { int result = data * data; printIntLine(result); } break; } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"data = <start> atoi(inputBuffer) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printIntLine(result) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	3
a49c4f6d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_square_13_bad() { int data; data = 0; if(GLOBAL_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(GLOBAL_CONST_FIVE==5) { { int result = data * data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printIntLine(result) <end> ;"	"if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );
printIntLine <start> result <end> );"	"int <start> result = data * data <end> ;
printIntLine <start> result <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	3
93ece312-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING ""hello"" static size_t CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_45_badData; static size_t CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_45_goodG2BData; static size_t CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_45_goodB2GData; static void badSink() { size_t data = CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_45_badData; { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); } else { printLine(""Input is less than the length of the source string""); } } } void CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_45_bad() { size_t data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = strtoul(inputBuffer, NULL, 0); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_45_badData = data; badSink(); }"	where is the vulnerable dataflow from data to malloc ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_45_badData = data <end> ;
static size_t <start> CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_45_badData <end> ;
size_t data = <start> CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_45_badData <end> ;
myString = (char *)malloc <start> data*sizeof(char) <end> );"	"size_t data = <start> CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_45_badData <end> ;
<start> CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_45_badData = data <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static size_t <start> CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_45_badData <end> ;
<start> printLine(myString) <end> ;"	"<start> CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_45_badData = data <end> ;
static size_t <start> CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_45_badData <end> ;
<start> printLine(myString) <end> ;
myString = (char *)malloc <start> data*sizeof(char) <end> );
size_t data = <start> CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_45_badData <end> ;"	"size_t data = <start> CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_45_badData <end> ;
<start> CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_45_badData = data <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
if  <start> recvResult == SOCKET_ERROR <end>  || recvResult == 0);
myString = (char *)malloc <start> data*sizeof(char) <end> );"	0
9d745387-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE127_Buffer_Underread__CWE839_connect_socket_01_bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { int buffer[10] = { 0 }; if (data < 10) { printIntLine(buffer[data]); } else { printLine(""ERROR: Array index is too big.""); } } }"	where is the vulnerable dataflow from buffer[data] to printIntLine ?	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> buffer[data] <end> );"	"printIntLine <start> buffer[data] <end> );
recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);"	"int <start> buffer[10] = { 0 } <end> ;
printIntLine <start> buffer[data] <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[data] <end> );"	3
977ea78d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink(int data) { { int i; int buffer[10] = { 0 }; if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } } } void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_41_bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badSink(data); }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"static void badSink(int <start> data <end> );
<start> data = -1 <end> ;
printIntLine <start> buffer[i] <end> );
badSink <start> data <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSink <start> data <end> );
static void badSink(int <start> data <end> );
printIntLine <start> buffer[i] <end> );"	"static void badSink(int <start> data <end> );
printIntLine <start> buffer[i] <end> );
badSink <start> data <end> );
<start> data = atoi(inputBuffer) <end> ;"	"badSink <start> data <end> );
recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);
printIntLine <start> buffer[i] <end> );
static void badSink(int <start> data <end> );"	1
964cdbf6-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FULL_COMMAND ""dir "" #else #define FULL_COMMAND ""ls "" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define POPEN _popen #define PCLOSE _pclose #else #define POPEN popen #define PCLOSE pclose #endif namespace CWE78_OS_Command_Injection__char_file_popen_43 { static void badSource(char * &data) { { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } void bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; badSource(data); { FILE *pipe; pipe = POPEN(data, ""w""); if (pipe != NULL) { PCLOSE(pipe); } } }"	where is the vulnerable dataflow from data to POPEN ?	"pipe = POPEN <start> data <end> , ""w"");
badSource <start> data <end> );
<start> data = data_buf <end> ;"	"pipe = POPEN <start> data <end> , ""w"");
badSource <start> data <end> );
<start> badSource(data) <end> ;"	"pipe = POPEN <start> data <end> , ""w"");
badSource <start> data <end> );
pipe = <start> POPEN(data, ""w"") <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
badSource <start> data <end> );
pipe = POPEN <start> data <end> , ""w"");"	3
bda4e427-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define EXECL _execl #else #define EXECL execl #endif static char * CWE78_OS_Command_Injection__char_listen_socket_execl_45_badData; static char * CWE78_OS_Command_Injection__char_listen_socket_execl_45_goodG2BData; static void badSink() { char * data = CWE78_OS_Command_Injection__char_listen_socket_execl_45_badData; EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL); } void CWE78_OS_Command_Injection__char_listen_socket_execl_45_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE78_OS_Command_Injection__char_listen_socket_execl_45_badData = data; badSink(); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECL ?	"<start> CWE78_OS_Command_Injection__char_listen_socket_execl_45_badData = data <end> ;
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
static char * <start> CWE78_OS_Command_Injection__char_listen_socket_execl_45_badData <end> ;
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
char * data = <start> CWE78_OS_Command_Injection__char_listen_socket_execl_45_badData <end> ;"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
<start> CWE78_OS_Command_Injection__char_listen_socket_execl_45_badData = data <end> ;
static char * <start> CWE78_OS_Command_Injection__char_listen_socket_execl_45_badData <end> ;
char * data = <start> CWE78_OS_Command_Injection__char_listen_socket_execl_45_badData <end> ;
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
size_t dataLen = <start> strlen(data) <end> ;
<start> CWE78_OS_Command_Injection__char_listen_socket_execl_45_badData = data <end> ;
static char * <start> CWE78_OS_Command_Injection__char_listen_socket_execl_45_badData <end> ;
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"size_t dataLen = <start> strlen(data) <end> ;
char * data = <start> CWE78_OS_Command_Injection__char_listen_socket_execl_45_badData <end> ;
static char * <start> CWE78_OS_Command_Injection__char_listen_socket_execl_45_badData <end> ;
<start> CWE78_OS_Command_Injection__char_listen_socket_execl_45_badData = data <end> ;
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	1
4a021153-6c15-11ed-81d4-94e6f77dd552	"void CWE190_Integer_Overflow__short_fscanf_add_15_bad() { short data; data = 0; switch(6) { case 6: fscanf (stdin, ""%hd"", &data); break; default: printLine(""Benign, fixed string""); break; } switch(7) { case 7: { short result = data + 1; printIntLine(result); } break; default: printLine(""Benign, fixed string""); break; } }"	where is the vulnerable dataflow from data ?	"short <start> result = data + 1 <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );"	"short result = <start> data <end>  + 1;
<start> printIntLine(result) <end> ;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
short result = <start> data <end>  + 1;"	"short result = <start> data + 1 <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );"	2
7c1275a2-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_65b_badSink(int data) { { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	"void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_65b_badSink(int <start> data <end> );
printLine <start> dest <end> );"	"printLine <start> dest <end> );
void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_65b_badSink(int <start> data <end> );"	"<start> memcpy(dest, source, data) <end> ;
void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_65b_badSink(int <start> data <end> );"	1
8f278a63-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_43 { static void badSource(int &data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } void bad() { int data; data = -1; badSource(data); { size_t i; int *intPointer; intPointer = (int*)malloc(data * sizeof(int)); if (intPointer == NULL) {exit(-1);} for (i = 0; i < (size_t)data; i++) { intPointer[i] = 0; } printIntLine(intPointer[0]); free(intPointer); } }"	where is the vulnerable dataflow from data to malloc ?	"intPointer = (int*)malloc <start> data * sizeof(int) <end> );
badSource <start> data <end> );
<start> badSource(data) <end> ;"	"<start> intPointer = (int*)malloc(data * sizeof(int)) <end> ;
intPointer = (int*)malloc <start> data * sizeof(int) <end> );
badSource <start> data <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSource <start> data <end> );
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
intPointer = (int*)malloc <start> data * sizeof(int) <end> );
badSource <start> data <end> );"	2
4db33f6e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticFive = 5; void CWE190_Integer_Overflow__int_connect_socket_postinc_07_bad() { int data; data = 0; if(staticFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticFive==5) { { data++; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);
<start> data <end> ++;"	"<start> data++ <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data <end> ++;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
data = <start> atoi(inputBuffer) <end> ;"	2
c4cd6f7a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_file_fopen_61 { char * badSource(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; data = badSource(data); { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"<start> data = badSource(data) <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"char <start> dataBuffer[FILENAME_MAX] = BASEPATH <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"data = <start> badSource <end> (data);
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	"data = <start> badSource <end> (data);
pFile = FOPEN <start> data <end> , ""wb+"");"	3
c72d5d66-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_listen_socket_fopen_54 { void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badSink_b(data); }"	where is the vulnerable dataflow from data to badSink_b ?	"if  <start> recvResult == SOCKET_ERROR <end>  || recvResult == 0);
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
badSink_b <start> data <end> );"	"size_t dataLen = <start> strlen(data) <end> ;
badSink_b <start> data <end> );"	"badSink_b <start> data <end> );
replace = <start> strchr(data, '\r') <end> ;"	1
af58097b-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE197_Numeric_Truncation_Error__int_fgets_to_char_11_bad() { int data; data = -1; if(globalReturnsTrue()) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } { char charData = (char)data; printHexCharLine(charData); } }"	where is the vulnerable dataflow from charData to printHexCharLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printHexCharLine <start> charData <end> );"	"if  <start> fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) <end>  != NULL);
printHexCharLine <start> charData <end> );"	"printHexCharLine <start> charData <end> );
<start> data = atoi(inputBuffer) <end> ;"	"if  <start> fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) <end>  != NULL);
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	0
6dc614fe-6c15-11ed-81d4-94e6f77dd552	#ifndef _WIN32 #endif namespace CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_72 { static void badVaSink(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); va_end(args); } } void badSink(vector<char *> dataVector) { char * data = dataVector[2]; badVaSink(data, data); }	where is the vulnerable dataflow from data to vprintf ?	"void badSink(vector<char *> <start> dataVector <end> );
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
vprintf <start> data <end> , args);"	"<start> vprintf(data, args) <end> ;
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
vprintf <start> data <end> , args);"	"badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
vprintf <start> data <end> , args);"	"static void badVaSink(char * <start> data <end> , ...);
badVaSink <start> data <end> , data);"	0
bb49c598-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #define EXECLP _execlp #else #define EXECLP execlp #endif void CWE78_OS_Command_Injection__char_console_execlp_01_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECLP ?	"EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"size_t dataLen = <start> strlen(data) <end> ;
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"<start> EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	1
c8600ae3-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 namespace CWE23_Relative_Path_Traversal__char_listen_socket_ofstream_13 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(GLOBAL_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"size_t <start> dataLen = strlen(data) <end> ;
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"outputFile.open((char * <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	"outputFile.open((char * <start> data <end> );
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
outputFile.open((char * <start> data <end> );"	3
9fe7ad45-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_add_09_bad() { int data; data = 0; if(GLOBAL_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(GLOBAL_CONST_TRUE) { { int result = data + 1; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
<start> data = 0 <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
data = <start> atoi(inputBuffer) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	2
669edaa7-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__int_rand_square_62 { void badSource(int &data); void bad() { int data; data = 0; badSource(data); { int result = data * data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  * data;"	"badSource <start> data <end> );
<start> printIntLine(result) <end> ;"	"int result = <start> data <end>  * data;
badSource <start> data <end> );"	"badSource <start> data <end> );
int result = <start> data <end>  * data;"	3
80d9872a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_console_open_16 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; while(1) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } break; } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
size_t dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	2
598370d5-6c15-11ed-81d4-94e6f77dd552	namespace CWE191_Integer_Underflow__short_fscanf_sub_62 { void badSource(short &data); void bad() { short data; data = 0; badSource(data); { short result = data - 1; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"short result = <start> data <end>  - 1;
<start> data = 0 <end> ;"	"badSource <start> data <end> );
short result = <start> data <end>  - 1;"	"short result = <start> data <end>  - 1;
badSource <start> data <end> );"	"badSource <start> data <end> );
<start> printIntLine(result) <end> ;"	1
85b15ed1-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_FIVE = 5; void CWE369_Divide_by_Zero__int_connect_socket_modulo_06_bad() { int data; data = -1; if(STATIC_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(STATIC_CONST_FIVE==5) { printIntLine(100 % data); } }"	where is the vulnerable dataflow from data to printIntLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> 100 % data <end> );"	"printIntLine <start> 100 % data <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"printIntLine <start> 100 % data <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"printIntLine <start> 100 % data <end> );
recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);"	0
9187cc0d-6c15-11ed-81d4-94e6f77dd552	"#define SEARCH_CHAR 'S' void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_console_64b_badSink(void * dataVoidPtr) { char * * dataPtr = (char * *)dataVoidPtr; char * data = (*dataPtr); for (; *data != '\0'; data++) { if (*data == SEARCH_CHAR) { printLine(""We have a match!""); break; } } free(data); }"	where is the vulnerable dataflow from data to free ?	"char <start> * data = (*dataPtr) <end> ;
void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_console_64b_badSink(void * <start> dataVoidPtr <end> );"	"free <start> data <end> );
<start> free(data) <end> ;"	"void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_console_64b_badSink(void * <start> dataVoidPtr <end> );
free <start> data <end> );"	"free <start> data <end> );
void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_console_64b_badSink(void * <start> dataVoidPtr <end> );"	2
af580934-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) int CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_61b_badSource(int data); void CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_61_bad() { int data; data = -1; data = CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_61b_badSource(data); { char charData = (char)data; printHexCharLine(charData); } }"	where is the vulnerable dataflow from charData to printHexCharLine ?	"char charData = <start> (char)data <end> ;
data = <start> CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_61b_badSource <end> (data);"	"data = <start> CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_61b_badSource <end> (data);
printHexCharLine <start> charData <end> );"	"printHexCharLine <start> charData <end> );
data = <start> CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_61b_badSource(data) <end> ;"	"data = <start> CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_61b_badSource <end> (data);
<start> printHexCharLine(charData) <end> ;"	1
435200ec-6c15-11ed-81d4-94e6f77dd552	"static int64_t badSource(int64_t data) { fscanf (stdin, ""%"" SCNd64, &data); return data; } void CWE190_Integer_Overflow__int64_t_fscanf_add_42_bad() { int64_t data; data = 0LL; data = badSource(data); { int64_t result = data + 1; printLongLongLine(result); } }"	where is the vulnerable dataflow from data ?	"fscanf (stdin, ""%"" SCNd64, <start> &data <end> );
static int64_t <start> badSource <end> (int64_t data);
data = <start> badSource <end> (data);
int64_t result = <start> data <end>  + 1;"	"fscanf (stdin, ""%"" SCNd64, <start> &data <end> );
static int64_t <start> badSource <end> (int64_t data);"	"fscanf (stdin, ""%"" SCNd64, <start> &data <end> );
static int64_t <start> badSource <end> (int64_t data);
data = <start> badSource <end> (data);"	"data = <start> badSource <end> (data);
static int64_t <start> badSource <end> (int64_t data);
fscanf (stdin, ""%"" SCNd64, <start> &data <end> );
int64_t result = <start> data <end>  + 1;"	0
acf67e5e-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) extern int CWE191_Integer_Underflow__int_fgets_predec_68_badData; extern int CWE191_Integer_Underflow__int_fgets_predec_68_goodG2BData; extern int CWE191_Integer_Underflow__int_fgets_predec_68_goodB2GData; void CWE191_Integer_Underflow__int_fgets_predec_68b_badSink() { int data = CWE191_Integer_Underflow__int_fgets_predec_68_badData; { --data; int result = data; printIntLine(result); } }	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
int data = <start> CWE191_Integer_Underflow__int_fgets_predec_68_badData <end> ;"	"int data = <start> CWE191_Integer_Underflow__int_fgets_predec_68_badData <end> ;
<start> --data <end> ;"	"int data = <start> CWE191_Integer_Underflow__int_fgets_predec_68_badData <end> ;
<start> printIntLine(result) <end> ;"	"int data = <start> CWE191_Integer_Underflow__int_fgets_predec_68_badData <end> ;
printIntLine <start> result <end> );"	3
c4cd6f51-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_environment_open_64 { void badSink(void * dataVoidPtr) { char * * dataPtr = (char * *)dataVoidPtr; char * data = (*dataPtr); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
void badSink(void * <start> dataVoidPtr <end> );"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);"	"void badSink(void * <start> dataVoidPtr <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	3
69161b46-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__int_rand_preinc_63b_badSink(int * dataPtr) { int data = *dataPtr; { ++data; int result = data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"int <start> data = *dataPtr <end> ;
+ <start> data <end> ;"	"void CWE190_Integer_Overflow__int_rand_preinc_63b_badSink(int * <start> dataPtr <end> );
+ <start> data <end> ;"	"int <start> result = data <end> ;
+ <start> data <end> ;"	"int <start> result = data <end> ;
void CWE190_Integer_Overflow__int_rand_preinc_63b_badSink(int * <start> dataPtr <end> );"	1
61da673a-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__short_rand_multiply_18_bad() { short data; data = 0; goto source; source: data = (short)RAND32(); goto sink; sink: if(data > 0) { short result = data * 2; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"data = (short <start> RAND32() <end> ;
short result = <start> data <end>  * 2;"	"short result = <start> data <end>  * 2;
<start> printIntLine(result) <end> ;"	"short result = <start> data * 2 <end> ;
data = (short <start> RAND32() <end> ;"	"<start> printIntLine(result) <end> ;
data = (short <start> RAND32() <end> ;"	0
6b862439-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) int CWE122_Heap_Based_Buffer_Overflow__c_CWE129_connect_socket_61b_badSource(int data); void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_connect_socket_61_bad() { int data; data = -1; data = CWE122_Heap_Based_Buffer_Overflow__c_CWE129_connect_socket_61b_badSource(data); { int i; int * buffer = (int *)malloc(10 * sizeof(int)); if (buffer == NULL) {exit(-1);} for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } free(buffer); } }"	where is the vulnerable dataflow from buffer to free ?	"data = <start> CWE122_Heap_Based_Buffer_Overflow__c_CWE129_connect_socket_61b_badSource <end> (data);
free <start> buffer <end> );"	"free <start> buffer <end> );
<start> printIntLine(buffer[i]) <end> ;"	"if  <start> buffer == NULL <end> ) {exit(-1);};
free <start> buffer <end> );"	"data = <start> CWE122_Heap_Based_Buffer_Overflow__c_CWE129_connect_socket_61b_badSource <end> (data);
<start> free(buffer) <end> ;"	0
87ff9851-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_connect_socket_fopen_41 { void badSink(char * data) { { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } } void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badSink(data); }"	where is the vulnerable dataflow from data to FOPEN ?	"void badSink(char * <start> data <end> );
pFile = FOPEN <start> data <end> , ""wb+"");
<start> badSink(data) <end> ;
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"replace = <start> strchr(data, '\n') <end> ;
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
void badSink(char * <start> data <end> );
badSink <start> data <end> );"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
badSink <start> data <end> );
void badSink(char * <start> data <end> );
pFile = FOPEN <start> data <end> , ""wb+"");"	"void badSink(char * <start> data <end> );
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
badSink <start> data <end> );
pFile = FOPEN <start> data <end> , ""wb+"");"	2
669edae0-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__int_rand_postinc_09_bad() { int data; data = 0; if(GLOBAL_CONST_TRUE) { data = RAND32(); } if(GLOBAL_CONST_TRUE) { { data++; int result = data; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"data = <start> RAND32() <end> ;
<start> data <end> ++;"	"data = <start> RAND32() <end> ;
int <start> result = data <end> ;"	"<start> data <end> ++;
data = <start> RAND32() <end> ;"	"<start> data <end> ++;
<start> printIntLine(result) <end> ;"	0
951c5e78-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FULL_COMMAND ""dir "" #else #define FULL_COMMAND ""ls "" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define POPEN _popen #define PCLOSE _pclose #else #define POPEN popen #define PCLOSE pclose #endif namespace CWE78_OS_Command_Injection__char_connect_socket_popen_43 { static void badSource(char * &data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } void bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; badSource(data); { FILE *pipe; pipe = POPEN(data, ""w""); if (pipe != NULL) { PCLOSE(pipe); } } }"	where is the vulnerable dataflow from data to POPEN ?	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
badSource <start> data <end> );
pipe = POPEN <start> data <end> , ""w"");"	"pipe = POPEN <start> data <end> , ""w"");
badSource <start> data <end> );
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"pipe = POPEN <start> data <end> , ""w"");
badSource <start> data <end> );
replace = <start> strchr(data, '\r') <end> ;"	"badSource <start> data <end> );
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	0
a1094911-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_square_18_bad() { int data; data = 0; goto source; source: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } goto sink; sink: { int result = data * data; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"data = <start> atoi(inputBuffer) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"printIntLine <start> result <end> );
<start> data = atoi(inputBuffer) <end> ;"	"printIntLine <start> result <end> );
data = <start> atoi(inputBuffer) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	3
99e16a9b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticTrue = 1; static int staticFalse = 0; void CWE124_Buffer_Underwrite__CWE839_connect_socket_05_bad() { int data; data = -1; if(staticTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticTrue) { { int i; int buffer[10] = { 0 }; if (data < 10) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } } } }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[i] <end> );"	"<start> printIntLine(buffer[i]) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> buffer[i] <end> );"	"printIntLine <start> buffer[i] <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	0
a36a78ee-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_add_13_bad() { int data; data = 0; if(GLOBAL_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(GLOBAL_CONST_FIVE==5) { { int result = data + 1; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"data = <start> atoi(inputBuffer) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
data = <start> atoi(inputBuffer) <end> ;"	"printIntLine <start> result <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	1
b54bcf2f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 20 void CWE369_Divide_by_Zero__float_listenSocket_17_bad() { int i,j; float data; data = 0.0F; for(i = 0; i < 1; i++) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = (float)atof(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } for(j = 0; j < 1; j++) { { int result = (int)(100.0 / data); printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"data = (float <start> atof(inputBuffer) <end> ;
printIntLine <start> result <end> );"	"<start> printIntLine(result) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> result <end> );"	0
656cd3c8-6c15-11ed-81d4-94e6f77dd552	typedef union { int unionFirst; int unionSecond; } CWE190_Integer_Overflow__int_rand_add_34_unionType; void CWE190_Integer_Overflow__int_rand_add_34_bad() { int data; CWE190_Integer_Overflow__int_rand_add_34_unionType myUnion; data = 0; data = RAND32(); myUnion.unionFirst = data; { int data = myUnion.unionSecond; { int result = data + 1; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"int <start> result = data + 1 <end> ;
data = <start> RAND32() <end> ;"	"int result = <start> data <end>  + 1;
data = <start> RAND32() <end> ;"	"data = <start> RAND32() <end> ;
int result = <start> data <end>  + 1;"	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  + 1;"	2
a95fd856-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_fgets_sub_14_bad() { int data; data = 0; if(globalFive==5) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(globalFive==5) { { int result = data - 1; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
int <start> result = data - 1 <end> ;"	"printIntLine <start> result <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"printIntLine <start> result <end> );
int result = <start> data - 1 <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );"	3
6c938bd2-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int badStatic = 0; static void badSink(int data) { if(badStatic) { { int i; int * buffer = (int *)malloc(10 * sizeof(int)); if (buffer == NULL) {exit(-1);} for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } free(buffer); } } } void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_21_bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badStatic = 1; badSink(data); }"	where is the vulnerable dataflow from buffer to free ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> badSink(data) <end> ;
badSink <start> data <end> );
static void badSink(int <start> data <end> );"	"static void badSink(int <start> data <end> );
badSink <start> data <end> );
free <start> buffer <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSink <start> data <end> );
static void badSink(int <start> data <end> );
free <start> buffer <end> );"	"static void badSink(int <start> data <end> );
free <start> buffer <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> free(buffer) <end> ;"	2
a95fd82d-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_fgets_multiply_16_bad() { int data; data = 0; while(1) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } break; } while(1) { if(data < 0) { int result = data * 2; printIntLine(result); } break; } }"	where is the vulnerable dataflow from result to printIntLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> printIntLine(result) <end> ;"	"printIntLine <start> result <end> );
int <start> result = data * 2 <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
if <start> data < 0 <end> ) ;"	2
c4cd6f5a-6c15-11ed-81d4-94e6f77dd552	#ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_environment_open_82 { void CWE23_Relative_Path_Traversal__char_environment_open_82_bad::action(char * data) { { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } } }	where is the vulnerable dataflow from data to OPEN ?	"void CWE23_Relative_Path_Traversal__char_environment_open_82_bad::action(char * <start> data <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
void CWE23_Relative_Path_Traversal__char_environment_open_82_bad::action(char * <start> data <end> );"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
void CWE23_Relative_Path_Traversal__char_environment_open_82_bad::action(char * <start> data <end> );"	0
67d010a9-6c15-11ed-81d4-94e6f77dd552	static int staticTrue = 1; static int staticFalse = 0; void CWE190_Integer_Overflow__short_rand_postinc_05_bad() { short data; data = 0; if(staticTrue) { data = (short)RAND32(); } if(staticTrue) { { data++; short result = data; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"<start> data <end> ++;
<start> printIntLine(result) <end> ;"	"data = (short <start> RAND32() <end> ;
<start> printIntLine(result) <end> ;"	"<start> data++ <end> ;
data = (short <start> RAND32() <end> ;"	"data = (short <start> RAND32() <end> ;
<start> data <end> ++;"	3
b7b09a37-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define NEW_PATH ""%SystemRoot%\\system32"" #define PUTENV _putenv #else #define NEW_PATH ""/bin"" #define PUTENV putenv #endif void CWE427_Uncontrolled_Search_Path_Element__char_console_13_bad() { char * data; char dataBuffer[250] = ""PATH=""; data = dataBuffer; if(GLOBAL_CONST_FIVE==5) { { size_t dataLen = strlen(data); if (250-dataLen > 1) { if (fgets(data+dataLen, (int)(250-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } PUTENV(data); }"	where is the vulnerable dataflow from data to PUTENV ?	"if (fgets <start> data+dataLen <end> , (int)(250-dataLen), stdin) != NULL);
<start> PUTENV(data) <end> ;"	"dataLen = <start> strlen(data) <end> ;
PUTENV <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(250-dataLen), stdin) != NULL);
PUTENV <start> data <end> );"	"if (dataLen > 0 && <start> data[dataLen-1] == '\n' <end> );
if (fgets <start> data+dataLen <end> , (int)(250-dataLen), stdin) != NULL);"	2
7fa68e05-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_16_bad() { int data; data = -1; while(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printLine(dest) <end> ;"	"if  <start> data < 100 <end> );
printLine <start> dest <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"printLine <start> dest <end> );
<start> data = atoi(inputBuffer) <end> ;"	2
c4cd6f81-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_file_fopen_73 { void badSink(list<char *> dataList) { char * data = dataList.back(); { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"void badSink(list<char *> <start> dataList <end> );
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"void badSink(list<char *> <start> dataList <end> );
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	"pFile = FOPEN <start> data <end> , ""wb+"");
void badSink(list<char *> <start> dataList <end> );"	0
92bb89f8-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define SEARCH_CHAR 'S' static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_04_bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\0'; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } if(STATIC_CONST_TRUE) { for (; *data != '\0'; data++) { if (*data == SEARCH_CHAR) { printLine(""We have a match!""); break; } } free(data); } }"	where is the vulnerable dataflow from data to free ?	"free <start> data <end> );
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
for (; *data != '\0'; <start> data++ <end> );"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
free <start> data <end> );"	"for (; *data != '\0'; <start> data++ <end> );
free <start> data <end> );"	2
55ef4cb1-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_fgets_multiply_53d_badSink(int data) { if(data < 0) { int result = data * 2; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"int result = <start> data * 2 <end> ;
void CWE191_Integer_Underflow__int_fgets_multiply_53d_badSink(int <start> data <end> );"	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  * 2;"	"if <start> data < 0 <end> ) ;
void CWE191_Integer_Underflow__int_fgets_multiply_53d_badSink(int <start> data <end> );"	"void CWE191_Integer_Underflow__int_fgets_multiply_53d_badSink(int <start> data <end> );
int result = <start> data <end>  * 2;"	3
bb49c593-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #define EXECL _execl #else #define EXECL execl #endif static void badSink(char * data) { EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL); } void CWE78_OS_Command_Injection__char_console_execl_44_bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } funcPtr(data); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECL ?	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
funcPtr <start> data <end> );
<start> data = dataBuffer <end> ;
static void badSink(char * <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
funcPtr <start> data <end> );
static void badSink(char * <start> data <end> );
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"static void badSink(char * <start> data <end> );
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
static void badSink(char * <start> data <end> );"	1
846ad342-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE369_Divide_by_Zero__int_connect_socket_divide_31_bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { int dataCopy = data; int data = dataCopy; printIntLine(100 / data); } }"	where is the vulnerable dataflow from data to printIntLine ?	"printIntLine <start> 100 / data <end> );
data = <start> atoi(inputBuffer) <end> ;"	"printIntLine <start> 100 / data <end> );
int <start> dataCopy = data <end> ;"	"printIntLine <start> 100 / data <end> );
recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> 100 / data <end> );"	3
8cc3a698-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(count) + 2) #ifdef _WIN32 #define SLEEP Sleep #else #define SLEEP usleep #endif static int badStatic = 0; static void badSink(int count) { if(badStatic) { SLEEP(count); printLine(""Sleep time possibly too long""); } } void CWE400_Resource_Exhaustion__listen_socket_sleep_21_bad() { int count; count = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; count = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badStatic = 1; badSink(count); }"	where is the vulnerable dataflow from count to SLEEP ?	"badSink <start> count <end> );
static void badSink(int <start> count <end> );
count = <start> atoi(inputBuffer) <end> ;
SLEEP <start> count <end> );"	"if  <start> recvResult == SOCKET_ERROR <end>  || recvResult == 0);
badSink <start> count <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
SLEEP <start> count <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSink <start> count <end> );
static void badSink(int <start> count <end> );
SLEEP <start> count <end> );"	"SLEEP <start> count <end> );
static void badSink(int <start> count <end> );
<start> count = atoi(inputBuffer) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	2
bb49c5a5-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #define EXECLP _execlp #else #define EXECLP execlp #endif void CWE78_OS_Command_Injection__char_console_execlp_14_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(globalFive==5) { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECLP ?	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	"dataLen = <start> strlen(data) <end> ;
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"<start> data = dataBuffer <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	0
a1094917-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int badSource(int data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } return data; } void CWE190_Integer_Overflow__int_connect_socket_square_42_bad() { int data; data = 0; data = badSource(data); { int result = data * data; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"data = <start> atoi(inputBuffer) <end> ;
printIntLine <start> result <end> );
data = <start> badSource <end> (data);
static int <start> badSource <end> (int data);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static int <start> badSource <end> (int data);
data = <start> badSource <end> (data);
printIntLine <start> result <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );
data = <start> badSource <end> (data);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static int <start> badSource <end> (int data);
printIntLine <start> result <end> );
data = <start> badSource <end> (data);"	1
a23a3e3b-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) extern int CWE190_Integer_Overflow__int_fgets_multiply_68_badData; extern int CWE190_Integer_Overflow__int_fgets_multiply_68_goodG2BData; extern int CWE190_Integer_Overflow__int_fgets_multiply_68_goodB2GData; void CWE190_Integer_Overflow__int_fgets_multiply_68b_badSink() { int data = CWE190_Integer_Overflow__int_fgets_multiply_68_badData; if(data > 0) { int result = data * 2; printIntLine(result); } }	where is the vulnerable dataflow from result to printIntLine ?	"<start> printIntLine(result) <end> ;
int data = <start> CWE190_Integer_Overflow__int_fgets_multiply_68_badData <end> ;"	"printIntLine <start> result <end> );
int <start> result = data * 2 <end> ;"	"int data = <start> CWE190_Integer_Overflow__int_fgets_multiply_68_badData <end> ;
printIntLine <start> result <end> );"	"int result = <start> data * 2 <end> ;
printIntLine <start> result <end> );"	2
445c11f4-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_add_15_bad() { int data; data = 0; switch(6) { case 6: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; default: printLine(""Benign, fixed string""); break; } switch(7) { case 7: { int result = data + 1; printIntLine(result); } break; default: printLine(""Benign, fixed string""); break; } }"	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  + 1;
recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);"	"int result = <start> data <end>  + 1;
<start> printIntLine(result) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printIntLine(result) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  + 1;"	3
8932180e-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_file_fopen_09 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(GLOBAL_CONST_TRUE) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
pFile = FOPEN <start> data <end> , ""wb+"");"	"<start> data = dataBuffer <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"<start> data = dataBuffer <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	1
54c5820b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_connect_socket_sub_03_bad() { int data; data = 0; if(5==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(5==5) { { int result = data - 1; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  - 1;"	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  - 1;"	"<start> printIntLine(result) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"int result = <start> data <end>  - 1;
recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);"	0
55ef4cdb-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_fgets_sub_52c_badSink(int data) { { int result = data - 1; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"void CWE191_Integer_Underflow__int_fgets_sub_52c_badSink(int <start> data <end> );
<start> printIntLine(result) <end> ;"	"void CWE191_Integer_Underflow__int_fgets_sub_52c_badSink(int <start> data <end> );
int result = <start> data <end>  - 1;"	"int <start> result = data - 1 <end> ;
void CWE191_Integer_Underflow__int_fgets_sub_52c_badSink(int <start> data <end> );"	"int result = <start> data <end>  - 1;
void CWE191_Integer_Underflow__int_fgets_sub_52c_badSink(int <start> data <end> );"	1
5f76fca1-6c15-11ed-81d4-94e6f77dd552	"static const int STATIC_CONST_FIVE = 5; void CWE191_Integer_Underflow__short_fscanf_predec_06_bad() { short data; data = 0; if(STATIC_CONST_FIVE==5) { fscanf (stdin, ""%hd"", &data); } if(STATIC_CONST_FIVE==5) { { --data; short result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"fscanf (stdin, ""%hd"", <start> &data <end> );
<start> printIntLine(result) <end> ;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
- <start> data <end> ;"	"<start> printIntLine(result) <end> ;
- <start> data <end> ;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
<start> --data <end> ;"	1
9b124d96-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE124_Buffer_Underwrite__CWE839_listen_socket_01_bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { int i; int buffer[10] = { 0 }; if (data < 10) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } } }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"printIntLine <start> buffer[i] <end> );
if  <start> acceptSocket == SOCKET_ERROR <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[i] <end> );"	"data = <start> atoi(inputBuffer) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
if  <start> acceptSocket == SOCKET_ERROR <end> );"	1
b2ea8db5-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 8 void CWE197_Numeric_Truncation_Error__short_fgets_01_bad() { short data; data = -1; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = (short)atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } { char charData = (char)data; printHexCharLine(charData); } }"	where is the vulnerable dataflow from charData to printHexCharLine ?	"printHexCharLine <start> charData <end> );
<start> printHexCharLine(charData) <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
char <start> charData = (char)data <end> ;"	"data = (short <start> atoi(inputBuffer) <end> ;
printHexCharLine <start> charData <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printHexCharLine <start> charData <end> );"	3
833ac90d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif static const int STATIC_CONST_FIVE = 5; namespace CWE23_Relative_Path_Traversal__char_listen_socket_fopen_06 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(STATIC_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = FOPEN <start> data <end> , ""wb+"");
replace = <start> strchr(data, '\n') <end> ;"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
char <start> dataBuffer[FILENAME_MAX] = BASEPATH <end> ;"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	2
5af03ded-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_connect_socket_postdec_01_bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { data--; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"<start> data <end> --;
<start> printIntLine(result) <end> ;"	"recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);
<start> data <end> --;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data <end> --;"	"int <start> result = data <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	2
73bc8149-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" void CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_16_bad() { short data; data = 0; while(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> memcpy(dest, source, data) <end> ;"	"if  <start> data < 100 <end> );
printLine <start> dest <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printLine <start> dest <end> );"	2
466e7ecf-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_multiply_02_bad() { int data; data = 0; if(1) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(1) { if(data > 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
int result = <start> data <end>  * 2;"	"int result = <start> data <end>  * 2;
<start> data = 0 <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
if <start> data > 0 <end> ) ;"	"int <start> result = data * 2 <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	0
7fa68e0d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int badSource(int data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } return data; } void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_42_bad() { int data; data = -1; data = badSource(data); { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static int <start> badSource <end> (int data);
data = <start> badSource <end> (data);
printLine <start> dest <end> );"	"static int <start> badSource <end> (int data);
printLine <start> dest <end> );
if  <start> acceptSocket == SOCKET_ERROR <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
if  <start> data < 100 <end> );
static int <start> badSource <end> (int data);
printLine <start> dest <end> );"	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
static int <start> badSource <end> (int data);
printLine <start> dest <end> );
data = <start> badSource <end> (data);"	0
7c1275a8-6c15-11ed-81d4-94e6f77dd552	"namespace CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_74 { void badSink(map<int, int> dataMap) { int data = dataMap[2]; { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"void badSink(map<int, int> <start> dataMap <end> );
printLine <start> dest <end> );"	"<start> memcpy(dest, source, data) <end> ;
printLine <start> dest <end> );"	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	"printLine <start> dest <end> );
if  <start> data < 100 <end> );"	0
bed4a8e9-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" namespace CWE23_Relative_Path_Traversal__char_connect_socket_ifstream_16 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; while(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; } { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"size_t dataLen = <start> strlen(data) <end> ;
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(connectSocket, (char *)(data + dataLen), <start> sizeof(char) * (FILENAME_MAX - dataLen - 1) <end> , 0);
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
inputFile.open((char * <start> data <end> );"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
inputFile.open((char * <start> data <end> );"	2
7d44fcd0-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_66b_badSink(int dataArray[]) { int data = dataArray[2]; if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }"	where is the vulnerable dataflow from data to malloc ?	"if  <start> data < 100 <end> );
char * dataBuffer = (char *)malloc <start> data <end> );"	"void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_66b_badSink(int <start> dataArray <end> []);
char * dataBuffer = (char *)malloc <start> data <end> );"	"<start> printLine(dataBuffer) <end> ;
void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_66b_badSink(int <start> dataArray <end> []);"	"<start> memset(dataBuffer, 'A', data-1) <end> ;
void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_66b_badSink(int <start> dataArray <end> []);"	1
820a46dc-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_file_open_11 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(globalReturnsTrue()) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
size_t dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	1
a830bfaf-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_connect_socket_sub_54e_badSink(int data) { { int result = data - 1; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"int <start> result = data - 1 <end> ;
printIntLine <start> result <end> );"	"void CWE191_Integer_Underflow__int_connect_socket_sub_54e_badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;"	"int <start> result = data - 1 <end> ;
void CWE191_Integer_Underflow__int_connect_socket_sub_54e_badSink(int <start> data <end> );"	1
87ff9854-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_connect_socket_fopen_44 { static void badSink(char * data) { { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } } void bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } funcPtr(data); }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = FOPEN <start> data <end> , ""wb+"");
static void badSink(char * <start> data <end> );
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
funcPtr <start> data <end> );"	"size_t dataLen = <start> strlen(data) <end> ;
funcPtr <start> data <end> );
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
funcPtr <start> data <end> );
static void badSink(char * <start> data <end> );
pFile = FOPEN <start> data <end> , ""wb+"");"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
funcPtr <start> data <end> );
static void badSink(char * <start> data <end> );"	2
93ece315-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING ""hello"" void CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_54e_badSink(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); } else { printLine(""Input is less than the length of the source string""); } } }"	where is the vulnerable dataflow from data to malloc ?	"myString = <start> (char *)malloc(data*sizeof(char)) <end> ;
myString = (char *)malloc <start> data*sizeof(char) <end> );"	"void CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_54e_badSink(size_t <start> data <end> );
myString = (char *)malloc <start> data*sizeof(char) <end> );"	"if  <start> data > strlen(HELLO_STRING) <end> );
myString = (char *)malloc <start> data*sizeof(char) <end> );"	"myString = (char *)malloc <start> data*sizeof(char) <end> );
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_54e_badSink(size_t <start> data <end> );"	1
d1e9da34-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_listen_socket_fopen_11 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(globalReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"<start> data = dataBuffer <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
char <start> dataBuffer[FILENAME_MAX] = """" <end> ;"	0
8a6310bd-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_file_open_13 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(GLOBAL_CONST_FIVE==5) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
<start> data = dataBuffer <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);"	2
964cdc05-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FULL_COMMAND ""dir "" #else #define FULL_COMMAND ""ls "" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define POPEN _popen #define PCLOSE _pclose #else #define POPEN popen #define PCLOSE pclose #endif static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; void CWE78_OS_Command_Injection__char_listen_socket_popen_04_bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; if(STATIC_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { FILE *pipe; pipe = POPEN(data, ""w""); if (pipe != NULL) { PCLOSE(pipe); } } }"	where is the vulnerable dataflow from data to POPEN ?	"replace = <start> strchr(data, '\r') <end> ;
pipe = POPEN <start> data <end> , ""w"");"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
pipe = POPEN <start> data <end> , ""w"");"	"size_t dataLen = <start> strlen(data) <end> ;
pipe = POPEN <start> data <end> , ""w"");"	"replace = <start> strchr(data, '\n') <end> ;
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	1
5133a76b-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink(int data) { { ++data; int result = data; printIntLine(result); } } void CWE190_Integer_Overflow__int_fgets_preinc_44_bad() { int data; void (*funcPtr) (int) = badSink; data = 0; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } funcPtr(data); }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
funcPtr <start> data <end> );
static void badSink(int <start> data <end> );"	"funcPtr <start> data <end> );
<start> printIntLine(result) <end> ;
+ <start> data <end> ;
static void badSink(int <start> data <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
funcPtr <start> data <end> );
static void badSink(int <start> data <end> );
+ <start> data <end> ;"	"<start> funcPtr(data) <end> ;
+ <start> data <end> ;
funcPtr <start> data <end> );
static void badSink(int <start> data <end> );"	2
99e16a9c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_FIVE = 5; void CWE124_Buffer_Underwrite__CWE839_connect_socket_06_bad() { int data; data = -1; if(STATIC_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(STATIC_CONST_FIVE==5) { { int i; int buffer[10] = { 0 }; if (data < 10) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } } } }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"<start> printIntLine(buffer[i]) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"data = <start> atoi(inputBuffer) <end> ;
printIntLine <start> buffer[i] <end> );"	"printIntLine <start> buffer[i] <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[i] <end> );"	3
761e2960-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 8 void CWE194_Unexpected_Sign_Extension__fgets_memcpy_51b_badSink(short data) { { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"void CWE194_Unexpected_Sign_Extension__fgets_memcpy_51b_badSink(short <start> data <end> );
<start> memcpy(dest, source, data) <end> ;"	"printLine <start> dest <end> );
<start> printLine(dest) <end> ;"	"printLine <start> dest <end> );
<start> memcpy(dest, source, data) <end> ;"	"void CWE194_Unexpected_Sign_Extension__fgets_memcpy_51b_badSink(short <start> data <end> );
printLine <start> dest <end> );"	3
acf67e1f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_connect_socket_predec_11_bad() { int data; data = 0; if(globalReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalReturnsTrue()) { { --data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"int <start> result = data <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"printIntLine <start> result <end> );
recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);"	"printIntLine <start> result <end> );
<start> --data <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	3
a6fd8240-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_preinc_10_bad() { int data; data = 0; if(globalTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalTrue) { { ++data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> ++data <end> ;"	"printIntLine <start> result <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	0
67d010aa-6c15-11ed-81d4-94e6f77dd552	static const int STATIC_CONST_FIVE = 5; void CWE190_Integer_Overflow__short_rand_postinc_06_bad() { short data; data = 0; if(STATIC_CONST_FIVE==5) { data = (short)RAND32(); } if(STATIC_CONST_FIVE==5) { { data++; short result = data; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"data = (short <start> RAND32() <end> ;
<start> data <end> ++;"	"short <start> result = data <end> ;
<start> data <end> ++;"	"<start> data <end> ++;
data = (short <start> RAND32() <end> ;"	"<start> printIntLine(result) <end> ;
data = (short <start> RAND32() <end> ;"	0
846ad320-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define STAT _stat #define OPEN _open #define WRITE _write #define O_RDWR _O_RDWR #define CLOSE _close #else #define STAT stat #define OPEN open #define WRITE write #define CLOSE close #endif #define BAD_SINK_STRING ""Bad Sink..."" #define GOOD_SINK_STRING ""Good Sink..."" static int staticTrue = 1; static int staticFalse = 0; void CWE367_TOC_TOU__stat_05_bad() { if(staticTrue) { { char filename[100] = """"; struct STAT statBuffer; int fileDesc = -1; if (fgets(filename, 100, stdin) == NULL) { printLine(""fgets() failed""); filename[0] = '\0'; } if (strlen(filename) > 0) { filename[strlen(filename)-1] = '\0'; } if (STAT(filename, &statBuffer) == -1) { exit(1); } fileDesc  = OPEN(filename, O_RDWR); if (fileDesc == -1) { exit(1); } if (WRITE(fileDesc, BAD_SINK_STRING, strlen(BAD_SINK_STRING)) == -1) { exit(1); } if (fileDesc != -1) { CLOSE(fileDesc); } } } }"	where is the vulnerable dataflow from filename to OPEN ?	"if (fgets <start> filename <end> , 100, stdin) == NULL);
filename <start> strlen(filename) <end> -1] = '\0'; ;"	"fileDesc  = OPEN <start> filename <end> , O_RDWR);
if (fgets <start> filename <end> , 100, stdin) == NULL);"	"if (fgets <start> filename <end> , 100, stdin) == NULL);
fileDesc  = <start> OPEN(filename, O_RDWR) <end> ;"	"if (fgets <start> filename <end> , 100, stdin) == NULL);
fileDesc  = OPEN <start> filename <end> , O_RDWR);"	3
60db839b-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__char_rand_add_16_bad() { char data; data = ' '; while(1) { data = (char)RAND32(); break; } while(1) { { char result = data + 1; printHexCharLine(result); } break; } }	where is the vulnerable dataflow from data ?	"char result = <start> data <end>  + 1;
data = (char <start> RAND32() <end> ;"	"data = (char <start> RAND32() <end> ;
char result = <start> data <end>  + 1;"	"char result = <start> data <end>  + 1;
<start> printHexCharLine(result) <end> ;"	"data = (char <start> RAND32() <end> ;
char <start> result = data + 1 <end> ;"	1
8f278a77-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_09_bad() { int data; data = -1; if(GLOBAL_CONST_TRUE) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } { size_t i; int *intPointer; intPointer = (int*)malloc(data * sizeof(int)); if (intPointer == NULL) {exit(-1);} for (i = 0; i < (size_t)data; i++) { intPointer[i] = 0; } printIntLine(intPointer[0]); free(intPointer); } }"	where is the vulnerable dataflow from data to malloc ?	"<start> data = atoi(inputBuffer) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> intPointer = (int*)malloc(data * sizeof(int)) <end> ;"	"<start> data = atoi(inputBuffer) <end> ;
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	1
8cc3a670-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(count) + 2) #ifdef _WIN32 #define SLEEP Sleep #else #define SLEEP usleep #endif void CWE400_Resource_Exhaustion__fgets_sleep_09_bad() { int count; count = -1; if(GLOBAL_CONST_TRUE) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { count = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(GLOBAL_CONST_TRUE) { SLEEP(count); printLine(""Sleep time possibly too long""); } }"	where is the vulnerable dataflow from count to SLEEP ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
SLEEP <start> count <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> SLEEP(count) <end> ;"	"<start> SLEEP(count) <end> ;
SLEEP <start> count <end> );"	"SLEEP <start> count <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	0
a10948d8-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticTrue = 1; static int staticFalse = 0; void CWE190_Integer_Overflow__int_connect_socket_multiply_05_bad() { int data; data = 0; if(staticTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticTrue) { if(data > 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);
printIntLine <start> result <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"printIntLine <start> result <end> );
data = <start> atoi(inputBuffer) <end> ;"	1
48d25da8-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_add_13_bad() { int data; data = 0; if(GLOBAL_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(GLOBAL_CONST_FIVE==5) { { int result = data + 1; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  + 1;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  + 1;"	"data = <start> atoi(inputBuffer) <end> ;
int result = <start> data <end>  + 1;"	"int <start> result = data + 1 <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	1
525b647e-6c15-11ed-81d4-94e6f77dd552	"void CWE190_Integer_Overflow__short_fscanf_preinc_09_bad() { short data; data = 0; if(GLOBAL_CONST_TRUE) { fscanf (stdin, ""%hd"", &data); } if(GLOBAL_CONST_TRUE) { { ++data; short result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"fscanf (stdin, ""%hd"", <start> &data <end> );
+ <start> data <end> ;"	"+ <start> data <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );"	"<start> printIntLine(result) <end> ;
+ <start> data <end> ;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
<start> printIntLine(result) <end> ;"	0
4b34b005-6c15-11ed-81d4-94e6f77dd552	extern int CWE190_Integer_Overflow__short_fscanf_square_22_badGlobal; void CWE190_Integer_Overflow__short_fscanf_square_22_badSink(short data) { if(CWE190_Integer_Overflow__short_fscanf_square_22_badGlobal) { { short result = data * data; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"void CWE190_Integer_Overflow__short_fscanf_square_22_badSink(short <start> data <end> );
short <start> result = data * data <end> ;"	"void CWE190_Integer_Overflow__short_fscanf_square_22_badSink(short <start> data <end> );
short result = <start> data <end>  * data;"	"<start> printIntLine(result) <end> ;
short result = <start> data <end>  * data;"	"short result = <start> data <end>  * data;
void CWE190_Integer_Overflow__short_fscanf_square_22_badSink(short <start> data <end> );"	1
6dc6150e-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif void CWE134_Uncontrolled_Format_String__char_console_snprintf_12_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; if(globalReturnsTrueOrFalse()) { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } else { strcpy(data, ""fixedstringtest""); } if(globalReturnsTrueOrFalse()) { { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } } else { { char dest[100] = """"; SNPRINTF(dest, 100-1, ""%s"", data); printLine(dest); } } }"	where is the vulnerable dataflow from dest to printLine ?	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
SNPRINTF(dest, <start> 100-1 <end> , data);"	"printLine <start> dest <end> );
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	"printLine <start> dest <end> );
<start> data = dataBuffer <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
printLine <start> dest <end> );"	3
b41b8797-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 20 #define IP_ADDRESS ""127.0.0.1"" static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } void CWE369_Divide_by_Zero__float_connect_socket_08_bad() { float data; data = 0.0F; if(staticReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = (float)atof(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticReturnsTrue()) { { int result = (int)(100.0 / data); printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printIntLine(result) <end> ;"	"int <start> result = (int)(100.0 / data) <end> ;
printIntLine <start> result <end> );"	"data = <start> (float)atof(inputBuffer) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	3
6b86244d-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_08_bad() { int data; data = -1; if(staticReturnsTrue()) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(staticReturnsTrue()) { { int i; int * buffer = (int *)malloc(10 * sizeof(int)); if (buffer == NULL) {exit(-1);} for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } free(buffer); } } }"	where is the vulnerable dataflow from buffer to free ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
free <start> buffer <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> printIntLine(buffer[i]) <end> ;"	"free <start> buffer <end> );
if  <start> buffer == NULL <end> ) {exit(-1);};"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
if  <start> buffer == NULL <end> ) {exit(-1);};"	0
c01af8d5-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_connect_socket_open_31 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { char * dataCopy = data; char * data = dataCopy; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
size_t <start> dataLen = strlen(data) <end> ;"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
size_t dataLen = <start> strlen(data) <end> ;"	1
5133a75b-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } void CWE190_Integer_Overflow__int_fgets_preinc_08_bad() { int data; data = 0; if(staticReturnsTrue()) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(staticReturnsTrue()) { { ++data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> ++data <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"+ <start> data <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
+ <start> data <end> ;"	"+ <start> data <end> ;
if  <start> fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) <end>  != NULL);"	2
a6fd8259-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) typedef struct _CWE190_Integer_Overflow__int_connect_socket_preinc_67_structType { int structFirst; } CWE190_Integer_Overflow__int_connect_socket_preinc_67_structType; void CWE190_Integer_Overflow__int_connect_socket_preinc_67b_badSink(CWE190_Integer_Overflow__int_connect_socket_preinc_67_structType myStruct) { int data = myStruct.structFirst; { ++data; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
void CWE190_Integer_Overflow__int_connect_socket_preinc_67b_badSink(CWE190_Integer_Overflow__int_connect_socket_preinc_67_structType <start> myStruct <end> );
int data = <start> myStruct <end> .structFirst;"	"void CWE190_Integer_Overflow__int_connect_socket_preinc_67b_badSink(CWE190_Integer_Overflow__int_connect_socket_preinc_67_structType <start> myStruct <end> );
int data = <start> myStruct <end> .structFirst;
printIntLine <start> result <end> );"	"int <start> result = data <end> ;
printIntLine <start> result <end> );
int data = <start> myStruct <end> .structFirst;"	"<start> printIntLine(result) <end> ;
int data = <start> myStruct <end> .structFirst;
printIntLine <start> result <end> );"	1
445c120b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) typedef struct _CWE190_Integer_Overflow__int_connect_socket_add_67_structType { int structFirst; } CWE190_Integer_Overflow__int_connect_socket_add_67_structType; void CWE190_Integer_Overflow__int_connect_socket_add_67b_badSink(CWE190_Integer_Overflow__int_connect_socket_add_67_structType myStruct) { int data = myStruct.structFirst; { int result = data + 1; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"void CWE190_Integer_Overflow__int_connect_socket_add_67b_badSink(CWE190_Integer_Overflow__int_connect_socket_add_67_structType <start> myStruct <end> );
int data = <start> myStruct <end> .structFirst;
<start> printIntLine(result) <end> ;"	"void CWE190_Integer_Overflow__int_connect_socket_add_67b_badSink(CWE190_Integer_Overflow__int_connect_socket_add_67_structType <start> myStruct <end> );
int data = <start> myStruct <end> .structFirst;"	"void CWE190_Integer_Overflow__int_connect_socket_add_67b_badSink(CWE190_Integer_Overflow__int_connect_socket_add_67_structType <start> myStruct <end> );
int data = <start> myStruct <end> .structFirst;
int result = <start> data <end>  + 1;"	"int result = <start> data <end>  + 1;
int data = <start> myStruct <end> .structFirst;
void CWE190_Integer_Overflow__int_connect_socket_add_67b_badSink(CWE190_Integer_Overflow__int_connect_socket_add_67_structType <start> myStruct <end> );"	2
774f581c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 8 void CWE194_Unexpected_Sign_Extension__listen_socket_malloc_41_badSink(short data) { if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } } void CWE194_Unexpected_Sign_Extension__listen_socket_malloc_41_bad() { short data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE194_Unexpected_Sign_Extension__listen_socket_malloc_41_badSink(data); }"	where is the vulnerable dataflow from data to malloc ?	"CWE194_Unexpected_Sign_Extension__listen_socket_malloc_41_badSink <start> data <end> );
void CWE194_Unexpected_Sign_Extension__listen_socket_malloc_41_badSink(short <start> data <end> );
<start> memset(dataBuffer, 'A', data-1) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
CWE194_Unexpected_Sign_Extension__listen_socket_malloc_41_badSink <start> data <end> );
void CWE194_Unexpected_Sign_Extension__listen_socket_malloc_41_badSink(short <start> data <end> );
char * dataBuffer = (char *)malloc <start> data <end> );"	"char * dataBuffer = (char *)malloc <start> data <end> );
CWE194_Unexpected_Sign_Extension__listen_socket_malloc_41_badSink <start> data <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> memset(dataBuffer, 'A', data-1) <end> ;"	"<start> printLine(dataBuffer) <end> ;
CWE194_Unexpected_Sign_Extension__listen_socket_malloc_41_badSink <start> data <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
char * dataBuffer = (char *)malloc <start> data <end> );"	1
cac216e7-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_connect_socket_open_52 { void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badSink_b(data); }"	where is the vulnerable dataflow from data to badSink_b ?	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
badSink_b <start> data <end> );"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
<start> badSink_b(data) <end> ;"	"replace = <start> strchr(data, '\r') <end> ;
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"size_t dataLen = <start> strlen(data) <end> ;
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	0
5be3a9d3-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_listen_socket_postdec_09_bad() { int data; data = 0; if(GLOBAL_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(GLOBAL_CONST_TRUE) { { data--; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> data <end> --;
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"if  <start> recvResult == SOCKET_ERROR <end>  || recvResult == 0);
<start> data <end> --;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data <end> --;"	"<start> data <end> --;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	2
525b646d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_preinc_53d_badSink(int data) { { ++data; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"+ <start> data <end> ;
int <start> result = data <end> ;"	"void CWE190_Integer_Overflow__int_listen_socket_preinc_53d_badSink(int <start> data <end> );
<start> printIntLine(result) <end> ;"	"int <start> result = data <end> ;
void CWE190_Integer_Overflow__int_listen_socket_preinc_53d_badSink(int <start> data <end> );"	"void CWE190_Integer_Overflow__int_listen_socket_preinc_53d_badSink(int <start> data <end> );
+ <start> data <end> ;"	3
9fe7ad51-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_add_31_bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { int dataCopy = data; int data = dataCopy; { int result = data + 1; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"int result = <start> data + 1 <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"printIntLine <start> result <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"printIntLine <start> result <end> );
int result = <start> data + 1 <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	3
761e294c-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 8 static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } void CWE194_Unexpected_Sign_Extension__fgets_memcpy_08_bad() { short data; data = 0; if(staticReturnsTrue()) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = (short)atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printLine <start> dest <end> );"	"<start> memcpy(dest, source, data) <end> ;
printLine <start> dest <end> );"	"printLine <start> dest <end> );
if  <start> data < 100 <end> );"	"if  <start> data < 100 <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	0
4ff7825e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_postinc_66b_badSink(int dataArray[]) { int data = dataArray[2]; { data++; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
void CWE190_Integer_Overflow__int_listen_socket_postinc_66b_badSink(int <start> dataArray <end> []);"	"<start> data <end> ++;
<start> printIntLine(result) <end> ;"	"<start> data <end> ++;
void CWE190_Integer_Overflow__int_listen_socket_postinc_66b_badSink(int <start> dataArray <end> []);"	"void CWE190_Integer_Overflow__int_listen_socket_postinc_66b_badSink(int <start> dataArray <end> []);
<start> data <end> ++;"	3
70279c44-6c15-11ed-81d4-94e6f77dd552	#ifndef _WIN32 #endif namespace CWE134_Uncontrolled_Format_String__char_file_vfprintf_74 { static void badVaSink(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); va_end(args); } } void badSink(map<int, char *> dataMap) { char * data = dataMap[2]; badVaSink(data, data); }	where is the vulnerable dataflow from data to vfprintf ?	"void badSink(map<int, char *> <start> dataMap <end> );
badVaSink <start> data <end> , data);
vfprintf(stdout, <start> data <end> , args);"	"badVaSink <start> data <end> , data);
void badSink(map<int, char *> <start> dataMap <end> );"	"void badSink(map<int, char *> <start> dataMap <end> );
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);"	"<start> va_start(args, data) <end> ;
vfprintf(stdout, <start> data <end> , args);
static void badVaSink(char * <start> data <end> , ...);
badVaSink <start> data <end> , data);"	2
846ad33d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE369_Divide_by_Zero__int_connect_socket_divide_15_bad() { int data; data = -1; switch(6) { case 6: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; default: printLine(""Benign, fixed string""); break; } switch(7) { case 7: printIntLine(100 / data); break; default: printLine(""Benign, fixed string""); break; } }"	where is the vulnerable dataflow from data to printIntLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> 100 / data <end> );"	"<start> data = atoi(inputBuffer) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"printIntLine <start> 100 / data <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"printIntLine <start> 100 / data <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	0
acf67e2e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int CWE191_Integer_Underflow__int_connect_socket_predec_45_badData; static int CWE191_Integer_Underflow__int_connect_socket_predec_45_goodG2BData; static int CWE191_Integer_Underflow__int_connect_socket_predec_45_goodB2GData; static void badSink() { int data = CWE191_Integer_Underflow__int_connect_socket_predec_45_badData; { --data; int result = data; printIntLine(result); } } void CWE191_Integer_Underflow__int_connect_socket_predec_45_bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE191_Integer_Underflow__int_connect_socket_predec_45_badData = data; badSink(); }"	where is the vulnerable dataflow from result to printIntLine ?	"int <start> result = data <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );
int data = <start> CWE191_Integer_Underflow__int_connect_socket_predec_45_badData <end> ;
<start> CWE191_Integer_Underflow__int_connect_socket_predec_45_badData = data <end> ;"	"int data = <start> CWE191_Integer_Underflow__int_connect_socket_predec_45_badData <end> ;
printIntLine <start> result <end> );
data = <start> atoi(inputBuffer) <end> ;
static int <start> CWE191_Integer_Underflow__int_connect_socket_predec_45_badData <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"<start> CWE191_Integer_Underflow__int_connect_socket_predec_45_badData = data <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static int <start> CWE191_Integer_Underflow__int_connect_socket_predec_45_badData <end> ;
int data = <start> CWE191_Integer_Underflow__int_connect_socket_predec_45_badData <end> ;
<start> printIntLine(result) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> CWE191_Integer_Underflow__int_connect_socket_predec_45_badData = data <end> ;
static int <start> CWE191_Integer_Underflow__int_connect_socket_predec_45_badData <end> ;
int data = <start> CWE191_Integer_Underflow__int_connect_socket_predec_45_badData <end> ;
printIntLine <start> result <end> );"	3
977ea79d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_03_bad() { int data; data = -1; if(5==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(5==5) { { int i; int buffer[10] = { 0 }; if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } } } }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"int <start> buffer[10] = { 0 } <end> ;
printIntLine <start> buffer[i] <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[i] <end> );"	"printIntLine <start> buffer[i] <end> );
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"printIntLine <start> buffer[i] <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	1
a6fd8281-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_preinc_03_bad() { int data; data = 0; if(5==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(5==5) { { ++data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int <start> result = data <end> ;"	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	0
acf67e39-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) extern int CWE191_Integer_Underflow__int_connect_socket_predec_68_badData; extern int CWE191_Integer_Underflow__int_connect_socket_predec_68_goodG2BData; extern int CWE191_Integer_Underflow__int_connect_socket_predec_68_goodB2GData; void CWE191_Integer_Underflow__int_connect_socket_predec_68b_badSink() { int data = CWE191_Integer_Underflow__int_connect_socket_predec_68_badData; { --data; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"int <start> data = CWE191_Integer_Underflow__int_connect_socket_predec_68_badData <end> ;
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
int data = <start> CWE191_Integer_Underflow__int_connect_socket_predec_68_badData <end> ;"	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	"int data = <start> CWE191_Integer_Underflow__int_connect_socket_predec_68_badData <end> ;
printIntLine <start> result <end> );"	3
656cd3db-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__int_rand_multiply_02_bad() { int data; data = 0; if(1) { data = RAND32(); } if(1) { if(data > 0) { int result = data * 2; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  * 2;
data = <start> RAND32() <end> ;"	"int result = <start> data <end>  * 2;
if <start> data > 0 <end> ) ;"	"data = <start> RAND32() <end> ;
int result = <start> data <end>  * 2;"	"int result = <start> data * 2 <end> ;
data = <start> RAND32() <end> ;"	2
571e9851-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } void CWE191_Integer_Underflow__int_listen_socket_multiply_08_bad() { int data; data = 0; if(staticReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticReturnsTrue()) { if(data < 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  * 2;
if  <start> recvResult == SOCKET_ERROR <end>  || recvResult == 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  * 2;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int <start> result = data * 2 <end> ;"	"int result = <start> data <end>  * 2;
<start> printIntLine(result) <end> ;"	1
a95fd861-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE191_Integer_Underflow__int_fgets_sub_43 { static void badSource(int &data) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } void bad() { int data; data = 0; badSource(data); { int result = data - 1; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
badSource <start> data <end> );
printIntLine <start> result <end> );"	"<start> printIntLine(result) <end> ;
badSource <start> data <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"int <start> result = data - 1 <end> ;
badSource <start> data <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"int result = <start> data - 1 <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );"	0
99e16aa3-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE124_Buffer_Underwrite__CWE839_connect_socket_13_bad() { int data; data = -1; if(GLOBAL_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(GLOBAL_CONST_FIVE==5) { { int i; int buffer[10] = { 0 }; if (data < 10) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } } } }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[i] <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printIntLine(buffer[i]) <end> ;"	"printIntLine <start> buffer[i] <end> );
recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);"	"printIntLine <start> buffer[i] <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	0
73bc8170-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" void CWE194_Unexpected_Sign_Extension__connect_socket_memmove_11_bad() { short data; data = 0; if(globalReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> tempInt = atoi(inputBuffer) <end> ;"	"<start> memmove(dest, source, data) <end> ;
printLine <start> dest <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"<start> data = 0 <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	2
c01af8ab-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" namespace CWE23_Relative_Path_Traversal__char_connect_socket_ofstream_10 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(globalTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"outputFile.open((char * <start> data <end> );
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
outputFile.open((char * <start> data <end> );"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
outputFile.open((char * <start> data <end> );"	"outputFile.open((char * <start> data <end> );
recvResult = <start> recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0) <end> ;"	2
cac216c8-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" namespace CWE36_Absolute_Path_Traversal__char_connect_socket_ofstream_53 { void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badSink_b(data); }"	where is the vulnerable dataflow from data to badSink_b ?	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
badSink_b <start> data <end> );"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
replace = <start> strchr(data, '\n') <end> ;"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
char <start> dataBuffer[FILENAME_MAX] = """" <end> ;"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	0
bb49c57d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #define EXECL _execl #else #define EXECL execl #endif void CWE78_OS_Command_Injection__char_console_execl_03_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(5==5) { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECL ?	"<start> EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"if  <start> fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL <end> );
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	1
466e7ede-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_multiply_18_bad() { int data; data = 0; goto source; source: { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } goto sink; sink: if(data > 0) { int result = data * 2; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> printIntLine(result) <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
if <start> data > 0 <end> ) ;"	"int result = <start> data * 2 <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
int result = <start> data <end>  * 2;"	3
5be3a9a6-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) typedef struct _CWE191_Integer_Underflow__int_fgets_postdec_67_structType { int structFirst; } CWE191_Integer_Underflow__int_fgets_postdec_67_structType; void CWE191_Integer_Underflow__int_fgets_postdec_67b_badSink(CWE191_Integer_Underflow__int_fgets_postdec_67_structType myStruct) { int data = myStruct.structFirst; { data--; int result = data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"<start> data <end> --;
void CWE191_Integer_Underflow__int_fgets_postdec_67b_badSink(CWE191_Integer_Underflow__int_fgets_postdec_67_structType <start> myStruct <end> );
int data = <start> myStruct <end> .structFirst;"	"<start> data-- <end> ;
int data = <start> myStruct <end> .structFirst;
void CWE191_Integer_Underflow__int_fgets_postdec_67b_badSink(CWE191_Integer_Underflow__int_fgets_postdec_67_structType <start> myStruct <end> );"	"<start> data <end> --;
int data = <start> myStruct <end> .structFirst;"	"void CWE191_Integer_Underflow__int_fgets_postdec_67b_badSink(CWE191_Integer_Underflow__int_fgets_postdec_67_structType <start> myStruct <end> );
int data = <start> myStruct <end> .structFirst;
<start> data <end> --;"	3
4b34b002-6c15-11ed-81d4-94e6f77dd552	"void CWE190_Integer_Overflow__short_fscanf_square_16_bad() { short data; data = 0; while(1) { fscanf (stdin, ""%hd"", &data); break; } while(1) { { short result = data * data; printIntLine(result); } break; } }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );"	"short result = <start> data <end>  * data;
fscanf (stdin, ""%hd"", <start> &data <end> );"	"short <start> result = data * data <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );"	"fscanf (stdin, ""%hd"", <start> &data <end> );
short result = <start> data <end>  * data;"	3
8f278a42-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define PATH_SZ 100 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define PATH_SZ PATH_MAX #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 void CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__listen_bind_accept_10_bad() { if(globalTrue) { { char data[100] = """"; #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[recvResult] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif printLine(data); } } }"	where is the vulnerable dataflow from data to printLine ?	"recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);
printLine <start> data <end> );"	"if  <start> recvResult == SOCKET_ERROR <end>  || recvResult == 0);
recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);"	"<start> printLine(data) <end> ;
recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);"	"recvResult = <start> recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0) <end> ;
printLine <start> data <end> );"	0
87ff9838-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int CWE369_Divide_by_Zero__int_listen_socket_modulo_45_badData; static int CWE369_Divide_by_Zero__int_listen_socket_modulo_45_goodG2BData; static int CWE369_Divide_by_Zero__int_listen_socket_modulo_45_goodB2GData; static void badSink() { int data = CWE369_Divide_by_Zero__int_listen_socket_modulo_45_badData; printIntLine(100 % data); } void CWE369_Divide_by_Zero__int_listen_socket_modulo_45_bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE369_Divide_by_Zero__int_listen_socket_modulo_45_badData = data; badSink(); }"	where is the vulnerable dataflow from data to printIntLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
if  <start> listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR <end> );
printIntLine <start> 100 % data <end> );
int data = <start> CWE369_Divide_by_Zero__int_listen_socket_modulo_45_badData <end> ;
static int <start> CWE369_Divide_by_Zero__int_listen_socket_modulo_45_badData <end> ;"	"printIntLine <start> 100 % data <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int data = <start> CWE369_Divide_by_Zero__int_listen_socket_modulo_45_badData <end> ;
static int <start> CWE369_Divide_by_Zero__int_listen_socket_modulo_45_badData <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> CWE369_Divide_by_Zero__int_listen_socket_modulo_45_badData = data <end> ;
static int <start> CWE369_Divide_by_Zero__int_listen_socket_modulo_45_badData <end> ;
int data = <start> CWE369_Divide_by_Zero__int_listen_socket_modulo_45_badData <end> ;
printIntLine <start> 100 % data <end> );"	"int data = <start> CWE369_Divide_by_Zero__int_listen_socket_modulo_45_badData <end> ;
printIntLine <start> 100 % data <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> CWE369_Divide_by_Zero__int_listen_socket_modulo_45_badData = data <end> ;
static int <start> CWE369_Divide_by_Zero__int_listen_socket_modulo_45_badData <end> ;"	2
538bfae9-6c15-11ed-81d4-94e6f77dd552	"static int badStatic = 0; static void badSink(int64_t data) { if(badStatic) { if(data < 0) { int64_t result = data * 2; printLongLongLine(result); } } } void CWE191_Integer_Underflow__int64_t_fscanf_multiply_21_bad() { int64_t data; data = 0LL; fscanf (stdin, ""%"" SCNd64, &data); badStatic = 1; badSink(data); }"	where is the vulnerable dataflow from data ?	"fscanf (stdin, ""%"" SCNd64, <start> &data <end> );
int64_t result = <start> data <end>  * 2;
badSink <start> data <end> );
static void badSink(int64_t <start> data <end> );"	"fscanf (stdin, ""%"" SCNd64, <start> &data <end> );
badSink <start> data <end> );
static void badSink(int64_t <start> data <end> );
int64_t result = <start> data <end>  * 2;"	"<start> badSink(data) <end> ;
static void badSink(int64_t <start> data <end> );
fscanf (stdin, ""%"" SCNd64, <start> &data <end> );
int64_t result = <start> data <end>  * 2;"	"int64_t result = <start> data <end>  * 2;
badSink <start> data <end> );
fscanf (stdin, ""%"" SCNd64, <start> &data <end> );"	1
b2ea8dd5-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE 8 void CWE197_Numeric_Truncation_Error__short_fgets_63b_badSink(short * dataPtr) { short data = *dataPtr; { char charData = (char)data; printHexCharLine(charData); } }	where is the vulnerable dataflow from charData to printHexCharLine ?	"printHexCharLine <start> charData <end> );
char charData = <start> (char)data <end> ;"	"void CWE197_Numeric_Truncation_Error__short_fgets_63b_badSink(short * <start> dataPtr <end> );
char charData = <start> (char)data <end> ;"	"char <start> charData = (char)data <end> ;
void CWE197_Numeric_Truncation_Error__short_fgets_63b_badSink(short * <start> dataPtr <end> );"	"void CWE197_Numeric_Truncation_Error__short_fgets_63b_badSink(short * <start> dataPtr <end> );
printHexCharLine <start> charData <end> );"	3
8f278a6a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_65b_badSink(int data) { { size_t i; int *intPointer; intPointer = (int*)malloc(data * sizeof(int)); if (intPointer == NULL) {exit(-1);} for (i = 0; i < (size_t)data; i++) { intPointer[i] = 0; } printIntLine(intPointer[0]); free(intPointer); } }"	where is the vulnerable dataflow from data to malloc ?	"intPointer = (int*)malloc <start> data * sizeof(int) <end> );
if  <start> intPointer == NULL <end> ) {exit(-1);};"	"if  <start> intPointer == NULL <end> ) {exit(-1);};
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_65b_badSink(int <start> data <end> );"	"void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_65b_badSink(int <start> data <end> );
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	"intPointer = (int*)malloc <start> data * sizeof(int) <end> );
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_65b_badSink(int <start> data <end> );"	2
48d25da0-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; void CWE190_Integer_Overflow__int_listen_socket_add_04_bad() { int data; data = 0; if(STATIC_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(STATIC_CONST_TRUE) { { int result = data + 1; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  + 1;
data = <start> atoi(inputBuffer) <end> ;"	"<start> printIntLine(result) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"int result = <start> data <end>  + 1;
<start> recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  + 1;"	3
7e74f350-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) typedef union { int unionFirst; int unionSecond; } CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_34_unionType; void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_34_bad() { int data; CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_34_unionType myUnion; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } myUnion.unionFirst = data; { int data = myUnion.unionSecond; { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } } }"	where is the vulnerable dataflow from dest to printLine ?	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printLine <start> dest <end> );"	"printLine <start> dest <end> );
data = <start> atoi(inputBuffer) <end> ;"	"printLine <start> dest <end> );
<start> printLine(dest) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	3
48d25dd1-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_multiply_13_bad() { int data; data = 0; if(GLOBAL_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(GLOBAL_CONST_FIVE==5) { if(data > 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"int result = <start> data <end>  * 2;
<start> recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data * 2 <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  * 2;"	3
a23a3e3c-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__int_fgets_multiply_72 { void badSink(vector<int> dataVector) { int data = dataVector[2]; if(data > 0) { int result = data * 2; printIntLine(result); } }	where is the vulnerable dataflow from result to printIntLine ?	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	"int result = <start> data * 2 <end> ;
printIntLine <start> result <end> );"	"void badSink(vector<int> <start> dataVector <end> );
<start> printIntLine(result) <end> ;"	"void badSink(vector<int> <start> dataVector <end> );
printIntLine <start> result <end> );"	3
60db83d1-6c15-11ed-81d4-94e6f77dd552	char CWE190_Integer_Overflow__char_rand_multiply_61b_badSource(char data); void CWE190_Integer_Overflow__char_rand_multiply_61_bad() { char data; data = ' '; data = CWE190_Integer_Overflow__char_rand_multiply_61b_badSource(data); if(data > 0) { char result = data * 2; printHexCharLine(result); } }	where is the vulnerable dataflow from data ?	"data = <start> CWE190_Integer_Overflow__char_rand_multiply_61b_badSource <end> (data);
char result = <start> data <end>  * 2;"	"data = <start> CWE190_Integer_Overflow__char_rand_multiply_61b_badSource <end> (data);
char result = <start> data * 2 <end> ;"	"<start> printHexCharLine(result) <end> ;
char result = <start> data <end>  * 2;"	"char result = <start> data <end>  * 2;
data = <start> CWE190_Integer_Overflow__char_rand_multiply_61b_badSource <end> (data);"	0
74ee23c8-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" void CWE194_Unexpected_Sign_Extension__connect_socket_strncpy_01_bad() { short data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> tempInt = atoi(inputBuffer) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
if (tempInt > SHRT_MAX || <start> tempInt < SHRT_MIN <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"printLine <start> dest <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	2
c72d5d47-6c15-11ed-81d4-94e6f77dd552	#ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_file_open_81 { void CWE23_Relative_Path_Traversal__char_file_open_81_bad::action(char * data) const { { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } } }	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
void CWE23_Relative_Path_Traversal__char_file_open_81_bad::action(char * <start> data <end> ) const;"	"void CWE23_Relative_Path_Traversal__char_file_open_81_bad::action(char * <start> data <end> ) const;
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"void CWE23_Relative_Path_Traversal__char_file_open_81_bad::action(char * <start> data <end> ) const;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	2
b41b876b-6c15-11ed-81d4-94e6f77dd552	namespace CWE197_Numeric_Truncation_Error__short_listen_socket_73 { void badSink(list<short> dataList) { short data = dataList.back(); { char charData = (char)data; printHexCharLine(charData); } }	where is the vulnerable dataflow from charData to printHexCharLine ?	"char <start> charData = (char)data <end> ;
void badSink(list<short> <start> dataList <end> );"	"printHexCharLine <start> charData <end> );
<start> printHexCharLine(charData) <end> ;"	"void badSink(list<short> <start> dataList <end> );
printHexCharLine <start> charData <end> );"	"printHexCharLine <start> charData <end> );
char <start> charData = (char)data <end> ;"	2
79b27524-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_12_bad() { int data; data = -1; if(globalReturnsTrueOrFalse()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } else { data = 100-1; } if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }"	where is the vulnerable dataflow from data to malloc ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
char * dataBuffer = (char *)malloc <start> data <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printLine(dataBuffer) <end> ;"	"<start> printLine(dataBuffer) <end> ;
char * dataBuffer = (char *)malloc <start> data <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data = atoi(inputBuffer) <end> ;"	0
cbf2379b-6c15-11ed-81d4-94e6f77dd552	#ifndef _WIN32 #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_connect_socket_open_74 { void badSink(map<int, char *> dataMap) { char * data = dataMap[2]; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
void badSink(map<int, char *> <start> dataMap <end> );"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"void badSink(map<int, char *> <start> dataMap <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
void badSink(map<int, char *> <start> dataMap <end> );"	2
761e299b-6c15-11ed-81d4-94e6f77dd552	"namespace CWE194_Unexpected_Sign_Extension__fgets_memmove_81 { void CWE194_Unexpected_Sign_Extension__fgets_memmove_81_bad::action(short data) const { { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> printLine(dest) <end> ;
void CWE194_Unexpected_Sign_Extension__fgets_memmove_81_bad::action(short <start> data <end> ) const;"	"if  <start> data < 100 <end> );
printLine <start> dest <end> );"	"void CWE194_Unexpected_Sign_Extension__fgets_memmove_81_bad::action(short <start> data <end> ) const;
printLine <start> dest <end> );"	"void CWE194_Unexpected_Sign_Extension__fgets_memmove_81_bad::action(short <start> data <end> ) const;
char <start> dest[100] = """" <end> ;"	2
79b2752d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_31_bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { int dataCopy = data; int data = dataCopy; if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } } }"	where is the vulnerable dataflow from data to malloc ?	"if  <start> data < 100 <end> );
char * dataBuffer = (char *)malloc <start> data <end> );"	"char * dataBuffer = (char *)malloc <start> data <end> );
<start> printLine(dataBuffer) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
char * dataBuffer = (char *)malloc <start> data <end> );"	"<start> data = -1 <end> ;
char * dataBuffer = (char *)malloc <start> data <end> );"	2
571e9849-6c15-11ed-81d4-94e6f77dd552	namespace CWE191_Integer_Underflow__int_fscanf_sub_81 { void CWE191_Integer_Underflow__int_fscanf_sub_81_bad::action(int data) const { { int result = data - 1; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
void CWE191_Integer_Underflow__int_fscanf_sub_81_bad::action(int <start> data <end> ) const;"	"int result = <start> data - 1 <end> ;
void CWE191_Integer_Underflow__int_fscanf_sub_81_bad::action(int <start> data <end> ) const;"	"void CWE191_Integer_Underflow__int_fscanf_sub_81_bad::action(int <start> data <end> ) const;
int result = <start> data <end>  - 1;"	"int result = <start> data <end>  - 1;
void CWE191_Integer_Underflow__int_fscanf_sub_81_bad::action(int <start> data <end> ) const;"	2
c8600b1b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_listen_socket_open_67 { typedef struct _structType { char * structFirst; } structType; void badSink(structType myStruct) { char * data = myStruct.structFirst; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = OPEN(data, O_RDWR|O_CREAT, <start> S_IREAD|S_IWRITE <end> );
void badSink(structType <start> myStruct <end> );"	"void badSink(structType <start> myStruct <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
char * data = <start> myStruct <end> .structFirst;"	"void badSink(structType <start> myStruct <end> );
char * data = <start> myStruct <end> .structFirst;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN(data, O_RDWR|O_CREAT, <start> S_IREAD|S_IWRITE <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
char * data = <start> myStruct <end> .structFirst;"	2
8df421f4-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define PATH_SZ 100 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define PATH_SZ PATH_MAX #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 void CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__accept_bind_listen_15_bad() { switch(6) { case 6: { char data[100] = """"; #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[recvResult] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif printLine(data); } break; default: printLine(""Benign, fixed string""); break; } }"	where is the vulnerable dataflow from data to printLine ?	"printLine <start> data <end> );
recvResult = recv(acceptSocket, <start> (char *)data <end> +dataLen, (int)(100-dataLen-1), 0);"	"printLine <start> data <end> );
recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);"	"recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);
printLine <start> data <end> );"	"replace = <start> strchr(data, '\r') <end> ;
recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);"	2
525b6457-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_FIVE = 5; void CWE190_Integer_Overflow__int_listen_socket_preinc_06_bad() { int data; data = 0; if(STATIC_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(STATIC_CONST_FIVE==5) { { ++data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );
+ <start> data <end> ;"	"int <start> result = data <end> ;
+ <start> data <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
+ <start> data <end> ;"	"<start> data = atoi(inputBuffer) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	2
a36a7903-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_add_64b_badSink(void * dataVoidPtr) { int * dataPtr = (int *)dataVoidPtr; int data = (*dataPtr); { int result = data + 1; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	"void CWE190_Integer_Overflow__int_listen_socket_add_64b_badSink(void * <start> dataVoidPtr <end> );
<start> printIntLine(result) <end> ;"	"void CWE190_Integer_Overflow__int_listen_socket_add_64b_badSink(void * <start> dataVoidPtr <end> );
printIntLine <start> result <end> );"	"int <start> result = data + 1 <end> ;
printIntLine <start> result <end> );"	2
c4cd6f33-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif static int staticTrue = 1; static int staticFalse = 0; namespace CWE23_Relative_Path_Traversal__char_environment_open_05 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(staticTrue) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
strncat(data+dataLen, environment, FILENAME_MAX <start> dataLen-1 <end> );"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
<start> data = dataBuffer <end> ;"	2
4ff78272-6c15-11ed-81d4-94e6f77dd552	"static int badStatic = 0; static void badSink(short data) { if(badStatic) { { data++; short result = data; printIntLine(result); } } } void CWE190_Integer_Overflow__short_fscanf_postinc_21_bad() { short data; data = 0; fscanf (stdin, ""%hd"", &data); badStatic = 1; badSink(data); }"	where is the vulnerable dataflow from data ?	"<start> data <end> ++;
static void badSink(short <start> data <end> );"	"fscanf (stdin, ""%hd"", <start> &data <end> );
badSink <start> data <end> );
static void badSink(short <start> data <end> );
<start> data <end> ++;"	"<start> printIntLine(result) <end> ;
badSink <start> data <end> );
fscanf (stdin, ""%hd"", <start> &data <end> );
<start> data <end> ++;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
<start> data = 0 <end> ;
badSink <start> data <end> );
static void badSink(short <start> data <end> );"	1
a109492e-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_add_03_bad() { int data; data = 0; if(5==5) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(5==5) { { int result = data + 1; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
int <start> result = data + 1 <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	2
c01af8a9-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } namespace CWE23_Relative_Path_Traversal__char_connect_socket_ofstream_08 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(staticReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
outputFile.open((char * <start> data <end> );"	"outputFile.open((char * <start> data <end> );
replace = <start> strchr(data, '\n') <end> ;"	"replace = <start> strchr(data, '\n') <end> ;
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"outputFile.open((char * <start> data <end> );
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	0
6c938be6-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) extern int CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_68_badData; extern int CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_68_goodG2BData; extern int CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_68_goodB2GData; void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_68b_badSink() { int data = CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_68_badData; { int i; int * buffer = (int *)malloc(10 * sizeof(int)); if (buffer == NULL) {exit(-1);} for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } free(buffer); } }"	where is the vulnerable dataflow from buffer to free ?	"int data = <start> CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_68_badData <end> ;
<start> free(buffer) <end> ;"	"free <start> buffer <end> );
int data = <start> CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_68_badData <end> ;"	"free <start> buffer <end> );
<start> printIntLine(buffer[i]) <end> ;"	"int data = <start> CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_68_badData <end> ;
free <start> buffer <end> );"	3
a6fd824c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink(int data) { { ++data; int result = data; printIntLine(result); } } void CWE190_Integer_Overflow__int_connect_socket_preinc_41_bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badSink(data); }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSink <start> data <end> );
static void badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"badSink <start> data <end> );
printIntLine <start> result <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"badSink <start> data <end> );
int <start> result = data <end> ;
printIntLine <start> result <end> );
static void badSink(int <start> data <end> );"	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
badSink <start> data <end> );
printIntLine <start> result <end> );
static void badSink(int <start> data <end> );"	0
8a6310e1-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif static const int STATIC_CONST_FIVE = 5; namespace CWE36_Absolute_Path_Traversal__char_listen_socket_fopen_06 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(STATIC_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
size_t dataLen = <start> strlen(data) <end> ;"	"pFile = FOPEN <start> data <end> , ""wb+"");
recvResult = <start> recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0) <end> ;"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
replace = <start> strchr(data, '\n') <end> ;"	2
8b91e4a6-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(count) + 2) #ifdef _WIN32 #define SLEEP Sleep #else #define SLEEP usleep #endif static const int STATIC_CONST_FIVE = 5; void CWE400_Resource_Exhaustion__connect_socket_sleep_06_bad() { int count; count = -1; if(STATIC_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; count = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(STATIC_CONST_FIVE==5) { SLEEP(count); printLine(""Sleep time possibly too long""); } }"	where is the vulnerable dataflow from count to SLEEP ?	"SLEEP <start> count <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"SLEEP <start> count <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"SLEEP <start> count <end> );
<start> SLEEP(count) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
SLEEP <start> count <end> );"	3
a95fd823-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_FIVE = 5; void CWE191_Integer_Underflow__int_fgets_multiply_06_bad() { int data; data = 0; if(STATIC_CONST_FIVE==5) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(STATIC_CONST_FIVE==5) { if(data < 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"if <start> data < 0 <end> ) ;
printIntLine <start> result <end> );"	"<start> printIntLine(result) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"int <start> result = data * 2 <end> ;
printIntLine <start> result <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );"	3
cd22815d-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_console_open_13 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(GLOBAL_CONST_FIVE==5) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
<start> data = dataBuffer <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
if (dataLen > 0 && <start> data[dataLen-1] == '\n' <end> );"	1
728a5036-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" static int staticTrue = 1; static int staticFalse = 0; void CWE194_Unexpected_Sign_Extension__connect_socket_malloc_05_bad() { short data; data = 0; if(staticTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }"	where is the vulnerable dataflow from data to malloc ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
char <start> * dataBuffer = (char *)malloc(data) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
char * dataBuffer = (char *)malloc <start> data <end> );"	"char * dataBuffer = (char *)malloc <start> data <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"tempInt = <start> atoi(inputBuffer) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	1
4b34afd2-6c15-11ed-81d4-94e6f77dd552	"static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } void CWE190_Integer_Overflow__short_fscanf_multiply_08_bad() { short data; data = 0; if(staticReturnsTrue()) { fscanf (stdin, ""%hd"", &data); } if(staticReturnsTrue()) { if(data > 0) { short result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"fscanf (stdin, ""%hd"", <start> &data <end> );
<start> printIntLine(result) <end> ;"	"short result = <start> data <end>  * 2;
fscanf (stdin, ""%hd"", <start> &data <end> );"	"fscanf (stdin, ""%hd"", <start> &data <end> );
short <start> result = data * 2 <end> ;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
short result = <start> data <end>  * 2;"	3
7ae3a71c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_45_badData; static int CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_45_goodG2BData; static void badSink() { int data = CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_45_badData; { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } } void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_45_bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_45_badData = data; badSink(); }"	where is the vulnerable dataflow from dest to printLine ?	"<start> CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_45_badData = data <end> ;
printLine <start> dest <end> );
int data = <start> CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_45_badData <end> ;
static int <start> CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_45_badData <end> ;
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"static int <start> CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_45_badData <end> ;
int data = <start> CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_45_badData <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> memmove(dest, source, data) <end> ;
<start> CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_45_badData = data <end> ;"	"char <start> dest[100] = """" <end> ;
int data = <start> CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_45_badData <end> ;
printLine <start> dest <end> );
static int <start> CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_45_badData <end> ;
<start> CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_45_badData = data <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_45_badData = data <end> ;
static int <start> CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_45_badData <end> ;
int data = <start> CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_45_badData <end> ;
printLine <start> dest <end> );"	3
630ae827-6c15-11ed-81d4-94e6f77dd552	static void badSink(int64_t data) { { int64_t result = data + 1; printLongLongLine(result); } } void CWE190_Integer_Overflow__int64_t_rand_add_41_bad() { int64_t data; data = 0LL; data = (int64_t)RAND64(); badSink(data); }	where is the vulnerable dataflow from data ?	"data = (int64_t <start> RAND64() <end> ;
badSink <start> data <end> );
static void badSink(int64_t <start> data <end> );
int64_t result = <start> data <end>  + 1;"	"<start> data = (int64_t)RAND64() <end> ;
badSink <start> data <end> );
static void badSink(int64_t <start> data <end> );
data = (int64_t <start> RAND64() <end> ;"	"data = (int64_t <start> RAND64() <end> ;
int64_t result = <start> data <end>  + 1;
static void badSink(int64_t <start> data <end> );
<start> badSink(data) <end> ;"	"int64_t result = <start> data <end>  + 1;
data = (int64_t <start> RAND64() <end> ;"	0
9fe7ad6b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_multiply_03_bad() { int data; data = 0; if(5==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(5==5) { if(data > 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int <start> result = data * 2 <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"<start> printIntLine(result) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"printIntLine <start> result <end> );
int <start> result = data * 2 <end> ;"	1
c136626d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif namespace CWE23_Relative_Path_Traversal__char_console_ifstream_21 { static int badStatic = 0; static char * badSource(char * data) { if(badStatic) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } return data; } void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; badStatic = 1; data = badSource(data); { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } ; }"	where is the vulnerable dataflow from data to open ?	"static char * <start> badSource <end> (char * data);
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
data = <start> badSource <end> (data);"	"static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);"	"dataLen = <start> strlen(data) <end> ;
static char * <start> badSource <end> (char * data);
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
data = <start> badSource <end> (data);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
inputFile.open((char * <start> data <end> );"	3
47a2a850-6c15-11ed-81d4-94e6f77dd552	typedef struct _CWE190_Integer_Overflow__int_fscanf_multiply_67_structType { int structFirst; } CWE190_Integer_Overflow__int_fscanf_multiply_67_structType; void CWE190_Integer_Overflow__int_fscanf_multiply_67b_badSink(CWE190_Integer_Overflow__int_fscanf_multiply_67_structType myStruct) { int data = myStruct.structFirst; if(data > 0) { int result = data * 2; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"if <start> data > 0 <end> ) ;
int data = <start> myStruct <end> .structFirst;
int result = <start> data <end>  * 2;"	"void CWE190_Integer_Overflow__int_fscanf_multiply_67b_badSink(CWE190_Integer_Overflow__int_fscanf_multiply_67_structType <start> myStruct <end> );
int data = <start> myStruct <end> .structFirst;
int result = <start> data <end>  * 2;"	"int <start> result = data * 2 <end> ;
void CWE190_Integer_Overflow__int_fscanf_multiply_67b_badSink(CWE190_Integer_Overflow__int_fscanf_multiply_67_structType <start> myStruct <end> );
int data = <start> myStruct <end> .structFirst;"	"int result = <start> data <end>  * 2;
int data = <start> myStruct <end> .structFirst;
void CWE190_Integer_Overflow__int_fscanf_multiply_67b_badSink(CWE190_Integer_Overflow__int_fscanf_multiply_67_structType <start> myStruct <end> );"	1
4ec5d089-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_postinc_64b_badSink(void * dataVoidPtr) { int * dataPtr = (int *)dataVoidPtr; int data = (*dataPtr); { data++; int result = data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"void CWE190_Integer_Overflow__int_fgets_postinc_64b_badSink(void * <start> dataVoidPtr <end> );
<start> data <end> ++;"	"<start> printIntLine(result) <end> ;
<start> data <end> ++;"	"<start> data <end> ++;
int <start> data = (*dataPtr) <end> ;"	"int <start> result = data <end> ;
<start> data <end> ++;"	0
ce547d44-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif namespace CWE36_Absolute_Path_Traversal__char_environment_ifstream_14 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(globalFive==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } } { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
strncat(data+dataLen, environment, <start> FILENAME_MAX-dataLen-1 <end> );"	"strncat(data+dataLen, environment, <start> FILENAME_MAX-dataLen-1 <end> );
inputFile.open((char * <start> data <end> );"	"inputFile.open((char * <start> data <end> );
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
inputFile.open((char * <start> data <end> );"	3
a36a7910-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_multiply_03_bad() { int data; data = 0; if(5==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(5==5) { if(data > 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"if  <start> listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
if  <start> listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR <end> );"	2
8a631097-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_file_fopen_11 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(globalReturnsTrue()) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = FOPEN <start> data <end> , ""wb+"");
char <start> dataBuffer[FILENAME_MAX] = """" <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
char <start> dataBuffer[FILENAME_MAX] = """" <end> ;"	1
b68484dc-6c15-11ed-81d4-94e6f77dd552	"namespace CWE36_Absolute_Path_Traversal__char_console_open_81 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } const CWE36_Absolute_Path_Traversal__char_console_open_81_base& baseObject = CWE36_Absolute_Path_Traversal__char_console_open_81_bad(); baseObject.action(data); }"	where is the vulnerable dataflow from data to action ?	"baseObject.action <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"baseObject.action <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
baseObject.action <start> data <end> );"	3
af58093e-6c15-11ed-81d4-94e6f77dd552	namespace CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_74 { void badSink(map<int, int> dataMap) { int data = dataMap[2]; { char charData = (char)data; printHexCharLine(charData); } }	where is the vulnerable dataflow from charData to printHexCharLine ?	"int <start> data = dataMap[2] <end> ;
printHexCharLine <start> charData <end> );"	"printHexCharLine <start> charData <end> );
<start> printHexCharLine(charData) <end> ;"	"void badSink(map<int, int> <start> dataMap <end> );
printHexCharLine <start> charData <end> );"	"char <start> charData = (char)data <end> ;
void badSink(map<int, int> <start> dataMap <end> );"	2
b08640f0-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) int CWE197_Numeric_Truncation_Error__int_fgets_to_short_61b_badSource(int data); void CWE197_Numeric_Truncation_Error__int_fgets_to_short_61_bad() { int data; data = -1; data = CWE197_Numeric_Truncation_Error__int_fgets_to_short_61b_badSource(data); { short shortData = (short)data; printShortLine(shortData); } }	where is the vulnerable dataflow from shortData to printShortLine ?	"data = <start> CWE197_Numeric_Truncation_Error__int_fgets_to_short_61b_badSource <end> (data);
printShortLine <start> shortData <end> );"	"data = <start> CWE197_Numeric_Truncation_Error__int_fgets_to_short_61b_badSource <end> (data);
<start> printShortLine(shortData) <end> ;"	"printShortLine <start> shortData <end> );
data = <start> CWE197_Numeric_Truncation_Error__int_fgets_to_short_61b_badSource <end> (data);"	"short <start> shortData = (short)data <end> ;
data = <start> CWE197_Numeric_Truncation_Error__int_fgets_to_short_61b_badSource <end> (data);"	0
5e44fc79-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_fgets_predec_17_bad() { int i,j; int data; data = 0; for(i = 0; i < 1; i++) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } for(j = 0; j < 1; j++) { { --data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
- <start> data <end> ;"	"data = <start> atoi(inputBuffer) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> printIntLine(result) <end> ;"	"int <start> result = data <end> ;
- <start> data <end> ;"	0
85b15ece-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE369_Divide_by_Zero__int_connect_socket_modulo_03_bad() { int data; data = -1; if(5==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(5==5) { printIntLine(100 % data); } }"	where is the vulnerable dataflow from data to printIntLine ?	"printIntLine <start> 100 % data <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> 100 % data <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data = -1 <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> 100 % data <end> );"	3
98b01540-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_connect_socket_01 { void bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { int i; int * buffer = new int[10]; for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } delete[] buffer; } }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> buffer[i] <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[i] <end> );"	"<start> printIntLine(buffer[i]) <end> ;
printIntLine <start> buffer[i] <end> );"	"printIntLine <start> buffer[i] <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	1
a5ce1c37-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_postinc_17_bad() { int i,j; int data; data = 0; for(i = 0; i < 1; i++) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } for(j = 0; j < 1; j++) { { data++; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);
printIntLine <start> result <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"int <start> result = data <end> ;
printIntLine <start> result <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data = atoi(inputBuffer) <end> ;"	1
453db013-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_multiply_14_bad() { int data; data = 0; if(globalFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalFive==5) { if(data > 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  * 2;"	"recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);
int result = <start> data <end>  * 2;"	"int result = <start> data <end>  * 2;
data = <start> atoi(inputBuffer) <end> ;"	"if <start> data > 0 <end> ) ;
int result = <start> data <end>  * 2;"	0
af580942-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_82 { void bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_82_base* baseObject = new CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_82_bad; baseObject->action(data); delete baseObject; }"	where is the vulnerable dataflow from data to action ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
baseObject->action <start> data <end> );"	"baseObject->action <start> data <end> );
recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);"	"baseObject->action <start> data <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"baseObject->action <start> data <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	0
c39a659a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif namespace CWE23_Relative_Path_Traversal__char_environment_ifstream_41 { void badSink(char * data) { { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } } void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } badSink(data); }"	where is the vulnerable dataflow from data to badSink ?	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
badSink <start> data <end> );"	"badSink <start> data <end> );
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"badSink <start> data <end> );
strncat(data+dataLen, environment, <start> FILENAME_MAX-dataLen-1 <end> );"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
size_t dataLen = <start> strlen(data) <end> ;"	0
7c1275a0-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_63b_badSink(int * dataPtr) { int data = *dataPtr; { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	"void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_63b_badSink(int * <start> dataPtr <end> );
printLine <start> dest <end> );"	"<start> printLine(dest) <end> ;
void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_63b_badSink(int * <start> dataPtr <end> );"	"void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_63b_badSink(int * <start> dataPtr <end> );
if  <start> data < 100 <end> );"	1
c4cd6f57-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_environment_open_73 { void badSink(list<char *> dataList) { char * data = dataList.back(); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"void badSink(list<char *> <start> dataList <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
void badSink(list<char *> <start> dataList <end> );"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
char <start> * data = dataList.back() <end> ;"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
void badSink(list<char *> <start> dataList <end> );"	0
820a46a3-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_console_open_64 { void badSink(void * dataVoidPtr) { char * * dataPtr = (char * *)dataVoidPtr; char * data = (*dataPtr); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"void badSink(void * <start> dataVoidPtr <end> );
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"void badSink(void * <start> dataVoidPtr <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
void badSink(void * <start> dataVoidPtr <end> );"	"fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	1
a23a3e2c-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int badSource(int data) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } return data; } void CWE190_Integer_Overflow__int_fgets_multiply_42_bad() { int data; data = 0; data = badSource(data); if(data > 0) { int result = data * 2; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"<start> printIntLine(result) <end> ;
static int <start> badSource <end> (int data);
printIntLine <start> result <end> );
data = <start> badSource <end> (data);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
static int <start> badSource <end> (int data);
data = <start> badSource <end> (data);
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
static int <start> badSource <end> (int data);
<start> data = 0 <end> ;
data = <start> badSource <end> (data);"	"if <start> data > 0 <end> ) ;
data = <start> badSource <end> (data);
static int <start> badSource <end> (int data);
printIntLine <start> result <end> );"	1
5133a76a-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int badSource(int data) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } return data; } void CWE190_Integer_Overflow__int_fgets_preinc_42_bad() { int data; data = 0; data = badSource(data); { ++data; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
static int <start> badSource <end> (int data);
data = <start> badSource <end> (data);
+ <start> data <end> ;"	"<start> ++data <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
static int <start> badSource <end> (int data);
+ <start> data <end> ;"	"+ <start> data <end> ;
static int <start> badSource <end> (int data);
data = <start> badSource <end> (data);"	"static int <start> badSource <end> (int data);
+ <start> data <end> ;
data = <start> badSource <end> (data);
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	0
a23a3e01-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE190_Integer_Overflow__int_fgets_add_43 { static void badSource(int &data) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } void bad() { int data; data = 0; badSource(data); { int result = data + 1; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );"	"badSource <start> data <end> );
printIntLine <start> result <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
badSource <start> data <end> );
printIntLine <start> result <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	2
964cdbee-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FULL_COMMAND ""dir "" #else #define FULL_COMMAND ""ls "" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define POPEN _popen #define PCLOSE _pclose #else #define POPEN popen #define PCLOSE pclose #endif void CWE78_OS_Command_Injection__char_file_popen_17_bad() { int i; char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; for(i = 0; i < 1; i++) { { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } { FILE *pipe; pipe = POPEN(data, ""w""); if (pipe != NULL) { PCLOSE(pipe); } } }"	where is the vulnerable dataflow from data to POPEN ?	"size_t dataLen = <start> strlen(data) <end> ;
pipe = POPEN <start> data <end> , ""w"");"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
pipe = POPEN <start> data <end> , ""w"");"	"pipe = POPEN <start> data <end> , ""w"");
<start> data = data_buf <end> ;"	"pipe = <start> POPEN(data, ""w"") <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	1
833ac914-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_listen_socket_fopen_13 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(GLOBAL_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"size_t dataLen = <start> strlen(data) <end> ;
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	"<start> data = dataBuffer <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
size_t dataLen = <start> strlen(data) <end> ;"	1
a10948ec-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE190_Integer_Overflow__int_connect_socket_multiply_43 { static void badSource(int &data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } void bad() { int data; data = 0; badSource(data); if(data > 0) { int result = data * 2; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );
badSource <start> data <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSource <start> data <end> );
printIntLine <start> result <end> );"	"data = <start> atoi(inputBuffer) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"int <start> result = data * 2 <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSource <start> data <end> );"	1
5be3a99e-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_fgets_postdec_52c_badSink(int data) { { data--; int result = data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"void CWE191_Integer_Underflow__int_fgets_postdec_52c_badSink(int <start> data <end> );
<start> printIntLine(result) <end> ;"	"void CWE191_Integer_Underflow__int_fgets_postdec_52c_badSink(int <start> data <end> );
<start> data <end> --;"	"<start> data <end> --;
<start> printIntLine(result) <end> ;"	"<start> data <end> --;
void CWE191_Integer_Underflow__int_fgets_postdec_52c_badSink(int <start> data <end> );"	1
86cea170-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE369_Divide_by_Zero__int_listen_socket_modulo_31_bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { int dataCopy = data; int data = dataCopy; printIntLine(100 % data); } }"	where is the vulnerable dataflow from data to printIntLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> 100 % data <end> );"	"if  <start> recvResult == SOCKET_ERROR <end>  || recvResult == 0);
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"<start> data = atoi(inputBuffer) <end> ;
printIntLine <start> 100 % data <end> );"	"printIntLine <start> 100 % data <end> );
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	0
61da66e3-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__char_rand_square_13_bad() { char data; data = ' '; if(GLOBAL_CONST_FIVE==5) { data = (char)RAND32(); } if(GLOBAL_CONST_FIVE==5) { { char result = data * data; printHexCharLine(result); } } }	where is the vulnerable dataflow from data ?	"data = (char <start> RAND32() <end> ;
char result = <start> data <end>  * data;"	"data = (char <start> RAND32() <end> ;
char <start> result = data * data <end> ;"	"char result = <start> data <end>  * data;
data = (char <start> RAND32() <end> ;"	"<start> printHexCharLine(result) <end> ;
data = (char <start> RAND32() <end> ;"	0
5d16c9c5-6c15-11ed-81d4-94e6f77dd552	"void CWE191_Integer_Underflow__short_fscanf_postdec_31_bad() { short data; data = 0; fscanf (stdin, ""%hd"", &data); { short dataCopy = data; short data = dataCopy; { data--; short result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> data-- <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );"	"fscanf (stdin, ""%hd"", <start> &data <end> );
<start> data <end> --;"	"<start> printIntLine(result) <end> ;
<start> data <end> --;"	"<start> data <end> --;
fscanf (stdin, ""%hd"", <start> &data <end> );"	1
b8e2bda0-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define NEW_PATH ""%SystemRoot%\\system32"" #define PUTENV _putenv #else #define NEW_PATH ""/bin"" #define PUTENV putenv #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 void CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_15_bad() { char * data; char dataBuffer[250] = ""PATH=""; data = dataBuffer; switch(6) { case 6: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (250 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; default: printLine(""Benign, fixed string""); break; } PUTENV(data); }"	where is the vulnerable dataflow from data to PUTENV ?	"replace = <start> strchr(data, '\n') <end> ;
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (250 - dataLen - 1), 0);"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (250 - dataLen - 1), 0);
PUTENV <start> data <end> );"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (250 - dataLen - 1), 0);
replace = <start> strchr(data, '\r') <end> ;"	"replace = <start> strchr(data, '\n') <end> ;
PUTENV <start> data <end> );"	1
67d010d8-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__char_rand_preinc_17_bad() { int i,j; char data; data = ' '; for(i = 0; i < 1; i++) { data = (char)RAND32(); } for(j = 0; j < 1; j++) { { ++data; char result = data; printHexCharLine(result); } } }	where is the vulnerable dataflow from data ?	"data = (char <start> RAND32() <end> ;
+ <start> data <end> ;"	"+ <start> data <end> ;
char <start> result = data <end> ;"	"char <start> result = data <end> ;
data = (char <start> RAND32() <end> ;"	"+ <start> data <end> ;
data = (char <start> RAND32() <end> ;"	0
a23a3dfc-6c15-11ed-81d4-94e6f77dd552	extern int CWE190_Integer_Overflow__int_fgets_add_22_badGlobal; void CWE190_Integer_Overflow__int_fgets_add_22_badSink(int data) { if(CWE190_Integer_Overflow__int_fgets_add_22_badGlobal) { { int result = data + 1; printIntLine(result); } } }	where is the vulnerable dataflow from result to printIntLine ?	"void CWE190_Integer_Overflow__int_fgets_add_22_badSink(int <start> data <end> );
<start> printIntLine(result) <end> ;"	"printIntLine <start> result <end> );
void CWE190_Integer_Overflow__int_fgets_add_22_badSink(int <start> data <end> );"	"void CWE190_Integer_Overflow__int_fgets_add_22_badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
int <start> result = data + 1 <end> ;"	2
7c12759d-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_54e_badSink(int data) { { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_54e_badSink(int <start> data <end> );
printLine <start> dest <end> );"	"<start> printLine(dest) <end> ;
void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_54e_badSink(int <start> data <end> );"	"void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_54e_badSink(int <start> data <end> );
<start> memcpy(dest, source, data) <end> ;"	"char <start> dest[100] = """" <end> ;
printLine <start> dest <end> );"	0
5e44fc4a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticTrue = 1; static int staticFalse = 0; void CWE191_Integer_Underflow__int_connect_socket_predec_05_bad() { int data; data = 0; if(staticTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticTrue) { { --data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"- <start> data <end> ;
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"- <start> data <end> ;
<start> printIntLine(result) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
- <start> data <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printIntLine(result) <end> ;"	2
453db029-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_multiply_65b_badSink(int data) { if(data > 0) { int result = data * 2; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"void CWE190_Integer_Overflow__int_connect_socket_multiply_65b_badSink(int <start> data <end> );
int result = <start> data <end>  * 2;"	"int result = <start> data <end>  * 2;
void CWE190_Integer_Overflow__int_connect_socket_multiply_65b_badSink(int <start> data <end> );"	"int <start> result = data * 2 <end> ;
void CWE190_Integer_Overflow__int_connect_socket_multiply_65b_badSink(int <start> data <end> );"	"<start> printIntLine(result) <end> ;
void CWE190_Integer_Overflow__int_connect_socket_multiply_65b_badSink(int <start> data <end> );"	0
715a3c02-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif namespace CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_73 { void badSink(list<char *> dataList) { char * data = dataList.back(); { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"printLine <start> dest <end> );
<start> SNPRINTF(dest, 100-1, data) <end> ;"	"printLine <start> dest <end> );
<start> printLine(dest) <end> ;"	"void badSink(list<char *> <start> dataList <end> );
printLine <start> dest <end> );"	"printLine <start> dest <end> );
void badSink(list<char *> <start> dataList <end> );"	2
a49c4f86-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) typedef struct _CWE190_Integer_Overflow__int_listen_socket_square_67_structType { int structFirst; } CWE190_Integer_Overflow__int_listen_socket_square_67_structType; void CWE190_Integer_Overflow__int_listen_socket_square_67b_badSink(CWE190_Integer_Overflow__int_listen_socket_square_67_structType myStruct) { int data = myStruct.structFirst; { int result = data * data; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"void CWE190_Integer_Overflow__int_listen_socket_square_67b_badSink(CWE190_Integer_Overflow__int_listen_socket_square_67_structType <start> myStruct <end> );
int data = <start> myStruct <end> .structFirst;
printIntLine <start> result <end> );"	"int <start> result = data * data <end> ;
int data = <start> myStruct <end> .structFirst;
void CWE190_Integer_Overflow__int_listen_socket_square_67b_badSink(CWE190_Integer_Overflow__int_listen_socket_square_67_structType <start> myStruct <end> );"	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );
void CWE190_Integer_Overflow__int_listen_socket_square_67b_badSink(CWE190_Integer_Overflow__int_listen_socket_square_67_structType <start> myStruct <end> );"	"printIntLine <start> result <end> );
void CWE190_Integer_Overflow__int_listen_socket_square_67b_badSink(CWE190_Integer_Overflow__int_listen_socket_square_67_structType <start> myStruct <end> );
int data = <start> myStruct <end> .structFirst;"	0
8df421d4-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define PATH_SZ 100 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define PATH_SZ PATH_MAX #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 void CWE605_Multiple_Binds_Same_Port__basic_03_bad() { if(5==5) { { char data[100] = """"; #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); #ifdef _WIN32 BOOL bOptVal = TRUE; int bOptLen = sizeof(BOOL); #else int bOptVal = 1; int bOptLen = sizeof(int); #endif do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } if (setsockopt(listenSocket, SOL_SOCKET, SO_REUSEADDR, (char*)&bOptVal, bOptLen) != 0) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, data+dataLen, (int)(100-dataLen-1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[recvResult] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif printLine(data); } } }"	where is the vulnerable dataflow from data to printLine ?	"recvResult = recv(acceptSocket, <start> data+dataLen <end> , (int)(100-dataLen-1), 0);
printLine <start> data <end> );"	"size_t dataLen = <start> strlen(data) <end> ;
recvResult = recv(acceptSocket, <start> data+dataLen <end> , (int)(100-dataLen-1), 0);"	"printLine <start> data <end> );
recvResult = recv(acceptSocket, <start> data+dataLen <end> , (int)(100-dataLen-1), 0);"	"printLine <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	0
5e44fca7-6c15-11ed-81d4-94e6f77dd552	void CWE191_Integer_Underflow__int_fscanf_predec_53d_badSink(int data) { { --data; int result = data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"- <start> data <end> ;
void CWE191_Integer_Underflow__int_fscanf_predec_53d_badSink(int <start> data <end> );"	"void CWE191_Integer_Underflow__int_fscanf_predec_53d_badSink(int <start> data <end> );
- <start> data <end> ;"	"- <start> data <end> ;
int <start> result = data <end> ;"	"<start> printIntLine(result) <end> ;
- <start> data <end> ;"	1
893217c1-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_console_fopen_11 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(globalReturnsTrue()) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
char <start> dataBuffer[FILENAME_MAX] = """" <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
<start> data = dataBuffer <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
pFile = FOPEN <start> data <end> , ""wb+"");"	3
9fe7ad2c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif namespace CWE134_Uncontrolled_Format_String__char_file_printf_81 { void bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } const CWE134_Uncontrolled_Format_String__char_file_printf_81_base& baseObject = CWE134_Uncontrolled_Format_String__char_file_printf_81_bad(); baseObject.action(data); }"	where is the vulnerable dataflow from data to action ?	"size_t dataLen = <start> strlen(data) <end> ;
baseObject.action <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
baseObject.action <start> data <end> );"	"baseObject.action <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	"<start> data = dataBuffer <end> ;
baseObject.action <start> data <end> );"	1
bc721f79-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define EXECL _execl #else #define EXECL execl #endif void CWE78_OS_Command_Injection__char_file_execl_15_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; switch(6) { case 6: { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } break; default: printLine(""Benign, fixed string""); break; } EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECL ?	"EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
if  <start> fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL <end> );"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
<start> EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL) <end> ;"	"EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	1
67d010d9-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__char_rand_preinc_18_bad() { char data; data = ' '; goto source; source: data = (char)RAND32(); goto sink; sink: { ++data; char result = data; printHexCharLine(result); } }	where is the vulnerable dataflow from data ?	"char <start> result = data <end> ;
data = (char <start> RAND32() <end> ;"	"data = (char <start> RAND32() <end> ;
+ <start> data <end> ;"	"char <start> result = data <end> ;
+ <start> data <end> ;"	"<start> printHexCharLine(result) <end> ;
data = (char <start> RAND32() <end> ;"	1
74ee23ff-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 8 void CWE194_Unexpected_Sign_Extension__fgets_malloc_12_bad() { short data; data = 0; if(globalReturnsTrueOrFalse()) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = (short)atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } else { data = 100-1; } if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }"	where is the vulnerable dataflow from data to malloc ?	"if  <start> dataBuffer == NULL <end> ) {exit(-1);};
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"<start> printLine(dataBuffer) <end> ;
char * dataBuffer = (char *)malloc <start> data <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
if  <start> data < 100 <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
char * dataBuffer = (char *)malloc <start> data <end> );"	3
86cea161-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticTrue = 1; static int staticFalse = 0; void CWE369_Divide_by_Zero__int_listen_socket_modulo_05_bad() { int data; data = -1; if(staticTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticTrue) { printIntLine(100 % data); } }"	where is the vulnerable dataflow from data to printIntLine ?	"<start> data = -1 <end> ;
printIntLine <start> 100 % data <end> );"	"<start> data = atoi(inputBuffer) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> 100 % data <end> );"	"printIntLine <start> 100 % data <end> );
<start> recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	2
584fa88b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_listen_socket_sub_65b_badSink(int data) { { int result = data - 1; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  - 1;
void CWE191_Integer_Underflow__int_listen_socket_sub_65b_badSink(int <start> data <end> );"	"int <start> result = data - 1 <end> ;
void CWE191_Integer_Underflow__int_listen_socket_sub_65b_badSink(int <start> data <end> );"	"void CWE191_Integer_Underflow__int_listen_socket_sub_65b_badSink(int <start> data <end> );
int result = <start> data <end>  - 1;"	"void CWE191_Integer_Underflow__int_listen_socket_sub_65b_badSink(int <start> data <end> );
<start> printIntLine(result) <end> ;"	2
73bc8176-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" void CWE194_Unexpected_Sign_Extension__connect_socket_memmove_17_bad() { int i; short data; data = 0; for(i = 0; i < 1; i++) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"printLine <start> dest <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);
printLine <start> dest <end> );"	"<start> memmove(dest, source, data) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	0
8df421d8-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define PATH_SZ 100 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define PATH_SZ PATH_MAX #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 static int staticFive = 5; void CWE605_Multiple_Binds_Same_Port__basic_07_bad() { if(staticFive==5) { { char data[100] = """"; #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); #ifdef _WIN32 BOOL bOptVal = TRUE; int bOptLen = sizeof(BOOL); #else int bOptVal = 1; int bOptLen = sizeof(int); #endif do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } if (setsockopt(listenSocket, SOL_SOCKET, SO_REUSEADDR, (char*)&bOptVal, bOptLen) != 0) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, data+dataLen, (int)(100-dataLen-1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[recvResult] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif printLine(data); } } }"	where is the vulnerable dataflow from data to printLine ?	"recvResult = recv(acceptSocket, <start> data+dataLen <end> , (int)(100-dataLen-1), 0);
printLine <start> data <end> );"	"size_t dataLen = <start> strlen(data) <end> ;
recvResult = recv(acceptSocket, <start> data+dataLen <end> , (int)(100-dataLen-1), 0);"	"replace = <start> strchr(data, '\r') <end> ;
recvResult = recv(acceptSocket, <start> data+dataLen <end> , (int)(100-dataLen-1), 0);"	"if  <start> recvResult == SOCKET_ERROR <end>  || recvResult == 0);
recvResult = recv(acceptSocket, <start> data+dataLen <end> , (int)(100-dataLen-1), 0);"	0
c39a6592-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif namespace CWE23_Relative_Path_Traversal__char_environment_ifstream_14 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(globalFive==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } } { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"<start> data = dataBuffer <end> ;
inputFile.open((char * <start> data <end> );"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
size_t dataLen = <start> strlen(data) <end> ;"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
inputFile.open((char * <start> data <end> );"	"size_t dataLen = <start> strlen(data) <end> ;
inputFile.open((char * <start> data <end> );"	2
8b91e483-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_listen_socket_open_54 { void badSink_e(char * data) { { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"void badSink_e(char * <start> data <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN(data, O_RDWR|O_CREAT, <start> S_IREAD|S_IWRITE <end> );
void badSink_e(char * <start> data <end> );"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
void badSink_e(char * <start> data <end> );"	"void badSink_e(char * <start> data <end> );
fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);"	0
73bc816d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } void CWE194_Unexpected_Sign_Extension__connect_socket_memmove_08_bad() { short data; data = 0; if(staticReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"printLine <start> dest <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"<start> memmove(dest, source, data) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"<start> memmove(dest, source, data) <end> ;
printLine <start> dest <end> );"	1
a95fd83e-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_fgets_multiply_63b_badSink(int * dataPtr) { int data = *dataPtr; if(data < 0) { int result = data * 2; printIntLine(result); } }	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;"	"void CWE191_Integer_Underflow__int_fgets_multiply_63b_badSink(int * <start> dataPtr <end> );
if <start> data < 0 <end> ) ;"	"void CWE191_Integer_Underflow__int_fgets_multiply_63b_badSink(int * <start> dataPtr <end> );
printIntLine <start> result <end> );"	"int result = <start> data * 2 <end> ;
void CWE191_Integer_Underflow__int_fgets_multiply_63b_badSink(int * <start> dataPtr <end> );"	2
7c12757d-6c15-11ed-81d4-94e6f77dd552	namespace CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_81 { void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_81_bad::action(int data) const { if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } } }	where is the vulnerable dataflow from data to malloc ?	"void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_81_bad::action(int <start> data <end> ) const;
char * dataBuffer = (char *)malloc <start> data <end> );"	"char * dataBuffer = (char *)malloc <start> data <end> );
char <start> * dataBuffer = (char *)malloc(data) <end> ;"	"<start> memset(dataBuffer, 'A', data-1) <end> ;
char * dataBuffer = (char *)malloc <start> data <end> );"	"void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_81_bad::action(int <start> data <end> ) const;
memset(dataBuffer, 'A', <start> data-1 <end> );"	0
cd22816a-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_console_open_44 { static void badSink(char * data) { { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } } void bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } funcPtr(data); }"	where is the vulnerable dataflow from data to funcPtr ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
funcPtr <start> data <end> );"	"<start> funcPtr(data) <end> ;
funcPtr <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
size_t dataLen = <start> strlen(data) <end> ;"	"funcPtr <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	0
c01af8a2-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" namespace CWE23_Relative_Path_Traversal__char_connect_socket_ofstream_01 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
size_t dataLen = <start> strlen(data) <end> ;"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
outputFile.open((char * <start> data <end> );"	"replace = <start> strchr(data, '\n') <end> ;
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - <start> dataLen - 1 <end> ), 0);
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	1
7c127567-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_31_bad() { int data; data = -1; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } { int dataCopy = data; int data = dataCopy; if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } } }"	where is the vulnerable dataflow from data to malloc ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
char * dataBuffer = (char *)malloc <start> data <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> printLine(dataBuffer) <end> ;"	"int <start> dataCopy = data <end> ;
char * dataBuffer = (char *)malloc <start> data <end> );"	"data = <start> atoi(inputBuffer) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	0
571e981c-6c15-11ed-81d4-94e6f77dd552	namespace CWE191_Integer_Underflow__int_fscanf_multiply_72 { void badSink(vector<int> dataVector) { int data = dataVector[2]; if(data < 0) { int result = data * 2; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
void badSink(vector<int> <start> dataVector <end> );"	"int result = <start> data <end>  * 2;
void badSink(vector<int> <start> dataVector <end> );"	"void badSink(vector<int> <start> dataVector <end> );
int result = <start> data * 2 <end> ;"	"void badSink(vector<int> <start> dataVector <end> );
int result = <start> data <end>  * 2;"	3
70279c3d-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif static void badVaSink(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_file_vfprintf_64b_badSink(void * dataVoidPtr) { char * * dataPtr = (char * *)dataVoidPtr; char * data = (*dataPtr); badVaSink(data, data); }"	where is the vulnerable dataflow from data to vfprintf ?	"badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
void CWE134_Uncontrolled_Format_String__char_file_vfprintf_64b_badSink(void * <start> dataVoidPtr <end> );"	"static void badVaSink(char * <start> data <end> , ...);
void CWE134_Uncontrolled_Format_String__char_file_vfprintf_64b_badSink(void * <start> dataVoidPtr <end> );"	"static void badVaSink(char * <start> data <end> , ...);
<start> vfprintf(stdout, data, args) <end> ;
badVaSink <start> data <end> , data);
void CWE134_Uncontrolled_Format_String__char_file_vfprintf_64b_badSink(void * <start> dataVoidPtr <end> );"	"void CWE134_Uncontrolled_Format_String__char_file_vfprintf_64b_badSink(void * <start> dataVoidPtr <end> );
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);"	3
466e7f08-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_square_18_bad() { int data; data = 0; goto source; source: { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } goto sink; sink: { int result = data * data; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> printIntLine(result) <end> ;"	"int <start> result = data * data <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
int result = <start> data <end>  * data;"	"<start> data = atoi(inputBuffer) <end> ;
int result = <start> data <end>  * data;"	2
7c1275be-6c15-11ed-81d4-94e6f77dd552	"int CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_22_badGlobal = 0; int CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_22_badSource(int data); void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_22_bad() { int data; data = -1; CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_22_badGlobal = 1; data = CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_22_badSource(data); { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> memmove(dest, source, data) <end> ;
data = <start> CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_22_badSource <end> (data);"	"printLine <start> dest <end> );
<start> printLine(dest) <end> ;"	"printLine <start> dest <end> );
data = <start> CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_22_badSource(data) <end> ;"	"data = <start> CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_22_badSource <end> (data);
printLine <start> dest <end> );"	3
5af03e01-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) typedef union { int unionFirst; int unionSecond; } CWE191_Integer_Underflow__int_connect_socket_postdec_34_unionType; void CWE191_Integer_Underflow__int_connect_socket_postdec_34_bad() { int data; CWE191_Integer_Underflow__int_connect_socket_postdec_34_unionType myUnion; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } myUnion.unionFirst = data; { int data = myUnion.unionSecond; { data--; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"data = <start> atoi(inputBuffer) <end> ;
<start> data <end> --;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data-- <end> ;"	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
<start> data <end> --;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data <end> --;"	3
69161b56-6c15-11ed-81d4-94e6f77dd552	"void CWE190_Integer_Overflow__short_rand_preinc_12_bad() { short data; data = 0; if(globalReturnsTrueOrFalse()) { data = (short)RAND32(); } else { data = 2; } if(globalReturnsTrueOrFalse()) { { ++data; short result = data; printIntLine(result); } } else { if (data < SHRT_MAX) { ++data; short result = data; printIntLine(result); } else { printLine(""data value is too large to perform arithmetic safely.""); } } }"	where is the vulnerable dataflow from data ?	"+ <start> data <end> ;
<start> printIntLine(result) <end> ;"	"data = (short <start> RAND32() <end> ;
+ <start> data <end> ;"	"+ <start> data <end> ;
<start> data = (short)RAND32() <end> ;"	"+ <start> data <end> ;
short <start> result = data <end> ;"	1
893217c5-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_console_fopen_15 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; switch(6) { case 6: { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } break; default: printLine(""Benign, fixed string""); break; } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"if (dataLen > 0 && <start> data[dataLen-1] == '\n' <end> );
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
pFile = FOPEN <start> data <end> , ""wb+"");"	3
47a2a852-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__int_fscanf_multiply_72 { void badSink(vector<int> dataVector) { int data = dataVector[2]; if(data > 0) { int result = data * 2; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"void badSink(vector<int> <start> dataVector <end> );
int result = <start> data * 2 <end> ;"	"if <start> data > 0 <end> ) ;
int result = <start> data <end>  * 2;"	"void badSink(vector<int> <start> dataVector <end> );
int result = <start> data <end>  * 2;"	"int <start> result = data * 2 <end> ;
void badSink(vector<int> <start> dataVector <end> );"	2
af58094c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE197_Numeric_Truncation_Error__int_connect_socket_to_short_10_bad() { int data; data = -1; if(globalTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { short shortData = (short)data; printShortLine(shortData); } }"	where is the vulnerable dataflow from shortData to printShortLine ?	"short <start> shortData = (short)data <end> ;
printShortLine <start> shortData <end> );"	"printShortLine <start> shortData <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"data = <start> atoi(inputBuffer) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printShortLine <start> shortData <end> );"	3
a49c4f80-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) int CWE190_Integer_Overflow__int_listen_socket_square_61b_badSource(int data); void CWE190_Integer_Overflow__int_listen_socket_square_61_bad() { int data; data = 0; data = CWE190_Integer_Overflow__int_listen_socket_square_61b_badSource(data); { int result = data * data; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	"data = <start> CWE190_Integer_Overflow__int_listen_socket_square_61b_badSource <end> (data);
printIntLine <start> result <end> );"	"data = <start> CWE190_Integer_Overflow__int_listen_socket_square_61b_badSource <end> (data);
int <start> result = data * data <end> ;"	"printIntLine <start> result <end> );
data = <start> CWE190_Integer_Overflow__int_listen_socket_square_61b_badSource <end> (data);"	1
5133a766-6c15-11ed-81d4-94e6f77dd552	extern int CWE190_Integer_Overflow__int_fgets_preinc_22_badGlobal; void CWE190_Integer_Overflow__int_fgets_preinc_22_badSink(int data) { if(CWE190_Integer_Overflow__int_fgets_preinc_22_badGlobal) { { ++data; int result = data; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"void CWE190_Integer_Overflow__int_fgets_preinc_22_badSink(int <start> data <end> );
<start> printIntLine(result) <end> ;"	"void CWE190_Integer_Overflow__int_fgets_preinc_22_badSink(int <start> data <end> );
+ <start> data <end> ;"	"void CWE190_Integer_Overflow__int_fgets_preinc_22_badSink(int <start> data <end> );
<start> ++data <end> ;"	"+ <start> data <end> ;
void CWE190_Integer_Overflow__int_fgets_preinc_22_badSink(int <start> data <end> );"	1
7ae3a75b-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_02_bad() { int data; data = -1; if(1) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }"	where is the vulnerable dataflow from data to malloc ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
if  <start> data < 100 <end> );"	"<start> memset(dataBuffer, 'A', data-1) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"char * dataBuffer = (char *)malloc <start> data <end> );
memset(dataBuffer, 'A', <start> data-1 <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
char * dataBuffer = (char *)malloc <start> data <end> );"	3
b54bcf2d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 20 void CWE369_Divide_by_Zero__float_listenSocket_15_bad() { float data; data = 0.0F; switch(6) { case 6: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = (float)atof(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; default: printLine(""Benign, fixed string""); break; } switch(7) { case 7: { int result = (int)(100.0 / data); printIntLine(result); } break; default: printLine(""Benign, fixed string""); break; } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"data = (float <start> atof(inputBuffer) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"int result = (int) <start> 100.0 / data <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"printIntLine <start> result <end> );
int result = (int) <start> 100.0 / data <end> );"	0
584fa86c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; void CWE191_Integer_Underflow__int_listen_socket_sub_04_bad() { int data; data = 0; if(STATIC_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(STATIC_CONST_TRUE) { { int result = data - 1; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  - 1;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"int <start> result = data - 1 <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"if  <start> acceptSocket == SOCKET_ERROR <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  - 1;"	3
c39a65b3-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif namespace CWE23_Relative_Path_Traversal__char_environment_ofstream_16 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; while(1) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } break; } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"<start> data = dataBuffer <end> ;
outputFile.open((char * <start> data <end> );"	"strncat <start> data+dataLen <end> , environment, FILENAME_MAX-dataLen-1);
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
<start> data = dataBuffer <end> ;"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
outputFile.open((char * <start> data <end> );"	3
7e74f31e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_16_bad() { int data; data = -1; while(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printLine <start> dest <end> );"	"<start> memcpy(dest, source, data) <end> ;
printLine <start> dest <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"data = <start> atoi(inputBuffer) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	2
aa91a18f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_listen_socket_sub_13_bad() { int data; data = 0; if(GLOBAL_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(GLOBAL_CONST_FIVE==5) { { int result = data - 1; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"printIntLine <start> result <end> );
<start> data = 0 <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	2
525b643c-6c15-11ed-81d4-94e6f77dd552	"static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } void CWE190_Integer_Overflow__int_fscanf_preinc_08_bad() { int data; data = 0; if(staticReturnsTrue()) { fscanf(stdin, ""%d"", &data); } if(staticReturnsTrue()) { { ++data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"fscanf(stdin, ""%d"", <start> &data <end> );
+ <start> data <end> ;"	"+ <start> data <end> ;
fscanf(stdin, ""%d"", <start> &data <end> );"	"int <start> result = data <end> ;
fscanf(stdin, ""%d"", <start> &data <end> );"	"<start> printIntLine(result) <end> ;
+ <start> data <end> ;"	0
8cc3a67c-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(count) + 2) #ifdef _WIN32 #define SLEEP Sleep #else #define SLEEP usleep #endif typedef union { int unionFirst; int unionSecond; } CWE400_Resource_Exhaustion__fgets_sleep_34_unionType; void CWE400_Resource_Exhaustion__fgets_sleep_34_bad() { int count; CWE400_Resource_Exhaustion__fgets_sleep_34_unionType myUnion; count = -1; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { count = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } myUnion.unionFirst = count; { int count = myUnion.unionSecond; SLEEP(count); printLine(""Sleep time possibly too long""); } }"	where is the vulnerable dataflow from count to SLEEP ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> SLEEP(count) <end> ;"	"SLEEP <start> count <end> );
<start> SLEEP(count) <end> ;"	"SLEEP <start> count <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
SLEEP <start> count <end> );"	3
951c5ea0-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FULL_COMMAND ""dir "" #else #define FULL_COMMAND ""ls "" #endif #ifdef _WIN32 #define POPEN _popen #define PCLOSE _pclose #else #define POPEN popen #define PCLOSE pclose #endif extern char * CWE78_OS_Command_Injection__char_console_popen_68_badData; extern char * CWE78_OS_Command_Injection__char_console_popen_68_goodG2BData; void CWE78_OS_Command_Injection__char_console_popen_68b_badSink() { char * data = CWE78_OS_Command_Injection__char_console_popen_68_badData; { FILE *pipe; pipe = POPEN(data, ""w""); if (pipe != NULL) { PCLOSE(pipe); } } }"	where is the vulnerable dataflow from data to POPEN ?	"pipe = POPEN <start> data <end> , ""w"");
char <start> * data = CWE78_OS_Command_Injection__char_console_popen_68_badData <end> ;"	"pipe = POPEN <start> data <end> , ""w"");
pipe = <start> POPEN(data, ""w"") <end> ;"	"char * data = <start> CWE78_OS_Command_Injection__char_console_popen_68_badData <end> ;
pipe = POPEN <start> data <end> , ""w"");"	"pipe = POPEN <start> data <end> , ""w"");
char * data = <start> CWE78_OS_Command_Injection__char_console_popen_68_badData <end> ;"	2
445c120a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_add_66b_badSink(int dataArray[]) { int data = dataArray[2]; { int result = data + 1; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
void CWE190_Integer_Overflow__int_connect_socket_add_66b_badSink(int <start> dataArray <end> []);"	"int <start> result = data + 1 <end> ;
void CWE190_Integer_Overflow__int_connect_socket_add_66b_badSink(int <start> dataArray <end> []);"	"void CWE190_Integer_Overflow__int_connect_socket_add_66b_badSink(int <start> dataArray <end> []);
int result = <start> data <end>  + 1;"	"int result = <start> data <end>  + 1;
void CWE190_Integer_Overflow__int_connect_socket_add_66b_badSink(int <start> dataArray <end> []);"	2
b7b09a2b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define NEW_PATH ""%SystemRoot%\\system32"" #define PUTENV _putenv #else #define NEW_PATH ""/bin"" #define PUTENV putenv #endif void CWE427_Uncontrolled_Search_Path_Element__char_console_01_bad() { char * data; char dataBuffer[250] = ""PATH=""; data = dataBuffer; { size_t dataLen = strlen(data); if (250-dataLen > 1) { if (fgets(data+dataLen, (int)(250-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } PUTENV(data); }"	where is the vulnerable dataflow from data to PUTENV ?	"if (fgets <start> data+dataLen <end> , (int)(250-dataLen), stdin) != NULL);
PUTENV <start> data <end> );"	"<start> data = dataBuffer <end> ;
PUTENV <start> data <end> );"	"dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(250-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(250-dataLen), stdin) != NULL);
<start> data = dataBuffer <end> ;"	0
47a2a815-6c15-11ed-81d4-94e6f77dd552	"void CWE190_Integer_Overflow__int_fscanf_add_31_bad() { int data; data = 0; fscanf(stdin, ""%d"", &data); { int dataCopy = data; int data = dataCopy; { int result = data + 1; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"fscanf(stdin, ""%d"", <start> &data <end> );
int result = <start> data <end>  + 1;"	"int result = <start> data <end>  + 1;
<start> printIntLine(result) <end> ;"	"<start> printIntLine(result) <end> ;
fscanf(stdin, ""%d"", <start> &data <end> );"	"fscanf(stdin, ""%d"", <start> &data <end> );
int <start> result = data + 1 <end> ;"	0
7c1275b7-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_13_bad() { int data; data = -1; if(GLOBAL_CONST_FIVE==5) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"printLine <start> dest <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printLine <start> dest <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> printLine(dest) <end> ;"	"data = <start> atoi(inputBuffer) <end> ;
printLine <start> dest <end> );"	1
74ee23fa-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 8 static int staticFive = 5; void CWE194_Unexpected_Sign_Extension__fgets_malloc_07_bad() { short data; data = 0; if(staticFive==5) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = (short)atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }"	where is the vulnerable dataflow from data to malloc ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> data = (short)atoi(inputBuffer) <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
char * dataBuffer = (char *)malloc <start> data <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
if  <start> dataBuffer == NULL <end> ) {exit(-1);};"	"<start> printLine(dataBuffer) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	1
b1b8080a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE197_Numeric_Truncation_Error__int_listen_socket_to_char_51b_badSink(int data) { { char charData = (char)data; printHexCharLine(charData); } }"	where is the vulnerable dataflow from charData to printHexCharLine ?	"<start> printHexCharLine(charData) <end> ;
printHexCharLine <start> charData <end> );"	"void CWE197_Numeric_Truncation_Error__int_listen_socket_to_char_51b_badSink(int <start> data <end> );
printHexCharLine <start> charData <end> );"	"void CWE197_Numeric_Truncation_Error__int_listen_socket_to_char_51b_badSink(int <start> data <end> );
<start> printHexCharLine(charData) <end> ;"	"printHexCharLine <start> charData <end> );
void CWE197_Numeric_Truncation_Error__int_listen_socket_to_char_51b_badSink(int <start> data <end> );"	1
728a503b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" void CWE194_Unexpected_Sign_Extension__connect_socket_malloc_10_bad() { short data; data = 0; if(globalTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }"	where is the vulnerable dataflow from data to malloc ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
char * dataBuffer = (char *)malloc <start> data <end> );"	"<start> free(dataBuffer) <end> ;
char * dataBuffer = (char *)malloc <start> data <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printLine(dataBuffer) <end> ;"	"char * dataBuffer = (char *)malloc <start> data <end> );
if  <start> data < 100 <end> );"	0
8b91e492-6c15-11ed-81d4-94e6f77dd552	"void CWE390_Error_Without_Action__fgets_char_03_bad() { if(5==5) { { char dataBuffer[100] = """"; char * data = dataBuffer; printLine(""Please enter a string: ""); if (fgets(data, 100, stdin) == NULL) { } printLine(data); } } }"	where is the vulnerable dataflow from data to printLine ?	"if (fgets <start> data <end> , 100, stdin) == NULL);
printLine <start> data <end> );"	"if (fgets <start> data <end> , 100, stdin) == NULL);
<start> printLine(data) <end> ;"	"printLine <start> data <end> );
if (fgets <start> data <end> , 100, stdin) == NULL);"	"<start> printLine(data) <end> ;
printLine <start> data <end> );"	0
8df4221e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define PATH_SZ 100 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define PATH_SZ PATH_MAX #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 void CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__listen_accept_bind_03_bad() { if(5==5) { { char data[100] = """"; #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[recvResult] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif printLine(data); } } }"	where is the vulnerable dataflow from data to printLine ?	"printLine <start> data <end> );
<start> printLine(data) <end> ;"	"recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);
printLine <start> data <end> );"	"<start> printLine(data) <end> ;
recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);"	"size_t dataLen = <start> strlen(data) <end> ;
printLine <start> data <end> );"	1
cac216d1-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif static int staticFive = 5; namespace CWE36_Absolute_Path_Traversal__char_connect_socket_open_07 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(staticFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"recvResult = recv(connectSocket, (char *)(data + dataLen), <start> sizeof(char) * (FILENAME_MAX - dataLen - 1) <end> , 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
replace = <start> strchr(data, '\n') <end> ;"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	2
7fa68e1d-6c15-11ed-81d4-94e6f77dd552	"namespace CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_72 { void badSink(vector<int> dataVector) { int data = dataVector[2]; { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"void badSink(vector<int> <start> dataVector <end> );
printLine <start> dest <end> );"	"printLine <start> dest <end> );
<start> strncpy(dest, source, data) <end> ;"	"void badSink(vector<int> <start> dataVector <end> );
<start> strncpy(dest, source, data) <end> ;"	"void badSink(vector<int> <start> dataVector <end> );
<start> printLine(dest) <end> ;"	0
cf8750ca-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_file_fopen_66 { void badSink(char * dataArray[]) { char * data = dataArray[2]; { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"char <start> * data = dataArray[2] <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"void badSink(char * <start> dataArray <end> []);
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	"pFile = FOPEN <start> data <end> , ""wb+"");
void badSink(char * <start> dataArray <end> []);"	1
5af03e0a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) int CWE191_Integer_Underflow__int_connect_socket_postdec_61b_badSource(int data); void CWE191_Integer_Underflow__int_connect_socket_postdec_61_bad() { int data; data = 0; data = CWE191_Integer_Underflow__int_connect_socket_postdec_61b_badSource(data); { data--; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"int <start> result = data <end> ;
data = <start> CWE191_Integer_Underflow__int_connect_socket_postdec_61b_badSource <end> (data);"	"<start> data <end> --;
<start> printIntLine(result) <end> ;"	"<start> printIntLine(result) <end> ;
data = <start> CWE191_Integer_Underflow__int_connect_socket_postdec_61b_badSource <end> (data);"	"data = <start> CWE191_Integer_Underflow__int_connect_socket_postdec_61b_badSource <end> (data);
<start> data <end> --;"	3
b1b80844-6c15-11ed-81d4-94e6f77dd552	namespace CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_74 { void badSink(map<int, int> dataMap) { int data = dataMap[2]; { short shortData = (short)data; printShortLine(shortData); } }	where is the vulnerable dataflow from shortData to printShortLine ?	"void badSink(map<int, int> <start> dataMap <end> );
printShortLine <start> shortData <end> );"	"<start> printShortLine(shortData) <end> ;
void badSink(map<int, int> <start> dataMap <end> );"	"<start> printShortLine(shortData) <end> ;
printShortLine <start> shortData <end> );"	"printShortLine <start> shortData <end> );
void badSink(map<int, int> <start> dataMap <end> );"	0
cac216c7-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" namespace CWE36_Absolute_Path_Traversal__char_connect_socket_ofstream_52 { void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badSink_b(data); }"	where is the vulnerable dataflow from data to badSink_b ?	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
badSink_b <start> data <end> );"	"recvResult = <start> recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0) <end> ;
badSink_b <start> data <end> );"	"replace = <start> strchr(data, '\n') <end> ;
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"badSink_b <start> data <end> );
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	0
c72d5d54-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_listen_socket_fopen_13 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(GLOBAL_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"<start> data = dataBuffer <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"<start> recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0) <end> ;
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	3
a6fd8271-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink(int data) { { ++data; int result = data; printIntLine(result); } } void CWE190_Integer_Overflow__int_fgets_preinc_41_bad() { int data; data = 0; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } badSink(data); }"	where is the vulnerable dataflow from result to printIntLine ?	"<start> data = 0 <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );
static void badSink(int <start> data <end> );"	"int <start> result = data <end> ;
printIntLine <start> result <end> );
static void badSink(int <start> data <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
badSink <start> data <end> );
static void badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );"	2
b08640c3-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE197_Numeric_Truncation_Error__int_fgets_to_char_52c_badSink(int data) { { char charData = (char)data; printHexCharLine(charData); } }	where is the vulnerable dataflow from charData to printHexCharLine ?	"printHexCharLine <start> charData <end> );
char <start> charData = (char)data <end> ;"	"printHexCharLine <start> charData <end> );
void CWE197_Numeric_Truncation_Error__int_fgets_to_char_52c_badSink(int <start> data <end> );"	"void CWE197_Numeric_Truncation_Error__int_fgets_to_char_52c_badSink(int <start> data <end> );
printHexCharLine <start> charData <end> );"	"printHexCharLine <start> charData <end> );
<start> printHexCharLine(charData) <end> ;"	2
b68484ff-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define NEW_PATH ""%SystemRoot%\\system32"" #define PUTENV _putenv #else #define NEW_PATH ""/bin"" #define PUTENV putenv #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } void CWE427_Uncontrolled_Search_Path_Element__char_connect_socket_08_bad() { char * data; char dataBuffer[250] = ""PATH=""; data = dataBuffer; if(staticReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (250 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } PUTENV(data); }"	where is the vulnerable dataflow from data to PUTENV ?	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (250 - dataLen - 1), 0);
char <start> dataBuffer[250] = ""PATH="" <end> ;"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (250 - dataLen - 1), 0);
size_t dataLen = <start> strlen(data) <end> ;"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (250 - dataLen - 1), 0);
PUTENV <start> data <end> );"	"PUTENV <start> data <end> );
<start> data = dataBuffer <end> ;"	2
b0864102-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_FIVE = 5; void CWE197_Numeric_Truncation_Error__int_listen_socket_to_char_06_bad() { int data; data = -1; if(STATIC_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { char charData = (char)data; printHexCharLine(charData); } }"	where is the vulnerable dataflow from charData to printHexCharLine ?	"<start> data = -1 <end> ;
printHexCharLine <start> charData <end> );"	"data = <start> atoi(inputBuffer) <end> ;
printHexCharLine <start> charData <end> );"	"char <start> charData = (char)data <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printHexCharLine <start> charData <end> );"	3
c4cd6f79-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_file_fopen_54 { void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } badSink_b(data); }"	where is the vulnerable dataflow from data to badSink_b ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
badSink_b <start> data <end> );"	"char <start> dataBuffer[FILENAME_MAX] = BASEPATH <end> ;
badSink_b <start> data <end> );"	"badSink_b <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	"<start> badSink_b(data) <end> ;
badSink_b <start> data <end> );"	0
445c1206-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__int_connect_socket_add_62 { void badSource(int &data); void bad() { int data; data = 0; badSource(data); { int result = data + 1; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"<start> data = 0 <end> ;
badSource <start> data <end> );"	"int result = <start> data <end>  + 1;
badSource <start> data <end> );"	"int <start> result = data + 1 <end> ;
badSource <start> data <end> );"	"badSource <start> data <end> );
int result = <start> data <end>  + 1;"	3
70279c1f-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; static void badVaSinkB(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_file_vfprintf_04_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; if(STATIC_CONST_TRUE) { { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } if(STATIC_CONST_TRUE) { badVaSinkB(data, data); } }"	where is the vulnerable dataflow from data to vfprintf ?	"<start> va_start(args, data) <end> ;
vfprintf(stdout, <start> data <end> , args);
badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);"	"<start> vfprintf(stdout, data, args) <end> ;
badVaSinkB <start> data <end> , data);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
static void badVaSinkB(char * <start> data <end> , ...);"	"badVaSinkB <start> data <end> , data);
vfprintf(stdout, <start> data <end> , args);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
static void badVaSinkB(char * <start> data <end> , ...);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);"	3
6dc614d8-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" static void badVaSink(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_01_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badVaSink(data, data); }"	where is the vulnerable dataflow from data to vprintf ?	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
vprintf <start> data <end> , args);"	"size_t dataLen = <start> strlen(data) <end> ;
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);"	"static void badVaSink(char * <start> data <end> , ...);
size_t dataLen = <start> strlen(data) <end> ;
badVaSink <start> data <end> , data);
vprintf <start> data <end> , args);"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
badVaSink <start> data <end> , data);
vprintf <start> data <end> , args);
static void badVaSink(char * <start> data <end> , ...);"	0
c99197ff-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" namespace CWE36_Absolute_Path_Traversal__char_connect_socket_ifstream_02 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"replace = <start> strchr(data, '\n') <end> ;
inputFile.open((char * <start> data <end> );"	"inputFile.open((char * <start> data <end> );
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"inputFile.open((char * <start> data <end> );
size_t <start> dataLen = strlen(data) <end> ;"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
inputFile.open((char * <start> data <end> );"	3
453db053-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_square_64b_badSink(void * dataVoidPtr) { int * dataPtr = (int *)dataVoidPtr; int data = (*dataPtr); { int result = data * data; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"void CWE190_Integer_Overflow__int_connect_socket_square_64b_badSink(void * <start> dataVoidPtr <end> );
int <start> result = data * data <end> ;"	"void CWE190_Integer_Overflow__int_connect_socket_square_64b_badSink(void * <start> dataVoidPtr <end> );
<start> printIntLine(result) <end> ;"	"int result = <start> data <end>  * data;
void CWE190_Integer_Overflow__int_connect_socket_square_64b_badSink(void * <start> dataVoidPtr <end> );"	"void CWE190_Integer_Overflow__int_connect_socket_square_64b_badSink(void * <start> dataVoidPtr <end> );
int result = <start> data <end>  * data;"	3
a830bf93-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_connect_socket_sub_03_bad() { int data; data = 0; if(5==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(5==5) { { int result = data - 1; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);"	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data = atoi(inputBuffer) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	3
715a3c04-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif namespace CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_81 { void CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_81_bad::action(char * data) const { { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> printLine(dest) <end> ;
void CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_81_bad::action(char * <start> data <end> ) const;"	"void CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_81_bad::action(char * <start> data <end> ) const;
printLine <start> dest <end> );"	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	"printLine <start> dest <end> );
void CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_81_bad::action(char * <start> data <end> ) const;"	1
4ec5d07b-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int badStatic = 0; static void badSink(int data) { if(badStatic) { { data++; int result = data; printIntLine(result); } } } void CWE190_Integer_Overflow__int_fgets_postinc_21_bad() { int data; data = 0; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } badStatic = 1; badSink(data); }"	where is the vulnerable dataflow from data ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
badSink <start> data <end> );
static void badSink(int <start> data <end> );
<start> data <end> ++;"	"<start> data = atoi(inputBuffer) <end> ;
static void badSink(int <start> data <end> );
<start> data <end> ++;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"<start> data <end> ++;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
static void badSink(int <start> data <end> );"	"<start> badSink(data) <end> ;
badSink <start> data <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
static void badSink(int <start> data <end> );"	0
b41b87a7-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 20 #define IP_ADDRESS ""127.0.0.1"" namespace CWE369_Divide_by_Zero__float_connect_socket_43 { static void badSource(float &data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = (float)atof(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } void bad() { float data; data = 0.0F; badSource(data); { int result = (int)(100.0 / data); printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"int result = <start> (int)(100.0 / data) <end> ;
badSource <start> data <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"badSource <start> data <end> );
printIntLine <start> result <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSource <start> data <end> );
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	2
6ef76810-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif void CWE134_Uncontrolled_Format_String__char_console_snprintf_53d_badSink(char * data) { { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"printLine <start> dest <end> );
<start> printLine(dest) <end> ;"	"printLine <start> dest <end> );
<start> SNPRINTF(dest, 100-1, data) <end> ;"	"void CWE134_Uncontrolled_Format_String__char_console_snprintf_53d_badSink(char * <start> data <end> );
SNPRINTF(dest, <start> 100-1 <end> , data);"	"void CWE134_Uncontrolled_Format_String__char_console_snprintf_53d_badSink(char * <start> data <end> );
printLine <start> dest <end> );"	3
8df4221d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define PATH_SZ 100 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define PATH_SZ PATH_MAX #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 void CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__listen_accept_bind_02_bad() { if(1) { { char data[100] = """"; #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[recvResult] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif printLine(data); } } }"	where is the vulnerable dataflow from data to printLine ?	"printLine <start> data <end> );
recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);"	"recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);
printLine <start> data <end> );"	"recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);
size_t dataLen = <start> strlen(data) <end> ;"	"replace = <start> strchr(data, '\r') <end> ;
printLine <start> data <end> );"	1
98b0154d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_connect_socket_14 { void bad() { int data; data = -1; if(globalFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalFive==5) { { int i; int * buffer = new int[10]; for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } delete[] buffer; } } }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"printIntLine <start> buffer[i] <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[i] <end> );"	"<start> printIntLine(buffer[i]) <end> ;
printIntLine <start> buffer[i] <end> );"	"printIntLine <start> buffer[i] <end> );
data = <start> atoi(inputBuffer) <end> ;"	1
86cea163-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticFive = 5; void CWE369_Divide_by_Zero__int_listen_socket_modulo_07_bad() { int data; data = -1; if(staticFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticFive==5) { printIntLine(100 % data); } }"	where is the vulnerable dataflow from data to printIntLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> 100 % data <end> );"	"printIntLine <start> 100 % data <end> );
data = <start> atoi(inputBuffer) <end> ;"	"printIntLine <start> 100 % data <end> );
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"printIntLine <start> 100 % data <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	0
8b91e498-6c15-11ed-81d4-94e6f77dd552	"void CWE390_Error_Without_Action__fgets_char_10_bad() { if(globalTrue) { { char dataBuffer[100] = """"; char * data = dataBuffer; printLine(""Please enter a string: ""); if (fgets(data, 100, stdin) == NULL) { } printLine(data); } } }"	where is the vulnerable dataflow from data to printLine ?	"printLine <start> data <end> );
if (fgets <start> data <end> , 100, stdin) == NULL);"	"printLine <start> data <end> );
<start> printLine(data) <end> ;"	"if (fgets <start> data <end> , 100, stdin) == NULL);
printLine <start> data <end> );"	"printLine <start> data <end> );
char <start> dataBuffer[100] = """" <end> ;"	2
87ff9845-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_connect_socket_fopen_11 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(globalReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	"recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - <start> dataLen - 1 <end> ), 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
size_t dataLen = <start> strlen(data) <end> ;"	"pFile = FOPEN <start> data <end> , ""wb+"");
size_t dataLen = <start> strlen(data) <end> ;"	0
54c58202-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) typedef struct _CWE191_Integer_Underflow__int_connect_socket_multiply_67_structType { int structFirst; } CWE191_Integer_Underflow__int_connect_socket_multiply_67_structType; void CWE191_Integer_Underflow__int_connect_socket_multiply_67b_badSink(CWE191_Integer_Underflow__int_connect_socket_multiply_67_structType myStruct) { int data = myStruct.structFirst; if(data < 0) { int result = data * 2; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"int data = <start> myStruct <end> .structFirst;
void CWE191_Integer_Underflow__int_connect_socket_multiply_67b_badSink(CWE191_Integer_Underflow__int_connect_socket_multiply_67_structType <start> myStruct <end> );
int result = <start> data <end>  * 2;"	"int result = <start> data <end>  * 2;
void CWE191_Integer_Underflow__int_connect_socket_multiply_67b_badSink(CWE191_Integer_Underflow__int_connect_socket_multiply_67_structType <start> myStruct <end> );
<start> printIntLine(result) <end> ;"	"void CWE191_Integer_Underflow__int_connect_socket_multiply_67b_badSink(CWE191_Integer_Underflow__int_connect_socket_multiply_67_structType <start> myStruct <end> );
int data = <start> myStruct <end> .structFirst;
<start> printIntLine(result) <end> ;"	"void CWE191_Integer_Underflow__int_connect_socket_multiply_67b_badSink(CWE191_Integer_Underflow__int_connect_socket_multiply_67_structType <start> myStruct <end> );
int data = <start> myStruct <end> .structFirst;
int result = <start> data <end>  * 2;"	3
b68484f6-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(count) + 2) namespace CWE400_Resource_Exhaustion__listen_socket_sleep_81 { void bad() { int count; count = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; count = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } const CWE400_Resource_Exhaustion__listen_socket_sleep_81_base& baseObject = CWE400_Resource_Exhaustion__listen_socket_sleep_81_bad(); baseObject.action(count); }"	where is the vulnerable dataflow from count to action ?	"if  <start> acceptSocket == SOCKET_ERROR <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
baseObject.action <start> count <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
baseObject.action <start> count <end> );"	"baseObject.action <start> count <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	2
a830bf7a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink(int data) { if(data < 0) { int result = data * 2; printIntLine(result); } } void CWE191_Integer_Underflow__int_connect_socket_multiply_41_bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badSink(data); }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);
badSink <start> data <end> );
static void badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSink <start> data <end> );
static void badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"badSink <start> data <end> );
static void badSink(int <start> data <end> );
<start> printIntLine(result) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"printIntLine <start> result <end> );
static void badSink(int <start> data <end> );
badSink <start> data <end> );
int <start> result = data * 2 <end> ;"	1
7ae3a710-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_15_bad() { int data; data = -1; switch(6) { case 6: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; default: printLine(""Benign, fixed string""); break; } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"<start> memmove(dest, source, data) <end> ;
printLine <start> dest <end> );"	"<start> memmove(dest, source, data) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"data = <start> atoi(inputBuffer) <end> ;
printLine <start> dest <end> );"	0
bc721f9b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define EXECLP _execlp #else #define EXECLP execlp #endif void CWE78_OS_Command_Injection__char_file_execlp_31_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } { char * dataCopy = data; char * data = dataCopy; EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL); } }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECLP ?	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
<start> EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL) <end> ;"	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
char <start> dataBuffer[100] = COMMAND_ARG2 <end> ;"	2
54c581f8-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_connect_socket_multiply_51b_badSink(int data) { if(data < 0) { int result = data * 2; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"void CWE191_Integer_Underflow__int_connect_socket_multiply_51b_badSink(int <start> data <end> );
int result = <start> data <end>  * 2;"	"int result = <start> data <end>  * 2;
void CWE191_Integer_Underflow__int_connect_socket_multiply_51b_badSink(int <start> data <end> );"	"int <start> result = data * 2 <end> ;
void CWE191_Integer_Underflow__int_connect_socket_multiply_51b_badSink(int <start> data <end> );"	"void CWE191_Integer_Underflow__int_connect_socket_multiply_51b_badSink(int <start> data <end> );
int result = <start> data * 2 <end> ;"	0
cac216a6-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" namespace CWE36_Absolute_Path_Traversal__char_connect_socket_ifstream_45 { static char * badData; static char * goodG2BData; static void badSink() { char * data = badData; { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } } void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badData = data; badSink(); }"	where is the vulnerable dataflow from data to open ?	"replace = <start> strchr(data, '\r') <end> ;
char * data = <start> badData <end> ;
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
static char * <start> badData <end> ;
<start> badData = data <end> ;"	"static char * <start> badData <end> ;
size_t dataLen = <start> strlen(data) <end> ;
char * data = <start> badData <end> ;
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
inputFile.open((char * <start> data <end> );"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
<start> badData = data <end> ;
static char * <start> badData <end> ;
char * data = <start> badData <end> ;
inputFile.open((char * <start> data <end> );"	"inputFile.open((char * <start> data <end> );
static char * <start> badData <end> ;
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	2
bda4e412-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define EXECL _execl #else #define EXECL execl #endif static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; void CWE78_OS_Command_Injection__char_listen_socket_execl_04_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(STATIC_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECL ?	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
size_t dataLen = <start> strlen(data) <end> ;"	"<start> EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL) <end> ;
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"<start> data = dataBuffer <end> ;
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	2
728a502c-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 extern char * CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_68_badData; extern char * CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_68_goodG2BData; extern char * CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_68_goodB2GData; static void badVaSink(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_68b_badSink() { char * data = CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_68_badData; badVaSink(data, data); }"	where is the vulnerable dataflow from data to vprintf ?	"char * data = <start> CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_68_badData <end> ;
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
vprintf <start> data <end> , args);"	"badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
vprintf <start> data <end> , args);"	"<start> va_start(args, data) <end> ;
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
vprintf <start> data <end> , args);"	"static void badVaSink(char * <start> data <end> , ...);
char * data = <start> CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_68_badData <end> ;
badVaSink <start> data <end> , data);
<start> vprintf(data, args) <end> ;"	0
c4cd6f5d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_file_fopen_03 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(5==5) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
pFile = FOPEN <start> data <end> , ""wb+"");"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	"pFile = FOPEN <start> data <end> , ""wb+"");
size_t dataLen = <start> strlen(data) <end> ;"	"pFile = FOPEN <start> data <end> , ""wb+"");
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	0
833ac93b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_listen_socket_open_15 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; switch(6) { case 6: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; default: printLine(""Benign, fixed string""); break; } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN(data, O_RDWR|O_CREAT, <start> S_IREAD|S_IWRITE <end> );"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
<start> data = dataBuffer <end> ;"	"replace = <start> strchr(data, '\r') <end> ;
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	1
6dc61517-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif void CWE134_Uncontrolled_Format_String__char_console_snprintf_31_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } { char * dataCopy = data; char * data = dataCopy; { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } } }"	where is the vulnerable dataflow from dest to printLine ?	"printLine <start> dest <end> );
char <start> dataBuffer[100] = """" <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
printLine <start> dest <end> );"	"printLine <start> dest <end> );
char <start> * data = dataCopy <end> ;"	"printLine <start> dest <end> );
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	1
78800f94-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 8 void CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_52c_badSink(short data) { { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> printLine(dest) <end> ;
void CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_52c_badSink(short <start> data <end> );"	"void CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_52c_badSink(short <start> data <end> );
printLine <start> dest <end> );"	"void CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_52c_badSink(short <start> data <end> );
<start> memcpy(dest, source, data) <end> ;"	"printLine <start> dest <end> );
<start> printLine(dest) <end> ;"	1
7c1275a3-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_66b_badSink(int dataArray[]) { int data = dataArray[2]; { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> memcpy(dest, source, data) <end> ;
printLine <start> dest <end> );"	"void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_66b_badSink(int <start> dataArray <end> []);
<start> printLine(dest) <end> ;"	"printLine <start> dest <end> );
void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_66b_badSink(int <start> dataArray <end> []);"	"void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_66b_badSink(int <start> dataArray <end> []);
printLine <start> dest <end> );"	3
c5fc2353-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif namespace CWE23_Relative_Path_Traversal__char_file_ofstream_11 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(globalReturnsTrue()) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"outputFile.open((char * <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"outputFile.open((char * <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
outputFile.open((char * <start> data <end> );"	"char <start> dataBuffer[FILENAME_MAX] = BASEPATH <end> ;
outputFile.open((char * <start> data <end> );"	2
774f5806-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 8 void CWE194_Unexpected_Sign_Extension__listen_socket_malloc_01_bad() { short data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }"	where is the vulnerable dataflow from data to malloc ?	"<start> memset(dataBuffer, 'A', data-1) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
char * dataBuffer = (char *)malloc <start> data <end> );"	"char * dataBuffer = (char *)malloc <start> data <end> );
tempInt = <start> atoi(inputBuffer) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
tempInt = <start> atoi(inputBuffer) <end> ;"	1
c8600aec-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 namespace CWE23_Relative_Path_Traversal__char_listen_socket_ofstream_41 { void badSink(char * data) { { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } } void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badSink(data); }"	where is the vulnerable dataflow from data to badSink ?	"size_t dataLen = <start> strlen(data) <end> ;
badSink <start> data <end> );"	"replace = <start> strchr(data, '\r') <end> ;
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"badSink <start> data <end> );
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
badSink <start> data <end> );"	3
cd228142-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif namespace CWE36_Absolute_Path_Traversal__char_console_ofstream_17 { void bad() { int i; char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; for(i = 0; i < 1; i++) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
outputFile.open((char * <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
<start> data = dataBuffer <end> ;"	"if (dataLen > 0 && <start> data[dataLen-1] == '\n' <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"outputFile.open((char * <start> data <end> );
<start> data = dataBuffer <end> ;"	0
aa91a17e-6c15-11ed-81d4-94e6f77dd552	namespace CWE191_Integer_Underflow__int_listen_socket_multiply_73 { void badSink(list<int> dataList) { int data = dataList.back(); if(data < 0) { int result = data * 2; printIntLine(result); } }	where is the vulnerable dataflow from result to printIntLine ?	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	"void badSink(list<int> <start> dataList <end> );
printIntLine <start> result <end> );"	"<start> printIntLine(result) <end> ;
void badSink(list<int> <start> dataList <end> );"	"int result = <start> data * 2 <end> ;
void badSink(list<int> <start> dataList <end> );"	1
a5ce1c83-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int badStatic = 0; static void badSink(int data) { if(badStatic) { { data++; int result = data; printIntLine(result); } } } void CWE190_Integer_Overflow__int_listen_socket_postinc_21_bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badStatic = 1; badSink(data); }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data = 0 <end> ;
static void badSink(int <start> data <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSink <start> data <end> );
static void badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"<start> data = atoi(inputBuffer) <end> ;
printIntLine <start> result <end> );
static void badSink(int <start> data <end> );
badSink <start> data <end> );"	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
badSink <start> data <end> );
printIntLine <start> result <end> );
static void badSink(int <start> data <end> );"	1
cac216e9-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_connect_socket_open_54 { void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badSink_b(data); }"	where is the vulnerable dataflow from data to badSink_b ?	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
badSink_b <start> data <end> );"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
size_t dataLen = <start> strlen(data) <end> ;"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
badSink_b <start> data <end> );"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
size_t <start> dataLen = strlen(data) <end> ;"	2
d0b64eec-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif namespace CWE36_Absolute_Path_Traversal__char_file_ofstream_17 { void bad() { int i; char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; for(i = 0; i < 1; i++) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
<start> data = dataBuffer <end> ;"	"outputFile.open((char * <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
outputFile.open((char * <start> data <end> );"	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	2
9187cc14-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #define SEARCH_CHAR 'S' void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_file_01_bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\0'; { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } for (; *data != '\0'; data++) { if (*data == SEARCH_CHAR) { printLine(""We have a match!""); break; } } free(data); }"	where is the vulnerable dataflow from data to free ?	"if  <start> data == NULL <end> ) {exit(-1);};
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	"free <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	"<start> data = (char *)malloc(100*sizeof(char)) <end> ;
free <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
free <start> data <end> );"	3
7e74f30a-6c15-11ed-81d4-94e6f77dd552	namespace CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_72 { void badSink(vector<int> dataVector) { int data = dataVector[2]; if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }	where is the vulnerable dataflow from data to malloc ?	"char * dataBuffer = (char *)malloc <start> data <end> );
char <start> * dataBuffer = (char *)malloc(data) <end> ;"	"void badSink(vector<int> <start> dataVector <end> );
char * dataBuffer = (char *)malloc <start> data <end> );"	"char * dataBuffer = (char *)malloc <start> data <end> );
int <start> data = dataVector[2] <end> ;"	"char * dataBuffer = (char *)malloc <start> data <end> );
<start> free(dataBuffer) <end> ;"	1
b1b80845-6c15-11ed-81d4-94e6f77dd552	namespace CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_81 { void CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_81_bad::action(int data) const { { short shortData = (short)data; printShortLine(shortData); } } }	where is the vulnerable dataflow from shortData to printShortLine ?	"short <start> shortData = (short)data <end> ;
void CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_81_bad::action(int <start> data <end> ) const;"	"void CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_81_bad::action(int <start> data <end> ) const;
printShortLine <start> shortData <end> );"	"<start> printShortLine(shortData) <end> ;
printShortLine <start> shortData <end> );"	"printShortLine <start> shortData <end> );
short <start> shortData = (short)data <end> ;"	1
9059f3a2-6c15-11ed-81d4-94e6f77dd552	int CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_22_badGlobal = 0; int CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_22_badSource(int data); void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_22_bad() { int data; data = -1; CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_22_badGlobal = 1; data = CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_22_badSource(data); { size_t i; int *intPointer; intPointer = (int*)malloc(data * sizeof(int)); if (intPointer == NULL) {exit(-1);} for (i = 0; i < (size_t)data; i++) { intPointer[i] = 0; } printIntLine(intPointer[0]); free(intPointer); } }	where is the vulnerable dataflow from data to malloc ?	"intPointer = (int*)malloc <start> data * sizeof(int) <end> );
intPointer = <start> (int*)malloc(data * sizeof(int)) <end> ;"	"data = <start> CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_22_badSource <end> (data);
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	"data = <start> CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_22_badSource <end> (data);
intPointer = <start> (int*)malloc(data * sizeof(int)) <end> ;"	"intPointer = (int* <start> malloc(data * sizeof(int)) <end> ;
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	1
a10948ff-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__int_connect_socket_multiply_82 { void CWE190_Integer_Overflow__int_connect_socket_multiply_82_bad::action(int data) { if(data > 0) { int result = data * 2; printIntLine(result); } } }	where is the vulnerable dataflow from result to printIntLine ?	"int result = <start> data * 2 <end> ;
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;"	"int <start> result = data * 2 <end> ;
void CWE190_Integer_Overflow__int_connect_socket_multiply_82_bad::action(int <start> data <end> );"	"void CWE190_Integer_Overflow__int_connect_socket_multiply_82_bad::action(int <start> data <end> );
printIntLine <start> result <end> );"	3
761e298b-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 8 static short CWE194_Unexpected_Sign_Extension__fgets_memmove_45_badData; static short CWE194_Unexpected_Sign_Extension__fgets_memmove_45_goodG2BData; static void badSink() { short data = CWE194_Unexpected_Sign_Extension__fgets_memmove_45_badData; { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } } void CWE194_Unexpected_Sign_Extension__fgets_memmove_45_bad() { short data; data = 0; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = (short)atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } CWE194_Unexpected_Sign_Extension__fgets_memmove_45_badData = data; badSink(); }"	where is the vulnerable dataflow from dest to printLine ?	"<start> CWE194_Unexpected_Sign_Extension__fgets_memmove_45_badData = data <end> ;
static short <start> CWE194_Unexpected_Sign_Extension__fgets_memmove_45_badData <end> ;
printLine <start> dest <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
if  <start> data < 100 <end> );"	"char <start> dest[100] = """" <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
short data = <start> CWE194_Unexpected_Sign_Extension__fgets_memmove_45_badData <end> ;
static short <start> CWE194_Unexpected_Sign_Extension__fgets_memmove_45_badData <end> ;
<start> CWE194_Unexpected_Sign_Extension__fgets_memmove_45_badData = data <end> ;"	"<start> memmove(dest, source, data) <end> ;
printLine <start> dest <end> );
<start> CWE194_Unexpected_Sign_Extension__fgets_memmove_45_badData = data <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
static short <start> CWE194_Unexpected_Sign_Extension__fgets_memmove_45_badData <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> CWE194_Unexpected_Sign_Extension__fgets_memmove_45_badData = data <end> ;
static short <start> CWE194_Unexpected_Sign_Extension__fgets_memmove_45_badData <end> ;
short data = <start> CWE194_Unexpected_Sign_Extension__fgets_memmove_45_badData <end> ;
printLine <start> dest <end> );"	3
893217bf-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_console_fopen_09 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(GLOBAL_CONST_TRUE) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
pFile = FOPEN <start> data <end> , ""wb+"");"	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"pFile = FOPEN <start> data <end> , ""wb+"");
<start> data = dataBuffer <end> ;"	"if (dataLen > 0 && <start> data[dataLen-1] == '\n' <end> );
pFile = FOPEN <start> data <end> , ""wb+"");"	0
70279c15-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif typedef struct _CWE134_Uncontrolled_Format_String__char_file_snprintf_67_structType { char * structFirst; } CWE134_Uncontrolled_Format_String__char_file_snprintf_67_structType; void CWE134_Uncontrolled_Format_String__char_file_snprintf_67b_badSink(CWE134_Uncontrolled_Format_String__char_file_snprintf_67_structType myStruct) { char * data = myStruct.structFirst; { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );
char * data = <start> myStruct <end> .structFirst;"	"printLine <start> dest <end> );
char * data = <start> myStruct <end> .structFirst;"	"void CWE134_Uncontrolled_Format_String__char_file_snprintf_67b_badSink(CWE134_Uncontrolled_Format_String__char_file_snprintf_67_structType <start> myStruct <end> );
char * data = <start> myStruct <end> .structFirst;
printLine <start> dest <end> );"	"<start> SNPRINTF(dest, 100-1, data) <end> ;
char * data = <start> myStruct <end> .structFirst;
printLine <start> dest <end> );"	2
bda4e446-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 namespace CWE78_OS_Command_Injection__char_listen_socket_execlp_82 { void bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE78_OS_Command_Injection__char_listen_socket_execlp_82_base* baseObject = new CWE78_OS_Command_Injection__char_listen_socket_execlp_82_bad; baseObject->action(data); delete baseObject; }"	where is the vulnerable dataflow from data to action ?	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
baseObject->action <start> data <end> );"	"<start> data = dataBuffer <end> ;
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"baseObject->action <start> data <end> );
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"size_t <start> dataLen = strlen(data) <end> ;
baseObject->action <start> data <end> );"	0
5d16c9c2-6c15-11ed-81d4-94e6f77dd552	"void CWE191_Integer_Underflow__short_fscanf_postdec_18_bad() { short data; data = 0; goto source; source: fscanf (stdin, ""%hd"", &data); goto sink; sink: { data--; short result = data; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"<start> data <end> --;
<start> printIntLine(result) <end> ;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
<start> data <end> --;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
<start> printIntLine(result) <end> ;"	"<start> data <end> --;
fscanf (stdin, ""%hd"", <start> &data <end> );"	1
6c938c0d-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif char * CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_61b_badSource(char * data); void CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_61_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; data = CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_61b_badSource(data); { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"printLine <start> dest <end> );
<start> SNPRINTF(dest, 100-1, data) <end> ;"	"data = <start> CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_61b_badSource <end> (data);
SNPRINTF(dest, <start> 100-1 <end> , data);"	"data = <start> CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_61b_badSource <end> (data);
printLine <start> dest <end> );"	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	2
833ac93f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_listen_socket_open_21 { static int badStatic = 0; static char * badSource(char * data) { if(badStatic) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } return data; } void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; badStatic = 1; data = badSource(data); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } ; }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
data = <start> badSource <end> (data);"	"static char * <start> badSource <end> (char * data);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
data = <start> badSource <end> (data);"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"static char * <start> badSource <end> (char * data);
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
if  <start> listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR <end> );
data = <start> badSource <end> (data);"	2
4b34afcd-6c15-11ed-81d4-94e6f77dd552	"void CWE190_Integer_Overflow__short_fscanf_multiply_03_bad() { short data; data = 0; if(5==5) { fscanf (stdin, ""%hd"", &data); } if(5==5) { if(data > 0) { short result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
short result = <start> data <end>  * 2;"	"short <start> result = data * 2 <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );"	"<start> printIntLine(result) <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );"	"fscanf (stdin, ""%hd"", <start> &data <end> );
short result = <start> data <end>  * 2;"	3
ba102b8c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define EXECL _execl #else #define EXECL execl #endif static char * badSource(char * data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } return data; } void CWE78_OS_Command_Injection__char_connect_socket_execl_42_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; data = badSource(data); EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECL ?	"data = <start> badSource <end> (data);
static char * <start> badSource <end> (char * data);
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
<start> EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL) <end> ;"	"EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);"	2
af580929-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_31_bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { int dataCopy = data; int data = dataCopy; { char charData = (char)data; printHexCharLine(charData); } } }"	where is the vulnerable dataflow from charData to printHexCharLine ?	"<start> printHexCharLine(charData) <end> ;
printHexCharLine <start> charData <end> );"	"data = <start> atoi(inputBuffer) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printHexCharLine <start> charData <end> );"	"printHexCharLine <start> charData <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	2
525b648c-6c15-11ed-81d4-94e6f77dd552	"static short badSource(short data) { fscanf (stdin, ""%hd"", &data); return data; } void CWE190_Integer_Overflow__short_fscanf_preinc_42_bad() { short data; data = 0; data = badSource(data); { ++data; short result = data; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"fscanf (stdin, ""%hd"", <start> &data <end> );
static short <start> badSource <end> (short data);
data = <start> badSource <end> (data);
+ <start> data <end> ;"	"static short <start> badSource <end> (short data);
fscanf (stdin, ""%hd"", <start> &data <end> );"	"static short <start> badSource <end> (short data);
fscanf (stdin, ""%hd"", <start> &data <end> );
data = <start> badSource <end> (data);
+ <start> data <end> ;"	"+ <start> data <end> ;
static short <start> badSource <end> (short data);
<start> printIntLine(result) <end> ;
data = <start> badSource <end> (data);"	0
951c5ea1-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FULL_COMMAND ""dir "" #else #define FULL_COMMAND ""ls "" #endif #ifdef _WIN32 #define POPEN _popen #define PCLOSE _pclose #else #define POPEN popen #define PCLOSE pclose #endif namespace CWE78_OS_Command_Injection__char_console_popen_73 { void badSink(list<char *> dataList) { char * data = dataList.back(); { FILE *pipe; pipe = POPEN(data, ""w""); if (pipe != NULL) { PCLOSE(pipe); } } }"	where is the vulnerable dataflow from data to POPEN ?	"char <start> * data = dataList.back() <end> ;
pipe = POPEN <start> data <end> , ""w"");"	"pipe = POPEN <start> data <end> , ""w"");
pipe = <start> POPEN(data, ""w"") <end> ;"	"void badSink(list<char *> <start> dataList <end> );
pipe = POPEN <start> data <end> , ""w"");"	"pipe = POPEN <start> data <end> , ""w"");
void badSink(list<char *> <start> dataList <end> );"	2
aa91a173-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_listen_socket_multiply_53d_badSink(int data) { if(data < 0) { int result = data * 2; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"void CWE191_Integer_Underflow__int_listen_socket_multiply_53d_badSink(int <start> data <end> );
<start> printIntLine(result) <end> ;"	"int <start> result = data * 2 <end> ;
void CWE191_Integer_Underflow__int_listen_socket_multiply_53d_badSink(int <start> data <end> );"	"void CWE191_Integer_Underflow__int_listen_socket_multiply_53d_badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"int <start> result = data * 2 <end> ;
printIntLine <start> result <end> );"	2
70279bf1-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif void CWE134_Uncontrolled_Format_String__char_file_snprintf_01_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
printLine <start> dest <end> );"	"SNPRINTF(dest, <start> 100-1 <end> , data);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
<start> printLine(dest) <end> ;"	"SNPRINTF(dest, <start> 100-1 <end> , data);
printLine <start> dest <end> );"	0
820a46dd-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_file_open_12 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(globalReturnsTrueOrFalse()) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } else { strcat(data, ""file.txt""); } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
<start> data = dataBuffer <end> ;"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
size_t dataLen = <start> strlen(data) <end> ;"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	3
cd22814e-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif namespace CWE36_Absolute_Path_Traversal__char_console_ofstream_53 { void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } badSink_b(data); }"	where is the vulnerable dataflow from data to badSink_b ?	"dataLen = <start> strlen(data) <end> ;
badSink_b <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
badSink_b <start> data <end> );"	"badSink_b <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	"<start> badSink_b(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	1
6dc614ed-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" static void badVaSink(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); va_end(args); } } static void badSink(char * data) { badVaSink(data, data); } void CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_41_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badSink(data); }"	where is the vulnerable dataflow from data to vprintf ?	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
badSink <start> data <end> );
static void badSink(char * <start> data <end> );
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
vprintf <start> data <end> , args);"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (100 - dataLen - 1), 0);
vprintf <start> data <end> , args);
static void badSink(char * <start> data <end> );
badVaSink <start> data <end> , data);
badSink <start> data <end> );
static void badVaSink(char * <start> data <end> , ...);"	"badSink <start> data <end> );
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (100 - dataLen - 1), 0);
badVaSink <start> data <end> , data);
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
static void badVaSink(char * <start> data <end> , ...);
vprintf <start> data <end> , args);"	"<start> badSink(data) <end> ;
static void badVaSink(char * <start> data <end> , ...);
vprintf <start> data <end> , args);
badSink <start> data <end> );
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
static void badSink(char * <start> data <end> );"	0
a23a3e1c-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } void CWE190_Integer_Overflow__int_fgets_multiply_08_bad() { int data; data = 0; if(staticReturnsTrue()) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(staticReturnsTrue()) { if(data > 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );"	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	"<start> printIntLine(result) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"printIntLine <start> result <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	0
74ee23e5-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" void CWE194_Unexpected_Sign_Extension__connect_socket_strncpy_53d_badSink(short data) { { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"void CWE194_Unexpected_Sign_Extension__connect_socket_strncpy_53d_badSink(short <start> data <end> );
printLine <start> dest <end> );"	"printLine <start> dest <end> );
void CWE194_Unexpected_Sign_Extension__connect_socket_strncpy_53d_badSink(short <start> data <end> );"	"<start> printLine(dest) <end> ;
void CWE194_Unexpected_Sign_Extension__connect_socket_strncpy_53d_badSink(short <start> data <end> );"	"<start> strncpy(dest, source, data) <end> ;
printLine <start> dest <end> );"	0
9fe7ad31-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif namespace CWE134_Uncontrolled_Format_String__char_file_vprintf_81 { void bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } const CWE134_Uncontrolled_Format_String__char_file_vprintf_81_base& baseObject = CWE134_Uncontrolled_Format_String__char_file_vprintf_81_bad(); baseObject.action(data); }"	where is the vulnerable dataflow from data to action ?	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
baseObject.action <start> data <end> );"	"baseObject.action <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	"baseObject.action <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	"<start> data = dataBuffer <end> ;
baseObject.action <start> data <end> );"	0
98b01551-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_connect_socket_18 { void bad() { int data; data = -1; goto source; source: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } goto sink; sink: { int i; int * buffer = new int[10]; for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } delete[] buffer; } }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"<start> printIntLine(buffer[i]) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"data = <start> atoi(inputBuffer) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> buffer[i] <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[i] <end> );"	3
5e44fc60-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_connect_socket_predec_52c_badSink(int data) { { --data; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
- <start> data <end> ;"	"void CWE191_Integer_Underflow__int_connect_socket_predec_52c_badSink(int <start> data <end> );
- <start> data <end> ;"	"void CWE191_Integer_Underflow__int_connect_socket_predec_52c_badSink(int <start> data <end> );
<start> printIntLine(result) <end> ;"	"- <start> data <end> ;
void CWE191_Integer_Underflow__int_connect_socket_predec_52c_badSink(int <start> data <end> );"	1
6ef7682c-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif static void badVaSinkB(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_console_vfprintf_14_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; if(globalFive==5) { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } if(globalFive==5) { badVaSinkB(data, data); } }"	where is the vulnerable dataflow from data to vfprintf ?	"<start> va_start(args, data) <end> ;
badVaSinkB <start> data <end> , data);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
vfprintf(stdout, <start> data <end> , args);"	"static void badVaSinkB(char * <start> data <end> , ...);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
badVaSinkB <start> data <end> , data);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);"	"static void badVaSinkB(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);
dataLen = <start> strlen(data) <end> ;
badVaSinkB <start> data <end> , data);"	2
67d0109d-6c15-11ed-81d4-94e6f77dd552	static int CWE190_Integer_Overflow__int_rand_postinc_45_badData; static int CWE190_Integer_Overflow__int_rand_postinc_45_goodG2BData; static int CWE190_Integer_Overflow__int_rand_postinc_45_goodB2GData; static void badSink() { int data = CWE190_Integer_Overflow__int_rand_postinc_45_badData; { data++; int result = data; printIntLine(result); } } void CWE190_Integer_Overflow__int_rand_postinc_45_bad() { int data; data = 0; data = RAND32(); CWE190_Integer_Overflow__int_rand_postinc_45_badData = data; badSink(); }	where is the vulnerable dataflow from data ?	"data = <start> RAND32() <end> ;
static int <start> CWE190_Integer_Overflow__int_rand_postinc_45_badData <end> ;
int data = <start> CWE190_Integer_Overflow__int_rand_postinc_45_badData <end> ;"	"data = <start> RAND32() <end> ;
<start> CWE190_Integer_Overflow__int_rand_postinc_45_badData = data <end> ;
static int <start> CWE190_Integer_Overflow__int_rand_postinc_45_badData <end> ;
int data = <start> CWE190_Integer_Overflow__int_rand_postinc_45_badData <end> ;
<start> data <end> ++;"	"<start> data++ <end> ;
int data = <start> CWE190_Integer_Overflow__int_rand_postinc_45_badData <end> ;
<start> CWE190_Integer_Overflow__int_rand_postinc_45_badData = data <end> ;
data = <start> RAND32() <end> ;
static int <start> CWE190_Integer_Overflow__int_rand_postinc_45_badData <end> ;"	"<start> CWE190_Integer_Overflow__int_rand_postinc_45_badData = data <end> ;
static int <start> CWE190_Integer_Overflow__int_rand_postinc_45_badData <end> ;
data = <start> RAND32() <end> ;
int data = <start> CWE190_Integer_Overflow__int_rand_postinc_45_badData <end> ;
<start> data <end> ++;"	1
78800fa2-6c15-11ed-81d4-94e6f77dd552	"namespace CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_81 { void CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_81_bad::action(short data) const { { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> memcpy(dest, source, data) <end> ;
void CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_81_bad::action(short <start> data <end> ) const;"	"printLine <start> dest <end> );
if  <start> data < 100 <end> );"	"printLine <start> dest <end> );
void CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_81_bad::action(short <start> data <end> ) const;"	"void CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_81_bad::action(short <start> data <end> ) const;
printLine <start> dest <end> );"	3
b1b8080d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE197_Numeric_Truncation_Error__int_listen_socket_to_char_54e_badSink(int data) { { char charData = (char)data; printHexCharLine(charData); } }"	where is the vulnerable dataflow from charData to printHexCharLine ?	"void CWE197_Numeric_Truncation_Error__int_listen_socket_to_char_54e_badSink(int <start> data <end> );
char <start> charData = (char)data <end> ;"	"void CWE197_Numeric_Truncation_Error__int_listen_socket_to_char_54e_badSink(int <start> data <end> );
printHexCharLine <start> charData <end> );"	"void CWE197_Numeric_Truncation_Error__int_listen_socket_to_char_54e_badSink(int <start> data <end> );
<start> printHexCharLine(charData) <end> ;"	"char charData = <start> (char)data <end> ;
printHexCharLine <start> charData <end> );"	1
6b862425-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_connect_socket_12_bad() { int data; data = -1; if(globalReturnsTrueOrFalse()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } else { data = 7; } if(globalReturnsTrueOrFalse()) { { int i; int * buffer = (int *)malloc(10 * sizeof(int)); if (buffer == NULL) {exit(-1);} for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } free(buffer); } } else { { int i; int * buffer = (int *)malloc(10 * sizeof(int)); if (buffer == NULL) {exit(-1);} for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0 && data < (10)) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is out-of-bounds""); } free(buffer); } } }"	where is the vulnerable dataflow from buffer to free ?	"free <start> buffer <end> );
recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
free <start> buffer <end> );"	"free <start> buffer <end> );
data = <start> atoi(inputBuffer) <end> ;"	"<start> free(buffer) <end> ;
free <start> buffer <end> );"	1
453db00e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } void CWE190_Integer_Overflow__int_connect_socket_multiply_08_bad() { int data; data = 0; if(staticReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticReturnsTrue()) { if(data > 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  * 2;
data = <start> atoi(inputBuffer) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  * 2;"	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
int result = <start> data <end>  * 2;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printIntLine(result) <end> ;"	1
d0b64ee1-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; namespace CWE36_Absolute_Path_Traversal__char_file_ofstream_04 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(STATIC_CONST_TRUE) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"char <start> dataBuffer[FILENAME_MAX] = """" <end> ;
outputFile.open((char * <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
size_t dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
outputFile.open((char * <start> data <end> );"	"<start> data = dataBuffer <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	2
453db00d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticFive = 5; void CWE190_Integer_Overflow__int_connect_socket_multiply_07_bad() { int data; data = 0; if(staticFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticFive==5) { if(data > 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int <start> result = data * 2 <end> ;"	"int result = <start> data <end>  * 2;
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data * 2 <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  * 2;"	3
a6fd8267-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_preinc_13_bad() { int data; data = 0; if(GLOBAL_CONST_FIVE==5) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(GLOBAL_CONST_FIVE==5) { { ++data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"printIntLine <start> result <end> );
int <start> result = data <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );"	"int <start> result = data <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	2
4ec5d090-6c15-11ed-81d4-94e6f77dd552	"void CWE190_Integer_Overflow__int_fscanf_postinc_03_bad() { int data; data = 0; if(5==5) { fscanf(stdin, ""%d"", &data); } if(5==5) { { data++; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"int <start> result = data <end> ;
<start> data <end> ++;"	"<start> data <end> ++;
fscanf(stdin, ""%d"", <start> &data <end> );"	"fscanf(stdin, ""%d"", <start> &data <end> );
int <start> result = data <end> ;"	"fscanf(stdin, ""%d"", <start> &data <end> );
<start> data <end> ++;"	3
a830bfa5-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_connect_socket_sub_31_bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { int dataCopy = data; int data = dataCopy; { int result = data - 1; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
int <start> result = data - 1 <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
data = <start> atoi(inputBuffer) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printIntLine(result) <end> ;"	1
7e74f33b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_01_bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"printLine <start> dest <end> );
<start> printLine(dest) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data = -1 <end> ;"	"<start> printLine(dest) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	0
69161b6a-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__short_rand_preinc_65b_badSink(short data) { { ++data; short result = data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"+ <start> data <end> ;
void CWE190_Integer_Overflow__short_rand_preinc_65b_badSink(short <start> data <end> );"	"<start> printIntLine(result) <end> ;
+ <start> data <end> ;"	"void CWE190_Integer_Overflow__short_rand_preinc_65b_badSink(short <start> data <end> );
+ <start> data <end> ;"	"void CWE190_Integer_Overflow__short_rand_preinc_65b_badSink(short <start> data <end> );
<start> printIntLine(result) <end> ;"	2
5af03df6-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_connect_socket_postdec_10_bad() { int data; data = 0; if(globalTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalTrue) { { data--; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data <end> --;"	"<start> data <end> --;
recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);"	"int <start> result = data <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	1
c01af8b1-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" namespace CWE23_Relative_Path_Traversal__char_connect_socket_ofstream_16 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; while(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"outputFile.open((char * <start> data <end> );
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"<start> data = dataBuffer <end> ;
outputFile.open((char * <start> data <end> );"	"size_t dataLen = <start> strlen(data) <end> ;
outputFile.open((char * <start> data <end> );"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
outputFile.open((char * <start> data <end> );"	3
715a3bee-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif extern int CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_22_badGlobal; void CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_22_badSink(char * data) { if(CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_22_badGlobal) { { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } } }"	where is the vulnerable dataflow from dest to printLine ?	"void CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_22_badSink(char * <start> data <end> );
printLine <start> dest <end> );"	"printLine <start> dest <end> );
void CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_22_badSink(char * <start> data <end> );"	"printLine <start> dest <end> );
SNPRINTF(dest, <start> 100-1 <end> , data);"	"void CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_22_badSink(char * <start> data <end> );
<start> printLine(dest) <end> ;"	0
92bb8a09-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define SEARCH_CHAR 'S' typedef union { char * unionFirst; char * unionSecond; } CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_34_unionType; void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_34_bad() { char * data; CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_34_unionType myUnion; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\0'; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } myUnion.unionFirst = data; { char * data = myUnion.unionSecond; for (; *data != '\0'; data++) { if (*data == SEARCH_CHAR) { printLine(""We have a match!""); break; } } free(data); } }"	where is the vulnerable dataflow from data to free ?	"<start> data = (char *)malloc(100*sizeof(char)) <end> ;
free <start> data <end> );"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
if  <start> data == NULL <end> ) {exit(-1);};"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
free <start> data <end> );"	"char <start> * data = myUnion.unionSecond <end> ;
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	2
8cc3a693-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(count) + 2) #ifdef _WIN32 #define SLEEP Sleep #else #define SLEEP usleep #endif void CWE400_Resource_Exhaustion__listen_socket_sleep_14_bad() { int count; count = -1; if(globalFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; count = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalFive==5) { SLEEP(count); printLine(""Sleep time possibly too long""); } }"	where is the vulnerable dataflow from count to SLEEP ?	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
SLEEP <start> count <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
SLEEP <start> count <end> );"	"if  <start> listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"<start> count = -1 <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	1
951c5e9f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FULL_COMMAND ""dir "" #else #define FULL_COMMAND ""ls "" #endif #ifdef _WIN32 #define POPEN _popen #define PCLOSE _pclose #else #define POPEN popen #define PCLOSE pclose #endif typedef struct _CWE78_OS_Command_Injection__char_console_popen_67_structType { char * structFirst; } CWE78_OS_Command_Injection__char_console_popen_67_structType; void CWE78_OS_Command_Injection__char_console_popen_67b_badSink(CWE78_OS_Command_Injection__char_console_popen_67_structType myStruct) { char * data = myStruct.structFirst; { FILE *pipe; pipe = POPEN(data, ""w""); if (pipe != NULL) { PCLOSE(pipe); } } }"	where is the vulnerable dataflow from data to POPEN ?	"void CWE78_OS_Command_Injection__char_console_popen_67b_badSink(CWE78_OS_Command_Injection__char_console_popen_67_structType <start> myStruct <end> );
pipe = POPEN <start> data <end> , ""w"");
char * data = <start> myStruct <end> .structFirst;"	"pipe = POPEN <start> data <end> , ""w"");
void CWE78_OS_Command_Injection__char_console_popen_67b_badSink(CWE78_OS_Command_Injection__char_console_popen_67_structType <start> myStruct <end> );
char <start> * data = myStruct.structFirst <end> ;"	"void CWE78_OS_Command_Injection__char_console_popen_67b_badSink(CWE78_OS_Command_Injection__char_console_popen_67_structType <start> myStruct <end> );
char * data = <start> myStruct <end> .structFirst;
pipe = POPEN <start> data <end> , ""w"");"	"pipe = <start> POPEN(data, ""w"") <end> ;
void CWE78_OS_Command_Injection__char_console_popen_67b_badSink(CWE78_OS_Command_Injection__char_console_popen_67_structType <start> myStruct <end> );
pipe = POPEN <start> data <end> , ""w"");"	2
a95fd83b-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_fgets_multiply_53d_badSink(int data) { if(data < 0) { int result = data * 2; printIntLine(result); } }	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
void CWE191_Integer_Underflow__int_fgets_multiply_53d_badSink(int <start> data <end> );"	"int result = <start> data * 2 <end> ;
printIntLine <start> result <end> );"	"void CWE191_Integer_Underflow__int_fgets_multiply_53d_badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"if <start> data < 0 <end> ) ;
printIntLine <start> result <end> );"	2
8df421f2-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define PATH_SZ 100 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define PATH_SZ PATH_MAX #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 void CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__accept_bind_listen_13_bad() { if(GLOBAL_CONST_FIVE==5) { { char data[100] = """"; #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[recvResult] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif printLine(data); } } }"	where is the vulnerable dataflow from data to printLine ?	"size_t dataLen = <start> strlen(data) <end> ;
printLine <start> data <end> );"	"printLine <start> data <end> );
replace = <start> strchr(data, '\r') <end> ;"	"<start> printLine(data) <end> ;
printLine <start> data <end> );"	"recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);
printLine <start> data <end> );"	3
80d98726-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_console_open_12 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(globalReturnsTrueOrFalse()) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } else { strcat(data, ""file.txt""); } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
size_t dataLen = <start> strlen(data) <end> ;"	"char <start> dataBuffer[FILENAME_MAX] = BASEPATH <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	0
846ad31d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define STAT _stat #define OPEN _open #define WRITE _write #define O_RDWR _O_RDWR #define CLOSE _close #else #define STAT stat #define OPEN open #define WRITE write #define CLOSE close #endif #define BAD_SINK_STRING ""Bad Sink..."" #define GOOD_SINK_STRING ""Good Sink..."" void CWE367_TOC_TOU__stat_02_bad() { if(1) { { char filename[100] = """"; struct STAT statBuffer; int fileDesc = -1; if (fgets(filename, 100, stdin) == NULL) { printLine(""fgets() failed""); filename[0] = '\0'; } if (strlen(filename) > 0) { filename[strlen(filename)-1] = '\0'; } if (STAT(filename, &statBuffer) == -1) { exit(1); } fileDesc  = OPEN(filename, O_RDWR); if (fileDesc == -1) { exit(1); } if (WRITE(fileDesc, BAD_SINK_STRING, strlen(BAD_SINK_STRING)) == -1) { exit(1); } if (fileDesc != -1) { CLOSE(fileDesc); } } } }"	where is the vulnerable dataflow from filename to OPEN ?	"if  <start> STAT(filename, &statBuffer) <end>  == -1);
if (fgets <start> filename <end> , 100, stdin) == NULL);"	"if (fgets <start> filename <end> , 100, stdin) == NULL);
if  <start> strlen(filename) <end>  > 0);"	"fileDesc  = <start> OPEN(filename, O_RDWR) <end> ;
if (fgets <start> filename <end> , 100, stdin) == NULL);"	"if (fgets <start> filename <end> , 100, stdin) == NULL);
fileDesc  = OPEN <start> filename <end> , O_RDWR);"	3
af580951-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE197_Numeric_Truncation_Error__int_connect_socket_to_short_15_bad() { int data; data = -1; switch(6) { case 6: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; default: printLine(""Benign, fixed string""); break; } { short shortData = (short)data; printShortLine(shortData); } }"	where is the vulnerable dataflow from shortData to printShortLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printShortLine <start> shortData <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data = atoi(inputBuffer) <end> ;"	"printShortLine <start> shortData <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printShortLine(shortData) <end> ;"	0
8f278a51-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticFive = 5; void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_07_bad() { int data; data = -1; if(staticFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { size_t i; int *intPointer; intPointer = (int*)malloc(data * sizeof(int)); if (intPointer == NULL) {exit(-1);} for (i = 0; i < (size_t)data; i++) { intPointer[i] = 0; } printIntLine(intPointer[0]); free(intPointer); } }"	where is the vulnerable dataflow from data to malloc ?	"data = <start> atoi(inputBuffer) <end> ;
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	"intPointer = (int*)malloc <start> data * sizeof(int) <end> );
recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);"	"intPointer = (int*)malloc <start> data * sizeof(int) <end> );
<start> data = -1 <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	3
4a02112c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_square_17_bad() { int i,j; int data; data = 0; for(i = 0; i < 1; i++) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } for(j = 0; j < 1; j++) { { int result = data * data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  * data;
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"int result = <start> data <end>  * data;
<start> printIntLine(result) <end> ;"	"if  <start> acceptSocket == SOCKET_ERROR <end> );
int result = <start> data <end>  * data;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  * data;"	3
c136623d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_console_fopen_09 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(GLOBAL_CONST_TRUE) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = FOPEN <start> data <end> , ""wb+"");
size_t dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
<start> data = dataBuffer <end> ;"	1
774f57f9-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 8 short CWE194_Unexpected_Sign_Extension__fgets_strncpy_61b_badSource(short data); void CWE194_Unexpected_Sign_Extension__fgets_strncpy_61_bad() { short data; data = 0; data = CWE194_Unexpected_Sign_Extension__fgets_strncpy_61b_badSource(data); { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> strncpy(dest, source, data) <end> ;
printLine <start> dest <end> );"	"data = <start> CWE194_Unexpected_Sign_Extension__fgets_strncpy_61b_badSource <end> (data);
printLine <start> dest <end> );"	"printLine <start> dest <end> );
data = <start> CWE194_Unexpected_Sign_Extension__fgets_strncpy_61b_badSource <end> (data);"	"<start> strncpy(dest, source, data) <end> ;
data = <start> CWE194_Unexpected_Sign_Extension__fgets_strncpy_61b_badSource <end> (data);"	1
73bc817e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" namespace CWE194_Unexpected_Sign_Extension__connect_socket_memmove_43 { static void badSource(short &data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } void bad() { short data; data = 0; badSource(data); { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSource <start> data <end> );
printLine <start> dest <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSource <start> data <end> );
if  <start> data < 100 <end> );"	"if  <start> data < 100 <end> );
printLine <start> dest <end> );
badSource <start> data <end> );"	"<start> memmove(dest, source, data) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	0
5af03e05-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int CWE191_Integer_Underflow__int_connect_socket_postdec_45_badData; static int CWE191_Integer_Underflow__int_connect_socket_postdec_45_goodG2BData; static int CWE191_Integer_Underflow__int_connect_socket_postdec_45_goodB2GData; static void badSink() { int data = CWE191_Integer_Underflow__int_connect_socket_postdec_45_badData; { data--; int result = data; printIntLine(result); } } void CWE191_Integer_Underflow__int_connect_socket_postdec_45_bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE191_Integer_Underflow__int_connect_socket_postdec_45_badData = data; badSink(); }"	where is the vulnerable dataflow from data ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> CWE191_Integer_Underflow__int_connect_socket_postdec_45_badData = data <end> ;
static int <start> CWE191_Integer_Underflow__int_connect_socket_postdec_45_badData <end> ;
int data = <start> CWE191_Integer_Underflow__int_connect_socket_postdec_45_badData <end> ;
<start> data <end> --;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printIntLine(result) <end> ;
<start> data <end> --;
<start> CWE191_Integer_Underflow__int_connect_socket_postdec_45_badData = data <end> ;
int data = <start> CWE191_Integer_Underflow__int_connect_socket_postdec_45_badData <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int data = <start> CWE191_Integer_Underflow__int_connect_socket_postdec_45_badData <end> ;
static int <start> CWE191_Integer_Underflow__int_connect_socket_postdec_45_badData <end> ;"	"<start> data <end> --;
static int <start> CWE191_Integer_Underflow__int_connect_socket_postdec_45_badData <end> ;
int data = <start> CWE191_Integer_Underflow__int_connect_socket_postdec_45_badData <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> CWE191_Integer_Underflow__int_connect_socket_postdec_45_badData = data <end> ;"	0
5f76fc9b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) extern int CWE191_Integer_Underflow__int_listen_socket_predec_68_badData; extern int CWE191_Integer_Underflow__int_listen_socket_predec_68_goodG2BData; extern int CWE191_Integer_Underflow__int_listen_socket_predec_68_goodB2GData; void CWE191_Integer_Underflow__int_listen_socket_predec_68b_badSink() { int data = CWE191_Integer_Underflow__int_listen_socket_predec_68_badData; { --data; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"<start> --data <end> ;
int data = <start> CWE191_Integer_Underflow__int_listen_socket_predec_68_badData <end> ;"	"int <start> result = data <end> ;
int data = <start> CWE191_Integer_Underflow__int_listen_socket_predec_68_badData <end> ;"	"int data = <start> CWE191_Integer_Underflow__int_listen_socket_predec_68_badData <end> ;
<start> printIntLine(result) <end> ;"	"int data = <start> CWE191_Integer_Underflow__int_listen_socket_predec_68_badData <end> ;
- <start> data <end> ;"	3
761e296d-6c15-11ed-81d4-94e6f77dd552	"namespace CWE194_Unexpected_Sign_Extension__fgets_memcpy_73 { void badSink(list<short> dataList) { short data = dataList.back(); { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	"void badSink(list<short> <start> dataList <end> );
printLine <start> dest <end> );"	"printLine <start> dest <end> );
void badSink(list<short> <start> dataList <end> );"	"<start> memcpy(dest, source, data) <end> ;
void badSink(list<short> <start> dataList <end> );"	1
b08640fc-6c15-11ed-81d4-94e6f77dd552	namespace CWE197_Numeric_Truncation_Error__int_fgets_to_short_82 { void CWE197_Numeric_Truncation_Error__int_fgets_to_short_82_bad::action(int data) { { short shortData = (short)data; printShortLine(shortData); } } }	where is the vulnerable dataflow from shortData to printShortLine ?	"short <start> shortData = (short)data <end> ;
printShortLine <start> shortData <end> );"	"void CWE197_Numeric_Truncation_Error__int_fgets_to_short_82_bad::action(int <start> data <end> );
printShortLine <start> shortData <end> );"	"printShortLine <start> shortData <end> );
void CWE197_Numeric_Truncation_Error__int_fgets_to_short_82_bad::action(int <start> data <end> );"	"<start> printShortLine(shortData) <end> ;
void CWE197_Numeric_Truncation_Error__int_fgets_to_short_82_bad::action(int <start> data <end> );"	1
80d9870b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_console_fopen_31 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } { char * dataCopy = data; char * data = dataCopy; { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } } }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
pFile = FOPEN <start> data <end> , ""wb+"");"	"size_t dataLen = <start> strlen(data) <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	2
78800fcf-6c15-11ed-81d4-94e6f77dd552	"namespace CWE194_Unexpected_Sign_Extension__listen_socket_memmove_82 { void CWE194_Unexpected_Sign_Extension__listen_socket_memmove_82_bad::action(short data) { { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } } }"	where is the vulnerable dataflow from dest to printLine ?	"void CWE194_Unexpected_Sign_Extension__listen_socket_memmove_82_bad::action(short <start> data <end> );
printLine <start> dest <end> );"	"<start> memmove(dest, source, data) <end> ;
printLine <start> dest <end> );"	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	"void CWE194_Unexpected_Sign_Extension__listen_socket_memmove_82_bad::action(short <start> data <end> );
if  <start> data < 100 <end> );"	0
55ef4cdf-6c15-11ed-81d4-94e6f77dd552	namespace CWE191_Integer_Underflow__int_fgets_sub_62 { void badSource(int &data); void bad() { int data; data = 0; badSource(data); { int result = data - 1; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  - 1;
<start> printIntLine(result) <end> ;"	"badSource <start> data <end> );
<start> data = 0 <end> ;"	"badSource <start> data <end> );
int result = <start> data <end>  - 1;"	"badSource <start> data <end> );
int <start> result = data - 1 <end> ;"	2
af580975-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticTrue = 1; static int staticFalse = 0; void CWE197_Numeric_Truncation_Error__int_fgets_to_char_05_bad() { int data; data = -1; if(staticTrue) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } { char charData = (char)data; printHexCharLine(charData); } }"	where is the vulnerable dataflow from charData to printHexCharLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printHexCharLine <start> charData <end> );"	"char charData = <start> (char)data <end> ;
printHexCharLine <start> charData <end> );"	"<start> data = -1 <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"printHexCharLine <start> charData <end> );
<start> printHexCharLine(charData) <end> ;"	0
54c581e7-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_connect_socket_multiply_10_bad() { int data; data = 0; if(globalTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalTrue) { if(data < 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> data = 0 <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"if <start> data < 0 <end> ) ;
int result = <start> data <end>  * 2;"	"recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);
int result = <start> data <end>  * 2;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  * 2;"	3
b54bcef9-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 20 static int staticTrue = 1; static int staticFalse = 0; void CWE369_Divide_by_Zero__float_fgets_05_bad() { float data; data = 0.0F; if(staticTrue) { { char inputBuffer[CHAR_ARRAY_SIZE]; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = (float)atof(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(staticTrue) { { int result = (int)(100.0 / data); printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> printIntLine(result) <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );"	3
951c5e86-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FULL_COMMAND ""dir "" #else #define FULL_COMMAND ""ls "" #endif #ifdef _WIN32 #define POPEN _popen #define PCLOSE _pclose #else #define POPEN popen #define PCLOSE pclose #endif static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; void CWE78_OS_Command_Injection__char_console_popen_04_bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; if(STATIC_CONST_TRUE) { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } { FILE *pipe; pipe = POPEN(data, ""w""); if (pipe != NULL) { PCLOSE(pipe); } } }"	where is the vulnerable dataflow from data to POPEN ?	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
pipe = POPEN <start> data <end> , ""w"");"	"pipe = POPEN <start> data <end> , ""w"");
pipe = <start> POPEN(data, ""w"") <end> ;"	"pipe = POPEN <start> data <end> , ""w"");
size_t dataLen = <start> strlen(data) <end> ;"	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	0
80d9871d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_console_open_03 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(5==5) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"<start> data = dataBuffer <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"size_t dataLen = <start> strlen(data) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	0
833ac93a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_listen_socket_open_14 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(globalFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
replace = <start> strchr(data, '\n') <end> ;"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
size_t dataLen = <start> strlen(data) <end> ;"	0
7e74f30d-6c15-11ed-81d4-94e6f77dd552	namespace CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_81 { void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_81_bad::action(int data) const { if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } } }	where is the vulnerable dataflow from data to malloc ?	"<start> printLine(dataBuffer) <end> ;
char * dataBuffer = (char *)malloc <start> data <end> );"	"void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_81_bad::action(int <start> data <end> ) const;
char * dataBuffer = (char *)malloc <start> data <end> );"	"<start> free(dataBuffer) <end> ;
char * dataBuffer = (char *)malloc <start> data <end> );"	"memset(dataBuffer, 'A', <start> data-1 <end> );
void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_81_bad::action(int <start> data <end> ) const;"	1
5be3a9e0-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink(int data) { { data--; int result = data; printIntLine(result); } } void CWE191_Integer_Underflow__int_listen_socket_postdec_41_bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badSink(data); }"	where is the vulnerable dataflow from data ?	"badSink <start> data <end> );
static void badSink(int <start> data <end> );
data = <start> atoi(inputBuffer) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSink <start> data <end> );
static void badSink(int <start> data <end> );
<start> data <end> --;"	"<start> badSink(data) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data <end> --;
static void badSink(int <start> data <end> );"	"badSink <start> data <end> );
if  <start> acceptSocket == SOCKET_ERROR <end> );
<start> data <end> --;
static void badSink(int <start> data <end> );"	1
761e296c-6c15-11ed-81d4-94e6f77dd552	"namespace CWE194_Unexpected_Sign_Extension__fgets_memcpy_72 { void badSink(vector<short> dataVector) { short data = dataVector[2]; { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"void badSink(vector<short> <start> dataVector <end> );
<start> memcpy(dest, source, data) <end> ;"	"char <start> dest[100] = """" <end> ;
printLine <start> dest <end> );"	"short <start> data = dataVector[2] <end> ;
printLine <start> dest <end> );"	"void badSink(vector<short> <start> dataVector <end> );
printLine <start> dest <end> );"	3
b08640e3-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE197_Numeric_Truncation_Error__int_fgets_to_short_18_bad() { int data; data = -1; goto source; source: { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } { short shortData = (short)data; printShortLine(shortData); } }"	where is the vulnerable dataflow from shortData to printShortLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printShortLine <start> shortData <end> );"	"<start> data = -1 <end> ;
printShortLine <start> shortData <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
short shortData = <start> (short)data <end> ;"	"printShortLine <start> shortData <end> );
short <start> shortData = (short)data <end> ;"	0
7d44fcbf-6c15-11ed-81d4-94e6f77dd552	int CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_22_badGlobal = 0; int CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_22_badSource(int data); void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_22_bad() { int data; data = -1; CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_22_badGlobal = 1; data = CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_22_badSource(data); if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }	where is the vulnerable dataflow from data to malloc ?	"char * dataBuffer = (char *)malloc <start> data <end> );
char * dataBuffer = (char * <start> malloc(data) <end> ;"	"char * dataBuffer = (char *)malloc <start> data <end> );
if  <start> data < 100 <end> );"	"data = <start> CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_22_badSource <end> (data);
char * dataBuffer = (char *)malloc <start> data <end> );"	"char * dataBuffer = (char *)malloc <start> data <end> );
data = <start> CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_22_badSource <end> (data);"	2
c01af8a6-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" static int staticTrue = 1; static int staticFalse = 0; namespace CWE23_Relative_Path_Traversal__char_connect_socket_ofstream_05 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(staticTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
outputFile.open((char * <start> data <end> );"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
size_t dataLen = <start> strlen(data) <end> ;"	"recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - <start> dataLen - 1 <end> ), 0);
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"size_t dataLen = <start> strlen(data) <end> ;
outputFile.open((char * <start> data <end> );"	0
715a3bf5-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif static char * CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_45_badData; static char * CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_45_goodG2BData; static char * CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_45_goodB2GData; static void badSink() { char * data = CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_45_badData; { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } } void CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_45_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_45_badData = data; badSink(); }"	where is the vulnerable dataflow from dest to printLine ?	"<start> printLine(dest) <end> ;
char * data = <start> CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_45_badData <end> ;
static char * <start> CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_45_badData <end> ;
printLine <start> dest <end> );
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
<start> CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_45_badData = data <end> ;
static char * <start> CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_45_badData <end> ;
char * data = <start> CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_45_badData <end> ;
printLine <start> dest <end> );"	"<start> CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_45_badData = data <end> ;
static char * <start> CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_45_badData <end> ;
char * data = <start> CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_45_badData <end> ;
replace = <start> strchr(data, '\n') <end> ;
printLine <start> dest <end> );"	"printLine <start> dest <end> );
<start> recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0) <end> ;
char * data = <start> CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_45_badData <end> ;
static char * <start> CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_45_badData <end> ;
<start> CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_45_badData = data <end> ;"	1
abc374f3-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticTrue = 1; static int staticFalse = 0; void CWE191_Integer_Underflow__int_connect_socket_postdec_05_bad() { int data; data = 0; if(staticTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticTrue) { { data--; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"data = <start> atoi(inputBuffer) <end> ;
printIntLine <start> result <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"<start> printIntLine(result) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> result <end> );"	1
833ac94b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_listen_socket_open_61 { char * badSource(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; data = badSource(data); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"data = <start> badSource <end> (data);
<start> data = dataBuffer <end> ;"	"data = <start> badSource(data) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"data = <start> badSource <end> (data);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);"	2
bed4a8db-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" namespace CWE23_Relative_Path_Traversal__char_connect_socket_ifstream_02 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
inputFile.open((char * <start> data <end> );"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
<start> data = dataBuffer <end> ;"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
recvResult = <start> recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0) <end> ;"	"recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - <start> dataLen - 1 <end> ), 0);
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	0
c136626c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif namespace CWE23_Relative_Path_Traversal__char_console_ifstream_18 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; goto source; source: { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"inputFile.open((char * <start> data <end> );
char <start> dataBuffer[FILENAME_MAX] = BASEPATH <end> ;"	"inputFile.open((char * <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
inputFile.open((char * <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
size_t dataLen = <start> strlen(data) <end> ;"	2
7fa68e0a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_31_bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { int dataCopy = data; int data = dataCopy; { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } } }"	where is the vulnerable dataflow from dest to printLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
if  <start> recvResult == SOCKET_ERROR <end>  || recvResult == 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"printLine <start> dest <end> );
data = <start> atoi(inputBuffer) <end> ;"	"printLine <start> dest <end> );
<start> strncpy(dest, source, data) <end> ;"	1
761e2943-6c15-11ed-81d4-94e6f77dd552	namespace CWE194_Unexpected_Sign_Extension__fgets_malloc_81 { void CWE194_Unexpected_Sign_Extension__fgets_malloc_81_bad::action(short data) const { if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } } }	where is the vulnerable dataflow from data to malloc ?	"char * dataBuffer = (char *)malloc <start> data <end> );
<start> printLine(dataBuffer) <end> ;"	"char * dataBuffer = (char *)malloc <start> data <end> );
char * dataBuffer = (char * <start> malloc(data) <end> ;"	"char * dataBuffer = (char *)malloc <start> data <end> );
<start> memset(dataBuffer, 'A', data-1) <end> ;"	"void CWE194_Unexpected_Sign_Extension__fgets_malloc_81_bad::action(short <start> data <end> ) const;
char * dataBuffer = (char *)malloc <start> data <end> );"	3
6c938bf2-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif static int staticTrue = 1; static int staticFalse = 0; void CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_05_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; if(staticTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticTrue) { { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } } }"	where is the vulnerable dataflow from dest to printLine ?	"recvResult = <start> recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0) <end> ;
printLine <start> dest <end> );"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
printLine <start> dest <end> );"	"recvResult = recv(connectSocket, (char *)(data + dataLen), <start> sizeof(char) * (100 - dataLen - 1) <end> , 0);
printLine <start> dest <end> );"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (100 - dataLen - 1), 0);
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	1
bed4a8ef-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" namespace CWE23_Relative_Path_Traversal__char_connect_socket_ifstream_41 { void badSink(char * data) { { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } } void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badSink(data); }"	where is the vulnerable dataflow from data to badSink ?	"badSink <start> data <end> );
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
badSink <start> data <end> );"	"badSink <start> data <end> );
replace = <start> strchr(data, '\r') <end> ;"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
size_t <start> dataLen = strlen(data) <end> ;"	1
c01af8c5-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif static int staticTrue = 1; static int staticFalse = 0; namespace CWE23_Relative_Path_Traversal__char_connect_socket_open_05 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(staticTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
replace = <start> strchr(data, '\n') <end> ;"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"char <start> dataBuffer[FILENAME_MAX] = BASEPATH <end> ;
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
replace = <start> strchr(data, '\r') <end> ;"	1
8b91e4a8-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(count) + 2) #ifdef _WIN32 #define SLEEP Sleep #else #define SLEEP usleep #endif static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } void CWE400_Resource_Exhaustion__connect_socket_sleep_08_bad() { int count; count = -1; if(staticReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; count = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticReturnsTrue()) { SLEEP(count); printLine(""Sleep time possibly too long""); } }"	where is the vulnerable dataflow from count to SLEEP ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
SLEEP <start> count <end> );"	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
SLEEP <start> count <end> );"	"SLEEP <start> count <end> );
<start> SLEEP(count) <end> ;"	"count = <start> atoi(inputBuffer) <end> ;
SLEEP <start> count <end> );"	0
78800f9d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 8 typedef struct _CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_67_structType { short structFirst; } CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_67_structType; void CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_67b_badSink(CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_67_structType myStruct) { short data = myStruct.structFirst; { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"printLine <start> dest <end> );
<start> memcpy(dest, source, data) <end> ;
void CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_67b_badSink(CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_67_structType <start> myStruct <end> );"	"<start> printLine(dest) <end> ;
short data = <start> myStruct <end> .structFirst;
printLine <start> dest <end> );"	"void CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_67b_badSink(CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_67_structType <start> myStruct <end> );
short data = <start> myStruct <end> .structFirst;
printLine <start> dest <end> );"	"void CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_67b_badSink(CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_67_structType <start> myStruct <end> );
printLine <start> dest <end> );
short data = <start> myStruct <end> .structFirst;"	2
7d44fc73-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) int CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_61b_badSource(int data); void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_61_bad() { int data; data = -1; data = CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_61b_badSource(data); { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"printLine <start> dest <end> );
<start> printLine(dest) <end> ;"	"if  <start> data < 100 <end> );
data = <start> CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_61b_badSource <end> (data);"	"data = <start> CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_61b_badSource <end> (data);
printLine <start> dest <end> );"	"<start> printLine(dest) <end> ;
data = <start> CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_61b_badSource <end> (data);"	2
9ebc76df-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink(int data) { { int buffer[10] = { 0 }; if (data < 10) { printIntLine(buffer[data]); } else { printLine(""ERROR: Array index is too big.""); } } } void CWE127_Buffer_Underread__CWE839_listen_socket_41_bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badSink(data); }"	where is the vulnerable dataflow from buffer[data] to printIntLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSink <start> data <end> );
static void badSink(int <start> data <end> );
printIntLine <start> buffer[data] <end> );"	"static void badSink(int <start> data <end> );
if  <start> listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSink <start> data <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static void badSink(int <start> data <end> );
printIntLine <start> buffer[data] <end> );"	"static void badSink(int <start> data <end> );
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> buffer[data] <end> );
badSink <start> data <end> );"	0
774f5819-6c15-11ed-81d4-94e6f77dd552	int CWE194_Unexpected_Sign_Extension__listen_socket_malloc_22_badGlobal = 0; short CWE194_Unexpected_Sign_Extension__listen_socket_malloc_22_badSource(short data); void CWE194_Unexpected_Sign_Extension__listen_socket_malloc_22_bad() { short data; data = 0; CWE194_Unexpected_Sign_Extension__listen_socket_malloc_22_badGlobal = 1; data = CWE194_Unexpected_Sign_Extension__listen_socket_malloc_22_badSource(data); if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }	where is the vulnerable dataflow from data to malloc ?	"char * dataBuffer = (char *)malloc <start> data <end> );
data = <start> CWE194_Unexpected_Sign_Extension__listen_socket_malloc_22_badSource <end> (data);"	"<start> free(dataBuffer) <end> ;
char * dataBuffer = (char *)malloc <start> data <end> );"	"data = <start> CWE194_Unexpected_Sign_Extension__listen_socket_malloc_22_badSource <end> (data);
char * dataBuffer = (char *)malloc <start> data <end> );"	"char * dataBuffer = (char *)malloc <start> data <end> );
memset(dataBuffer, 'A', <start> data-1 <end> );"	2
656cd3d1-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__int_rand_add_62 { void badSource(int &data); void bad() { int data; data = 0; badSource(data); { int result = data + 1; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  + 1;
badSource <start> data <end> );"	"badSource <start> data <end> );
int result = <start> data <end>  + 1;"	"int <start> result = data + 1 <end> ;
badSource <start> data <end> );"	"<start> data = 0 <end> ;
badSource <start> data <end> );"	1
5f76fc7c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticTrue = 1; static int staticFalse = 0; void CWE191_Integer_Underflow__int_listen_socket_predec_05_bad() { int data; data = 0; if(staticTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticTrue) { { --data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"if  <start> recvResult == SOCKET_ERROR <end>  || recvResult == 0);
- <start> data <end> ;"	"- <start> data <end> ;
<start> printIntLine(result) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
- <start> data <end> ;"	3
a36a7913-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_FIVE = 5; void CWE190_Integer_Overflow__int_listen_socket_multiply_06_bad() { int data; data = 0; if(STATIC_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(STATIC_CONST_FIVE==5) { if(data > 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"<start> data = atoi(inputBuffer) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
if  <start> listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR <end> );"	"<start> printIntLine(result) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	0
761e296a-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 8 typedef struct _CWE194_Unexpected_Sign_Extension__fgets_memcpy_67_structType { short structFirst; } CWE194_Unexpected_Sign_Extension__fgets_memcpy_67_structType; void CWE194_Unexpected_Sign_Extension__fgets_memcpy_67b_badSink(CWE194_Unexpected_Sign_Extension__fgets_memcpy_67_structType myStruct) { short data = myStruct.structFirst; { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"short data = <start> myStruct <end> .structFirst;
void CWE194_Unexpected_Sign_Extension__fgets_memcpy_67b_badSink(CWE194_Unexpected_Sign_Extension__fgets_memcpy_67_structType <start> myStruct <end> );
printLine <start> dest <end> );"	"void CWE194_Unexpected_Sign_Extension__fgets_memcpy_67b_badSink(CWE194_Unexpected_Sign_Extension__fgets_memcpy_67_structType <start> myStruct <end> );
short data = <start> myStruct <end> .structFirst;
<start> memcpy(dest, source, data) <end> ;"	"void CWE194_Unexpected_Sign_Extension__fgets_memcpy_67b_badSink(CWE194_Unexpected_Sign_Extension__fgets_memcpy_67_structType <start> myStruct <end> );
short data = <start> myStruct <end> .structFirst;
printLine <start> dest <end> );"	"printLine <start> dest <end> );
if  <start> data < 100 <end> );
void CWE194_Unexpected_Sign_Extension__fgets_memcpy_67b_badSink(CWE194_Unexpected_Sign_Extension__fgets_memcpy_67_structType <start> myStruct <end> );"	2
6c938c1c-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" static void badVaSinkB(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_03_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; if(5==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(5==5) { badVaSinkB(data, data); } }"	where is the vulnerable dataflow from data to vfprintf ?	"vfprintf(stdout, <start> data <end> , args);
static void badVaSinkB(char * <start> data <end> , ...);
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
size_t dataLen = <start> strlen(data) <end> ;"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);"	"static void badVaSinkB(char * <start> data <end> , ...);
size_t dataLen = <start> strlen(data) <end> ;
badVaSinkB <start> data <end> , data);
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"replace = <start> strchr(data, '\n') <end> ;
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
static void badVaSinkB(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);"	1
78800fc0-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 8 void CWE194_Unexpected_Sign_Extension__listen_socket_memmove_52c_badSink(short data) { { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> memmove(dest, source, data) <end> ;
void CWE194_Unexpected_Sign_Extension__listen_socket_memmove_52c_badSink(short <start> data <end> );"	"printLine <start> dest <end> );
char <start> dest[100] = """" <end> ;"	"if  <start> data < 100 <end> );
void CWE194_Unexpected_Sign_Extension__listen_socket_memmove_52c_badSink(short <start> data <end> );"	"void CWE194_Unexpected_Sign_Extension__listen_socket_memmove_52c_badSink(short <start> data <end> );
printLine <start> dest <end> );"	3
60db83c4-6c15-11ed-81d4-94e6f77dd552	static int badStatic = 0; static void badSink(char data) { if(badStatic) { if(data > 0) { char result = data * 2; printHexCharLine(result); } } } void CWE190_Integer_Overflow__char_rand_multiply_21_bad() { char data; data = ' '; data = (char)RAND32(); badStatic = 1; badSink(data); }	where is the vulnerable dataflow from data ?	"data = (char <start> RAND32() <end> ;
badSink <start> data <end> );
static void badSink(char <start> data <end> );
char result = <start> data <end>  * 2;"	"static void badSink(char <start> data <end> );
data = (char <start> RAND32() <end> ;
badSink <start> data <end> );
char result = <start> data <end>  * 2;"	"char result = <start> data * 2 <end> ;
badSink <start> data <end> );
static void badSink(char <start> data <end> );
data = (char <start> RAND32() <end> ;"	"<start> printHexCharLine(result) <end> ;
char result = <start> data <end>  * 2;
static void badSink(char <start> data <end> );
badSink <start> data <end> );"	0
98b0155b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_connect_socket_81 { void bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } const CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_connect_socket_81_base& o = CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_connect_socket_81_bad(); o.action(data); }"	where is the vulnerable dataflow from data to action ?	"o.action <start> data <end> );
recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
data = <start> atoi(inputBuffer) <end> ;"	"o.action <start> data <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
o.action <start> data <end> );"	3
b8e2bd99-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define NEW_PATH ""%SystemRoot%\\system32"" #define PUTENV _putenv #else #define NEW_PATH ""/bin"" #define PUTENV putenv #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } void CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_08_bad() { char * data; char dataBuffer[250] = ""PATH=""; data = dataBuffer; if(staticReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (250 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } PUTENV(data); }"	where is the vulnerable dataflow from data to PUTENV ?	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (250 - dataLen - 1), 0);
PUTENV <start> data <end> );"	"PUTENV <start> data <end> );
<start> data = dataBuffer <end> ;"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (250 - dataLen - 1), 0);
replace = <start> strchr(data, '\n') <end> ;"	"replace = <start> strchr(data, '\n') <end> ;
PUTENV <start> data <end> );"	0
445c11f2-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_add_13_bad() { int data; data = 0; if(GLOBAL_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(GLOBAL_CONST_FIVE==5) { { int result = data + 1; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> data = atoi(inputBuffer) <end> ;
int result = <start> data <end>  + 1;"	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
int result = <start> data <end>  + 1;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  + 1;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printIntLine(result) <end> ;"	2
ae26ae33-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_listen_socket_predec_15_bad() { int data; data = 0; switch(6) { case 6: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; default: printLine(""Benign, fixed string""); break; } switch(7) { case 7: { --data; int result = data; printIntLine(result); } break; default: printLine(""Benign, fixed string""); break; } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> result <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data = atoi(inputBuffer) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"int <start> result = data <end> ;
printIntLine <start> result <end> );"	2
a1094919-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink(int data) { { int result = data * data; printIntLine(result); } } void CWE190_Integer_Overflow__int_connect_socket_square_44_bad() { int data; void (*funcPtr) (int) = badSink; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } funcPtr(data); }"	where is the vulnerable dataflow from result to printIntLine ?	"data = <start> atoi(inputBuffer) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );
static void badSink(int <start> data <end> );"	"printIntLine <start> result <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
funcPtr <start> data <end> );
static void badSink(int <start> data <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
funcPtr <start> data <end> );
static void badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
<start> data = atoi(inputBuffer) <end> ;
static void badSink(int <start> data <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	2
cf8750cc-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif extern char * CWE36_Absolute_Path_Traversal__char_file_fopen_68_badData; extern char * CWE36_Absolute_Path_Traversal__char_file_fopen_68_goodG2BData; namespace CWE36_Absolute_Path_Traversal__char_file_fopen_68 { void badSink() { char * data = CWE36_Absolute_Path_Traversal__char_file_fopen_68_badData; { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"char * data = <start> CWE36_Absolute_Path_Traversal__char_file_fopen_68_badData <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
char * data = <start> CWE36_Absolute_Path_Traversal__char_file_fopen_68_badData <end> ;"	"pFile = FOPEN <start> data <end> , ""wb+"");
char * data = <start> CWE36_Absolute_Path_Traversal__char_file_fopen_68_badData <end> ;"	"pFile = FOPEN <start> data <end> , ""wb+"");
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	0
cd228169-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_console_open_43 { void badSource(char * &data) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; badSource(data); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"badSource <start> data <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
char <start> dataBuffer[FILENAME_MAX] = """" <end> ;"	"badSource <start> data <end> );
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"size_t dataLen = <start> strlen(data) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
badSource <start> data <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	3
445c1203-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_add_53d_badSink(int data) { { int result = data + 1; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"void CWE190_Integer_Overflow__int_connect_socket_add_53d_badSink(int <start> data <end> );
int result = <start> data <end>  + 1;"	"void CWE190_Integer_Overflow__int_connect_socket_add_53d_badSink(int <start> data <end> );
int <start> result = data + 1 <end> ;"	"int result = <start> data <end>  + 1;
void CWE190_Integer_Overflow__int_connect_socket_add_53d_badSink(int <start> data <end> );"	"<start> printIntLine(result) <end> ;
void CWE190_Integer_Overflow__int_connect_socket_add_53d_badSink(int <start> data <end> );"	0
5f76fc8d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink(int data) { { --data; int result = data; printIntLine(result); } } void CWE191_Integer_Underflow__int_listen_socket_predec_41_bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badSink(data); }"	where is the vulnerable dataflow from data ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSink <start> data <end> );
static void badSink(int <start> data <end> );
- <start> data <end> ;"	"<start> printIntLine(result) <end> ;
static void badSink(int <start> data <end> );
badSink <start> data <end> );
- <start> data <end> ;"	"static void badSink(int <start> data <end> );
int <start> result = data <end> ;
- <start> data <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"- <start> data <end> ;
<start> badSink(data) <end> ;
badSink <start> data <end> );
static void badSink(int <start> data <end> );"	0
74ee2417-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE 8 void CWE194_Unexpected_Sign_Extension__fgets_malloc_65b_badSink(short data) { if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }	where is the vulnerable dataflow from data to malloc ?	"char * dataBuffer = (char *)malloc <start> data <end> );
memset(dataBuffer, 'A', <start> data-1 <end> );"	"void CWE194_Unexpected_Sign_Extension__fgets_malloc_65b_badSink(short <start> data <end> );
<start> memset(dataBuffer, 'A', data-1) <end> ;"	"void CWE194_Unexpected_Sign_Extension__fgets_malloc_65b_badSink(short <start> data <end> );
char * dataBuffer = (char *)malloc <start> data <end> );"	"char * dataBuffer = (char *)malloc <start> data <end> );
<start> memset(dataBuffer, 'A', data-1) <end> ;"	2
87ff9874-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_connect_socket_open_31 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { char * dataCopy = data; char * data = dataCopy; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } } }"	where is the vulnerable dataflow from data to OPEN ?	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"char <start> * data = dataCopy <end> ;
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
char <start> dataBuffer[FILENAME_MAX] = """" <end> ;"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN(data, O_RDWR|O_CREAT, <start> S_IREAD|S_IWRITE <end> );"	0
728a501f-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 namespace CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_43 { static void badVaSink(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); va_end(args); } } static void badSource(char * &data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } void bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; badSource(data); badVaSink(data, data); }"	where is the vulnerable dataflow from data to vprintf ?	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
badVaSink <start> data <end> , data);
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (100 - dataLen - 1), 0);
vprintf <start> data <end> , args);
badSource <start> data <end> );"	"replace = <start> strchr(data, '\n') <end> ;
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
badSource <start> data <end> );
vprintf <start> data <end> , args);
badVaSink <start> data <end> , data);"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
badSource <start> data <end> );
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
vprintf <start> data <end> , args);"	"badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
badSource <start> data <end> );
size_t <start> dataLen = strlen(data) <end> ;
vprintf <start> data <end> , args);"	2
86cea16c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE369_Divide_by_Zero__int_listen_socket_modulo_16_bad() { int data; data = -1; while(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; } while(1) { printIntLine(100 % data); break; } }"	where is the vulnerable dataflow from data to printIntLine ?	"printIntLine <start> 100 % data <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> 100 % data <end> );"	"data = <start> atoi(inputBuffer) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
if  <start> listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR <end> );"	1
5be3a9ad-6c15-11ed-81d4-94e6f77dd552	"static const int STATIC_CONST_FIVE = 5; void CWE191_Integer_Underflow__int_fscanf_postdec_06_bad() { int data; data = 0; if(STATIC_CONST_FIVE==5) { fscanf(stdin, ""%d"", &data); } if(STATIC_CONST_FIVE==5) { { data--; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> data <end> --;
fscanf(stdin, ""%d"", <start> &data <end> );"	"<start> data <end> --;
<start> printIntLine(result) <end> ;"	"<start> printIntLine(result) <end> ;
fscanf(stdin, ""%d"", <start> &data <end> );"	"fscanf(stdin, ""%d"", <start> &data <end> );
<start> data <end> --;"	3
7c127592-6c15-11ed-81d4-94e6f77dd552	"int CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_22_badGlobal = 0; int CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_22_badSource(int data); void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_22_bad() { int data; data = -1; CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_22_badGlobal = 1; data = CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_22_badSource(data); { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> printLine(dest) <end> ;
data = <start> CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_22_badSource <end> (data);"	"data = <start> CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_22_badSource <end> (data);
printLine <start> dest <end> );"	"printLine <start> dest <end> );
<start> memcpy(dest, source, data) <end> ;"	"<start> data = CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_22_badSource(data) <end> ;
printLine <start> dest <end> );"	1
c8600b15-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_listen_socket_open_61 { char * badSource(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; data = badSource(data); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
<start> data = dataBuffer <end> ;"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
data = <start> badSource(data) <end> ;"	"data = <start> badSource <end> (data);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);"	2
c01af8ca-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_connect_socket_open_10 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(globalTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"replace = <start> strchr(data, '\n') <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	1
4a021154-6c15-11ed-81d4-94e6f77dd552	"void CWE190_Integer_Overflow__short_fscanf_add_16_bad() { short data; data = 0; while(1) { fscanf (stdin, ""%hd"", &data); break; } while(1) { { short result = data + 1; printIntLine(result); } break; } }"	where is the vulnerable dataflow from data ?	"fscanf (stdin, ""%hd"", <start> &data <end> );
short result = <start> data <end>  + 1;"	"short result = <start> data <end>  + 1;
fscanf (stdin, ""%hd"", <start> &data <end> );"	"<start> printIntLine(result) <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );"	"<start> printIntLine(result) <end> ;
short result = <start> data <end>  + 1;"	0
4b34afbf-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__short_fscanf_add_54e_badSink(short data) { { short result = data + 1; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"void CWE190_Integer_Overflow__short_fscanf_add_54e_badSink(short <start> data <end> );
short <start> result = data + 1 <end> ;"	"void CWE190_Integer_Overflow__short_fscanf_add_54e_badSink(short <start> data <end> );
short result = <start> data <end>  + 1;"	"void CWE190_Integer_Overflow__short_fscanf_add_54e_badSink(short <start> data <end> );
<start> printIntLine(result) <end> ;"	"short result = <start> data <end>  + 1;
void CWE190_Integer_Overflow__short_fscanf_add_54e_badSink(short <start> data <end> );"	1
ae26ae46-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_listen_socket_predec_65b_badSink(int data) { { --data; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"int <start> result = data <end> ;
void CWE191_Integer_Underflow__int_listen_socket_predec_65b_badSink(int <start> data <end> );"	"void CWE191_Integer_Underflow__int_listen_socket_predec_65b_badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"void CWE191_Integer_Underflow__int_listen_socket_predec_65b_badSink(int <start> data <end> );
<start> printIntLine(result) <end> ;"	"printIntLine <start> result <end> );
void CWE191_Integer_Underflow__int_listen_socket_predec_65b_badSink(int <start> data <end> );"	1
99e16a8b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_listen_socket_34 { typedef union { int unionFirst; int unionSecond; } unionType; void bad() { int data; unionType myUnion; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } myUnion.unionFirst = data; { int data = myUnion.unionSecond; { int i; int * buffer = new int[10]; for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } delete[] buffer; } } }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printIntLine(buffer[i]) <end> ;"	"data = <start> atoi(inputBuffer) <end> ;
printIntLine <start> buffer[i] <end> );"	"printIntLine <start> buffer[i] <end> );
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[i] <end> );"	3
d1e9da59-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } namespace CWE36_Absolute_Path_Traversal__char_listen_socket_ifstream_08 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(staticReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"if  <start> recvResult == SOCKET_ERROR <end>  || recvResult == 0);
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"inputFile.open((char * <start> data <end> );
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
inputFile.open((char * <start> data <end> );"	"inputFile.open((char * <start> data <end> );
char <start> dataBuffer[FILENAME_MAX] = """" <end> ;"	2
54c5821c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_connect_socket_sub_31_bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { int dataCopy = data; int data = dataCopy; { int result = data - 1; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  - 1;
<start> printIntLine(result) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  - 1;"	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
int result = <start> data <end>  - 1;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
data = <start> atoi(inputBuffer) <end> ;"	1
af580940-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_81 { void bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } const CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_81_base& baseObject = CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_81_bad(); baseObject.action(data); }"	where is the vulnerable dataflow from data to action ?	"baseObject.action <start> data <end> );
data = <start> atoi(inputBuffer) <end> ;"	"baseObject.action <start> data <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
baseObject.action <start> data <end> );"	"baseObject.action <start> data <end> );
recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);"	2
8cc3a678-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(count) + 2) #ifdef _WIN32 #define SLEEP Sleep #else #define SLEEP usleep #endif void CWE400_Resource_Exhaustion__fgets_sleep_17_bad() { int i,j; int count; count = -1; for(i = 0; i < 1; i++) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { count = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } for(j = 0; j < 1; j++) { SLEEP(count); printLine(""Sleep time possibly too long""); } }"	where is the vulnerable dataflow from count to SLEEP ?	"<start> SLEEP(count) <end> ;
SLEEP <start> count <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
SLEEP <start> count <end> );"	"SLEEP <start> count <end> );
char <start> inputBuffer[CHAR_ARRAY_SIZE] = """" <end> ;"	"<start> count = atoi(inputBuffer) <end> ;
SLEEP <start> count <end> );"	1
c99197d8-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_connect_socket_fopen_03 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(5==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = FOPEN <start> data <end> , ""wb+"");
size_t dataLen = <start> strlen(data) <end> ;"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
<start> data = dataBuffer <end> ;"	"size_t dataLen = <start> strlen(data) <end> ;
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	1
aa91a189-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticFive = 5; void CWE191_Integer_Underflow__int_listen_socket_sub_07_bad() { int data; data = 0; if(staticFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticFive==5) { { int result = data - 1; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"if  <start> acceptSocket == SOCKET_ERROR <end> );
printIntLine <start> result <end> );"	"if  <start> acceptSocket == SOCKET_ERROR <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;"	0
669edac3-6c15-11ed-81d4-94e6f77dd552	extern int CWE190_Integer_Overflow__char_rand_postinc_22_badGlobal; void CWE190_Integer_Overflow__char_rand_postinc_22_badSink(char data) { if(CWE190_Integer_Overflow__char_rand_postinc_22_badGlobal) { { data++; char result = data; printHexCharLine(result); } } }	where is the vulnerable dataflow from data ?	"<start> data <end> ++;
void CWE190_Integer_Overflow__char_rand_postinc_22_badSink(char <start> data <end> );"	"<start> printHexCharLine(result) <end> ;
void CWE190_Integer_Overflow__char_rand_postinc_22_badSink(char <start> data <end> );"	"<start> data <end> ++;
char <start> result = data <end> ;"	"void CWE190_Integer_Overflow__char_rand_postinc_22_badSink(char <start> data <end> );
<start> data <end> ++;"	3
73bc8181-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" void CWE194_Unexpected_Sign_Extension__connect_socket_memmove_51b_badSink(short data) { { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"void CWE194_Unexpected_Sign_Extension__connect_socket_memmove_51b_badSink(short <start> data <end> );
printLine <start> dest <end> );"	"printLine <start> dest <end> );
<start> memmove(dest, source, data) <end> ;"	"if  <start> data < 100 <end> );
printLine <start> dest <end> );"	"if  <start> data < 100 <end> );
void CWE194_Unexpected_Sign_Extension__connect_socket_memmove_51b_badSink(short <start> data <end> );"	0
79b27527-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_15_bad() { int data; data = -1; switch(6) { case 6: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; default: printLine(""Benign, fixed string""); break; } if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }"	where is the vulnerable dataflow from data to malloc ?	"if  <start> dataBuffer == NULL <end> ) {exit(-1);};
char * dataBuffer = (char *)malloc <start> data <end> );"	"<start> data = atoi(inputBuffer) <end> ;
char * dataBuffer = (char *)malloc <start> data <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
char * dataBuffer = (char *)malloc <start> data <end> );"	"char * dataBuffer = (char *)malloc <start> data <end> );
data = <start> atoi(inputBuffer) <end> ;"	2
820a46f1-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_file_open_62 { void badSource(char * &data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; badSource(data); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"badSource <start> data <end> );
char <start> dataBuffer[FILENAME_MAX] = BASEPATH <end> ;"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"badSource <start> data <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
badSource <start> data <end> );"	2
453db061-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_FIVE = 5; void CWE190_Integer_Overflow__int_fgets_add_06_bad() { int data; data = 0; if(STATIC_CONST_FIVE==5) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(STATIC_CONST_FIVE==5) { { int result = data + 1; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  + 1;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  + 1;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
int result = <start> data <end>  + 1;"	"int result = <start> data + 1 <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	2
715a3bc0-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif static int badStatic = 0; static void badVaSink(char * data, ...) { if(badStatic) { { va_list args; va_start(args, data); vprintf(data, args); va_end(args); } } } void CWE134_Uncontrolled_Format_String__char_file_vprintf_21_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } badStatic = 1; badVaSink(data, data); }"	where is the vulnerable dataflow from data to vprintf ?	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
vprintf <start> data <end> , args);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
static void badVaSink(char * <start> data <end> , ...);
vprintf <start> data <end> , args);
badVaSink <start> data <end> , data);"	"size_t dataLen = <start> strlen(data) <end> ;
vprintf <start> data <end> , args);
static void badVaSink(char * <start> data <end> , ...);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	"<start> va_start(args, data) <end> ;
badVaSink <start> data <end> , data);
vprintf <start> data <end> , args);
static void badVaSink(char * <start> data <end> , ...);"	0
5be3a9d7-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_listen_socket_postdec_14_bad() { int data; data = 0; if(globalFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalFive==5) { { data--; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data <end> --;"	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
<start> data <end> --;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printIntLine(result) <end> ;"	"<start> data <end> --;
int <start> result = data <end> ;"	0
5133a73b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_preinc_11_bad() { int data; data = 0; if(globalReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalReturnsTrue()) { { ++data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
+ <start> data <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> ++data <end> ;"	"<start> ++data <end> ;
+ <start> data <end> ;"	1
b68484f1-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(count) + 2) namespace CWE400_Resource_Exhaustion__connect_socket_sleep_81 { void bad() { int count; count = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; count = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } const CWE400_Resource_Exhaustion__connect_socket_sleep_81_base& baseObject = CWE400_Resource_Exhaustion__connect_socket_sleep_81_bad(); baseObject.action(count); }"	where is the vulnerable dataflow from count to action ?	"count = <start> atoi(inputBuffer) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
baseObject.action <start> count <end> );"	"count = <start> atoi(inputBuffer) <end> ;
baseObject.action <start> count <end> );"	"baseObject.action <start> count <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	1
9ebc76d6-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE127_Buffer_Underread__CWE839_listen_socket_13_bad() { int data; data = -1; if(GLOBAL_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(GLOBAL_CONST_FIVE==5) { { int buffer[10] = { 0 }; if (data < 10) { printIntLine(buffer[data]); } else { printLine(""ERROR: Array index is too big.""); } } } }"	where is the vulnerable dataflow from buffer[data] to printIntLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[data] <end> );"	"if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );
printIntLine <start> buffer[data] <end> );"	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> buffer[data] <end> );"	1
cd228155-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif static int staticTrue = 1; static int staticFalse = 0; namespace CWE36_Absolute_Path_Traversal__char_console_open_05 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(staticTrue) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"<start> data = dataBuffer <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
size_t dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	3
85b15ef9-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int badSource(int data) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } return data; } void CWE369_Divide_by_Zero__int_fgets_divide_42_bad() { int data; data = -1; data = badSource(data); printIntLine(100 / data); }"	where is the vulnerable dataflow from data to printIntLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
static int <start> badSource <end> (int data);
data = <start> badSource <end> (data);
printIntLine <start> 100 / data <end> );"	"<start> data = badSource(data) <end> ;
static int <start> badSource <end> (int data);
printIntLine <start> 100 / data <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"printIntLine <start> 100 / data <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
data = <start> badSource <end> (data);"	"static int <start> badSource <end> (int data);
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> 100 / data <end> );
data = <start> badSource <end> (data);"	0
d31a2511-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_listen_socket_open_03 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(5==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
if  <start> acceptSocket == SOCKET_ERROR <end> );"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
size_t <start> dataLen = strlen(data) <end> ;"	0
8a6310be-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_file_open_14 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(globalFive==5) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	3
b2ea8dd9-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE 8 typedef struct _CWE197_Numeric_Truncation_Error__short_fgets_67_structType { short structFirst; } CWE197_Numeric_Truncation_Error__short_fgets_67_structType; void CWE197_Numeric_Truncation_Error__short_fgets_67b_badSink(CWE197_Numeric_Truncation_Error__short_fgets_67_structType myStruct) { short data = myStruct.structFirst; { char charData = (char)data; printHexCharLine(charData); } }	where is the vulnerable dataflow from charData to printHexCharLine ?	"void CWE197_Numeric_Truncation_Error__short_fgets_67b_badSink(CWE197_Numeric_Truncation_Error__short_fgets_67_structType <start> myStruct <end> );
printHexCharLine <start> charData <end> );"	"void CWE197_Numeric_Truncation_Error__short_fgets_67b_badSink(CWE197_Numeric_Truncation_Error__short_fgets_67_structType <start> myStruct <end> );
short data = <start> myStruct <end> .structFirst;
printHexCharLine <start> charData <end> );"	"<start> printHexCharLine(charData) <end> ;
short data = <start> myStruct <end> .structFirst;
void CWE197_Numeric_Truncation_Error__short_fgets_67b_badSink(CWE197_Numeric_Truncation_Error__short_fgets_67_structType <start> myStruct <end> );"	"<start> printHexCharLine(charData) <end> ;
short data = <start> myStruct <end> .structFirst;
printHexCharLine <start> charData <end> );"	1
69161b6c-6c15-11ed-81d4-94e6f77dd552	typedef struct _CWE190_Integer_Overflow__short_rand_preinc_67_structType { short structFirst; } CWE190_Integer_Overflow__short_rand_preinc_67_structType; void CWE190_Integer_Overflow__short_rand_preinc_67b_badSink(CWE190_Integer_Overflow__short_rand_preinc_67_structType myStruct) { short data = myStruct.structFirst; { ++data; short result = data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"void CWE190_Integer_Overflow__short_rand_preinc_67b_badSink(CWE190_Integer_Overflow__short_rand_preinc_67_structType <start> myStruct <end> );
short data = <start> myStruct <end> .structFirst;
+ <start> data <end> ;"	"short <start> result = data <end> ;
short data = <start> myStruct <end> .structFirst;
void CWE190_Integer_Overflow__short_rand_preinc_67b_badSink(CWE190_Integer_Overflow__short_rand_preinc_67_structType <start> myStruct <end> );"	"+ <start> data <end> ;
void CWE190_Integer_Overflow__short_rand_preinc_67b_badSink(CWE190_Integer_Overflow__short_rand_preinc_67_structType <start> myStruct <end> );
short data = <start> myStruct <end> .structFirst;"	"+ <start> data <end> ;
short <start> result = data <end> ;
void CWE190_Integer_Overflow__short_rand_preinc_67b_badSink(CWE190_Integer_Overflow__short_rand_preinc_67_structType <start> myStruct <end> );"	0
b41b87b8-6c15-11ed-81d4-94e6f77dd552	namespace CWE369_Divide_by_Zero__float_connect_socket_74 { void badSink(map<int, float> dataMap) { float data = dataMap[2]; { int result = (int)(100.0 / data); printIntLine(result); } }	where is the vulnerable dataflow from result to printIntLine ?	"void badSink(map<int, float> <start> dataMap <end> );
<start> printIntLine(result) <end> ;"	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	"void badSink(map<int, float> <start> dataMap <end> );
printIntLine <start> result <end> );"	"float <start> data = dataMap[2] <end> ;
printIntLine <start> result <end> );"	2
715a3c0b-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 static const int STATIC_CONST_FIVE = 5; static void badVaSinkB(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_06_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; if(STATIC_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(STATIC_CONST_FIVE==5) { badVaSinkB(data, data); } }"	where is the vulnerable dataflow from data to vfprintf ?	"<start> data = dataBuffer <end> ;
static void badVaSinkB(char * <start> data <end> , ...);
badVaSinkB <start> data <end> , data);
vfprintf(stdout, <start> data <end> , args);"	"size_t dataLen = <start> strlen(data) <end> ;
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
badVaSinkB <start> data <end> , data);
vfprintf(stdout, <start> data <end> , args);"	"badVaSinkB <start> data <end> , data);
<start> vfprintf(stdout, data, args) <end> ;
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
static void badVaSinkB(char * <start> data <end> , ...);"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);"	3
99e16a9a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; void CWE124_Buffer_Underwrite__CWE839_connect_socket_04_bad() { int data; data = -1; if(STATIC_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(STATIC_CONST_TRUE) { { int i; int buffer[10] = { 0 }; if (data < 10) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } } } }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[i] <end> );"	"data = <start> atoi(inputBuffer) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"printIntLine <start> buffer[i] <end> );
recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);"	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> buffer[i] <end> );"	0
a6fd8292-6c15-11ed-81d4-94e6f77dd552	extern int CWE190_Integer_Overflow__int_listen_socket_preinc_22_badGlobal; void CWE190_Integer_Overflow__int_listen_socket_preinc_22_badSink(int data) { if(CWE190_Integer_Overflow__int_listen_socket_preinc_22_badGlobal) { { ++data; int result = data; printIntLine(result); } } }	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
void CWE190_Integer_Overflow__int_listen_socket_preinc_22_badSink(int <start> data <end> );"	"int <start> result = data <end> ;
printIntLine <start> result <end> );"	"void CWE190_Integer_Overflow__int_listen_socket_preinc_22_badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"<start> ++data <end> ;
void CWE190_Integer_Overflow__int_listen_socket_preinc_22_badSink(int <start> data <end> );"	2
87ff986f-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_connect_socket_open_15 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; switch(6) { case 6: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; default: printLine(""Benign, fixed string""); break; } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"replace = <start> strchr(data, '\n') <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"char <start> dataBuffer[FILENAME_MAX] = """" <end> ;
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	2
7ae3a722-6c15-11ed-81d4-94e6f77dd552	"namespace CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_62 { void badSource(int &data); void bad() { int data; data = -1; badSource(data); { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"badSource <start> data <end> );
printLine <start> dest <end> );"	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	"<start> memmove(dest, source, data) <end> ;
badSource <start> data <end> );"	"printLine <start> dest <end> );
badSource <start> data <end> );"	0
a23a3e46-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_FIVE = 5; void CWE190_Integer_Overflow__int_fgets_square_06_bad() { int data; data = 0; if(STATIC_CONST_FIVE==5) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(STATIC_CONST_FIVE==5) { { int result = data * data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"<start> printIntLine(result) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );"	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	"int <start> result = data * data <end> ;
printIntLine <start> result <end> );"	1
86cea162-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_FIVE = 5; void CWE369_Divide_by_Zero__int_listen_socket_modulo_06_bad() { int data; data = -1; if(STATIC_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(STATIC_CONST_FIVE==5) { printIntLine(100 % data); } }"	where is the vulnerable dataflow from data to printIntLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> 100 % data <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data = atoi(inputBuffer) <end> ;"	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> 100 % data <end> );"	"<start> data = -1 <end> ;
printIntLine <start> 100 % data <end> );"	0
5f76fca4-6c15-11ed-81d4-94e6f77dd552	"void CWE191_Integer_Underflow__short_fscanf_predec_09_bad() { short data; data = 0; if(GLOBAL_CONST_TRUE) { fscanf (stdin, ""%hd"", &data); } if(GLOBAL_CONST_TRUE) { { --data; short result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> --data <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );"	"fscanf (stdin, ""%hd"", <start> &data <end> );
<start> printIntLine(result) <end> ;"	"<start> --data <end> ;
- <start> data <end> ;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
- <start> data <end> ;"	3
d31a2518-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_listen_socket_open_10 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(globalTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) *  <start> FILENAME_MAX - dataLen - 1 <end> ), 0);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	0
cf875096-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_environment_open_52 { void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } badSink_b(data); }"	where is the vulnerable dataflow from data to badSink_b ?	"char <start> dataBuffer[FILENAME_MAX] = """" <end> ;
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
strncat <start> data+dataLen <end> , environment, FILENAME_MAX-dataLen-1);"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
<start> badSink_b(data) <end> ;"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
badSink_b <start> data <end> );"	3
8b91e464-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 namespace CWE36_Absolute_Path_Traversal__char_listen_socket_ofstream_17 { void bad() { int i; char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; for(i = 0; i < 1; i++) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to sizeof ?	size_t dataLen = <start> strlen(data) <end> ;	replace = <start> strchr(data, '\n') <end> ;	recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);	recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);	2
5be3a9de-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_listen_socket_postdec_31_bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { int dataCopy = data; int data = dataCopy; { data--; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data <end> --;"	"<start> data <end> --;
if  <start> acceptSocket == SOCKET_ERROR <end> );"	"<start> data <end> --;
int <start> result = data <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int <start> dataCopy = data <end> ;"	0
61da671d-6c15-11ed-81d4-94e6f77dd552	short CWE190_Integer_Overflow__short_rand_add_61b_badSource(short data); void CWE190_Integer_Overflow__short_rand_add_61_bad() { short data; data = 0; data = CWE190_Integer_Overflow__short_rand_add_61b_badSource(data); { short result = data + 1; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"short result = <start> data <end>  + 1;
<start> printIntLine(result) <end> ;"	"short result = <start> data <end>  + 1;
<start> data = CWE190_Integer_Overflow__short_rand_add_61b_badSource(data) <end> ;"	"data = <start> CWE190_Integer_Overflow__short_rand_add_61b_badSource <end> (data);
short result = <start> data <end>  + 1;"	"short result = <start> data <end>  + 1;
data = <start> CWE190_Integer_Overflow__short_rand_add_61b_badSource <end> (data);"	2
a1094909-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_square_10_bad() { int data; data = 0; if(globalTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalTrue) { { int result = data * data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"<start> data = atoi(inputBuffer) <end> ;
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);
printIntLine <start> result <end> );"	0
9059f3b7-6c15-11ed-81d4-94e6f77dd552	namespace CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_74 { void badSink(map<int, int> dataMap) { int data = dataMap[2]; { size_t i; int *intPointer; intPointer = (int*)malloc(data * sizeof(int)); if (intPointer == NULL) {exit(-1);} for (i = 0; i < (size_t)data; i++) { intPointer[i] = 0; } printIntLine(intPointer[0]); free(intPointer); } }	where is the vulnerable dataflow from data to malloc ?	"void badSink(map<int, int> <start> dataMap <end> );
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	"void badSink(map<int, int> <start> dataMap <end> );
int <start> data = dataMap[2] <end> ;"	"intPointer = (int*)malloc <start> data * sizeof(int) <end> );
intPointer = (int* <start> malloc(data * sizeof(int)) <end> ;"	"void badSink(map<int, int> <start> dataMap <end> );
intPointer = (int* <start> malloc(data * sizeof(int)) <end> ;"	0
4b34b010-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__short_fscanf_square_54e_badSink(short data) { { short result = data * data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"void CWE190_Integer_Overflow__short_fscanf_square_54e_badSink(short <start> data <end> );
<start> printIntLine(result) <end> ;"	"void CWE190_Integer_Overflow__short_fscanf_square_54e_badSink(short <start> data <end> );
short result = <start> data <end>  * data;"	"void CWE190_Integer_Overflow__short_fscanf_square_54e_badSink(short <start> data <end> );
short <start> result = data * data <end> ;"	"short result = <start> data <end>  * data;
void CWE190_Integer_Overflow__short_fscanf_square_54e_badSink(short <start> data <end> );"	1
cd228154-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; namespace CWE36_Absolute_Path_Traversal__char_console_open_04 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(STATIC_CONST_TRUE) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	0
85b15ed8-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE369_Divide_by_Zero__int_connect_socket_modulo_13_bad() { int data; data = -1; if(GLOBAL_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(GLOBAL_CONST_FIVE==5) { printIntLine(100 % data); } }"	where is the vulnerable dataflow from data to printIntLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data = atoi(inputBuffer) <end> ;"	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> 100 % data <end> );"	"printIntLine <start> 100 % data <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> 100 % data <end> );"	3
728a5033-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" void CWE194_Unexpected_Sign_Extension__connect_socket_malloc_02_bad() { short data; data = 0; if(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }"	where is the vulnerable dataflow from data to malloc ?	"<start> data = tempInt <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"char * dataBuffer = (char * <start> malloc(data) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
char * dataBuffer = (char *)malloc <start> data <end> );"	"char * dataBuffer = (char *)malloc <start> data <end> );
<start> memset(dataBuffer, 'A', data-1) <end> ;"	2
ba102b9b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define EXECLP _execlp #else #define EXECLP execlp #endif void CWE78_OS_Command_Injection__char_connect_socket_execlp_09_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(GLOBAL_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECLP ?	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
<start> EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL) <end> ;"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
replace = <start> strchr(data, '\r') <end> ;"	1
a49c4f6c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_square_12_bad() { int data; data = 0; if(globalReturnsTrueOrFalse()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } else { data = 2; } if(globalReturnsTrueOrFalse()) { { int result = data * data; printIntLine(result); } } else { if (data > INT_MIN && abs(data) < (long)sqrt((double)INT_MAX)) { int result = data * data; printIntLine(result); } else { printLine(""data value is too large to perform arithmetic safely.""); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"<start> recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> result <end> );"	"if (data > INT_MIN && <start> abs(data) <end>  < (long)sqrt((double)INT_MAX));
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	0
6c938bc2-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_03_bad() { int data; data = -1; if(5==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(5==5) { { int i; int * buffer = (int *)malloc(10 * sizeof(int)); if (buffer == NULL) {exit(-1);} for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } free(buffer); } } }"	where is the vulnerable dataflow from buffer to free ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
free <start> buffer <end> );"	"free <start> buffer <end> );
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"free <start> buffer <end> );
recvResult = recv(acceptSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);"	"if  <start> buffer == NULL <end> ) {exit(-1);};
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	0
af58093b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) extern int CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_68_badData; extern int CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_68_goodG2BData; void CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_68b_badSink() { int data = CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_68_badData; { char charData = (char)data; printHexCharLine(charData); } }"	where is the vulnerable dataflow from charData to printHexCharLine ?	"<start> printHexCharLine(charData) <end> ;
printHexCharLine <start> charData <end> );"	"int data = <start> CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_68_badData <end> ;
printHexCharLine <start> charData <end> );"	"printHexCharLine <start> charData <end> );
int data = <start> CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_68_badData <end> ;"	"printHexCharLine <start> charData <end> );
int <start> data = CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_68_badData <end> ;"	1
669edaa4-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__int_rand_square_53d_badSink(int data) { { int result = data * data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  * data;
<start> printIntLine(result) <end> ;"	"void CWE190_Integer_Overflow__int_rand_square_53d_badSink(int <start> data <end> );
int result = <start> data * data <end> ;"	"void CWE190_Integer_Overflow__int_rand_square_53d_badSink(int <start> data <end> );
int result = <start> data <end>  * data;"	"int result = <start> data <end>  * data;
void CWE190_Integer_Overflow__int_rand_square_53d_badSink(int <start> data <end> );"	2
a95fd864-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_fgets_sub_51b_badSink(int data) { { int result = data - 1; printIntLine(result); } }	where is the vulnerable dataflow from result to printIntLine ?	"void CWE191_Integer_Underflow__int_fgets_sub_51b_badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"void CWE191_Integer_Underflow__int_fgets_sub_51b_badSink(int <start> data <end> );
<start> printIntLine(result) <end> ;"	"printIntLine <start> result <end> );
void CWE191_Integer_Underflow__int_fgets_sub_51b_badSink(int <start> data <end> );"	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	0
820a46e7-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_file_open_34 { typedef union { char * unionFirst; char * unionSecond; } unionType; void bad() { char * data; unionType myUnion; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN(data, O_RDWR|O_CREAT, <start> S_IREAD|S_IWRITE <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	3
8cc3a696-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(count) + 2) #ifdef _WIN32 #define SLEEP Sleep #else #define SLEEP usleep #endif void CWE400_Resource_Exhaustion__listen_socket_sleep_17_bad() { int i,j; int count; count = -1; for(i = 0; i < 1; i++) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; count = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } for(j = 0; j < 1; j++) { SLEEP(count); printLine(""Sleep time possibly too long""); } }"	where is the vulnerable dataflow from count to SLEEP ?	"SLEEP <start> count <end> );
count = <start> atoi(inputBuffer) <end> ;"	"<start> SLEEP(count) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
SLEEP <start> count <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> count = atoi(inputBuffer) <end> ;"	2
b2ea8dcb-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 8 void CWE197_Numeric_Truncation_Error__short_fgets_41_badSink(short data) { { char charData = (char)data; printHexCharLine(charData); } } void CWE197_Numeric_Truncation_Error__short_fgets_41_bad() { short data; data = -1; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = (short)atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } CWE197_Numeric_Truncation_Error__short_fgets_41_badSink(data); }"	where is the vulnerable dataflow from charData to printHexCharLine ?	"<start> printHexCharLine(charData) <end> ;
CWE197_Numeric_Truncation_Error__short_fgets_41_badSink <start> data <end> );
printHexCharLine <start> charData <end> );
void CWE197_Numeric_Truncation_Error__short_fgets_41_badSink(short <start> data <end> );"	"void <start> CWE197_Numeric_Truncation_Error__short_fgets_41_badSink(short data) <end>;
printHexCharLine <start> charData <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
CWE197_Numeric_Truncation_Error__short_fgets_41_badSink <start> data <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
CWE197_Numeric_Truncation_Error__short_fgets_41_badSink <start> data <end> );
void CWE197_Numeric_Truncation_Error__short_fgets_41_badSink(short <start> data <end> );
printHexCharLine <start> charData <end> );"	"void CWE197_Numeric_Truncation_Error__short_fgets_41_badSink(short <start> data <end> );
CWE197_Numeric_Truncation_Error__short_fgets_41_badSink <start> data <end> );
<start> printHexCharLine(charData) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	2
951c5e97-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FULL_COMMAND ""dir "" #else #define FULL_COMMAND ""ls "" #endif #ifdef _WIN32 #define POPEN _popen #define PCLOSE _pclose #else #define POPEN popen #define PCLOSE pclose #endif void CWE78_OS_Command_Injection__char_console_popen_31_bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } { char * dataCopy = data; char * data = dataCopy; { FILE *pipe; pipe = POPEN(data, ""w""); if (pipe != NULL) { PCLOSE(pipe); } } } }"	where is the vulnerable dataflow from data to POPEN ?	"<start> data = data_buf <end> ;
pipe = POPEN <start> data <end> , ""w"");"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
pipe = POPEN <start> data <end> , ""w"");"	"if (dataLen > 0 && <start> data[dataLen-1] == '\n' <end> );
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
<start> data = data_buf <end> ;"	1
d0b64ede-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif namespace CWE36_Absolute_Path_Traversal__char_file_ifstream_65 { void badSink(char * data); void bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } funcPtr(data); }"	where is the vulnerable dataflow from data to funcPtr ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
funcPtr <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
char <start> dataBuffer[FILENAME_MAX] = """" <end> ;"	"funcPtr <start> data <end> );
<start> funcPtr(data) <end> ;"	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	0
525b643f-6c15-11ed-81d4-94e6f77dd552	"void CWE190_Integer_Overflow__int_fscanf_preinc_11_bad() { int data; data = 0; if(globalReturnsTrue()) { fscanf(stdin, ""%d"", &data); } if(globalReturnsTrue()) { { ++data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> ++data <end> ;
+ <start> data <end> ;"	"<start> ++data <end> ;
fscanf(stdin, ""%d"", <start> &data <end> );"	"+ <start> data <end> ;
<start> printIntLine(result) <end> ;"	"fscanf(stdin, ""%d"", <start> &data <end> );
+ <start> data <end> ;"	3
9ebc76e4-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) typedef struct _CWE127_Buffer_Underread__CWE839_listen_socket_67_structType { int structFirst; } CWE127_Buffer_Underread__CWE839_listen_socket_67_structType; void CWE127_Buffer_Underread__CWE839_listen_socket_67b_badSink(CWE127_Buffer_Underread__CWE839_listen_socket_67_structType myStruct) { int data = myStruct.structFirst; { int buffer[10] = { 0 }; if (data < 10) { printIntLine(buffer[data]); } else { printLine(""ERROR: Array index is too big.""); } } }"	where is the vulnerable dataflow from buffer[data] to printIntLine ?	"int data = <start> myStruct <end> .structFirst;
void CWE127_Buffer_Underread__CWE839_listen_socket_67b_badSink(CWE127_Buffer_Underread__CWE839_listen_socket_67_structType <start> myStruct <end> );"	"void CWE127_Buffer_Underread__CWE839_listen_socket_67b_badSink(CWE127_Buffer_Underread__CWE839_listen_socket_67_structType <start> myStruct <end> );
int data = <start> myStruct <end> .structFirst;
printIntLine <start> buffer[data] <end> );"	"int <start> buffer[10] = { 0 } <end> ;
printIntLine <start> buffer[data] <end> );
int data = <start> myStruct <end> .structFirst;"	"printIntLine <start> buffer[data] <end> );
int data = <start> myStruct <end> .structFirst;
void CWE127_Buffer_Underread__CWE839_listen_socket_67b_badSink(CWE127_Buffer_Underread__CWE839_listen_socket_67_structType <start> myStruct <end> );"	1
a10948f8-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) typedef struct _CWE190_Integer_Overflow__int_connect_socket_multiply_67_structType { int structFirst; } CWE190_Integer_Overflow__int_connect_socket_multiply_67_structType; void CWE190_Integer_Overflow__int_connect_socket_multiply_67b_badSink(CWE190_Integer_Overflow__int_connect_socket_multiply_67_structType myStruct) { int data = myStruct.structFirst; if(data > 0) { int result = data * 2; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"int data = <start> myStruct <end> .structFirst;
printIntLine <start> result <end> );"	"void CWE190_Integer_Overflow__int_connect_socket_multiply_67b_badSink(CWE190_Integer_Overflow__int_connect_socket_multiply_67_structType <start> myStruct <end> );
int data = <start> myStruct <end> .structFirst;
printIntLine <start> result <end> );"	"int <start> result = data * 2 <end> ;
printIntLine <start> result <end> );
int data = <start> myStruct <end> .structFirst;"	"<start> printIntLine(result) <end> ;
void CWE190_Integer_Overflow__int_connect_socket_multiply_67b_badSink(CWE190_Integer_Overflow__int_connect_socket_multiply_67_structType <start> myStruct <end> );
printIntLine <start> result <end> );"	1
ce547d60-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif namespace CWE36_Absolute_Path_Traversal__char_environment_ofstream_11 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(globalReturnsTrue()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
outputFile.open((char * <start> data <end> );"	"strncat(data+dataLen, environment, FILENAME_MAX <start> dataLen-1 <end> );
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"outputFile.open((char * <start> data <end> );
char <start> dataBuffer[FILENAME_MAX] = """" <end> ;"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
size_t dataLen = <start> strlen(data) <end> ;"	0
8a6310cb-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_file_open_45 { static char * badData; static char * goodG2BData; static void badSink() { char * data = badData; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } } void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } badData = data; badSink(); }"	where is the vulnerable dataflow from data to OPEN ?	"static char * <start> badData <end> ;
char * data = <start> badData <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
<start> badData = data <end> ;
static char * <start> badData <end> ;
char * data = <start> badData <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"char <start> * data = badData <end> ;
<start> badData = data <end> ;
static char * <start> badData <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
<start> badData = data <end> ;
char * data = <start> badData <end> ;
static char * <start> badData <end> ;"	1
8f278a4c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_02_bad() { int data; data = -1; if(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { size_t i; int *intPointer; intPointer = (int*)malloc(data * sizeof(int)); if (intPointer == NULL) {exit(-1);} for (i = 0; i < (size_t)data; i++) { intPointer[i] = 0; } printIntLine(intPointer[0]); free(intPointer); } }"	where is the vulnerable dataflow from data to malloc ?	"data = <start> atoi(inputBuffer) <end> ;
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	"<start> data = atoi(inputBuffer) <end> ;
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	"intPointer = (int*)malloc <start> data * sizeof(int) <end> );
intPointer = <start> (int*)malloc(data * sizeof(int)) <end> ;"	1
b54bcf26-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 20 static int staticFive = 5; void CWE369_Divide_by_Zero__float_listenSocket_07_bad() { float data; data = 0.0F; if(staticFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = (float)atof(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticFive==5) { { int result = (int)(100.0 / data); printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"<start> printIntLine(result) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"int <start> result = (int)(100.0 / data) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	0
9187cbeb-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define SEARCH_CHAR 'S' typedef struct _CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_67_structType { char * structFirst; } CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_67_structType; void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_67b_badSink(CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_67_structType myStruct) { char * data = myStruct.structFirst; for (; *data != '\0'; data++) { if (*data == SEARCH_CHAR) { printLine(""We have a match!""); break; } } free(data); }"	where is the vulnerable dataflow from data to free ?	"void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_67b_badSink(CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_67_structType <start> myStruct <end> );
free <start> data <end> );
char * data = <start> myStruct <end> .structFirst;"	"free <start> data <end> );
for (; *data != '\0'; <start> data++ <end> );
void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_67b_badSink(CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_67_structType <start> myStruct <end> );"	"void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_67b_badSink(CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_67_structType <start> myStruct <end> );
char * data = <start> myStruct <end> .structFirst;
free <start> data <end> );"	"char * data = <start> myStruct <end> .structFirst;
void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_67b_badSink(CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_67_structType <start> myStruct <end> );"	2
b8e2bdae-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define NEW_PATH ""%SystemRoot%\\system32"" #define PUTENV _putenv #else #define NEW_PATH ""/bin"" #define PUTENV putenv #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 void CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_63b_badSink(char * * dataPtr) { char * data = *dataPtr; PUTENV(data); }"	where is the vulnerable dataflow from data to PUTENV ?	"PUTENV <start> data <end> );
char <start> * data = *dataPtr <end> ;"	"void CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_63b_badSink(char * * <start> dataPtr <end> );
PUTENV <start> data <end> );"	"PUTENV <start> data <end> );
void CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_63b_badSink(char * * <start> dataPtr <end> );"	"void CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_63b_badSink(char * * <start> dataPtr <end> );
<start> PUTENV(data) <end> ;"	1
b41b877e-6c15-11ed-81d4-94e6f77dd552	"namespace CWE23_Relative_Path_Traversal__char_console_ofstream_82 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } CWE23_Relative_Path_Traversal__char_console_ofstream_82_base* baseObject = new CWE23_Relative_Path_Traversal__char_console_ofstream_82_bad; baseObject->action(data); delete baseObject; }"	where is the vulnerable dataflow from data to action ?	"<start> data = dataBuffer <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"size_t dataLen = <start> strlen(data) <end> ;
baseObject->action <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
baseObject->action <start> data <end> );"	"baseObject->action <start> data <end> );
dataLen = <start> strlen(data) <end> ;"	2
846ad32e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 20 #define IP_ADDRESS ""127.0.0.1"" void CWE369_Divide_by_Zero__float_connect_socket_12_bad() { float data; data = 0.0F; if(globalReturnsTrueOrFalse()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = (float)atof(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } else { data = 2.0F; } if(globalReturnsTrueOrFalse()) { { int result = (int)(100.0 / data); printIntLine(result); } } else { if(fabs(data) > 0.000001) { int result = (int)(100.0 / data); printIntLine(result); } else { printLine(""This would result in a divide by zero""); } } }"	where is the vulnerable dataflow from data to fabs ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
data = <start> (float)atof(inputBuffer) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
if(fabs <start> data <end> ) > 0.000001);"	"if(fabs <start> data <end> ) > 0.000001);
<start> data = (float)atof(inputBuffer) <end> ;"	"int <start> result = (int)(100.0 / data) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	1
4a02114f-6c15-11ed-81d4-94e6f77dd552	"void CWE190_Integer_Overflow__short_fscanf_add_10_bad() { short data; data = 0; if(globalTrue) { fscanf (stdin, ""%hd"", &data); } if(globalTrue) { { short result = data + 1; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"short <start> result = data + 1 <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );"	"short result = <start> data <end>  + 1;
<start> printIntLine(result) <end> ;"	"short result = <start> data <end>  + 1;
fscanf (stdin, ""%hd"", <start> &data <end> );"	"fscanf (stdin, ""%hd"", <start> &data <end> );
short result = <start> data <end>  + 1;"	3
cd228136-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif static int staticTrue = 1; static int staticFalse = 0; namespace CWE36_Absolute_Path_Traversal__char_console_ofstream_05 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(staticTrue) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"outputFile.open((char * <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
outputFile.open((char * <start> data <end> );"	"outputFile.open((char * <start> data <end> );
<start> data = dataBuffer <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
dataLen = <start> strlen(data) <end> ;"	1
69161b44-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__int_rand_preinc_54e_badSink(int data) { { ++data; int result = data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"void CWE190_Integer_Overflow__int_rand_preinc_54e_badSink(int <start> data <end> );
+ <start> data <end> ;"	"+ <start> data <end> ;
<start> printIntLine(result) <end> ;"	"<start> ++data <end> ;
+ <start> data <end> ;"	"int <start> result = data <end> ;
+ <start> data <end> ;"	0
aa91a16a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_listen_socket_multiply_31_bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { int dataCopy = data; int data = dataCopy; if(data < 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"<start> recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"printIntLine <start> result <end> );
data = <start> atoi(inputBuffer) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	3
453db012-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_multiply_13_bad() { int data; data = 0; if(GLOBAL_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(GLOBAL_CONST_FIVE==5) { if(data > 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
int result = <start> data <end>  * 2;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data * 2 <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  * 2;"	"int <start> result = data * 2 <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	2
5133a74a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_preinc_52c_badSink(int data) { { ++data; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"int <start> result = data <end> ;
+ <start> data <end> ;"	"void CWE190_Integer_Overflow__int_connect_socket_preinc_52c_badSink(int <start> data <end> );
+ <start> data <end> ;"	"int <start> result = data <end> ;
void CWE190_Integer_Overflow__int_connect_socket_preinc_52c_badSink(int <start> data <end> );"	"<start> printIntLine(result) <end> ;
+ <start> data <end> ;"	1
a36a78ff-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_add_53d_badSink(int data) { { int result = data + 1; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
void CWE190_Integer_Overflow__int_listen_socket_add_53d_badSink(int <start> data <end> );"	"void CWE190_Integer_Overflow__int_listen_socket_add_53d_badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;"	"printIntLine <start> result <end> );
int <start> result = data + 1 <end> ;"	1
5e44fc70-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticFive = 5; void CWE191_Integer_Underflow__int_fgets_predec_07_bad() { int data; data = 0; if(staticFive==5) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(staticFive==5) { { --data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"- <start> data <end> ;
int <start> result = data <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
- <start> data <end> ;"	"<start> printIntLine(result) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"- <start> data <end> ;
<start> data = atoi(inputBuffer) <end> ;"	1
acf67e44-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_fgets_predec_11_bad() { int data; data = 0; if(globalReturnsTrue()) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(globalReturnsTrue()) { { --data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
int <start> result = data <end> ;"	"int <start> result = data <end> ;
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
<start> data = 0 <end> ;"	0
c39a659c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif namespace CWE23_Relative_Path_Traversal__char_environment_ifstream_43 { void badSource(char * &data) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } } void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; badSource(data); { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
badSource <start> data <end> );
inputFile.open((char * <start> data <end> );"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
inputFile.open((char * <start> data <end> );
badSource <start> data <end> );"	"inputFile.open((char * <start> data <end> );
size_t <start> dataLen = strlen(data) <end> ;
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
inputFile.open((char * <start> data <end> );"	0
a6fd825f-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticTrue = 1; static int staticFalse = 0; void CWE190_Integer_Overflow__int_fgets_preinc_05_bad() { int data; data = 0; if(staticTrue) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(staticTrue) { { ++data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> printIntLine(result) <end> ;"	"printIntLine <start> result <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"printIntLine <start> result <end> );
<start> ++data <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );"	3
8df421d2-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define PATH_SZ 100 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define PATH_SZ PATH_MAX #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 void CWE605_Multiple_Binds_Same_Port__basic_01_bad() { { char data[100] = """"; #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); #ifdef _WIN32 BOOL bOptVal = TRUE; int bOptLen = sizeof(BOOL); #else int bOptVal = 1; int bOptLen = sizeof(int); #endif do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } if (setsockopt(listenSocket, SOL_SOCKET, SO_REUSEADDR, (char*)&bOptVal, bOptLen) != 0) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, data+dataLen, (int)(100-dataLen-1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[recvResult] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif printLine(data); } }"	where is the vulnerable dataflow from data to printLine ?	"if  <start> acceptSocket == SOCKET_ERROR <end> );
recvResult = recv(acceptSocket, <start> data+dataLen <end> , (int)(100-dataLen-1), 0);"	"size_t dataLen = <start> strlen(data) <end> ;
recvResult = recv(acceptSocket, <start> data+dataLen <end> , (int)(100-dataLen-1), 0);"	"recvResult = recv(acceptSocket, <start> data+dataLen <end> , (int)(100-dataLen-1), 0);
printLine <start> data <end> );"	"size_t dataLen = <start> strlen(data) <end> ;
printLine <start> data <end> );"	2
6b862465-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) int CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_61b_badSource(int data); void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_61_bad() { int data; data = -1; data = CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_61b_badSource(data); { int i; int * buffer = (int *)malloc(10 * sizeof(int)); if (buffer == NULL) {exit(-1);} for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } free(buffer); } }"	where is the vulnerable dataflow from buffer to free ?	"free <start> buffer <end> );
int <start> * buffer = (int *)malloc(10 * sizeof(int)) <end> ;"	"<start> free(buffer) <end> ;
data = <start> CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_61b_badSource <end> (data);"	"free <start> buffer <end> );
<start> free(buffer) <end> ;"	"data = <start> CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_61b_badSource <end> (data);
free <start> buffer <end> );"	3
761e2985-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 8 void CWE194_Unexpected_Sign_Extension__fgets_memmove_31_bad() { short data; data = 0; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = (short)atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } { short dataCopy = data; short data = dataCopy; { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } } }"	where is the vulnerable dataflow from dest to printLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printLine <start> dest <end> );"	"<start> data = (short)atoi(inputBuffer) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"<start> memmove(dest, source, data) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
short <start> dataCopy = data <end> ;"	0
bed4a8f2-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" namespace CWE23_Relative_Path_Traversal__char_connect_socket_ifstream_44 { static void badSink(char * data) { { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } } void bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } funcPtr(data); }"	where is the vulnerable dataflow from data to funcPtr ?	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
funcPtr <start> data <end> );"	"size_t dataLen = <start> strlen(data) <end> ;
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"funcPtr <start> data <end> );
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(connectSocket, (char *)(data + dataLen), <start> sizeof(char) * (FILENAME_MAX - dataLen - 1) <end> , 0);
funcPtr <start> data <end> );"	0
af58095c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink(int data) { { short shortData = (short)data; printShortLine(shortData); } } void CWE197_Numeric_Truncation_Error__int_connect_socket_to_short_44_bad() { int data; void (*funcPtr) (int) = badSink; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } funcPtr(data); }"	where is the vulnerable dataflow from shortData to printShortLine ?	"static void badSink(int <start> data <end> );
funcPtr <start> data <end> );
<start> data = atoi(inputBuffer) <end> ;
printShortLine <start> shortData <end> );"	"funcPtr <start> data <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printShortLine <start> shortData <end> );
<start> data = -1 <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
funcPtr <start> data <end> );
printShortLine <start> shortData <end> );
static void badSink(int <start> data <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
funcPtr <start> data <end> );
static void badSink(int <start> data <end> );
printShortLine <start> shortData <end> );"	3
a830bf5d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_preinc_54e_badSink(int data) { { ++data; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	"void CWE190_Integer_Overflow__int_listen_socket_preinc_54e_badSink(int <start> data <end> );
int <start> result = data <end> ;"	"void CWE190_Integer_Overflow__int_listen_socket_preinc_54e_badSink(int <start> data <end> );
<start> ++data <end> ;"	"void CWE190_Integer_Overflow__int_listen_socket_preinc_54e_badSink(int <start> data <end> );
printIntLine <start> result <end> );"	3
774f5816-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 8 void CWE194_Unexpected_Sign_Extension__listen_socket_malloc_17_bad() { int i; short data; data = 0; for(i = 0; i < 1; i++) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }"	where is the vulnerable dataflow from data to malloc ?	"char * dataBuffer = (char *)malloc <start> data <end> );
if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
char * dataBuffer = (char *)malloc <start> data <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
if  <start> tempInt > SHRT_MAX <end>  || tempInt < SHRT_MIN);"	"memset(dataBuffer, 'A', <start> data-1 <end> );
char * dataBuffer = (char *)malloc <start> data <end> );"	1
c72d5d3a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_file_open_53 { void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } badSink_b(data); }"	where is the vulnerable dataflow from data to badSink_b ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
<start> badSink_b(data) <end> ;"	"badSink_b <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	"badSink_b <start> data <end> );
<start> badSink_b(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
badSink_b <start> data <end> );"	3
5d16c9d2-6c15-11ed-81d4-94e6f77dd552	void CWE191_Integer_Underflow__short_fscanf_postdec_65b_badSink(short data) { { data--; short result = data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"void CWE191_Integer_Underflow__short_fscanf_postdec_65b_badSink(short <start> data <end> );
<start> data-- <end> ;"	"<start> data <end> --;
void CWE191_Integer_Underflow__short_fscanf_postdec_65b_badSink(short <start> data <end> );"	"<start> printIntLine(result) <end> ;
<start> data <end> --;"	"void CWE191_Integer_Underflow__short_fscanf_postdec_65b_badSink(short <start> data <end> );
<start> data <end> --;"	3
bc721f7b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define EXECL _execl #else #define EXECL execl #endif void CWE78_OS_Command_Injection__char_file_execl_17_bad() { int i; char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; for(i = 0; i < 1; i++) { { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECL ?	"char <start> dataBuffer[100] = COMMAND_ARG2 <end> ;
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"if  <start> pFile != NULL <end> );
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"<start> data = dataBuffer <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	1
cbf237a8-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_console_fopen_11 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(globalReturnsTrue()) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
pFile = FOPEN <start> data <end> , ""wb+"");"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
dataLen = <start> strlen(data) <end> ;"	"pFile = FOPEN <start> data <end> , ""wb+"");
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"pFile = FOPEN <start> data <end> , ""wb+"");
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	0
73bc8162-6c15-11ed-81d4-94e6f77dd552	"namespace CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_73 { void badSink(list<short> dataList) { short data = dataList.back(); { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"void badSink(list<short> <start> dataList <end> );
printLine <start> dest <end> );"	"<start> memcpy(dest, source, data) <end> ;
void badSink(list<short> <start> dataList <end> );"	"printLine <start> dest <end> );
void badSink(list<short> <start> dataList <end> );"	"<start> memcpy(dest, source, data) <end> ;
printLine <start> dest <end> );"	0
525b648d-6c15-11ed-81d4-94e6f77dd552	"static void badSink(short data) { { ++data; short result = data; printIntLine(result); } } void CWE190_Integer_Overflow__short_fscanf_preinc_44_bad() { short data; void (*funcPtr) (short) = badSink; data = 0; fscanf (stdin, ""%hd"", &data); funcPtr(data); }"	where is the vulnerable dataflow from data ?	"fscanf (stdin, ""%hd"", <start> &data <end> );
static void badSink(short <start> data <end> );"	"funcPtr <start> data <end> );
+ <start> data <end> ;
static void badSink(short <start> data <end> );
fscanf (stdin, ""%hd"", <start> &data <end> );"	"<start> data = 0 <end> ;
static void badSink(short <start> data <end> );
fscanf (stdin, ""%hd"", <start> &data <end> );
funcPtr <start> data <end> );"	"fscanf (stdin, ""%hd"", <start> &data <end> );
funcPtr <start> data <end> );
static void badSink(short <start> data <end> );
+ <start> data <end> ;"	3
ce547d55-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif namespace CWE36_Absolute_Path_Traversal__char_environment_ifstream_65 { void badSink(char * data); void bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } funcPtr(data); }"	where is the vulnerable dataflow from data to funcPtr ?	"funcPtr <start> data <end> );
strncat(data+dataLen, environment, FILENAME_MAX <start> dataLen-1 <end> );"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
funcPtr <start> data <end> );"	"<start> funcPtr(data) <end> ;
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"<start> strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1) <end> ;
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	1
c5fc2373-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_file_open_12 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(globalReturnsTrueOrFalse()) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } else { strcat(data, ""file.txt""); } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
<start> data = dataBuffer <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	3
5e44fc9f-6c15-11ed-81d4-94e6f77dd552	extern int CWE191_Integer_Underflow__int_fscanf_predec_22_badGlobal; void CWE191_Integer_Underflow__int_fscanf_predec_22_badSink(int data) { if(CWE191_Integer_Underflow__int_fscanf_predec_22_badGlobal) { { --data; int result = data; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
- <start> data <end> ;"	"<start> --data <end> ;
void CWE191_Integer_Underflow__int_fscanf_predec_22_badSink(int <start> data <end> );"	"void CWE191_Integer_Underflow__int_fscanf_predec_22_badSink(int <start> data <end> );
- <start> data <end> ;"	"- <start> data <end> ;
void CWE191_Integer_Underflow__int_fscanf_predec_22_badSink(int <start> data <end> );"	2
8f278a53-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_09_bad() { int data; data = -1; if(GLOBAL_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { size_t i; int *intPointer; intPointer = (int*)malloc(data * sizeof(int)); if (intPointer == NULL) {exit(-1);} for (i = 0; i < (size_t)data; i++) { intPointer[i] = 0; } printIntLine(intPointer[0]); free(intPointer); } }"	where is the vulnerable dataflow from data to malloc ?	"data = <start> atoi(inputBuffer) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"intPointer = (int*)malloc <start> data * sizeof(int) <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	"<start> data = -1 <end> ;
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	2
453db017-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_multiply_18_bad() { int data; data = 0; goto source; source: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } goto sink; sink: if(data > 0) { int result = data * 2; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data * 2 <end> ;"	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
int result = <start> data <end>  * 2;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  * 2;"	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  * 2;"	2
4db33f81-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_postinc_52c_badSink(int data) { { data++; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"void CWE190_Integer_Overflow__int_connect_socket_postinc_52c_badSink(int <start> data <end> );
int <start> result = data <end> ;"	"int <start> result = data <end> ;
<start> data <end> ++;"	"void CWE190_Integer_Overflow__int_connect_socket_postinc_52c_badSink(int <start> data <end> );
<start> data <end> ++;"	"<start> data <end> ++;
<start> printIntLine(result) <end> ;"	2
a49c4f8b-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__int_listen_socket_square_81 { void CWE190_Integer_Overflow__int_listen_socket_square_81_bad::action(int data) const { { int result = data * data; printIntLine(result); } } }	where is the vulnerable dataflow from result to printIntLine ?	"int result = <start> data * data <end> ;
printIntLine <start> result <end> );"	"void CWE190_Integer_Overflow__int_listen_socket_square_81_bad::action(int <start> data <end> ) const;
<start> printIntLine(result) <end> ;"	"int <start> result = data * data <end> ;
void CWE190_Integer_Overflow__int_listen_socket_square_81_bad::action(int <start> data <end> ) const;"	"void CWE190_Integer_Overflow__int_listen_socket_square_81_bad::action(int <start> data <end> ) const;
printIntLine <start> result <end> );"	3
584fa86f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticFive = 5; void CWE191_Integer_Underflow__int_listen_socket_sub_07_bad() { int data; data = 0; if(staticFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticFive==5) { { int result = data - 1; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"int <start> result = data - 1 <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printIntLine(result) <end> ;"	"int result = <start> data <end>  - 1;
if  <start> acceptSocket == SOCKET_ERROR <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  - 1;"	3
9d745369-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) typedef struct _CWE126_Buffer_Overread__CWE129_fgets_67_structType { int structFirst; } CWE126_Buffer_Overread__CWE129_fgets_67_structType; void CWE126_Buffer_Overread__CWE129_fgets_67b_badSink(CWE126_Buffer_Overread__CWE129_fgets_67_structType myStruct) { int data = myStruct.structFirst; { int buffer[10] = { 0 }; if (data >= 0) { printIntLine(buffer[data]); } else { printLine(""ERROR: Array index is negative""); } } }"	where is the vulnerable dataflow from buffer[data] to printIntLine ?	"int data = <start> myStruct <end> .structFirst;
printIntLine <start> buffer[data] <end> );
void CWE126_Buffer_Overread__CWE129_fgets_67b_badSink(CWE126_Buffer_Overread__CWE129_fgets_67_structType <start> myStruct <end> );"	"void CWE126_Buffer_Overread__CWE129_fgets_67b_badSink(CWE126_Buffer_Overread__CWE129_fgets_67_structType <start> myStruct <end> );
int data = <start> myStruct <end> .structFirst;
printIntLine <start> buffer[data] <end> );"	"printIntLine <start> buffer[data] <end> );
int data = <start> myStruct <end> .structFirst;"	"int <start> buffer[10] = { 0 } <end> ;
printIntLine <start> buffer[data] <end> );
int data = <start> myStruct <end> .structFirst;"	1
70279c19-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif namespace CWE134_Uncontrolled_Format_String__char_file_snprintf_74 { void badSink(map<int, char *> dataMap) { char * data = dataMap[2]; { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"printLine <start> dest <end> );
<start> SNPRINTF(dest, 100-1, data) <end> ;"	"void badSink(map<int, char *> <start> dataMap <end> );
<start> SNPRINTF(dest, 100-1, data) <end> ;"	"void badSink(map<int, char *> <start> dataMap <end> );
printLine <start> dest <end> );"	"printLine <start> dest <end> );
void badSink(map<int, char *> <start> dataMap <end> );"	2
60db83ba-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__char_rand_multiply_09_bad() { char data; data = ' '; if(GLOBAL_CONST_TRUE) { data = (char)RAND32(); } if(GLOBAL_CONST_TRUE) { if(data > 0) { char result = data * 2; printHexCharLine(result); } } }	where is the vulnerable dataflow from data ?	"data = (char <start> RAND32() <end> ;
<start> printHexCharLine(result) <end> ;"	"data = (char <start> RAND32() <end> ;
char <start> result = data * 2 <end> ;"	"char result = <start> data <end>  * 2;
data = (char <start> RAND32() <end> ;"	"data = (char <start> RAND32() <end> ;
char result = <start> data <end>  * 2;"	3
8cc3a674-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(count) + 2) #ifdef _WIN32 #define SLEEP Sleep #else #define SLEEP usleep #endif void CWE400_Resource_Exhaustion__fgets_sleep_13_bad() { int count; count = -1; if(GLOBAL_CONST_FIVE==5) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { count = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(GLOBAL_CONST_FIVE==5) { SLEEP(count); printLine(""Sleep time possibly too long""); } }"	where is the vulnerable dataflow from count to SLEEP ?	"count = <start> atoi(inputBuffer) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"<start> SLEEP(count) <end> ;
SLEEP <start> count <end> );"	"<start> SLEEP(count) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
SLEEP <start> count <end> );"	3
b54bcefd-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 20 void CWE369_Divide_by_Zero__float_fgets_09_bad() { float data; data = 0.0F; if(GLOBAL_CONST_TRUE) { { char inputBuffer[CHAR_ARRAY_SIZE]; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = (float)atof(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(GLOBAL_CONST_TRUE) { { int result = (int)(100.0 / data); printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"int result = <start> (int)(100.0 / data) <end> ;
printIntLine <start> result <end> );"	"int <start> result = (int)(100.0 / data) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	2
c99197d4-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define STAT _stat #define OPEN _open #define WRITE _write #define O_RDWR _O_RDWR #define CLOSE _close #else #define STAT stat #define OPEN open #define WRITE write #define CLOSE close #endif #define BAD_SINK_STRING ""Bad Sink..."" #define GOOD_SINK_STRING ""Good Sink..."" void CWE367_TOC_TOU__stat_17_bad() { int j; for(j = 0; j < 1; j++) { { char filename[100] = """"; struct STAT statBuffer; int fileDesc = -1; if (fgets(filename, 100, stdin) == NULL) { printLine(""fgets() failed""); filename[0] = '\0'; } if (strlen(filename) > 0) { filename[strlen(filename)-1] = '\0'; } if (STAT(filename, &statBuffer) == -1) { exit(1); } fileDesc  = OPEN(filename, O_RDWR); if (fileDesc == -1) { exit(1); } if (WRITE(fileDesc, BAD_SINK_STRING, strlen(BAD_SINK_STRING)) == -1) { exit(1); } if (fileDesc != -1) { CLOSE(fileDesc); } } } }"	where is the vulnerable dataflow from filename to OPEN ?	"if  <start> strlen(filename) <end>  > 0);
if (fgets <start> filename <end> , 100, stdin) == NULL);"	"if (fgets <start> filename <end> , 100, stdin) == NULL);
fileDesc  = OPEN <start> filename <end> , O_RDWR);"	"fileDesc  = OPEN <start> filename <end> , O_RDWR);
filename <start> strlen(filename) <end> -1] = '\0'; ;"	"filename <start> strlen(filename) <end> -1] = '\0'; ;
if (fgets <start> filename <end> , 100, stdin) == NULL);"	1
6c938bd6-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink(int data) { { int i; int * buffer = (int *)malloc(10 * sizeof(int)); if (buffer == NULL) {exit(-1);} for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } free(buffer); } } void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_41_bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badSink(data); }"	where is the vulnerable dataflow from buffer to free ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSink <start> data <end> );
static void badSink(int <start> data <end> );
free <start> buffer <end> );"	"free <start> buffer <end> );
data = <start> atoi(inputBuffer) <end> ;
badSink <start> data <end> );
static void badSink(int <start> data <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSink <start> data <end> );
free <start> buffer <end> );"	"static void badSink(int <start> data <end> );
<start> badSink(data) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
free <start> buffer <end> );"	0
80d98736-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_console_open_51 { void badSink(char * data) { { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"void badSink(char * <start> data <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
void badSink(char * <start> data <end> );"	"fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
void badSink(char * <start> data <end> );"	0
7d44fcaa-6c15-11ed-81d4-94e6f77dd552	"namespace CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_81 { void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_81_bad::action(int data) const { { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } } }"	where is the vulnerable dataflow from dest to printLine ?	"void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_81_bad::action(int <start> data <end> ) const;
char <start> dest[100] = """" <end> ;"	"printLine <start> dest <end> );
if  <start> data < 100 <end> );"	"void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_81_bad::action(int <start> data <end> ) const;
printLine <start> dest <end> );"	"<start> printLine(dest) <end> ;
void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_81_bad::action(int <start> data <end> ) const;"	2
93ece31c-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING ""hello"" typedef struct _CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_67_structType { size_t structFirst; } CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_67_structType; void CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_67b_badSink(CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_67_structType myStruct) { size_t data = myStruct.structFirst; { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); } else { printLine(""Input is less than the length of the source string""); } } }"	where is the vulnerable dataflow from data to malloc ?	"size_t data = <start> myStruct <end> .structFirst;
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_67b_badSink(CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_67_structType <start> myStruct <end> );
if  <start> myString == NULL <end> ) {exit(-1);};"	"void CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_67b_badSink(CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_67_structType <start> myStruct <end> );
size_t data = <start> myStruct <end> .structFirst;
myString = (char *)malloc <start> data*sizeof(char) <end> );"	"size_t <start> data = myStruct.structFirst <end> ;
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_67b_badSink(CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_67_structType <start> myStruct <end> );
myString = (char *)malloc <start> data*sizeof(char) <end> );"	"myString = (char *)malloc <start> data*sizeof(char) <end> );
size_t data = <start> myStruct <end> .structFirst;
if  <start> myString == NULL <end> ) {exit(-1);};"	1
7e74f31b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_13_bad() { int data; data = -1; if(GLOBAL_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"printLine <start> dest <end> );
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"<start> memcpy(dest, source, data) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	2
774f5817-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 8 void CWE194_Unexpected_Sign_Extension__listen_socket_malloc_18_bad() { short data; data = 0; goto source; source: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }"	where is the vulnerable dataflow from data to malloc ?	"<start> data = tempInt <end> ;
char * dataBuffer = (char *)malloc <start> data <end> );"	"char * dataBuffer = (char *)malloc <start> data <end> );
if  <start> data < 100 <end> );"	"char * dataBuffer = (char *)malloc <start> data <end> );
memset(dataBuffer, 'A', <start> data-1 <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
char * dataBuffer = (char *)malloc <start> data <end> );"	3
774f57f2-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 8 namespace CWE194_Unexpected_Sign_Extension__fgets_strncpy_43 { static void badSource(short &data) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = (short)atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } void bad() { short data; data = 0; badSource(data); { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printLine <start> dest <end> );"	"<start> printLine(dest) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printLine <start> dest <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printLine <start> dest <end> );
badSource <start> data <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
badSource <start> data <end> );
printLine <start> dest <end> );"	3
60db839a-6c15-11ed-81d4-94e6f77dd552	"void CWE190_Integer_Overflow__char_rand_add_15_bad() { char data; data = ' '; switch(6) { case 6: data = (char)RAND32(); break; default: printLine(""Benign, fixed string""); break; } switch(7) { case 7: { char result = data + 1; printHexCharLine(result); } break; default: printLine(""Benign, fixed string""); break; } }"	where is the vulnerable dataflow from data ?	"data = (char <start> RAND32() <end> ;
char <start> result = data + 1 <end> ;"	"char result = <start> data <end>  + 1;
data = (char <start> RAND32() <end> ;"	"data = (char <start> RAND32() <end> ;
char result = <start> data <end>  + 1;"	"char result = <start> data <end>  + 1;
<start> printHexCharLine(result) <end> ;"	2
7fa68e37-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_connect_socket_fopen_34 { typedef union { char * unionFirst; char * unionSecond; } unionType; void bad() { char * data; unionType myUnion; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } } }"	where is the vulnerable dataflow from data to FOPEN ?	"recvResult = <start> recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0) <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	"char <start> * data = myUnion.unionSecond <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	2
87ff985a-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_connect_socket_fopen_66 { void badSink(char * dataArray[]) { char * data = dataArray[2]; { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = FOPEN <start> data <end> , ""wb+"");
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	"void badSink(char * <start> dataArray <end> []);
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
void badSink(char * <start> dataArray <end> []);"	"pFile = FOPEN <start> data <end> , ""wb+"");
void badSink(char * <start> dataArray <end> []);"	1
7ae3a708-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticFive = 5; void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_07_bad() { int data; data = -1; if(staticFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> data = atoi(inputBuffer) <end> ;
printLine <start> dest <end> );"	"printLine <start> dest <end> );
<start> memmove(dest, source, data) <end> ;"	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printLine <start> dest <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	3
55ef4cca-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_fgets_sub_11_bad() { int data; data = 0; if(globalReturnsTrue()) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(globalReturnsTrue()) { { int result = data - 1; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
data = <start> atoi(inputBuffer) <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
int result = <start> data <end>  - 1;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
int <start> result = data - 1 <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> printIntLine(result) <end> ;"	1
a49c4f4d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int CWE190_Integer_Overflow__int_listen_socket_multiply_45_badData; static int CWE190_Integer_Overflow__int_listen_socket_multiply_45_goodG2BData; static int CWE190_Integer_Overflow__int_listen_socket_multiply_45_goodB2GData; static void badSink() { int data = CWE190_Integer_Overflow__int_listen_socket_multiply_45_badData; if(data > 0) { int result = data * 2; printIntLine(result); } } void CWE190_Integer_Overflow__int_listen_socket_multiply_45_bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE190_Integer_Overflow__int_listen_socket_multiply_45_badData = data; badSink(); }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );
<start> CWE190_Integer_Overflow__int_listen_socket_multiply_45_badData = data <end> ;
static int <start> CWE190_Integer_Overflow__int_listen_socket_multiply_45_badData <end> ;
<start> printIntLine(result) <end> ;"	"data = <start> atoi(inputBuffer) <end> ;
static int <start> CWE190_Integer_Overflow__int_listen_socket_multiply_45_badData <end> ;
<start> CWE190_Integer_Overflow__int_listen_socket_multiply_45_badData = data <end> ;
int data = <start> CWE190_Integer_Overflow__int_listen_socket_multiply_45_badData <end> ;
printIntLine <start> result <end> );"	"data = <start> atoi(inputBuffer) <end> ;
int data = <start> CWE190_Integer_Overflow__int_listen_socket_multiply_45_badData <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> CWE190_Integer_Overflow__int_listen_socket_multiply_45_badData = data <end> ;
static int <start> CWE190_Integer_Overflow__int_listen_socket_multiply_45_badData <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> CWE190_Integer_Overflow__int_listen_socket_multiply_45_badData = data <end> ;
static int <start> CWE190_Integer_Overflow__int_listen_socket_multiply_45_badData <end> ;
int data = <start> CWE190_Integer_Overflow__int_listen_socket_multiply_45_badData <end> ;
printIntLine <start> result <end> );"	3
cf875082-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_environment_open_09 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(GLOBAL_CONST_TRUE) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"<start> data = dataBuffer <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"size_t dataLen = <start> strlen(data) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
char <start> dataBuffer[FILENAME_MAX] = """" <end> ;"	1
8b91e4ac-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(count) + 2) #ifdef _WIN32 #define SLEEP Sleep #else #define SLEEP usleep #endif void CWE400_Resource_Exhaustion__connect_socket_sleep_12_bad() { int count; count = -1; if(globalReturnsTrueOrFalse()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; count = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } else { count = 20; } if(globalReturnsTrueOrFalse()) { SLEEP(count); printLine(""Sleep time possibly too long""); } else { if (count > 0 && count <= 2000) { SLEEP(count); printLine(""Sleep time OK""); } else { printLine(""Sleep time too long""); } } }"	where is the vulnerable dataflow from count to SLEEP ?	"count = <start> atoi(inputBuffer) <end> ;
SLEEP <start> count <end> );"	"<start> count = atoi(inputBuffer) <end> ;
SLEEP <start> count <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
SLEEP <start> count <end> );"	"count = <start> atoi(inputBuffer) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	2
c99197be-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define STAT _stat #define OPEN _open #define WRITE _write #define O_RDWR _O_RDWR #define CLOSE _close #else #define STAT stat #define OPEN open #define WRITE write #define CLOSE close #endif #define BAD_SINK_STRING ""Bad Sink..."" #define GOOD_SINK_STRING ""Good Sink..."" #ifdef _WIN32 #define ACCESS _access #define W_OK 02 #else #define ACCESS access #endif void CWE367_TOC_TOU__access_13_bad() { if(GLOBAL_CONST_FIVE==5) { { char filename[100] = """"; int fileDesc = -1; if (fgets(filename, 100, stdin) == NULL) { printLine(""fgets() failed""); filename[0] = '\0'; } if (strlen(filename) > 0) { filename[strlen(filename)-1] = '\0'; } if (ACCESS(filename, W_OK) == -1) { exit(1); } fileDesc  = OPEN(filename, O_RDWR); if (fileDesc == -1) { exit(1); } if (WRITE(fileDesc, BAD_SINK_STRING, strlen(BAD_SINK_STRING)) == -1) { exit(1); } if (fileDesc != -1) { CLOSE(fileDesc); } } } }"	where is the vulnerable dataflow from filename to OPEN ?	"if (fgets <start> filename <end> , 100, stdin) == NULL);
fileDesc  = OPEN <start> filename <end> , O_RDWR);"	"fileDesc  = <start> OPEN(filename, O_RDWR) <end> ;
fileDesc  = OPEN <start> filename <end> , O_RDWR);"	"fileDesc  = OPEN <start> filename <end> , O_RDWR);
if  <start> ACCESS(filename, W_OK) <end>  == -1);"	"fileDesc  = OPEN <start> filename <end> , O_RDWR);
filename <start> strlen(filename) <end> -1] = '\0'; ;"	0
86cea15b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) int CWE369_Divide_by_Zero__int_listen_socket_divide_61b_badSource(int data); void CWE369_Divide_by_Zero__int_listen_socket_divide_61_bad() { int data; data = -1; data = CWE369_Divide_by_Zero__int_listen_socket_divide_61b_badSource(data); printIntLine(100 / data); }"	where is the vulnerable dataflow from data to printIntLine ?	"data = <start> CWE369_Divide_by_Zero__int_listen_socket_divide_61b_badSource <end> (data);
printIntLine <start> 100 / data <end> );"	"printIntLine <start> 100 / data <end> );
data = <start> CWE369_Divide_by_Zero__int_listen_socket_divide_61b_badSource <end> (data);"	"printIntLine <start> 100 / data <end> );
<start> data = CWE369_Divide_by_Zero__int_listen_socket_divide_61b_badSource(data) <end> ;"	"<start> data = -1 <end> ;
data = <start> CWE369_Divide_by_Zero__int_listen_socket_divide_61b_badSource <end> (data);"	0
cd228139-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } namespace CWE36_Absolute_Path_Traversal__char_console_ofstream_08 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(staticReturnsTrue()) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
outputFile.open((char * <start> data <end> );"	"outputFile.open((char * <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
dataLen = <start> strlen(data) <end> ;"	"dataLen = <start> strlen(data) <end> ;
outputFile.open((char * <start> data <end> );"	0
aa91a18e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_listen_socket_sub_12_bad() { int data; data = 0; if(globalReturnsTrueOrFalse()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } else { data = -2; } if(globalReturnsTrueOrFalse()) { { int result = data - 1; printIntLine(result); } } else { if (data > INT_MIN) { int result = data - 1; printIntLine(result); } else { printLine(""data value is too large to perform subtraction.""); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"int result = <start> data - 1 <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"<start> data = atoi(inputBuffer) <end> ;
printIntLine <start> result <end> );"	"int <start> result = data - 1 <end> ;
printIntLine <start> result <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	3
ba102b95-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define EXECLP _execlp #else #define EXECLP execlp #endif void CWE78_OS_Command_Injection__char_connect_socket_execlp_03_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(5==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECLP ?	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"<start> data = dataBuffer <end> ;
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
<start> data = dataBuffer <end> ;"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
replace = <start> strchr(data, '\n') <end> ;"	0
54c58217-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_connect_socket_sub_16_bad() { int data; data = 0; while(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; } while(1) { { int result = data - 1; printIntLine(result); } break; } }"	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  - 1;
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  - 1;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printIntLine(result) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  - 1;"	3
c39a658a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif static const int STATIC_CONST_FIVE = 5; namespace CWE23_Relative_Path_Traversal__char_environment_ifstream_06 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(STATIC_CONST_FIVE==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } } { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"inputFile.open((char * <start> data <end> );
char <start> dataBuffer[FILENAME_MAX] = BASEPATH <end> ;"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
inputFile.open((char * <start> data <end> );"	"inputFile.open((char * <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	"inputFile.open((char * <start> data <end> );
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	1
b7b09a4a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define NEW_PATH ""%SystemRoot%\\system32"" #define PUTENV _putenv #else #define NEW_PATH ""/bin"" #define PUTENV putenv #endif namespace CWE427_Uncontrolled_Search_Path_Element__char_console_72 { void badSink(vector<char *> dataVector) { char * data = dataVector[2]; PUTENV(data); }"	where is the vulnerable dataflow from data to PUTENV ?	"PUTENV <start> data <end> );
void badSink(vector<char *> <start> dataVector <end> );"	"PUTENV <start> data <end> );
char <start> * data = dataVector[2] <end> ;"	"void badSink(vector<char *> <start> dataVector <end> );
PUTENV <start> data <end> );"	"<start> PUTENV(data) <end> ;
PUTENV <start> data <end> );"	2
571e9839-6c15-11ed-81d4-94e6f77dd552	"static int CWE191_Integer_Underflow__int_fscanf_sub_45_badData; static int CWE191_Integer_Underflow__int_fscanf_sub_45_goodG2BData; static int CWE191_Integer_Underflow__int_fscanf_sub_45_goodB2GData; static void badSink() { int data = CWE191_Integer_Underflow__int_fscanf_sub_45_badData; { int result = data - 1; printIntLine(result); } } void CWE191_Integer_Underflow__int_fscanf_sub_45_bad() { int data; data = 0; fscanf(stdin, ""%d"", &data); CWE191_Integer_Underflow__int_fscanf_sub_45_badData = data; badSink(); }"	where is the vulnerable dataflow from data ?	"fscanf(stdin, ""%d"", <start> &data <end> );
<start> CWE191_Integer_Underflow__int_fscanf_sub_45_badData = data <end> ;
static int <start> CWE191_Integer_Underflow__int_fscanf_sub_45_badData <end> ;
int data = <start> CWE191_Integer_Underflow__int_fscanf_sub_45_badData <end> ;
int result = <start> data <end>  - 1;"	"static int <start> CWE191_Integer_Underflow__int_fscanf_sub_45_badData <end> ;
int result = <start> data - 1 <end> ;
fscanf(stdin, ""%d"", <start> &data <end> );
<start> CWE191_Integer_Underflow__int_fscanf_sub_45_badData = data <end> ;
int data = <start> CWE191_Integer_Underflow__int_fscanf_sub_45_badData <end> ;"	"<start> CWE191_Integer_Underflow__int_fscanf_sub_45_badData = data <end> ;
fscanf(stdin, ""%d"", <start> &data <end> );"	"static int <start> CWE191_Integer_Underflow__int_fscanf_sub_45_badData <end> ;
<start> CWE191_Integer_Underflow__int_fscanf_sub_45_badData = data <end> ;
fscanf(stdin, ""%d"", <start> &data <end> );
int <start> data = CWE191_Integer_Underflow__int_fscanf_sub_45_badData <end> ;
int result = <start> data <end>  - 1;"	0
b1b80855-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" void CWE197_Numeric_Truncation_Error__short_connect_socket_13_bad() { short data; data = -1; if(GLOBAL_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = (short)atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { char charData = (char)data; printHexCharLine(charData); } }"	where is the vulnerable dataflow from charData to printHexCharLine ?	"recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);
printHexCharLine <start> charData <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printHexCharLine <start> charData <end> );"	"<start> data = -1 <end> ;
printHexCharLine <start> charData <end> );"	"<start> printHexCharLine(charData) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	1
d31a2529-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_listen_socket_open_45 { static char * badData; static char * goodG2BData; static void badSink() { char * data = badData; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } } void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badData = data; badSink(); }"	where is the vulnerable dataflow from data to OPEN ?	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
static char * <start> badData <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
char * data = <start> badData <end> ;"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
<start> badData = data <end> ;
static char * <start> badData <end> ;
char * data = <start> badData <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"replace = <start> strchr(data, '\r') <end> ;
static char * <start> badData <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
<start> badData = data <end> ;"	"recvResult = <start> recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0) <end> ;
char * data = <start> badData <end> ;
static char * <start> badData <end> ;
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
<start> badData = data <end> ;"	1
70279bfb-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif void CWE134_Uncontrolled_Format_String__char_file_snprintf_11_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; if(globalReturnsTrue()) { { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } if(globalReturnsTrue()) { { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } } }"	where is the vulnerable dataflow from dest to printLine ?	"printLine <start> dest <end> );
size_t dataLen = <start> strlen(data) <end> ;"	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	"<start> data = dataBuffer <end> ;
printLine <start> dest <end> );"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
printLine <start> dest <end> );"	3
820a46fb-6c15-11ed-81d4-94e6f77dd552	#ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_file_open_82 { void CWE23_Relative_Path_Traversal__char_file_open_82_bad::action(char * data) { { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } } }	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
void CWE23_Relative_Path_Traversal__char_file_open_82_bad::action(char * <start> data <end> );"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
void CWE23_Relative_Path_Traversal__char_file_open_82_bad::action(char * <start> data <end> );"	"void CWE23_Relative_Path_Traversal__char_file_open_82_bad::action(char * <start> data <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	3
669edac9-6c15-11ed-81d4-94e6f77dd552	static char CWE190_Integer_Overflow__char_rand_postinc_45_badData; static char CWE190_Integer_Overflow__char_rand_postinc_45_goodG2BData; static char CWE190_Integer_Overflow__char_rand_postinc_45_goodB2GData; static void badSink() { char data = CWE190_Integer_Overflow__char_rand_postinc_45_badData; { data++; char result = data; printHexCharLine(result); } } void CWE190_Integer_Overflow__char_rand_postinc_45_bad() { char data; data = ' '; data = (char)RAND32(); CWE190_Integer_Overflow__char_rand_postinc_45_badData = data; badSink(); }	where is the vulnerable dataflow from data ?	"char data = <start> CWE190_Integer_Overflow__char_rand_postinc_45_badData <end> ;
<start> CWE190_Integer_Overflow__char_rand_postinc_45_badData = data <end> ;
data = (char <start> RAND32() <end> ;
<start> data <end> ++;"	"<start> printHexCharLine(result) <end> ;
<start> data <end> ++;
data = (char <start> RAND32() <end> ;
static char <start> CWE190_Integer_Overflow__char_rand_postinc_45_badData <end> ;
<start> CWE190_Integer_Overflow__char_rand_postinc_45_badData = data <end> ;"	"data = (char <start> RAND32() <end> ;
char data = <start> CWE190_Integer_Overflow__char_rand_postinc_45_badData <end> ;
<start> CWE190_Integer_Overflow__char_rand_postinc_45_badData = data <end> ;"	"data = (char <start> RAND32() <end> ;
<start> CWE190_Integer_Overflow__char_rand_postinc_45_badData = data <end> ;
static char <start> CWE190_Integer_Overflow__char_rand_postinc_45_badData <end> ;
char data = <start> CWE190_Integer_Overflow__char_rand_postinc_45_badData <end> ;
<start> data <end> ++;"	3
b41b87b3-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 20 #define IP_ADDRESS ""127.0.0.1"" void CWE369_Divide_by_Zero__float_connect_socket_66b_badSink(float dataArray[]) { float data = dataArray[2]; { int result = (int)(100.0 / data); printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"void CWE369_Divide_by_Zero__float_connect_socket_66b_badSink(float <start> dataArray <end> []);
printIntLine <start> result <end> );"	"int result = (int) <start> 100.0 / data <end> );
void CWE369_Divide_by_Zero__float_connect_socket_66b_badSink(float <start> dataArray <end> []);"	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
void CWE369_Divide_by_Zero__float_connect_socket_66b_badSink(float <start> dataArray <end> []);"	0
630ae7e7-6c15-11ed-81d4-94e6f77dd552	typedef union { short unionFirst; short unionSecond; } CWE190_Integer_Overflow__short_rand_multiply_34_unionType; void CWE190_Integer_Overflow__short_rand_multiply_34_bad() { short data; CWE190_Integer_Overflow__short_rand_multiply_34_unionType myUnion; data = 0; data = (short)RAND32(); myUnion.unionFirst = data; { short data = myUnion.unionSecond; if(data > 0) { short result = data * 2; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"short result = <start> data * 2 <end> ;
data = (short <start> RAND32() <end> ;"	"short result = <start> data <end>  * 2;
<start> printIntLine(result) <end> ;"	"data = (short <start> RAND32() <end> ;
short result = <start> data <end>  * 2;"	"short result = <start> data <end>  * 2;
data = (short <start> RAND32() <end> ;"	2
7fa68e3a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_connect_socket_fopen_43 { void badSource(char * &data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; badSource(data); { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
badSource <start> data <end> );
pFile = FOPEN <start> data <end> , ""wb+"");"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
badSource <start> data <end> );
replace = <start> strchr(data, '\r') <end> ;"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = FOPEN <start> data <end> , ""wb+"");
badSource <start> data <end> );"	"size_t <start> dataLen = strlen(data) <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");
badSource <start> data <end> );"	0
b41b8783-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif namespace CWE23_Relative_Path_Traversal__char_file_ifstream_82 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } CWE23_Relative_Path_Traversal__char_file_ifstream_82_base* baseObject = new CWE23_Relative_Path_Traversal__char_file_ifstream_82_bad; baseObject->action(data); delete baseObject; }"	where is the vulnerable dataflow from data to action ?	"baseObject->action <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
size_t dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
baseObject->action <start> data <end> );"	"baseObject->action <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	2
5d16c9c6-6c15-11ed-81d4-94e6f77dd552	"typedef union { short unionFirst; short unionSecond; } CWE191_Integer_Underflow__short_fscanf_postdec_34_unionType; void CWE191_Integer_Underflow__short_fscanf_postdec_34_bad() { short data; CWE191_Integer_Underflow__short_fscanf_postdec_34_unionType myUnion; data = 0; fscanf (stdin, ""%hd"", &data); myUnion.unionFirst = data; { short data = myUnion.unionSecond; { data--; short result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"fscanf (stdin, ""%hd"", <start> &data <end> );
<start> data <end> --;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
short <start> result = data <end> ;"	"<start> data-- <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );"	"<start> printIntLine(result) <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );"	0
8a6310a9-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_file_fopen_62 { void badSource(char * &data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; badSource(data); { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"<start> data = dataBuffer <end> ;
badSource <start> data <end> );"	"badSource <start> data <end> );
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	"badSource <start> data <end> );
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	2
70279c28-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif static void badVaSinkB(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_file_vfprintf_13_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; if(GLOBAL_CONST_FIVE==5) { { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } if(GLOBAL_CONST_FIVE==5) { badVaSinkB(data, data); } }"	where is the vulnerable dataflow from data to vfprintf ?	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
<start> va_start(args, data) <end> ;
badVaSinkB <start> data <end> , data);
vfprintf(stdout, <start> data <end> , args);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);"	"char <start> dataBuffer[100] = """" <end> ;
badVaSinkB <start> data <end> , data);
vfprintf(stdout, <start> data <end> , args);
static void badVaSinkB(char * <start> data <end> , ...);"	"badVaSinkB <start> data <end> , data);
<start> vfprintf(stdout, data, args) <end> ;
static void badVaSinkB(char * <start> data <end> , ...);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	1
93ece2eb-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING ""hello"" void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_53d_badSink(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); } else { printLine(""Input is less than the length of the source string""); } } }"	where is the vulnerable dataflow from data to malloc ?	"myString = (char *)malloc <start> data*sizeof(char) <end> );
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_53d_badSink(size_t <start> data <end> );"	"myString = (char *)malloc <start> data*sizeof(char) <end> );
if  <start> data > strlen(HELLO_STRING) <end> );"	"void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_53d_badSink(size_t <start> data <end> );
myString = (char *)malloc <start> data*sizeof(char) <end> );"	"<start> free(myString) <end> ;
myString = (char *)malloc <start> data*sizeof(char) <end> );"	2
cd228151-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_console_open_01 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"<start> data = dataBuffer <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"if (dataLen > 0 && <start> data[dataLen-1] == '\n' <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	2
c5fc235c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif namespace CWE23_Relative_Path_Traversal__char_file_ofstream_31 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } { char * dataCopy = data; char * data = dataCopy; { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } } }"	where is the vulnerable dataflow from data to open ?	"outputFile.open((char * <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
outputFile.open((char * <start> data <end> );"	"size_t dataLen = <start> strlen(data) <end> ;
outputFile.open((char * <start> data <end> );"	"char <start> dataBuffer[FILENAME_MAX] = BASEPATH <end> ;
outputFile.open((char * <start> data <end> );"	1
c8600ade-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } namespace CWE23_Relative_Path_Traversal__char_listen_socket_ofstream_08 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(staticReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
outputFile.open((char * <start> data <end> );"	"<start> data = dataBuffer <end> ;
outputFile.open((char * <start> data <end> );"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - <start> dataLen - 1 <end> ), 0);"	"outputFile.open((char * <start> data <end> );
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	0
7c1275ad-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_03_bad() { int data; data = -1; if(5==5) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printLine <start> dest <end> );"	"printLine <start> dest <end> );
if  <start> data < 100 <end> );"	"printLine <start> dest <end> );
<start> memmove(dest, source, data) <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> printLine(dest) <end> ;"	0
a23a3e04-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_add_51b_badSink(int data) { { int result = data + 1; printIntLine(result); } }	where is the vulnerable dataflow from result to printIntLine ?	"int <start> result = data + 1 <end> ;
printIntLine <start> result <end> );"	"void CWE190_Integer_Overflow__int_fgets_add_51b_badSink(int <start> data <end> );
<start> printIntLine(result) <end> ;"	"printIntLine <start> result <end> );
void CWE190_Integer_Overflow__int_fgets_add_51b_badSink(int <start> data <end> );"	"void CWE190_Integer_Overflow__int_fgets_add_51b_badSink(int <start> data <end> );
printIntLine <start> result <end> );"	3
a830bfa8-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int badSource(int data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } return data; } void CWE191_Integer_Underflow__int_connect_socket_sub_42_bad() { int data; data = 0; data = badSource(data); { int result = data - 1; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"static int <start> badSource <end> (int data);
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int <start> result = data - 1 <end> ;
printIntLine <start> result <end> );"	"static int <start> badSource <end> (int data);
printIntLine <start> result <end> );
data = <start> badSource <end> (data);
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static int <start> badSource <end> (int data);
data = <start> badSource <end> (data);
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
data = <start> badSource <end> (data);
data = <start> atoi(inputBuffer) <end> ;"	2
bb49c58d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #define EXECL _execl #else #define EXECL execl #endif static int badStatic = 0; static char * badSource(char * data) { if(badStatic) { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } return data; } void CWE78_OS_Command_Injection__char_console_execl_21_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; badStatic = 1; data = badSource(data); EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECL ?	"static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
size_t dataLen = <start> strlen(data) <end> ;
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"data = <start> badSource <end> (data);
<start> EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
static char * <start> badSource <end> (char * data);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
dataLen = <start> strlen(data) <end> ;
data = <start> badSource <end> (data);
static char * <start> badSource <end> (char * data);"	1
b68484cf-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" namespace CWE36_Absolute_Path_Traversal__char_connect_socket_fopen_82 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE36_Absolute_Path_Traversal__char_connect_socket_fopen_82_base* baseObject = new CWE36_Absolute_Path_Traversal__char_connect_socket_fopen_82_bad; baseObject->action(data); delete baseObject; }"	where is the vulnerable dataflow from data to action ?	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
replace = <start> strchr(data, '\n') <end> ;"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
baseObject->action <start> data <end> );"	"baseObject->action <start> data <end> );
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"baseObject->action <start> data <end> );
replace = <start> strchr(data, '\n') <end> ;"	1
54c58206-6c15-11ed-81d4-94e6f77dd552	namespace CWE191_Integer_Underflow__int_connect_socket_multiply_74 { void badSink(map<int, int> dataMap) { int data = dataMap[2]; if(data < 0) { int result = data * 2; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"void badSink(map<int, int> <start> dataMap <end> );
int result = <start> data <end>  * 2;"	"void badSink(map<int, int> <start> dataMap <end> );
<start> printIntLine(result) <end> ;"	"int result = <start> data <end>  * 2;
void badSink(map<int, int> <start> dataMap <end> );"	"int <start> data = dataMap[2] <end> ;
int result = <start> data <end>  * 2;"	0
d0b64ed6-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif namespace CWE36_Absolute_Path_Traversal__char_file_ifstream_42 { static char * badSource(char * data) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } return data; } void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; data = badSource(data); { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
inputFile.open((char * <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"inputFile.open((char * <start> data <end> );
data = <start> badSource <end> (data);
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
inputFile.open((char * <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
data = <start> badSource <end> (data);"	2
99e16a78-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_listen_socket_02 { void bad() { int data; data = -1; if(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(1) { { int i; int * buffer = new int[10]; for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } delete[] buffer; } } }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"printIntLine <start> buffer[i] <end> );
int <start> * buffer = new int[10] <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[i] <end> );"	"if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );
printIntLine <start> buffer[i] <end> );"	"if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	1
648a9bf5-6c15-11ed-81d4-94e6f77dd552	static int badStatic = 0; static void badSink(int64_t data) { if(badStatic) { { int64_t result = data * data; printLongLongLine(result); } } } void CWE190_Integer_Overflow__int64_t_rand_square_21_bad() { int64_t data; data = 0LL; data = (int64_t)RAND64(); badStatic = 1; badSink(data); }	where is the vulnerable dataflow from data ?	"data = (int64_t <start> RAND64() <end> ;
static void badSink(int64_t <start> data <end> );
int64_t result = <start> data <end>  * data;
badSink <start> data <end> );"	"data = (int64_t <start> RAND64() <end> ;
badSink <start> data <end> );"	"data = (int64_t <start> RAND64() <end> ;
badSink <start> data <end> );
static void badSink(int64_t <start> data <end> );
<start> data = (int64_t)RAND64() <end> ;"	"data = (int64_t <start> RAND64() <end> ;
badSink <start> data <end> );
static void badSink(int64_t <start> data <end> );
int64_t result = <start> data <end>  * data;"	3
4a021121-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticTrue = 1; static int staticFalse = 0; void CWE190_Integer_Overflow__int_listen_socket_square_05_bad() { int data; data = 0; if(staticTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticTrue) { { int result = data * data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"int result = <start> data <end>  * data;
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"int <start> result = data * data <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  * data;"	3
630ae828-6c15-11ed-81d4-94e6f77dd552	static int64_t badSource(int64_t data) { data = (int64_t)RAND64(); return data; } void CWE190_Integer_Overflow__int64_t_rand_add_42_bad() { int64_t data; data = 0LL; data = badSource(data); { int64_t result = data + 1; printLongLongLine(result); } }	where is the vulnerable dataflow from data ?	"data = (int64_t <start> RAND64() <end> ;
static int64_t <start> badSource <end> (int64_t data);
data = <start> badSource <end> (data);
int64_t result = <start> data <end>  + 1;"	"static int64_t <start> badSource <end> (int64_t data);
data = <start> badSource <end> (data);
data = (int64_t <start> RAND64() <end> ;
int64_t result = <start> data <end>  + 1;"	"static int64_t <start> badSource <end> (int64_t data);
data = <start> badSource <end> (data);
data = (int64_t <start> RAND64() <end> ;"	"data = (int64_t <start> RAND64() <end> ;
static int64_t <start> badSource <end> (int64_t data);"	0
bda4e436-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define EXECLP _execlp #else #define EXECLP execlp #endif void CWE78_OS_Command_Injection__char_listen_socket_execlp_12_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(globalReturnsTrueOrFalse()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } else { strcat(data, ""*.*""); } EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECLP ?	"EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
<start> data = dataBuffer <end> ;"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
<start> EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL) <end> ;"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	2
820a469f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_console_open_54 { void badSink_e(char * data) { { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"void badSink_e(char * <start> data <end> );
fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);"	"void badSink_e(char * <start> data <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = OPEN(data, O_RDWR|O_CREAT, <start> S_IREAD|S_IWRITE <end> );"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
void badSink_e(char * <start> data <end> );"	1
964cdc2d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_08_bad() { int data; data = -1; if(staticReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticReturnsTrue()) { { int i; int buffer[10] = { 0 }; if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } } } }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);
printIntLine <start> buffer[i] <end> );"	"<start> printIntLine(buffer[i]) <end> ;
printIntLine <start> buffer[i] <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[i] <end> );"	"data = <start> atoi(inputBuffer) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	2
9187cbff-6c15-11ed-81d4-94e6f77dd552	"#define SEARCH_CHAR 'S' void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_console_16_bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\0'; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } while(1) { for (; *data != '\0'; data++) { if (*data == SEARCH_CHAR) { printLine(""We have a match!""); break; } } free(data); break; } }"	where is the vulnerable dataflow from data to free ?	"free <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
size_t dataLen = <start> strlen(data) <end> ;"	"dataLen = <start> strlen(data) <end> ;
free <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
free <start> data <end> );"	3
c9919807-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" namespace CWE36_Absolute_Path_Traversal__char_connect_socket_ifstream_10 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(globalTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
inputFile.open((char * <start> data <end> );"	"recvResult = recv(connectSocket, (char *)(data + dataLen), <start> sizeof(char) * (FILENAME_MAX - dataLen - 1) <end> , 0);
inputFile.open((char * <start> data <end> );"	"<start> data = dataBuffer <end> ;
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"inputFile.open((char * <start> data <end> );
<start> data = dataBuffer <end> ;"	0
bed4a8e4-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" namespace CWE23_Relative_Path_Traversal__char_connect_socket_ifstream_11 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(globalReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
inputFile.open((char * <start> data <end> );"	"size_t dataLen = <start> strlen(data) <end> ;
inputFile.open((char * <start> data <end> );"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"size_t dataLen = <start> strlen(data) <end> ;
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	0
9fe7ad22-6c15-11ed-81d4-94e6f77dd552	"namespace CWE134_Uncontrolled_Format_String__char_console_printf_81 { void bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } const CWE134_Uncontrolled_Format_String__char_console_printf_81_base& baseObject = CWE134_Uncontrolled_Format_String__char_console_printf_81_bad(); baseObject.action(data); }"	where is the vulnerable dataflow from data to action ?	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
baseObject.action <start> data <end> );"	"<start> data = dataBuffer <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	"baseObject.action <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	"baseObject.action <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	0
8b91e463-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_listen_socket_fopen_73 { void badSink(list<char *> dataList) { char * data = dataList.back(); { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
void badSink(list<char *> <start> dataList <end> );"	"void badSink(list<char *> <start> dataList <end> );
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
void badSink(list<char *> <start> dataList <end> );"	2
80d986f8-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_console_fopen_02 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(1) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"char <start> dataBuffer[FILENAME_MAX] = BASEPATH <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
size_t dataLen = <start> strlen(data) <end> ;"	"if (dataLen > 0 && <start> data[dataLen-1] == '\n' <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	1
60db83cc-6c15-11ed-81d4-94e6f77dd552	static char CWE190_Integer_Overflow__char_rand_multiply_45_badData; static char CWE190_Integer_Overflow__char_rand_multiply_45_goodG2BData; static char CWE190_Integer_Overflow__char_rand_multiply_45_goodB2GData; static void badSink() { char data = CWE190_Integer_Overflow__char_rand_multiply_45_badData; if(data > 0) { char result = data * 2; printHexCharLine(result); } } void CWE190_Integer_Overflow__char_rand_multiply_45_bad() { char data; data = ' '; data = (char)RAND32(); CWE190_Integer_Overflow__char_rand_multiply_45_badData = data; badSink(); }	where is the vulnerable dataflow from data ?	"data = (char <start> RAND32() <end> ;
char <start> data = CWE190_Integer_Overflow__char_rand_multiply_45_badData <end> ;
<start> CWE190_Integer_Overflow__char_rand_multiply_45_badData = data <end> ;
char result = <start> data <end>  * 2;
static char <start> CWE190_Integer_Overflow__char_rand_multiply_45_badData <end> ;"	"char result = <start> data <end>  * 2;
char data = <start> CWE190_Integer_Overflow__char_rand_multiply_45_badData <end> ;
<start> CWE190_Integer_Overflow__char_rand_multiply_45_badData = data <end> ;
static char <start> CWE190_Integer_Overflow__char_rand_multiply_45_badData <end> ;
data = (char <start> RAND32() <end> ;"	"data = (char <start> RAND32() <end> ;
<start> CWE190_Integer_Overflow__char_rand_multiply_45_badData = data <end> ;
static char <start> CWE190_Integer_Overflow__char_rand_multiply_45_badData <end> ;
char data = <start> CWE190_Integer_Overflow__char_rand_multiply_45_badData <end> ;
char result = <start> data <end>  * 2;"	"<start> CWE190_Integer_Overflow__char_rand_multiply_45_badData = data <end> ;
char result = <start> data <end>  * 2;
data = (char <start> RAND32() <end> ;
static char <start> CWE190_Integer_Overflow__char_rand_multiply_45_badData <end> ;
<start> printHexCharLine(result) <end> ;"	2
8a6310bc-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_file_open_12 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(globalReturnsTrueOrFalse()) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } else { #ifdef _WIN32 strcat(data, ""c:\\temp\\file.txt""); #else strcat(data, ""/tmp/file.txt""); #endif } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"char <start> dataBuffer[FILENAME_MAX] = """" <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"char <start> dataBuffer[FILENAME_MAX] = """" <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	3
7c1275a9-6c15-11ed-81d4-94e6f77dd552	"namespace CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_81 { void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_81_bad::action(int data) const { { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> printLine(dest) <end> ;
void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_81_bad::action(int <start> data <end> ) const;"	"char <start> dest[100] = """" <end> ;
printLine <start> dest <end> );"	"printLine <start> dest <end> );
<start> memcpy(dest, source, data) <end> ;"	"void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_81_bad::action(int <start> data <end> ) const;
printLine <start> dest <end> );"	3
47a2a842-6c15-11ed-81d4-94e6f77dd552	"static int badSource(int data) { fscanf(stdin, ""%d"", &data); return data; } void CWE190_Integer_Overflow__int_fscanf_multiply_42_bad() { int data; data = 0; data = badSource(data); if(data > 0) { int result = data * 2; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"fscanf(stdin, ""%d"", <start> &data <end> );
static int <start> badSource <end> (int data);
data = <start> badSource <end> (data);
int result = <start> data <end>  * 2;"	"<start> printIntLine(result) <end> ;
static int <start> badSource <end> (int data);
data = <start> badSource <end> (data);
int result = <start> data <end>  * 2;"	"static int <start> badSource <end> (int data);
data = <start> badSource <end> (data);
int result = <start> data * 2 <end> ;
fscanf(stdin, ""%d"", <start> &data <end> );"	"data = <start> badSource <end> (data);
int result = <start> data <end>  * 2;
static int <start> badSource <end> (int data);
fscanf(stdin, ""%d"", <start> &data <end> );"	0
951c5e82-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FULL_COMMAND ""dir "" #else #define FULL_COMMAND ""ls "" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define SYSTEM system #else #define SYSTEM system #endif void CWE78_OS_Command_Injection__char_connect_socket_system_17_bad() { int i; char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; for(i = 0; i < 1; i++) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if (SYSTEM(data) != 0) { printLine(""command execution failed!""); exit(1); } }"	where is the vulnerable dataflow from data to sizeof ?	replace = <start> strchr(data, '\r') <end> ;	recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);	size_t dataLen = <start> strlen(data) <end> ;	replace = <start> strchr(data, '\n') <end> ;	1
bed4a8c6-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_connect_socket_fopen_22 { int badGlobal = 0; char * badSource(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; badGlobal = 1; data = badSource(data); { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } ; }"	where is the vulnerable dataflow from data to FOPEN ?	"data = <start> badSource(data) <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"data = <start> badSource <end> (data);
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
<start> data = badSource(data) <end> ;"	"data = <start> badSource <end> (data);
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	1
a5ce1c54-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_postinc_09_bad() { int data; data = 0; if(GLOBAL_CONST_TRUE) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(GLOBAL_CONST_TRUE) { { data++; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;"	"printIntLine <start> result <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
int <start> result = data <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );"	3
a6fd8246-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_preinc_16_bad() { int data; data = 0; while(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; } while(1) { { ++data; int result = data; printIntLine(result); } break; } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
data = <start> atoi(inputBuffer) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int <start> result = data <end> ;"	"printIntLine <start> result <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	0
525b644c-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__int_fscanf_preinc_54e_badSink(int data) { { ++data; int result = data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
void CWE190_Integer_Overflow__int_fscanf_preinc_54e_badSink(int <start> data <end> );"	"void CWE190_Integer_Overflow__int_fscanf_preinc_54e_badSink(int <start> data <end> );
+ <start> data <end> ;"	"+ <start> data <end> ;
<start> printIntLine(result) <end> ;"	"+ <start> data <end> ;
void CWE190_Integer_Overflow__int_fscanf_preinc_54e_badSink(int <start> data <end> );"	1
55ef4cc9-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_fgets_sub_10_bad() { int data; data = 0; if(globalTrue) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(globalTrue) { { int result = data - 1; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  - 1;
<start> printIntLine(result) <end> ;"	"int result = <start> data <end>  - 1;
<start> data = atoi(inputBuffer) <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> printIntLine(result) <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
int result = <start> data <end>  - 1;"	3
d0b64ed0-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif namespace CWE36_Absolute_Path_Traversal__char_file_ifstream_17 { void bad() { int i; char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; for(i = 0; i < 1; i++) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"inputFile.open((char * <start> data <end> );
char <start> dataBuffer[FILENAME_MAX] = """" <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
size_t dataLen = <start> strlen(data) <end> ;"	"inputFile.open((char * <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
inputFile.open((char * <start> data <end> );"	3
87ff985d-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_connect_socket_fopen_72 { void badSink(vector<char *> dataVector) { char * data = dataVector[2]; { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
void badSink(vector<char *> <start> dataVector <end> );"	"pFile = FOPEN <start> data <end> , ""wb+"");
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	"void badSink(vector<char *> <start> dataVector <end> );
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
void badSink(vector<char *> <start> dataVector <end> );"	2
4ec5d064-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) int CWE190_Integer_Overflow__int_connect_socket_postinc_61b_badSource(int data); void CWE190_Integer_Overflow__int_connect_socket_postinc_61_bad() { int data; data = 0; data = CWE190_Integer_Overflow__int_connect_socket_postinc_61b_badSource(data); { data++; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"<start> data <end> ++;
<start> printIntLine(result) <end> ;"	"data = <start> CWE190_Integer_Overflow__int_connect_socket_postinc_61b_badSource <end> (data);
<start> data <end> ++;"	"<start> data = 0 <end> ;
data = <start> CWE190_Integer_Overflow__int_connect_socket_postinc_61b_badSource <end> (data);"	"data = <start> CWE190_Integer_Overflow__int_connect_socket_postinc_61b_badSource <end> (data);
<start> data++ <end> ;"	1
a36a790f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_multiply_02_bad() { int data; data = 0; if(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(1) { if(data > 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	"<start> printIntLine(result) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"if <start> data > 0 <end> ) ;
printIntLine <start> result <end> );"	0
453db021-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_multiply_51b_badSink(int data) { if(data > 0) { int result = data * 2; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"void CWE190_Integer_Overflow__int_connect_socket_multiply_51b_badSink(int <start> data <end> );
int result = <start> data <end>  * 2;"	"int result = <start> data <end>  * 2;
<start> printIntLine(result) <end> ;"	"int result = <start> data <end>  * 2;
void CWE190_Integer_Overflow__int_connect_socket_multiply_51b_badSink(int <start> data <end> );"	"int <start> result = data * 2 <end> ;
void CWE190_Integer_Overflow__int_connect_socket_multiply_51b_badSink(int <start> data <end> );"	0
951c5e98-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FULL_COMMAND ""dir "" #else #define FULL_COMMAND ""ls "" #endif #ifdef _WIN32 #define POPEN _popen #define PCLOSE _pclose #else #define POPEN popen #define PCLOSE pclose #endif typedef union { char * unionFirst; char * unionSecond; } CWE78_OS_Command_Injection__char_console_popen_34_unionType; void CWE78_OS_Command_Injection__char_console_popen_34_bad() { char * data; CWE78_OS_Command_Injection__char_console_popen_34_unionType myUnion; char data_buf[100] = FULL_COMMAND; data = data_buf; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { FILE *pipe; pipe = POPEN(data, ""w""); if (pipe != NULL) { PCLOSE(pipe); } } } }"	where is the vulnerable dataflow from data to POPEN ?	"char <start> * data = myUnion.unionSecond <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
size_t dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
pipe = POPEN <start> data <end> , ""w"");"	"size_t dataLen = <start> strlen(data) <end> ;
pipe = POPEN <start> data <end> , ""w"");"	2
86cea166-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE369_Divide_by_Zero__int_listen_socket_modulo_10_bad() { int data; data = -1; if(globalTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalTrue) { printIntLine(100 % data); } }"	where is the vulnerable dataflow from data to printIntLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
if  <start> recvResult == SOCKET_ERROR <end>  || recvResult == 0);"	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> 100 % data <end> );"	"data = <start> atoi(inputBuffer) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> 100 % data <end> );"	3
c99197e8-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_connect_socket_fopen_21 { static int badStatic = 0; static char * badSource(char * data) { if(badStatic) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } return data; } void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; badStatic = 1; data = badSource(data); { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } ; }"	where is the vulnerable dataflow from data to FOPEN ?	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
static char * <start> badSource <end> (char * data);"	"static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
recvResult = recv(connectSocket, (char *)(data + dataLen), <start> sizeof(char) * (FILENAME_MAX - dataLen - 1) <end> , 0);"	"pFile = FOPEN <start> data <end> , ""wb+"");
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	0
cac216a9-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" namespace CWE36_Absolute_Path_Traversal__char_connect_socket_ifstream_53 { void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badSink_b(data); }"	where is the vulnerable dataflow from data to badSink_b ?	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
badSink_b <start> data <end> );"	"badSink_b <start> data <end> );
replace = <start> strchr(data, '\n') <end> ;"	"<start> data = dataBuffer <end> ;
badSink_b <start> data <end> );"	"badSink_b <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	0
820a46cf-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_file_fopen_72 { void badSink(vector<char *> dataVector) { char * data = dataVector[2]; { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"void badSink(vector<char *> <start> dataVector <end> );
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	"pFile = FOPEN <start> data <end> , ""wb+"");
void badSink(vector<char *> <start> dataVector <end> );"	"void badSink(vector<char *> <start> dataVector <end> );
pFile = FOPEN <start> data <end> , ""wb+"");"	3
656cd3d7-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__int_rand_add_74 { void badSink(map<int, int> dataMap) { int data = dataMap[2]; { int result = data + 1; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"int <start> data = dataMap[2] <end> ;
void badSink(map<int, int> <start> dataMap <end> );"	"void badSink(map<int, int> <start> dataMap <end> );
<start> printIntLine(result) <end> ;"	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  + 1;"	"void badSink(map<int, int> <start> dataMap <end> );
int result = <start> data <end>  + 1;"	3
7d44fc9d-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_53d_badSink(int data) { { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"printLine <start> dest <end> );
void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_53d_badSink(int <start> data <end> );"	"void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_53d_badSink(int <start> data <end> );
<start> printLine(dest) <end> ;"	"void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_53d_badSink(int <start> data <end> );
printLine <start> dest <end> );"	"<start> strncpy(dest, source, data) <end> ;
void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_53d_badSink(int <start> data <end> );"	2
54c58211-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_connect_socket_sub_09_bad() { int data; data = 0; if(GLOBAL_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(GLOBAL_CONST_TRUE) { { int result = data - 1; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  - 1;"	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
int result = <start> data <end>  - 1;"	"<start> data = atoi(inputBuffer) <end> ;
int result = <start> data <end>  - 1;"	"<start> data = 0 <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	0
79b2755d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_43 { static void badSource(int &data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } void bad() { int data; data = -1; badSource(data); { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSource <start> data <end> );
printLine <start> dest <end> );"	"printLine <start> dest <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
if  <start> data < 100 <end> );"	"badSource <start> data <end> );
printLine <start> dest <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"printLine <start> dest <end> );
badSource <start> data <end> );
<start> memcpy(dest, source, data) <end> ;"	0
728a5037-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" static const int STATIC_CONST_FIVE = 5; void CWE194_Unexpected_Sign_Extension__connect_socket_malloc_06_bad() { short data; data = 0; if(STATIC_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }"	where is the vulnerable dataflow from data to malloc ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
char * dataBuffer = (char *)malloc <start> data <end> );"	"char * dataBuffer = (char *)malloc <start> data <end> );
memset(dataBuffer, 'A', <start> data-1 <end> );"	"<start> memset(dataBuffer, 'A', data-1) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
char * dataBuffer = (char * <start> malloc(data) <end> ;"	0
b8e2bdc5-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE680_Integer_Overflow_to_Buffer_Overflow__new_connect_socket_82 { void bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE680_Integer_Overflow_to_Buffer_Overflow__new_connect_socket_82_base* baseObject = new CWE680_Integer_Overflow_to_Buffer_Overflow__new_connect_socket_82_bad; baseObject->action(data); delete baseObject; }"	where is the vulnerable dataflow from data to action ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
baseObject->action <start> data <end> );"	"baseObject->action <start> data <end> );
recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);"	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
baseObject->action <start> data <end> );"	"baseObject->action <start> data <end> );
data = <start> atoi(inputBuffer) <end> ;"	0
80d9870d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_console_fopen_41 { void badSink(char * data) { { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } } void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } badSink(data); }"	where is the vulnerable dataflow from data to FOPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
badSink <start> data <end> );
pFile = FOPEN <start> data <end> , ""wb+"");
char <start> dataBuffer[FILENAME_MAX] = BASEPATH <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
badSink <start> data <end> );
void badSink(char * <start> data <end> );
pFile = FOPEN <start> data <end> , ""wb+"");"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
void badSink(char * <start> data <end> );
badSink <start> data <end> );"	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
void badSink(char * <start> data <end> );
pFile = FOPEN <start> data <end> , ""wb+"");"	1
b68484d8-6c15-11ed-81d4-94e6f77dd552	"namespace CWE36_Absolute_Path_Traversal__char_console_ifstream_81 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } const CWE36_Absolute_Path_Traversal__char_console_ifstream_81_base& baseObject = CWE36_Absolute_Path_Traversal__char_console_ifstream_81_bad(); baseObject.action(data); }"	where is the vulnerable dataflow from data to action ?	"baseObject.action <start> data <end> );
dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
baseObject.action <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
dataLen = <start> strlen(data) <end> ;"	"baseObject.action <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	1
bc721fa3-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif namespace CWE78_OS_Command_Injection__char_file_execlp_81 { void bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } const CWE78_OS_Command_Injection__char_file_execlp_81_base& baseObject = CWE78_OS_Command_Injection__char_file_execlp_81_bad(); baseObject.action(data); }"	where is the vulnerable dataflow from data to action ?	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
baseObject.action <start> data <end> );"	"<start> data = dataBuffer <end> ;
baseObject.action <start> data <end> );"	"<start> data = dataBuffer <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	"baseObject.action <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	0
6b862427-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_connect_socket_14_bad() { int data; data = -1; if(globalFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalFive==5) { { int i; int * buffer = (int *)malloc(10 * sizeof(int)); if (buffer == NULL) {exit(-1);} for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } free(buffer); } } }"	where is the vulnerable dataflow from buffer to free ?	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
free <start> buffer <end> );"	"<start> printIntLine(buffer[i]) <end> ;
free <start> buffer <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> free(buffer) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
free <start> buffer <end> );"	3
89321809-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; namespace CWE36_Absolute_Path_Traversal__char_file_fopen_04 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(STATIC_CONST_TRUE) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
size_t dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	"size_t dataLen = <start> strlen(data) <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	1
