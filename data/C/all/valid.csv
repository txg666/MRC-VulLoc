id	context	question	answer0	answer1	answer2	answer3	label
a95fd81d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE191_Integer_Underflow__int_connect_socket_sub_82 { void bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE191_Integer_Underflow__int_connect_socket_sub_82_base* baseObject = new CWE191_Integer_Underflow__int_connect_socket_sub_82_bad; baseObject->action(data); delete baseObject; }"	where is the vulnerable dataflow from data to action ?	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
baseObject->action <start> data <end> );"	"recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);
baseObject->action <start> data <end> );"	"baseObject->action <start> data <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
baseObject->action <start> data <end> );"	3
ba102b96-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define EXECLP _execlp #else #define EXECLP execlp #endif static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; void CWE78_OS_Command_Injection__char_connect_socket_execlp_04_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(STATIC_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECLP ?	"size_t dataLen = <start> strlen(data) <end> ;
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"<start> EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL) <end> ;
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	1
b41b8798-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 20 #define IP_ADDRESS ""127.0.0.1"" void CWE369_Divide_by_Zero__float_connect_socket_09_bad() { float data; data = 0.0F; if(GLOBAL_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = (float)atof(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(GLOBAL_CONST_TRUE) { { int result = (int)(100.0 / data); printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data = (float)atof(inputBuffer) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"int <start> result = (int)(100.0 / data) <end> ;
printIntLine <start> result <end> );"	2
4a021110-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) int CWE190_Integer_Overflow__int_listen_socket_multiply_61b_badSource(int data); void CWE190_Integer_Overflow__int_listen_socket_multiply_61_bad() { int data; data = 0; data = CWE190_Integer_Overflow__int_listen_socket_multiply_61b_badSource(data); if(data > 0) { int result = data * 2; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"int <start> result = data * 2 <end> ;
data = <start> CWE190_Integer_Overflow__int_listen_socket_multiply_61b_badSource <end> (data);"	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  * 2;"	"data = <start> CWE190_Integer_Overflow__int_listen_socket_multiply_61b_badSource <end> (data);
int result = <start> data <end>  * 2;"	"if <start> data > 0 <end> ) ;
int result = <start> data <end>  * 2;"	2
9059f3b0-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_64b_badSink(void * dataVoidPtr) { int * dataPtr = (int *)dataVoidPtr; int data = (*dataPtr); { size_t i; int *intPointer; intPointer = (int*)malloc(data * sizeof(int)); if (intPointer == NULL) {exit(-1);} for (i = 0; i < (size_t)data; i++) { intPointer[i] = 0; } printIntLine(intPointer[0]); free(intPointer); } }"	where is the vulnerable dataflow from data to malloc ?	"void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_64b_badSink(void * <start> dataVoidPtr <end> );
if  <start> intPointer == NULL <end> ) {exit(-1);};"	"void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_64b_badSink(void * <start> dataVoidPtr <end> );
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	"if  <start> intPointer == NULL <end> ) {exit(-1);};
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	"intPointer = (int*)malloc <start> data * sizeof(int) <end> );
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_64b_badSink(void * <start> dataVoidPtr <end> );"	1
a95fd839-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_fgets_multiply_51b_badSink(int data) { if(data < 0) { int result = data * 2; printIntLine(result); } }	where is the vulnerable dataflow from result to printIntLine ?	"<start> printIntLine(result) <end> ;
void CWE191_Integer_Underflow__int_fgets_multiply_51b_badSink(int <start> data <end> );"	"void CWE191_Integer_Underflow__int_fgets_multiply_51b_badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
if <start> data < 0 <end> ) ;"	"printIntLine <start> result <end> );
void CWE191_Integer_Underflow__int_fgets_multiply_51b_badSink(int <start> data <end> );"	1
715a3bca-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif static void badVaSink(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_file_vprintf_52c_badSink(char * data) { badVaSink(data, data); }"	where is the vulnerable dataflow from data to vprintf ?	"<start> vprintf(data, args) <end> ;
badVaSink <start> data <end> , data);
vprintf <start> data <end> , args);
void CWE134_Uncontrolled_Format_String__char_file_vprintf_52c_badSink(char * <start> data <end> );"	"<start> va_start(args, data) <end> ;
void CWE134_Uncontrolled_Format_String__char_file_vprintf_52c_badSink(char * <start> data <end> );
static void badVaSink(char * <start> data <end> , ...);
badVaSink <start> data <end> , data);"	"void CWE134_Uncontrolled_Format_String__char_file_vprintf_52c_badSink(char * <start> data <end> );
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
vprintf <start> data <end> , args);"	"vprintf <start> data <end> , args);
void CWE134_Uncontrolled_Format_String__char_file_vprintf_52c_badSink(char * <start> data <end> );"	2
4b34afde-6c15-11ed-81d4-94e6f77dd552	"typedef union { short unionFirst; short unionSecond; } CWE190_Integer_Overflow__short_fscanf_multiply_34_unionType; void CWE190_Integer_Overflow__short_fscanf_multiply_34_bad() { short data; CWE190_Integer_Overflow__short_fscanf_multiply_34_unionType myUnion; data = 0; fscanf (stdin, ""%hd"", &data); myUnion.unionFirst = data; { short data = myUnion.unionSecond; if(data > 0) { short result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"short result = <start> data <end>  * 2;
if <start> data > 0 <end> ) ;"	"short result = <start> data <end>  * 2;
<start> printIntLine(result) <end> ;"	"short result = <start> data <end>  * 2;
fscanf (stdin, ""%hd"", <start> &data <end> );"	"fscanf (stdin, ""%hd"", <start> &data <end> );
short result = <start> data <end>  * 2;"	3
648a9bf9-6c15-11ed-81d4-94e6f77dd552	static int64_t CWE190_Integer_Overflow__int64_t_rand_square_45_badData; static int64_t CWE190_Integer_Overflow__int64_t_rand_square_45_goodG2BData; static int64_t CWE190_Integer_Overflow__int64_t_rand_square_45_goodB2GData; static void badSink() { int64_t data = CWE190_Integer_Overflow__int64_t_rand_square_45_badData; { int64_t result = data * data; printLongLongLine(result); } } void CWE190_Integer_Overflow__int64_t_rand_square_45_bad() { int64_t data; data = 0LL; data = (int64_t)RAND64(); CWE190_Integer_Overflow__int64_t_rand_square_45_badData = data; badSink(); }	where is the vulnerable dataflow from data ?	"<start> CWE190_Integer_Overflow__int64_t_rand_square_45_badData = data <end> ;
data = (int64_t <start> RAND64() <end> ;"	"data = (int64_t <start> RAND64() <end> ;
<start> CWE190_Integer_Overflow__int64_t_rand_square_45_badData = data <end> ;
static int64_t <start> CWE190_Integer_Overflow__int64_t_rand_square_45_badData <end> ;
int64_t data = <start> CWE190_Integer_Overflow__int64_t_rand_square_45_badData <end> ;
int64_t result = <start> data <end>  * data;"	"<start> CWE190_Integer_Overflow__int64_t_rand_square_45_badData = data <end> ;
data = (int64_t <start> RAND64() <end> ;
static int64_t <start> CWE190_Integer_Overflow__int64_t_rand_square_45_badData <end> ;"	"data = (int64_t <start> RAND64() <end> ;
<start> CWE190_Integer_Overflow__int64_t_rand_square_45_badData = data <end> ;
static int64_t <start> CWE190_Integer_Overflow__int64_t_rand_square_45_badData <end> ;
int64_t data = <start> CWE190_Integer_Overflow__int64_t_rand_square_45_badData <end> ;"	1
584fa892-6c15-11ed-81d4-94e6f77dd552	"void CWE191_Integer_Underflow__short_fscanf_multiply_01_bad() { short data; data = 0; fscanf (stdin, ""%hd"", &data); if(data < 0) { short result = data * 2; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"short result = <start> data <end>  * 2;
if <start> data < 0 <end> ) ;"	"short result = <start> data * 2 <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );"	"short <start> result = data * 2 <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );"	"fscanf (stdin, ""%hd"", <start> &data <end> );
short result = <start> data <end>  * 2;"	3
cd22817a-6c15-11ed-81d4-94e6f77dd552	#ifndef _WIN32 #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_console_open_74 { void badSink(map<int, char *> dataMap) { char * data = dataMap[2]; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }	where is the vulnerable dataflow from data to OPEN ?	"void badSink(map<int, char *> <start> dataMap <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"void badSink(map<int, char *> <start> dataMap <end> );
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
void badSink(map<int, char *> <start> dataMap <end> );"	0
4ec5d0a0-6c15-11ed-81d4-94e6f77dd552	"void CWE190_Integer_Overflow__int_fscanf_postinc_31_bad() { int data; data = 0; fscanf(stdin, ""%d"", &data); { int dataCopy = data; int data = dataCopy; { data++; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"fscanf(stdin, ""%d"", <start> &data <end> );
<start> data <end> ++;"	"<start> data <end> ++;
<start> printIntLine(result) <end> ;"	"<start> data++ <end> ;
fscanf(stdin, ""%d"", <start> &data <end> );"	"<start> data <end> ++;
fscanf(stdin, ""%d"", <start> &data <end> );"	0
80d98701-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_console_fopen_11 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(globalReturnsTrue()) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"pFile = FOPEN <start> data <end> , ""wb+"");
dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
pFile = FOPEN <start> data <end> , ""wb+"");"	3
584fa89f-6c15-11ed-81d4-94e6f77dd552	"void CWE191_Integer_Underflow__short_fscanf_multiply_15_bad() { short data; data = 0; switch(6) { case 6: fscanf (stdin, ""%hd"", &data); break; default: printLine(""Benign, fixed string""); break; } switch(7) { case 7: if(data < 0) { short result = data * 2; printIntLine(result); } break; default: printLine(""Benign, fixed string""); break; } }"	where is the vulnerable dataflow from data ?	"fscanf (stdin, ""%hd"", <start> &data <end> );
<start> printIntLine(result) <end> ;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
short result = <start> data <end>  * 2;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
short result = <start> data * 2 <end> ;"	"short <start> result = data * 2 <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );"	1
c1366250-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_console_fopen_51 { void badSink(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } badSink(data); }"	where is the vulnerable dataflow from data to badSink ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
badSink <start> data <end> );"	"badSink <start> data <end> );
<start> data = dataBuffer <end> ;"	"<start> badSink(data) <end> ;
badSink <start> data <end> );"	"badSink <start> data <end> );
char <start> dataBuffer[FILENAME_MAX] = BASEPATH <end> ;"	0
b1b80856-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" void CWE197_Numeric_Truncation_Error__short_connect_socket_14_bad() { short data; data = -1; if(globalFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = (short)atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { char charData = (char)data; printHexCharLine(charData); } }"	where is the vulnerable dataflow from charData to printHexCharLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printHexCharLine <start> charData <end> );"	"printHexCharLine <start> charData <end> );
data = <start> (short)atoi(inputBuffer) <end> ;"	"printHexCharLine <start> charData <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"char <start> charData = (char)data <end> ;
printHexCharLine <start> charData <end> );"	0
5133a731-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_preinc_01_bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { ++data; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
+ <start> data <end> ;"	"+ <start> data <end> ;
recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int <start> result = data <end> ;"	"data = <start> atoi(inputBuffer) <end> ;
+ <start> data <end> ;"	0
9fe7ad20-6c15-11ed-81d4-94e6f77dd552	"namespace CWE134_Uncontrolled_Format_String__char_console_fprintf_81 { void bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } const CWE134_Uncontrolled_Format_String__char_console_fprintf_81_base& baseObject = CWE134_Uncontrolled_Format_String__char_console_fprintf_81_bad(); baseObject.action(data); }"	where is the vulnerable dataflow from data to action ?	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
baseObject.action <start> data <end> );"	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	"size_t dataLen = <start> strlen(data) <end> ;
baseObject.action <start> data <end> );"	"baseObject.action <start> data <end> );
dataLen = <start> strlen(data) <end> ;"	0
728a501c-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 typedef union { char * unionFirst; char * unionSecond; } CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_34_unionType; static void badVaSink(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_34_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { char * dataCopy = data; char * data = dataCopy; badVaSink(data, data); } }"	where is the vulnerable dataflow from data to vprintf ?	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
vprintf <start> data <end> , args);"	"vprintf <start> data <end> , args);
static void badVaSink(char * <start> data <end> , ...);
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
badVaSink <start> data <end> , data);"	"size_t <start> dataLen = strlen(data) <end> ;
vprintf <start> data <end> , args);
static void badVaSink(char * <start> data <end> , ...);
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"static void badVaSink(char * <start> data <end> , ...);
<start> recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0) <end> ;
badVaSink <start> data <end> , data);
vprintf <start> data <end> , args);"	0
8a6310b7-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif static int staticFive = 5; namespace CWE36_Absolute_Path_Traversal__char_file_open_07 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(staticFive==5) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"size_t dataLen = <start> strlen(data) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
char <start> dataBuffer[FILENAME_MAX] = """" <end> ;"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
<start> data = dataBuffer <end> ;"	0
5133a76e-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_preinc_52c_badSink(int data) { { ++data; int result = data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"+ <start> data <end> ;
int <start> result = data <end> ;"	"<start> printIntLine(result) <end> ;
void CWE190_Integer_Overflow__int_fgets_preinc_52c_badSink(int <start> data <end> );"	"+ <start> data <end> ;
void CWE190_Integer_Overflow__int_fgets_preinc_52c_badSink(int <start> data <end> );"	"void CWE190_Integer_Overflow__int_fgets_preinc_52c_badSink(int <start> data <end> );
+ <start> data <end> ;"	3
8df421e9-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define PATH_SZ 100 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define PATH_SZ PATH_MAX #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; void CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__accept_bind_listen_04_bad() { if(STATIC_CONST_TRUE) { { char data[100] = """"; #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[recvResult] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif printLine(data); } } }"	where is the vulnerable dataflow from data to printLine ?	"if  <start> recvResult == SOCKET_ERROR <end>  || recvResult == 0);
recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);"	"recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);
printLine <start> data <end> );"	"replace = <start> strchr(data, '\r') <end> ;
printLine <start> data <end> );"	"printLine <start> data <end> );
recvResult = recv(acceptSocket, <start> (char *)data <end> +dataLen, (int)(100-dataLen-1), 0);"	1
60db83c8-6c15-11ed-81d4-94e6f77dd552	static void badSink(char data) { if(data > 0) { char result = data * 2; printHexCharLine(result); } } void CWE190_Integer_Overflow__char_rand_multiply_41_bad() { char data; data = ' '; data = (char)RAND32(); badSink(data); }	where is the vulnerable dataflow from data ?	"<start> printHexCharLine(result) <end> ;
data = (char <start> RAND32() <end> ;
static void badSink(char <start> data <end> );
char result = <start> data <end>  * 2;"	"data = (char <start> RAND32() <end> ;
badSink <start> data <end> );
<start> data = (char)RAND32() <end> ;
char result = <start> data <end>  * 2;"	"<start> badSink(data) <end> ;
badSink <start> data <end> );
data = (char <start> RAND32() <end> ;
static void badSink(char <start> data <end> );"	"data = (char <start> RAND32() <end> ;
badSink <start> data <end> );
static void badSink(char <start> data <end> );
char result = <start> data <end>  * 2;"	3
6ef7684c-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; static void badVaSinkB(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_console_vprintf_04_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; if(STATIC_CONST_TRUE) { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } if(STATIC_CONST_TRUE) { badVaSinkB(data, data); } }"	where is the vulnerable dataflow from data to vprintf ?	"badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);
<start> va_start(args, data) <end> ;
vprintf <start> data <end> , args);"	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
static void badVaSinkB(char * <start> data <end> , ...);
vprintf <start> data <end> , args);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);
vprintf <start> data <end> , args);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);"	2
d1e9da58-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 static int staticFive = 5; namespace CWE36_Absolute_Path_Traversal__char_listen_socket_ifstream_07 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(staticFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
<start> data = dataBuffer <end> ;"	"inputFile.open((char * <start> data <end> );
if  <start> acceptSocket == SOCKET_ERROR <end> );"	"replace = <start> strchr(data, '\n') <end> ;
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
inputFile.open((char * <start> data <end> );"	3
ae26ae55-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 8 namespace CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_81 { void bad() { short data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } const CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_81_base& baseObject = CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_81_bad(); baseObject.action(data); }"	where is the vulnerable dataflow from data to action ?	"tempInt = <start> atoi(inputBuffer) <end> ;
baseObject.action <start> data <end> );"	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
baseObject.action <start> data <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
baseObject.action <start> data <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
if  <start> acceptSocket == SOCKET_ERROR <end> );"	2
9187cc11-6c15-11ed-81d4-94e6f77dd552	"#define SEARCH_CHAR 'S' namespace CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_console_72 { void badSink(vector<char *> dataVector) { char * data = dataVector[2]; for (; *data != '\0'; data++) { if (*data == SEARCH_CHAR) { printLine(""We have a match!""); break; } } free(data); }"	where is the vulnerable dataflow from data to free ?	"<start> free(data) <end> ;
free <start> data <end> );"	"free <start> data <end> );
void badSink(vector<char *> <start> dataVector <end> );"	"void badSink(vector<char *> <start> dataVector <end> );
free <start> data <end> );"	"void badSink(vector<char *> <start> dataVector <end> );
for (; *data != '\0'; <start> data++ <end> );"	2
4b34afe1-6c15-11ed-81d4-94e6f77dd552	"namespace CWE190_Integer_Overflow__short_fscanf_multiply_43 { static void badSource(short &data) { fscanf (stdin, ""%hd"", &data); } void bad() { short data; data = 0; badSource(data); if(data > 0) { short result = data * 2; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"<start> data = 0 <end> ;
badSource <start> data <end> );
fscanf (stdin, ""%hd"", <start> &data <end> );"	"fscanf (stdin, ""%hd"", <start> &data <end> );
<start> printIntLine(result) <end> ;
badSource <start> data <end> );"	"badSource <start> data <end> );
fscanf (stdin, ""%hd"", <start> &data <end> );
short result = <start> data <end>  * 2;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
badSource <start> data <end> );
short result = <start> data <end>  * 2;"	3
8df421ee-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define PATH_SZ 100 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define PATH_SZ PATH_MAX #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 void CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__accept_bind_listen_09_bad() { if(GLOBAL_CONST_TRUE) { { char data[100] = """"; #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[recvResult] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif printLine(data); } } }"	where is the vulnerable dataflow from data to printLine ?	"replace = <start> strchr(data, '\n') <end> ;
printLine <start> data <end> );"	"size_t <start> dataLen = strlen(data) <end> ;
recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);"	"recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);
printLine <start> data <end> );"	"printLine <start> data <end> );
recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);"	2
61da66fb-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__char_rand_square_72 { void badSink(vector<char> dataVector) { char data = dataVector[2]; { char result = data * data; printHexCharLine(result); } }	where is the vulnerable dataflow from data ?	"void badSink(vector<char> <start> dataVector <end> );
char <start> result = data * data <end> ;"	"void badSink(vector<char> <start> dataVector <end> );
char result = <start> data <end>  * data;"	"void badSink(vector<char> <start> dataVector <end> );
char <start> data = dataVector[2] <end> ;"	"<start> printHexCharLine(result) <end> ;
char result = <start> data <end>  * data;"	1
cac216e3-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_connect_socket_open_43 { void badSource(char * &data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; badSource(data); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
badSource <start> data <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"badSource <start> data <end> );
<start> data = dataBuffer <end> ;
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	0
86cea174-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE369_Divide_by_Zero__int_listen_socket_modulo_43 { static void badSource(int &data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } void bad() { int data; data = -1; badSource(data); printIntLine(100 % data); }"	where is the vulnerable dataflow from data to printIntLine ?	"if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );
badSource <start> data <end> );
printIntLine <start> 100 % data <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSource <start> data <end> );
printIntLine <start> 100 % data <end> );"	"printIntLine <start> 100 % data <end> );
badSource <start> data <end> );
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"badSource <start> data <end> );
if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	1
4ec5d0a6-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__int_fscanf_postinc_51b_badSink(int data) { { data++; int result = data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"<start> data++ <end> ;
void CWE190_Integer_Overflow__int_fscanf_postinc_51b_badSink(int <start> data <end> );"	"<start> printIntLine(result) <end> ;
<start> data <end> ++;"	"<start> data <end> ++;
void CWE190_Integer_Overflow__int_fscanf_postinc_51b_badSink(int <start> data <end> );"	"void CWE190_Integer_Overflow__int_fscanf_postinc_51b_badSink(int <start> data <end> );
<start> data <end> ++;"	3
7e74f31c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_14_bad() { int data; data = -1; if(globalFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"if  <start> data < 100 <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"printLine <start> dest <end> );
<start> data = -1 <end> ;"	"printLine <start> dest <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	3
584fa86d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticTrue = 1; static int staticFalse = 0; void CWE191_Integer_Underflow__int_listen_socket_sub_05_bad() { int data; data = 0; if(staticTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticTrue) { { int result = data - 1; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> data = atoi(inputBuffer) <end> ;
int result = <start> data <end>  - 1;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int <start> result = data - 1 <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  - 1;"	"int result = <start> data <end>  - 1;
<start> printIntLine(result) <end> ;"	2
c8600b0f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_listen_socket_open_44 { static void badSink(char * data) { { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } } void bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } funcPtr(data); }"	where is the vulnerable dataflow from data to funcPtr ?	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
funcPtr <start> data <end> );"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
funcPtr <start> data <end> );"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"funcPtr <start> data <end> );
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	1
4ec5d0b7-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticFive = 5; void CWE190_Integer_Overflow__int_listen_socket_postinc_07_bad() { int data; data = 0; if(staticFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticFive==5) { { data++; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> data <end> ++;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data <end> ++;"	"<start> data <end> ++;
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"data = <start> atoi(inputBuffer) <end> ;
<start> data <end> ++;"	1
d0b64edc-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif namespace CWE36_Absolute_Path_Traversal__char_file_ifstream_53 { void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } badSink_b(data); }"	where is the vulnerable dataflow from data to badSink_b ?	"badSink_b <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"size_t dataLen = <start> strlen(data) <end> ;
badSink_b <start> data <end> );"	"<start> data = dataBuffer <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
badSink_b <start> data <end> );"	3
715a3bb4-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif static int staticFive = 5; static void badVaSinkB(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_file_vprintf_07_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; if(staticFive==5) { { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } if(staticFive==5) { badVaSinkB(data, data); } }"	where is the vulnerable dataflow from data to vprintf ?	"<start> vprintf(data, args) <end> ;
badVaSinkB <start> data <end> , data);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
static void badVaSinkB(char * <start> data <end> , ...);"	"vprintf <start> data <end> , args);
badVaSinkB <start> data <end> , data);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	"size_t dataLen = <start> strlen(data) <end> ;
vprintf <start> data <end> , args);
badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);
vprintf <start> data <end> , args);"	3
98b01537-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) typedef union { int unionFirst; int unionSecond; } CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_34_unionType; void CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_34_bad() { int data; CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_34_unionType myUnion; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } myUnion.unionFirst = data; { int data = myUnion.unionSecond; { int i; int buffer[10] = { 0 }; if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } } } }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[i] <end> );"	"printIntLine <start> buffer[i] <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"if  <start> recvResult == SOCKET_ERROR <end>  || recvResult == 0);
printIntLine <start> buffer[i] <end> );"	"if  <start> recvResult == SOCKET_ERROR <end>  || recvResult == 0);
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	0
a5ce1c7f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_postinc_15_bad() { int data; data = 0; switch(6) { case 6: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; default: printLine(""Benign, fixed string""); break; } switch(7) { case 7: { data++; int result = data; printIntLine(result); } break; default: printLine(""Benign, fixed string""); break; } }"	where is the vulnerable dataflow from result to printIntLine ?	"<start> data++ <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	2
4b34afe2-6c15-11ed-81d4-94e6f77dd552	"static void badSink(short data) { if(data > 0) { short result = data * 2; printIntLine(result); } } void CWE190_Integer_Overflow__short_fscanf_multiply_44_bad() { short data; void (*funcPtr) (short) = badSink; data = 0; fscanf (stdin, ""%hd"", &data); funcPtr(data); }"	where is the vulnerable dataflow from data ?	"funcPtr <start> data <end> );
static void badSink(short <start> data <end> );
<start> printIntLine(result) <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );"	"fscanf (stdin, ""%hd"", <start> &data <end> );
funcPtr <start> data <end> );
static void badSink(short <start> data <end> );
short result = <start> data <end>  * 2;"	"short result = <start> data <end>  * 2;
fscanf (stdin, ""%hd"", <start> &data <end> );"	"short result = <start> data <end>  * 2;
<start> funcPtr(data) <end> ;
static void badSink(short <start> data <end> );
funcPtr <start> data <end> );"	1
820a46c0-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_file_fopen_22 { int badGlobal = 0; char * badSource(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; badGlobal = 1; data = badSource(data); { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } ; }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = FOPEN <start> data <end> , ""wb+"");
data = <start> badSource(data) <end> ;"	"data = <start> badSource <end> (data);
pFile = FOPEN <start> data <end> , ""wb+"");"	"data = <start> badSource <end> (data);
<start> data = dataBuffer <end> ;"	"pFile = FOPEN <start> data <end> , ""wb+"");
<start> data = badSource(data) <end> ;"	1
7c1275b1-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticFive = 5; void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_07_bad() { int data; data = -1; if(staticFive==5) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"printLine <start> dest <end> );
if  <start> data < 100 <end> );"	"char <start> dest[100] = """" <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> printLine(dest) <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printLine <start> dest <end> );"	3
60db83d3-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__char_rand_multiply_63b_badSink(char * dataPtr) { char data = *dataPtr; if(data > 0) { char result = data * 2; printHexCharLine(result); } }	where is the vulnerable dataflow from data ?	"void CWE190_Integer_Overflow__char_rand_multiply_63b_badSink(char * <start> dataPtr <end> );
<start> printHexCharLine(result) <end> ;"	"char result = <start> data * 2 <end> ;
void CWE190_Integer_Overflow__char_rand_multiply_63b_badSink(char * <start> dataPtr <end> );"	"char result = <start> data <end>  * 2;
void CWE190_Integer_Overflow__char_rand_multiply_63b_badSink(char * <start> dataPtr <end> );"	"void CWE190_Integer_Overflow__char_rand_multiply_63b_badSink(char * <start> dataPtr <end> );
char result = <start> data <end>  * 2;"	3
7c12758c-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_14_bad() { int data; data = -1; if(globalFive==5) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> memcpy(dest, source, data) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"<start> data = atoi(inputBuffer) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"printLine <start> dest <end> );
if  <start> data < 100 <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printLine <start> dest <end> );"	3
466e7ee7-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_multiply_51b_badSink(int data) { if(data > 0) { int result = data * 2; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"void CWE190_Integer_Overflow__int_fgets_multiply_51b_badSink(int <start> data <end> );
<start> printIntLine(result) <end> ;"	"void CWE190_Integer_Overflow__int_fgets_multiply_51b_badSink(int <start> data <end> );
int result = <start> data <end>  * 2;"	"void CWE190_Integer_Overflow__int_fgets_multiply_51b_badSink(int <start> data <end> );
int <start> result = data * 2 <end> ;"	"int result = <start> data <end>  * 2;
void CWE190_Integer_Overflow__int_fgets_multiply_51b_badSink(int <start> data <end> );"	1
79b27525-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_13_bad() { int data; data = -1; if(GLOBAL_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }"	where is the vulnerable dataflow from data to malloc ?	"if  <start> data < 100 <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"char * dataBuffer = (char *)malloc <start> data <end> );
memset(dataBuffer, 'A', <start> data-1 <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
char * dataBuffer = (char *)malloc <start> data <end> );"	"<start> free(dataBuffer) <end> ;
char * dataBuffer = (char *)malloc <start> data <end> );"	2
93ece2d0-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING ""hello"" void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_02_bad() { size_t data; data = 0; if(1) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = strtoul(inputBuffer, NULL, 0); } else { printLine(""fgets() failed.""); } } } if(1) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); } else { printLine(""Input is less than the length of the source string""); } } } }"	where is the vulnerable dataflow from data to malloc ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
myString = (char *)malloc <start> data*sizeof(char) <end> );"	"if  <start> data > strlen(HELLO_STRING) <end> );
myString = (char *)malloc <start> data*sizeof(char) <end> );"	"<start> data = 0 <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"myString = (char *)malloc <start> data*sizeof(char) <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	0
b7b09a6d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define NEW_PATH ""%SystemRoot%\\system32"" #define PUTENV _putenv #else #define NEW_PATH ""/bin"" #define PUTENV putenv #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif void CWE427_Uncontrolled_Search_Path_Element__char_file_64b_badSink(void * dataVoidPtr) { char * * dataPtr = (char * *)dataVoidPtr; char * data = (*dataPtr); PUTENV(data); }"	where is the vulnerable dataflow from data to PUTENV ?	"void CWE427_Uncontrolled_Search_Path_Element__char_file_64b_badSink(void * <start> dataVoidPtr <end> );
<start> PUTENV(data) <end> ;"	"PUTENV <start> data <end> );
void CWE427_Uncontrolled_Search_Path_Element__char_file_64b_badSink(void * <start> dataVoidPtr <end> );"	"void CWE427_Uncontrolled_Search_Path_Element__char_file_64b_badSink(void * <start> dataVoidPtr <end> );
char <start> * data = (*dataPtr) <end> ;"	"void CWE427_Uncontrolled_Search_Path_Element__char_file_64b_badSink(void * <start> dataVoidPtr <end> );
PUTENV <start> data <end> );"	3
61da6736-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__short_rand_multiply_14_bad() { short data; data = 0; if(globalFive==5) { data = (short)RAND32(); } if(globalFive==5) { if(data > 0) { short result = data * 2; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"short result = <start> data <end>  * 2;
data = (short <start> RAND32() <end> ;"	"<start> printIntLine(result) <end> ;
short result = <start> data <end>  * 2;"	"data = (short <start> RAND32() <end> ;
short result = <start> data <end>  * 2;"	"<start> printIntLine(result) <end> ;
data = (short <start> RAND32() <end> ;"	2
a36a78ef-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_add_14_bad() { int data; data = 0; if(globalFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalFive==5) { { int result = data + 1; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int <start> result = data + 1 <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"<start> printIntLine(result) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	2
4db33f6d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_FIVE = 5; void CWE190_Integer_Overflow__int_connect_socket_postinc_06_bad() { int data; data = 0; if(STATIC_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(STATIC_CONST_FIVE==5) { { data++; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> data++ <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"<start> printIntLine(result) <end> ;
<start> data <end> ++;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data <end> ++;"	"<start> printIntLine(result) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	2
8df4221f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define PATH_SZ 100 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define PATH_SZ PATH_MAX #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; void CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__listen_accept_bind_04_bad() { if(STATIC_CONST_TRUE) { { char data[100] = """"; #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[recvResult] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif printLine(data); } } }"	where is the vulnerable dataflow from data to printLine ?	"recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);
printLine <start> data <end> );"	"<start> printLine(data) <end> ;
printLine <start> data <end> );"	"recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);
replace = <start> strchr(data, '\n') <end> ;"	"printLine <start> data <end> );
replace = <start> strchr(data, '\n') <end> ;"	0
8df421f8-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define PATH_SZ 100 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define PATH_SZ PATH_MAX #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 void CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__accept_listen_bind_01_bad() { { char data[100] = """"; #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[recvResult] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif printLine(data); } }"	where is the vulnerable dataflow from data to printLine ?	"<start> printLine(data) <end> ;
recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);"	"printLine <start> data <end> );
recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);"	"printLine <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	"recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);
printLine <start> data <end> );"	3
b68484e8-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 namespace CWE36_Absolute_Path_Traversal__char_listen_socket_ifstream_82 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE36_Absolute_Path_Traversal__char_listen_socket_ifstream_82_base* baseObject = new CWE36_Absolute_Path_Traversal__char_listen_socket_ifstream_82_bad; baseObject->action(data); delete baseObject; }"	where is the vulnerable dataflow from data to action ?	"<start> data = dataBuffer <end> ;
baseObject->action <start> data <end> );"	"replace = <start> strchr(data, '\n') <end> ;
baseObject->action <start> data <end> );"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
baseObject->action <start> data <end> );"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
size_t dataLen = <start> strlen(data) <end> ;"	2
7ae3a720-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_54e_badSink(int data) { { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"printLine <start> dest <end> );
<start> printLine(dest) <end> ;"	"void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_54e_badSink(int <start> data <end> );
if  <start> data < 100 <end> );"	"void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_54e_badSink(int <start> data <end> );
printLine <start> dest <end> );"	"<start> memmove(dest, source, data) <end> ;
printLine <start> dest <end> );"	2
6ef76813-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif namespace CWE134_Uncontrolled_Format_String__char_console_snprintf_62 { void badSource(char * &data); void bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; badSource(data); { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"badSource <start> data <end> );
printLine <start> dest <end> );"	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	"badSource <start> data <end> );
<start> printLine(dest) <end> ;"	"char <start> dataBuffer[100] = """" <end> ;
printLine <start> dest <end> );"	0
4a021144-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__int_listen_socket_square_74 { void badSink(map<int, int> dataMap) { int data = dataMap[2]; { int result = data * data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
void badSink(map<int, int> <start> dataMap <end> );"	"void badSink(map<int, int> <start> dataMap <end> );
int result = <start> data <end>  * data;"	"int <start> data = dataMap[2] <end> ;
void badSink(map<int, int> <start> dataMap <end> );"	"void badSink(map<int, int> <start> dataMap <end> );
int result = <start> data * data <end> ;"	1
74ee23c7-6c15-11ed-81d4-94e6f77dd552	"namespace CWE194_Unexpected_Sign_Extension__connect_socket_memmove_82 { void CWE194_Unexpected_Sign_Extension__connect_socket_memmove_82_bad::action(short data) { { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } } }"	where is the vulnerable dataflow from dest to printLine ?	"void CWE194_Unexpected_Sign_Extension__connect_socket_memmove_82_bad::action(short <start> data <end> );
printLine <start> dest <end> );"	"printLine <start> dest <end> );
void CWE194_Unexpected_Sign_Extension__connect_socket_memmove_82_bad::action(short <start> data <end> );"	"<start> memmove(dest, source, data) <end> ;
void CWE194_Unexpected_Sign_Extension__connect_socket_memmove_82_bad::action(short <start> data <end> );"	"<start> memmove(dest, source, data) <end> ;
printLine <start> dest <end> );"	0
60db83d9-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__char_rand_multiply_73 { void badSink(list<char> dataList) { char data = dataList.back(); if(data > 0) { char result = data * 2; printHexCharLine(result); } }	where is the vulnerable dataflow from data ?	"void badSink(list<char> <start> dataList <end> );
char result = <start> data <end>  * 2;"	"char result = <start> data <end>  * 2;
<start> printHexCharLine(result) <end> ;"	"char result = <start> data <end>  * 2;
char <start> data = dataList.back() <end> ;"	"char result = <start> data <end>  * 2;
void badSink(list<char> <start> dataList <end> );"	0
b7b09a62-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define NEW_PATH ""%SystemRoot%\\system32"" #define PUTENV _putenv #else #define NEW_PATH ""/bin"" #define PUTENV putenv #endif int CWE427_Uncontrolled_Search_Path_Element__char_file_22_badGlobal = 0; char * CWE427_Uncontrolled_Search_Path_Element__char_file_22_badSource(char * data); void CWE427_Uncontrolled_Search_Path_Element__char_file_22_bad() { char * data; char dataBuffer[250] = ""PATH=""; data = dataBuffer; CWE427_Uncontrolled_Search_Path_Element__char_file_22_badGlobal = 1; data = CWE427_Uncontrolled_Search_Path_Element__char_file_22_badSource(data); PUTENV(data); }"	where is the vulnerable dataflow from data to PUTENV ?	"<start> data = dataBuffer <end> ;
PUTENV <start> data <end> );"	"PUTENV <start> data <end> );
data = <start> CWE427_Uncontrolled_Search_Path_Element__char_file_22_badSource <end> (data);"	"data = <start> CWE427_Uncontrolled_Search_Path_Element__char_file_22_badSource <end> (data);
PUTENV <start> data <end> );"	"PUTENV <start> data <end> );
<start> data = CWE427_Uncontrolled_Search_Path_Element__char_file_22_badSource(data) <end> ;"	2
85b15f02-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; void CWE369_Divide_by_Zero__int_fgets_modulo_04_bad() { int data; data = -1; if(STATIC_CONST_TRUE) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(STATIC_CONST_TRUE) { printIntLine(100 % data); } }"	where is the vulnerable dataflow from data to printIntLine ?	"<start> data = atoi(inputBuffer) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"printIntLine <start> 100 % data <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> 100 % data <end> );"	"<start> data = -1 <end> ;
printIntLine <start> 100 % data <end> );"	2
cd228147-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif namespace CWE36_Absolute_Path_Traversal__char_console_ofstream_41 { void badSink(char * data) { { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } } void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } badSink(data); }"	where is the vulnerable dataflow from data to badSink ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
badSink <start> data <end> );"	"<start> data = dataBuffer <end> ;
badSink <start> data <end> );"	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"<start> badSink(data) <end> ;
badSink <start> data <end> );"	0
cac216bf-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" namespace CWE36_Absolute_Path_Traversal__char_connect_socket_ofstream_31 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { char * dataCopy = data; char * data = dataCopy; { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } } }"	where is the vulnerable dataflow from data to open ?	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
outputFile.open((char * <start> data <end> );"	"<start> data = dataBuffer <end> ;
outputFile.open((char * <start> data <end> );"	"outputFile.open((char * <start> data <end> );
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"size_t dataLen = <start> strlen(data) <end> ;
outputFile.open((char * <start> data <end> );"	0
85b15ee4-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink(int data) { printIntLine(100 % data); } void CWE369_Divide_by_Zero__int_connect_socket_modulo_44_bad() { int data; void (*funcPtr) (int) = badSink; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } funcPtr(data); }"	where is the vulnerable dataflow from data to printIntLine ?	"printIntLine <start> 100 % data <end> );
funcPtr <start> data <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data = atoi(inputBuffer) <end> ;"	"printIntLine <start> 100 % data <end> );
funcPtr <start> data <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static void badSink(int <start> data <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
funcPtr <start> data <end> );
static void badSink(int <start> data <end> );
printIntLine <start> 100 % data <end> );"	"<start> funcPtr(data) <end> ;
funcPtr <start> data <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static void badSink(int <start> data <end> );"	2
ae26ae66-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; void CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_04_bad() { int data; data = -1; if(STATIC_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { char charData = (char)data; printHexCharLine(charData); } }"	where is the vulnerable dataflow from charData to printHexCharLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printHexCharLine <start> charData <end> );"	"printHexCharLine <start> charData <end> );
<start> printHexCharLine(charData) <end> ;"	"printHexCharLine <start> charData <end> );
char charData = <start> (char)data <end> ;"	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printHexCharLine <start> charData <end> );"	0
a109490e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_square_15_bad() { int data; data = 0; switch(6) { case 6: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; default: printLine(""Benign, fixed string""); break; } switch(7) { case 7: { int result = data * data; printIntLine(result); } break; default: printLine(""Benign, fixed string""); break; } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"data = <start> atoi(inputBuffer) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"printIntLine <start> result <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printIntLine(result) <end> ;"	0
a10948e6-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int badStatic = 0; static void badSink(int data) { if(badStatic) { if(data > 0) { int result = data * 2; printIntLine(result); } } } void CWE190_Integer_Overflow__int_connect_socket_multiply_21_bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badStatic = 1; badSink(data); }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
<start> badSink(data) <end> ;
badSink <start> data <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"badSink <start> data <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> result <end> );
static void badSink(int <start> data <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSink <start> data <end> );
static void badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static void badSink(int <start> data <end> );
int <start> result = data * 2 <end> ;
printIntLine <start> result <end> );"	2
a23a3e0d-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_add_66b_badSink(int dataArray[]) { int data = dataArray[2]; { int result = data + 1; printIntLine(result); } }	where is the vulnerable dataflow from result to printIntLine ?	"void CWE190_Integer_Overflow__int_fgets_add_66b_badSink(int <start> dataArray <end> []);
int <start> data = dataArray[2] <end> ;"	"void CWE190_Integer_Overflow__int_fgets_add_66b_badSink(int <start> dataArray <end> []);
<start> printIntLine(result) <end> ;"	"int <start> result = data + 1 <end> ;
printIntLine <start> result <end> );"	"void CWE190_Integer_Overflow__int_fgets_add_66b_badSink(int <start> dataArray <end> []);
printIntLine <start> result <end> );"	3
b08640f2-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE197_Numeric_Truncation_Error__int_fgets_to_short_63b_badSink(int * dataPtr) { int data = *dataPtr; { short shortData = (short)data; printShortLine(shortData); } }	where is the vulnerable dataflow from shortData to printShortLine ?	"void CWE197_Numeric_Truncation_Error__int_fgets_to_short_63b_badSink(int * <start> dataPtr <end> );
printShortLine <start> shortData <end> );"	"printShortLine <start> shortData <end> );
void CWE197_Numeric_Truncation_Error__int_fgets_to_short_63b_badSink(int * <start> dataPtr <end> );"	"printShortLine <start> shortData <end> );
<start> printShortLine(shortData) <end> ;"	"short <start> shortData = (short)data <end> ;
void CWE197_Numeric_Truncation_Error__int_fgets_to_short_63b_badSink(int * <start> dataPtr <end> );"	0
820a46a0-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_console_open_61 { char * badSource(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; data = badSource(data); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"data = <start> badSource <end> (data);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"data = <start> badSource(data) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN(data, O_RDWR|O_CREAT, <start> S_IREAD|S_IWRITE <end> );
data = <start> badSource <end> (data);"	0
c1366255-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_console_fopen_62 { void badSource(char * &data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; badSource(data); { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"badSource <start> data <end> );
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"<start> badSource(data) <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"badSource <start> data <end> );
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	0
bda4e40f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define EXECL _execl #else #define EXECL execl #endif void CWE78_OS_Command_Injection__char_listen_socket_execl_01_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECL ?	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"size_t dataLen = <start> strlen(data) <end> ;
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"<start> EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL) <end> ;
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"if  <start> recvResult == SOCKET_ERROR <end>  || recvResult == 0);
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	0
4ff7826f-6c15-11ed-81d4-94e6f77dd552	"void CWE190_Integer_Overflow__short_fscanf_postinc_16_bad() { short data; data = 0; while(1) { fscanf (stdin, ""%hd"", &data); break; } while(1) { { data++; short result = data; printIntLine(result); } break; } }"	where is the vulnerable dataflow from data ?	"fscanf (stdin, ""%hd"", <start> &data <end> );
<start> printIntLine(result) <end> ;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
<start> data <end> ++;"	"short <start> result = data <end> ;
<start> data <end> ++;"	"<start> data <end> ++;
fscanf (stdin, ""%hd"", <start> &data <end> );"	1
893217cf-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_console_fopen_43 { void badSource(char * &data) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; badSource(data); { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
badSource <start> data <end> );
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
badSource <start> data <end> );
pFile = FOPEN <start> data <end> , ""wb+"");"	"size_t dataLen = <start> strlen(data) <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");
badSource <start> data <end> );"	"<start> data = dataBuffer <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
badSource <start> data <end> );"	1
4ff7827d-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__short_fscanf_postinc_54e_badSink(short data) { { data++; short result = data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"<start> data <end> ++;
<start> printIntLine(result) <end> ;"	"<start> printIntLine(result) <end> ;
void CWE190_Integer_Overflow__short_fscanf_postinc_54e_badSink(short <start> data <end> );"	"<start> data <end> ++;
void CWE190_Integer_Overflow__short_fscanf_postinc_54e_badSink(short <start> data <end> );"	"void CWE190_Integer_Overflow__short_fscanf_postinc_54e_badSink(short <start> data <end> );
<start> data <end> ++;"	3
5e44fc8f-6c15-11ed-81d4-94e6f77dd552	"void CWE191_Integer_Underflow__int_fscanf_predec_02_bad() { int data; data = 0; if(1) { fscanf(stdin, ""%d"", &data); } if(1) { { --data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
fscanf(stdin, ""%d"", <start> &data <end> );"	"- <start> data <end> ;
fscanf(stdin, ""%d"", <start> &data <end> );"	"<start> printIntLine(result) <end> ;
- <start> data <end> ;"	"fscanf(stdin, ""%d"", <start> &data <end> );
- <start> data <end> ;"	3
c26a7e55-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_console_open_61 { char * badSource(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; data = badSource(data); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
<start> data = badSource(data) <end> ;"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
data = <start> badSource(data) <end> ;"	"data = <start> badSource <end> (data);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
data = <start> badSource <end> (data);"	2
728a4ff7-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 static void badVaSink(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_51b_badSink(char * data) { badVaSink(data, data); }"	where is the vulnerable dataflow from data to vfprintf ?	"vfprintf(stdout, <start> data <end> , args);
void CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_51b_badSink(char * <start> data <end> );"	"<start> vfprintf(stdout, data, args) <end> ;
static void badVaSink(char * <start> data <end> , ...);
badVaSink <start> data <end> , data);
void CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_51b_badSink(char * <start> data <end> );"	"void CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_51b_badSink(char * <start> data <end> );
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);"	"static void badVaSink(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);
badVaSink <start> data <end> , data);
void CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_51b_badSink(char * <start> data <end> );"	2
a95fd83d-6c15-11ed-81d4-94e6f77dd552	namespace CWE191_Integer_Underflow__int_fgets_multiply_62 { void badSource(int &data); void bad() { int data; data = 0; badSource(data); if(data < 0) { int result = data * 2; printIntLine(result); } }	where is the vulnerable dataflow from result to printIntLine ?	"badSource <start> data <end> );
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
int <start> result = data * 2 <end> ;"	"printIntLine <start> result <end> );
int result = <start> data * 2 <end> ;"	"<start> printIntLine(result) <end> ;
badSource <start> data <end> );"	0
acf67e07-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int badSource(int data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } return data; } void CWE191_Integer_Underflow__int_listen_socket_postdec_42_bad() { int data; data = 0; data = badSource(data); { data--; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"static int <start> badSource <end> (int data);
if  <start> acceptSocket == SOCKET_ERROR <end> );
data = <start> badSource <end> (data);
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static int <start> badSource <end> (int data);
data = <start> badSource <end> (data);
printIntLine <start> result <end> );"	"<start> printIntLine(result) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static int <start> badSource <end> (int data);
data = <start> badSource <end> (data);"	"if  <start> acceptSocket == SOCKET_ERROR <end> );
printIntLine <start> result <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
data = <start> badSource <end> (data);"	1
d31a2503-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 namespace CWE36_Absolute_Path_Traversal__char_listen_socket_ofstream_31 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { char * dataCopy = data; char * data = dataCopy; { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } } }"	where is the vulnerable dataflow from data to open ?	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"outputFile.open((char * <start> data <end> );
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
size_t <start> dataLen = strlen(data) <end> ;"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
outputFile.open((char * <start> data <end> );"	3
85b15f08-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE369_Divide_by_Zero__int_fgets_modulo_10_bad() { int data; data = -1; if(globalTrue) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(globalTrue) { printIntLine(100 % data); } }"	where is the vulnerable dataflow from data to printIntLine ?	"if  <start> fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) <end>  != NULL);
printIntLine <start> 100 % data <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> 100 % data <end> );"	"<start> data = atoi(inputBuffer) <end> ;
printIntLine <start> 100 % data <end> );"	"<start> data = atoi(inputBuffer) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	1
a23a3e1b-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticFive = 5; void CWE190_Integer_Overflow__int_fgets_multiply_07_bad() { int data; data = 0; if(staticFive==5) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(staticFive==5) { if(data > 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
if <start> data > 0 <end> ) ;"	"<start> data = atoi(inputBuffer) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	2
55ef4ce5-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) extern int CWE191_Integer_Underflow__int_fgets_sub_68_badData; extern int CWE191_Integer_Underflow__int_fgets_sub_68_goodG2BData; extern int CWE191_Integer_Underflow__int_fgets_sub_68_goodB2GData; void CWE191_Integer_Underflow__int_fgets_sub_68b_badSink() { int data = CWE191_Integer_Underflow__int_fgets_sub_68_badData; { int result = data - 1; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"int <start> result = data - 1 <end> ;
int data = <start> CWE191_Integer_Underflow__int_fgets_sub_68_badData <end> ;"	"int result = <start> data <end>  - 1;
int data = <start> CWE191_Integer_Underflow__int_fgets_sub_68_badData <end> ;"	"<start> printIntLine(result) <end> ;
int data = <start> CWE191_Integer_Underflow__int_fgets_sub_68_badData <end> ;"	"int data = <start> CWE191_Integer_Underflow__int_fgets_sub_68_badData <end> ;
int result = <start> data <end>  - 1;"	3
a36a78d4-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_square_53d_badSink(int data) { { int result = data * data; printIntLine(result); } }	where is the vulnerable dataflow from result to printIntLine ?	"void CWE190_Integer_Overflow__int_fgets_square_53d_badSink(int <start> data <end> );
<start> printIntLine(result) <end> ;"	"void CWE190_Integer_Overflow__int_fgets_square_53d_badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;"	"printIntLine <start> result <end> );
void CWE190_Integer_Overflow__int_fgets_square_53d_badSink(int <start> data <end> );"	1
6c938be0-6c15-11ed-81d4-94e6f77dd552	"namespace CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_62 { void badSource(int &data); void bad() { int data; data = -1; badSource(data); { int i; int * buffer = (int *)malloc(10 * sizeof(int)); if (buffer == NULL) {exit(-1);} for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } free(buffer); } }"	where is the vulnerable dataflow from buffer to free ?	"badSource <start> data <end> );
<start> printIntLine(buffer[i]) <end> ;"	"badSource <start> data <end> );
free <start> buffer <end> );"	"badSource <start> data <end> );
if  <start> buffer == NULL <end> ) {exit(-1);};"	"free <start> buffer <end> );
badSource <start> data <end> );"	1
b8e2bdd4-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 256 void CWE681_Incorrect_Conversion_Between_Numeric_Types__doubleNaN2int_14_bad() { if(globalFive==5) { { char inputBuffer[CHAR_ARRAY_SIZE]; double doubleNumber = 0; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { doubleNumber = atof(inputBuffer); } else { printLine(""fgets() failed.""); } printIntLine((int)(sqrt(doubleNumber))); } } }"	where is the vulnerable dataflow from doubleNumber to printIntLine ?	"printIntLine((int)(sqrt <start> doubleNumber <end> )));
printIntLine((int) <start> sqrt(doubleNumber) <end> ));"	"if  <start> fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) <end>  != NULL);
printIntLine((int)(sqrt <start> doubleNumber <end> )));"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine((int)(sqrt <start> doubleNumber <end> )));"	"printIntLine((int)(sqrt <start> doubleNumber <end> )));
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	2
8f278a74-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_FIVE = 5; void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_06_bad() { int data; data = -1; if(STATIC_CONST_FIVE==5) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } { size_t i; int *intPointer; intPointer = (int*)malloc(data * sizeof(int)); if (intPointer == NULL) {exit(-1);} for (i = 0; i < (size_t)data; i++) { intPointer[i] = 0; } printIntLine(intPointer[0]); free(intPointer); } }"	where is the vulnerable dataflow from data to malloc ?	"intPointer = (int*)malloc <start> data * sizeof(int) <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	"<start> printIntLine(intPointer[0]) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"<start> printIntLine(intPointer[0]) <end> ;
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	1
93ece2fa-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING ""hello"" void CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_03_bad() { size_t data; data = 0; if(5==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = strtoul(inputBuffer, NULL, 0); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(5==5) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); } else { printLine(""Input is less than the length of the source string""); } } } }"	where is the vulnerable dataflow from data to malloc ?	"if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );
myString = (char *)malloc <start> data*sizeof(char) <end> );"	"<start> data = strtoul(inputBuffer, NULL, 0) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
myString = (char *)malloc <start> data*sizeof(char) <end> );"	"myString = (char *)malloc <start> data*sizeof(char) <end> );
if  <start> data > strlen(HELLO_STRING) <end> );"	2
c4cd6f6b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_file_fopen_17 { void bad() { int i; char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; for(i = 0; i < 1; i++) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"<start> data = dataBuffer <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"size_t dataLen = <start> strlen(data) <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
pFile = FOPEN <start> data <end> , ""wb+"");"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
<start> data = dataBuffer <end> ;"	2
7ae3a735-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_08_bad() { int data; data = -1; if(staticReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printLine <start> dest <end> );"	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	"printLine <start> dest <end> );
char <start> dest[100] = """" <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	3
7c12758e-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_16_bad() { int data; data = -1; while(1) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } break; } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> memcpy(dest, source, data) <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printLine <start> dest <end> );"	"printLine <start> dest <end> );
<start> memcpy(dest, source, data) <end> ;"	"<start> printLine(dest) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	1
92bb8a13-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define SEARCH_CHAR 'S' typedef struct _CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_67_structType { char * structFirst; } CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_67_structType; void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_67b_badSink(CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_67_structType myStruct) { char * data = myStruct.structFirst; for (; *data != '\0'; data++) { if (*data == SEARCH_CHAR) { printLine(""We have a match!""); break; } } free(data); }"	where is the vulnerable dataflow from data to free ?	"char * data = <start> myStruct <end> .structFirst;
free <start> data <end> );"	"void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_67b_badSink(CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_67_structType <start> myStruct <end> );
char * data = <start> myStruct <end> .structFirst;
free <start> data <end> );"	"free <start> data <end> );
void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_67b_badSink(CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_67_structType <start> myStruct <end> );
char * data = <start> myStruct <end> .structFirst;"	"char <start> * data = myStruct.structFirst <end> ;
free <start> data <end> );
void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_67b_badSink(CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_67_structType <start> myStruct <end> );"	1
833ac91d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_listen_socket_fopen_34 { typedef union { char * unionFirst; char * unionSecond; } unionType; void bad() { char * data; unionType myUnion; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } } }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = FOPEN <start> data <end> , ""wb+"");
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"size_t dataLen = <start> strlen(data) <end> ;
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"<start> data = dataBuffer <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	3
6a52bef3-6c15-11ed-81d4-94e6f77dd552	static void badSink(unsigned int data) { { --data; unsigned int result = data; printUnsignedLine(result); } } void CWE191_Integer_Underflow__unsigned_int_rand_predec_44_bad() { unsigned int data; void (*funcPtr) (unsigned int) = badSink; data = 0; data = (unsigned int)RAND32(); funcPtr(data); }	where is the vulnerable dataflow from data ?	"funcPtr <start> data <end> );
data = (unsigned int <start> RAND32() <end> ;"	"static void badSink(unsigned int <start> data <end> );
funcPtr <start> data <end> );
data = (unsigned int <start> RAND32() <end> ;"	"data = (unsigned int <start> RAND32() <end> ;
funcPtr <start> data <end> );
static void badSink(unsigned int <start> data <end> );
- <start> data <end> ;"	"funcPtr <start> data <end> );
static void badSink(unsigned int <start> data <end> );
data = (unsigned int <start> RAND32() <end> ;
- <start> data <end> ;"	2
6b862452-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_13_bad() { int data; data = -1; if(GLOBAL_CONST_FIVE==5) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(GLOBAL_CONST_FIVE==5) { { int i; int * buffer = (int *)malloc(10 * sizeof(int)); if (buffer == NULL) {exit(-1);} for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } free(buffer); } } }"	where is the vulnerable dataflow from buffer to free ?	"free <start> buffer <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"<start> printIntLine(buffer[i]) <end> ;
free <start> buffer <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
free <start> buffer <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> free(buffer) <end> ;"	2
8f278a81-6c15-11ed-81d4-94e6f77dd552	int CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_22_badGlobal = 0; int CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_22_badSource(int data); void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_22_bad() { int data; data = -1; CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_22_badGlobal = 1; data = CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_22_badSource(data); { size_t i; int *intPointer; intPointer = (int*)malloc(data * sizeof(int)); if (intPointer == NULL) {exit(-1);} for (i = 0; i < (size_t)data; i++) { intPointer[i] = 0; } printIntLine(intPointer[0]); free(intPointer); } }	where is the vulnerable dataflow from data to malloc ?	"intPointer = (int*)malloc <start> data * sizeof(int) <end> );
data = <start> CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_22_badSource <end> (data);"	"<start> intPointer = (int*)malloc(data * sizeof(int)) <end> ;
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	"data = <start> CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_22_badSource <end> (data);
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	"<start> intPointer = (int*)malloc(data * sizeof(int)) <end> ;
data = <start> CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_22_badSource <end> (data);"	2
bb49c578-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" namespace CWE78_OS_Command_Injection__char_connect_socket_popen_82 { void bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE78_OS_Command_Injection__char_connect_socket_popen_82_base* baseObject = new CWE78_OS_Command_Injection__char_connect_socket_popen_82_bad; baseObject->action(data); delete baseObject; }"	where is the vulnerable dataflow from data to action ?	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
baseObject->action <start> data <end> );"	"baseObject->action <start> data <end> );
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
replace = <start> strchr(data, '\n') <end> ;"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (100 - dataLen - 1), 0);"	0
8f278a7c-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_14_bad() { int data; data = -1; if(globalFive==5) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } { size_t i; int *intPointer; intPointer = (int*)malloc(data * sizeof(int)); if (intPointer == NULL) {exit(-1);} for (i = 0; i < (size_t)data; i++) { intPointer[i] = 0; } printIntLine(intPointer[0]); free(intPointer); } }"	where is the vulnerable dataflow from data to malloc ?	"if  <start> intPointer == NULL <end> ) {exit(-1);};
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	"if  <start> intPointer == NULL <end> ) {exit(-1);};
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"intPointer = (int*)malloc <start> data * sizeof(int) <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	3
5be3a9ea-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_listen_socket_postdec_65b_badSink(int data) { { data--; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"void CWE191_Integer_Underflow__int_listen_socket_postdec_65b_badSink(int <start> data <end> );
int <start> result = data <end> ;"	"<start> data-- <end> ;
void CWE191_Integer_Underflow__int_listen_socket_postdec_65b_badSink(int <start> data <end> );"	"void CWE191_Integer_Underflow__int_listen_socket_postdec_65b_badSink(int <start> data <end> );
<start> data <end> --;"	"<start> printIntLine(result) <end> ;
<start> data <end> --;"	2
5133a743-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_preinc_31_bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { int dataCopy = data; int data = dataCopy; { ++data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int <start> result = data <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int <start> dataCopy = data <end> ;"	"+ <start> data <end> ;
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
+ <start> data <end> ;"	3
7fa68e07-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_18_bad() { int data; data = -1; goto source; source: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printLine(dest) <end> ;"	"data = <start> atoi(inputBuffer) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"<start> strncpy(dest, source, data) <end> ;
printLine <start> dest <end> );"	0
a5ce1c8e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) int CWE190_Integer_Overflow__int_listen_socket_postinc_61b_badSource(int data); void CWE190_Integer_Overflow__int_listen_socket_postinc_61_bad() { int data; data = 0; data = CWE190_Integer_Overflow__int_listen_socket_postinc_61b_badSource(data); { data++; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"data = <start> CWE190_Integer_Overflow__int_listen_socket_postinc_61b_badSource <end> (data);
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
<start> data = CWE190_Integer_Overflow__int_listen_socket_postinc_61b_badSource(data) <end> ;"	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;"	"<start> printIntLine(result) <end> ;
data = <start> CWE190_Integer_Overflow__int_listen_socket_postinc_61b_badSource <end> (data);"	0
b2ea8dc4-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 8 void CWE197_Numeric_Truncation_Error__short_fgets_16_bad() { short data; data = -1; while(1) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = (short)atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } break; } { char charData = (char)data; printHexCharLine(charData); } }"	where is the vulnerable dataflow from charData to printHexCharLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
data = <start> (short)atoi(inputBuffer) <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printHexCharLine <start> charData <end> );"	"char <start> charData = (char)data <end> ;
printHexCharLine <start> charData <end> );"	"<start> data = -1 <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	1
cac216e6-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_connect_socket_open_51 { void badSink(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badSink(data); }"	where is the vulnerable dataflow from data to badSink ?	"<start> data = dataBuffer <end> ;
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"badSink <start> data <end> );
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
badSink <start> data <end> );"	"size_t <start> dataLen = strlen(data) <end> ;
badSink <start> data <end> );"	2
48d25db1-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink(int data) { { int result = data + 1; printIntLine(result); } } void CWE190_Integer_Overflow__int_listen_socket_add_41_bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badSink(data); }"	where is the vulnerable dataflow from data ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSink <start> data <end> );
static void badSink(int <start> data <end> );
int result = <start> data <end>  + 1;"	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
static void badSink(int <start> data <end> );
int result = <start> data <end>  + 1;
badSink <start> data <end> );"	"static void badSink(int <start> data <end> );
int result = <start> data <end>  + 1;
<start> data = atoi(inputBuffer) <end> ;
badSink <start> data <end> );"	"badSink <start> data <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  + 1;"	0
ae26ae37-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int badStatic = 0; static void badSink(int data) { if(badStatic) { { --data; int result = data; printIntLine(result); } } } void CWE191_Integer_Underflow__int_listen_socket_predec_21_bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badStatic = 1; badSink(data); }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSink <start> data <end> );
static void badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"static void badSink(int <start> data <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
if  <start> acceptSocket == SOCKET_ERROR <end> );
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static void badSink(int <start> data <end> );"	"printIntLine <start> result <end> );
badSink <start> data <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data = atoi(inputBuffer) <end> ;"	0
54c58220-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE191_Integer_Underflow__int_connect_socket_sub_43 { static void badSource(int &data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } void bad() { int data; data = 0; badSource(data); { int result = data - 1; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"badSource <start> data <end> );
int result = <start> data <end>  - 1;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"badSource <start> data <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);
badSource <start> data <end> );
int result = <start> data <end>  - 1;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSource <start> data <end> );
int result = <start> data <end>  - 1;"	3
af58096c-6c15-11ed-81d4-94e6f77dd552	namespace CWE197_Numeric_Truncation_Error__int_connect_socket_to_short_74 { void badSink(map<int, int> dataMap) { int data = dataMap[2]; { short shortData = (short)data; printShortLine(shortData); } }	where is the vulnerable dataflow from shortData to printShortLine ?	"void badSink(map<int, int> <start> dataMap <end> );
<start> printShortLine(shortData) <end> ;"	"printShortLine <start> shortData <end> );
<start> printShortLine(shortData) <end> ;"	"short shortData = <start> (short)data <end> ;
void badSink(map<int, int> <start> dataMap <end> );"	"void badSink(map<int, int> <start> dataMap <end> );
printShortLine <start> shortData <end> );"	3
d1e9da12-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_file_open_31 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } { char * dataCopy = data; char * data = dataCopy; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
char <start> * data = dataCopy <end> ;"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	3
4db33f76-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_postinc_16_bad() { int data; data = 0; while(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; } while(1) { { data++; int result = data; printIntLine(result); } break; } }"	where is the vulnerable dataflow from data ?	"<start> data = 0 <end> ;
<start> data <end> ++;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data <end> ++;"	"<start> data++ <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"<start> data <end> ++;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	1
ce547d41-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif namespace CWE36_Absolute_Path_Traversal__char_environment_ifstream_11 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(globalReturnsTrue()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } } { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
strncat(data+dataLen, environment, <start> FILENAME_MAX-dataLen-1 <end> );"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
inputFile.open((char * <start> data <end> );"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
size_t dataLen = <start> strlen(data) <end> ;"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
char <start> dataBuffer[FILENAME_MAX] = """" <end> ;"	1
669edaaf-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__int_rand_square_81 { void CWE190_Integer_Overflow__int_rand_square_81_bad::action(int data) const { { int result = data * data; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"int <start> result = data * data <end> ;
void CWE190_Integer_Overflow__int_rand_square_81_bad::action(int <start> data <end> ) const;"	"void CWE190_Integer_Overflow__int_rand_square_81_bad::action(int <start> data <end> ) const;
int result = <start> data <end>  * data;"	"void CWE190_Integer_Overflow__int_rand_square_81_bad::action(int <start> data <end> ) const;
<start> printIntLine(result) <end> ;"	"void CWE190_Integer_Overflow__int_rand_square_81_bad::action(int <start> data <end> ) const;
int result = <start> data * data <end> ;"	1
b8e2bd92-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define NEW_PATH ""%SystemRoot%\\system32"" #define PUTENV _putenv #else #define NEW_PATH ""/bin"" #define PUTENV putenv #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 void CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_01_bad() { char * data; char dataBuffer[250] = ""PATH=""; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (250 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } PUTENV(data); }"	where is the vulnerable dataflow from data to PUTENV ?	"size_t dataLen = <start> strlen(data) <end> ;
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (250 - dataLen - 1), 0);"	"<start> PUTENV(data) <end> ;
PUTENV <start> data <end> );"	"PUTENV <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (250 - dataLen - 1), 0);
PUTENV <start> data <end> );"	3
79b27518-6c15-11ed-81d4-94e6f77dd552	"namespace CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_82 { void CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_82_bad::action(short data) { { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } } }"	where is the vulnerable dataflow from dest to printLine ?	"printLine <start> dest <end> );
char <start> dest[100] = """" <end> ;"	"void CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_82_bad::action(short <start> data <end> );
<start> printLine(dest) <end> ;"	"void CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_82_bad::action(short <start> data <end> );
printLine <start> dest <end> );"	"printLine <start> dest <end> );
<start> strncpy(dest, source, data) <end> ;"	2
c4cd6f3a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_environment_open_12 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(globalReturnsTrueOrFalse()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } } else { strcat(data, ""file.txt""); } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"<start> data = dataBuffer <end> ;
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);"	2
5be3a9b4-6c15-11ed-81d4-94e6f77dd552	"void CWE191_Integer_Underflow__int_fscanf_postdec_14_bad() { int data; data = 0; if(globalFive==5) { fscanf(stdin, ""%d"", &data); } if(globalFive==5) { { data--; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> data = 0 <end> ;
<start> data <end> --;"	"fscanf(stdin, ""%d"", <start> &data <end> );
<start> data <end> --;"	"<start> data <end> --;
fscanf(stdin, ""%d"", <start> &data <end> );"	"<start> printIntLine(result) <end> ;
<start> data <end> --;"	1
54c581dc-6c15-11ed-81d4-94e6f77dd552	"static void badSink(int64_t data) { { int64_t result = data - 1; printLongLongLine(result); } } void CWE191_Integer_Underflow__int64_t_fscanf_sub_44_bad() { int64_t data; void (*funcPtr) (int64_t) = badSink; data = 0LL; fscanf (stdin, ""%"" SCNd64, &data); funcPtr(data); }"	where is the vulnerable dataflow from data ?	"int64_t result = <start> data <end>  - 1;
fscanf (stdin, ""%"" SCNd64, <start> &data <end> );
funcPtr <start> data <end> );
static void badSink(int64_t <start> data <end> );"	"int64_t result = <start> data <end>  - 1;
fscanf (stdin, ""%"" SCNd64, <start> &data <end> );
funcPtr <start> data <end> );"	"<start> funcPtr(data) <end> ;
static void badSink(int64_t <start> data <end> );
int64_t result = <start> data <end>  - 1;
fscanf (stdin, ""%"" SCNd64, <start> &data <end> );"	"fscanf (stdin, ""%"" SCNd64, <start> &data <end> );
funcPtr <start> data <end> );
static void badSink(int64_t <start> data <end> );
int64_t result = <start> data <end>  - 1;"	3
c5fc2350-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } namespace CWE23_Relative_Path_Traversal__char_file_ofstream_08 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(staticReturnsTrue()) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
outputFile.open((char * <start> data <end> );"	"outputFile.open((char * <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	"outputFile.open((char * <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
size_t dataLen = <start> strlen(data) <end> ;"	0
af58092b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_41_badSink(int data) { { char charData = (char)data; printHexCharLine(charData); } } void CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_41_bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_41_badSink(data); }"	where is the vulnerable dataflow from charData to printHexCharLine ?	"char charData = <start> (char)data <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
void CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_41_badSink(int <start> data <end> );
printHexCharLine <start> charData <end> );"	"printHexCharLine <start> charData <end> );
void CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_41_badSink(int <start> data <end> );
CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_41_badSink <start> data <end> );
char charData = <start> (char)data <end> ;"	"<start> printHexCharLine(charData) <end> ;
printHexCharLine <start> charData <end> );
void CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_41_badSink(int <start> data <end> );
CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_41_badSink <start> data <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_41_badSink <start> data <end> );
void CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_41_badSink(int <start> data <end> );
printHexCharLine <start> charData <end> );"	3
70279c2b-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif static void badVaSinkB(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_file_vfprintf_16_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; while(1) { { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } break; } while(1) { badVaSinkB(data, data); break; } }"	where is the vulnerable dataflow from data to vfprintf ?	"vfprintf(stdout, <start> data <end> , args);
static void badVaSinkB(char * <start> data <end> , ...);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
badVaSinkB <start> data <end> , data);"	"badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);
<start> data = dataBuffer <end> ;"	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
vfprintf(stdout, <start> data <end> , args);
static void badVaSinkB(char * <start> data <end> , ...);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);"	3
cd22816f-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_console_open_54 { void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } badSink_b(data); }"	where is the vulnerable dataflow from data to badSink_b ?	"<start> badSink_b(data) <end> ;
badSink_b <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
size_t dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
badSink_b <start> data <end> );"	3
aa91a154-6c15-11ed-81d4-94e6f77dd552	namespace CWE191_Integer_Underflow__int_fgets_sub_74 { void badSink(map<int, int> dataMap) { int data = dataMap[2]; { int result = data - 1; printIntLine(result); } }	where is the vulnerable dataflow from result to printIntLine ?	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
void badSink(map<int, int> <start> dataMap <end> );"	"printIntLine <start> result <end> );
int result = <start> data - 1 <end> ;"	"void badSink(map<int, int> <start> dataMap <end> );
printIntLine <start> result <end> );"	3
951c5e90-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FULL_COMMAND ""dir "" #else #define FULL_COMMAND ""ls "" #endif #ifdef _WIN32 #define POPEN _popen #define PCLOSE _pclose #else #define POPEN popen #define PCLOSE pclose #endif void CWE78_OS_Command_Injection__char_console_popen_14_bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; if(globalFive==5) { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } { FILE *pipe; pipe = POPEN(data, ""w""); if (pipe != NULL) { PCLOSE(pipe); } } }"	where is the vulnerable dataflow from data to POPEN ?	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
pipe = POPEN <start> data <end> , ""w"");"	"pipe = POPEN <start> data <end> , ""w"");
size_t dataLen = <start> strlen(data) <end> ;"	"pipe = POPEN <start> data <end> , ""w"");
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	"pipe = <start> POPEN(data, ""w"") <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	0
c8600b1d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_listen_socket_open_72 { void badSink(vector<char *> dataVector) { char * data = dataVector[2]; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
void badSink(vector<char *> <start> dataVector <end> );"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
void badSink(vector<char *> <start> dataVector <end> );"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"void badSink(vector<char *> <start> dataVector <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	3
466e7eec-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__int_fgets_multiply_62 { void badSource(int &data); void bad() { int data; data = 0; badSource(data); if(data > 0) { int result = data * 2; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  * 2;
<start> printIntLine(result) <end> ;"	"badSource <start> data <end> );
int result = <start> data <end>  * 2;"	"if <start> data > 0 <end> ) ;
badSource <start> data <end> );"	"int result = <start> data <end>  * 2;
badSource <start> data <end> );"	1
60db83bd-6c15-11ed-81d4-94e6f77dd552	"void CWE190_Integer_Overflow__char_rand_multiply_12_bad() { char data; data = ' '; if(globalReturnsTrueOrFalse()) { data = (char)RAND32(); } else { data = 2; } if(globalReturnsTrueOrFalse()) { if(data > 0) { char result = data * 2; printHexCharLine(result); } } else { if(data > 0) { if (data < (CHAR_MAX/2)) { char result = data * 2; printHexCharLine(result); } else { printLine(""data value is too large to perform arithmetic safely.""); } } } }"	where is the vulnerable dataflow from data ?	"<start> data = 2 <end> ;
data = (char <start> RAND32() <end> ;"	"<start> printHexCharLine(result) <end> ;
data = (char <start> RAND32() <end> ;"	"char result = <start> data * 2 <end> ;
data = (char <start> RAND32() <end> ;"	"data = (char <start> RAND32() <end> ;
char result = <start> data <end>  * 2;"	3
a95fd86a-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_fgets_sub_63b_badSink(int * dataPtr) { int data = *dataPtr; { int result = data - 1; printIntLine(result); } }	where is the vulnerable dataflow from result to printIntLine ?	"void CWE191_Integer_Underflow__int_fgets_sub_63b_badSink(int * <start> dataPtr <end> );
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
int <start> result = data - 1 <end> ;"	"printIntLine <start> result <end> );
int result = <start> data - 1 <end> ;"	"void CWE191_Integer_Underflow__int_fgets_sub_63b_badSink(int * <start> dataPtr <end> );
int result = <start> data - 1 <end> ;"	0
584fa89d-6c15-11ed-81d4-94e6f77dd552	"void CWE191_Integer_Underflow__short_fscanf_multiply_13_bad() { short data; data = 0; if(GLOBAL_CONST_FIVE==5) { fscanf (stdin, ""%hd"", &data); } if(GLOBAL_CONST_FIVE==5) { if(data < 0) { short result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"short result = <start> data * 2 <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );"	"short result = <start> data <end>  * 2;
fscanf (stdin, ""%hd"", <start> &data <end> );"	"fscanf (stdin, ""%hd"", <start> &data <end> );
short result = <start> data <end>  * 2;"	"<start> printIntLine(result) <end> ;
short result = <start> data <end>  * 2;"	2
8f278a89-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_51b_badSink(int data) { { size_t i; int *intPointer; intPointer = (int*)malloc(data * sizeof(int)); if (intPointer == NULL) {exit(-1);} for (i = 0; i < (size_t)data; i++) { intPointer[i] = 0; } printIntLine(intPointer[0]); free(intPointer); } }	where is the vulnerable dataflow from data to malloc ?	"void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_51b_badSink(int <start> data <end> );
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	"void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_51b_badSink(int <start> data <end> );
intPointer = (int* <start> malloc(data * sizeof(int)) <end> ;"	"intPointer = (int*)malloc <start> data * sizeof(int) <end> );
intPointer = (int* <start> malloc(data * sizeof(int)) <end> ;"	"intPointer = (int*)malloc <start> data * sizeof(int) <end> );
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_51b_badSink(int <start> data <end> );"	0
669edacf-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__char_rand_postinc_63b_badSink(char * dataPtr) { char data = *dataPtr; { data++; char result = data; printHexCharLine(result); } }	where is the vulnerable dataflow from data ?	"<start> data <end> ++;
<start> printHexCharLine(result) <end> ;"	"void CWE190_Integer_Overflow__char_rand_postinc_63b_badSink(char * <start> dataPtr <end> );
<start> data <end> ++;"	"<start> data <end> ++;
void CWE190_Integer_Overflow__char_rand_postinc_63b_badSink(char * <start> dataPtr <end> );"	"void CWE190_Integer_Overflow__char_rand_postinc_63b_badSink(char * <start> dataPtr <end> );
<start> printHexCharLine(result) <end> ;"	1
5133a72c-6c15-11ed-81d4-94e6f77dd552	"static int badStatic = 0; static void badSink(int64_t data) { if(badStatic) { { ++data; int64_t result = data; printLongLongLine(result); } } } void CWE190_Integer_Overflow__int64_t_fscanf_preinc_21_bad() { int64_t data; data = 0LL; fscanf (stdin, ""%"" SCNd64, &data); badStatic = 1; badSink(data); }"	where is the vulnerable dataflow from data ?	"fscanf (stdin, ""%"" SCNd64, <start> &data <end> );
static void badSink(int64_t <start> data <end> );"	"static void badSink(int64_t <start> data <end> );
fscanf (stdin, ""%"" SCNd64, <start> &data <end> );
badSink <start> data <end> );"	"fscanf (stdin, ""%"" SCNd64, <start> &data <end> );
badSink <start> data <end> );
static void badSink(int64_t <start> data <end> );
+ <start> data <end> ;"	"static void badSink(int64_t <start> data <end> );
fscanf (stdin, ""%"" SCNd64, <start> &data <end> );
badSink <start> data <end> );
+ <start> data <end> ;"	2
a23a3e3e-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__int_fgets_multiply_74 { void badSink(map<int, int> dataMap) { int data = dataMap[2]; if(data > 0) { int result = data * 2; printIntLine(result); } }	where is the vulnerable dataflow from result to printIntLine ?	"void badSink(map<int, int> <start> dataMap <end> );
printIntLine <start> result <end> );"	"void badSink(map<int, int> <start> dataMap <end> );
int <start> result = data * 2 <end> ;"	"printIntLine <start> result <end> );
int <start> result = data * 2 <end> ;"	"printIntLine <start> result <end> );
void badSink(map<int, int> <start> dataMap <end> );"	0
c5fc2347-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif namespace CWE23_Relative_Path_Traversal__char_file_ifstream_54 { void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } badSink_b(data); }"	where is the vulnerable dataflow from data to badSink_b ?	"badSink_b <start> data <end> );
<start> data = dataBuffer <end> ;"	"badSink_b <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
badSink_b <start> data <end> );"	"badSink_b <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	2
b41b87b2-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 20 #define IP_ADDRESS ""127.0.0.1"" void CWE369_Divide_by_Zero__float_connect_socket_65b_badSink(float data) { { int result = (int)(100.0 / data); printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	"void CWE369_Divide_by_Zero__float_connect_socket_65b_badSink(float <start> data <end> );
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
int <start> result = (int)(100.0 / data) <end> ;"	"printIntLine <start> result <end> );
void CWE369_Divide_by_Zero__float_connect_socket_65b_badSink(float <start> data <end> );"	1
6c938bef-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif void CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_02_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; if(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(1) { { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } } }"	where is the vulnerable dataflow from dest to printLine ?	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
printLine <start> dest <end> );"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
replace = <start> strchr(data, '\n') <end> ;"	"size_t dataLen = <start> strlen(data) <end> ;
printLine <start> dest <end> );"	"printLine <start> dest <end> );
replace = <start> strchr(data, '\n') <end> ;"	0
a830bf9f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_connect_socket_sub_15_bad() { int data; data = 0; switch(6) { case 6: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; default: printLine(""Benign, fixed string""); break; } switch(7) { case 7: { int result = data - 1; printIntLine(result); } break; default: printLine(""Benign, fixed string""); break; } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printIntLine(result) <end> ;"	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> result <end> );"	0
8cc3a652-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(count) + 2) #ifdef _WIN32 #define SLEEP Sleep #else #define SLEEP usleep #endif void CWE400_Resource_Exhaustion__connect_socket_sleep_14_bad() { int count; count = -1; if(globalFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; count = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalFive==5) { SLEEP(count); printLine(""Sleep time possibly too long""); } }"	where is the vulnerable dataflow from count to SLEEP ?	"SLEEP <start> count <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"<start> count = -1 <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"SLEEP <start> count <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
SLEEP <start> count <end> );"	3
47a2a825-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__int_fscanf_add_66b_badSink(int dataArray[]) { int data = dataArray[2]; { int result = data + 1; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  + 1;
void CWE190_Integer_Overflow__int_fscanf_add_66b_badSink(int <start> dataArray <end> []);"	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  + 1;"	"int <start> result = data + 1 <end> ;
void CWE190_Integer_Overflow__int_fscanf_add_66b_badSink(int <start> dataArray <end> []);"	"void CWE190_Integer_Overflow__int_fscanf_add_66b_badSink(int <start> dataArray <end> []);
int result = <start> data <end>  + 1;"	3
c4cd6f42-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_environment_open_22 { int badGlobal = 0; char * badSource(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; badGlobal = 1; data = badSource(data); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } ; }"	where is the vulnerable dataflow from data to OPEN ?	"data = <start> badSource <end> (data);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"data = <start> badSource <end> (data);
fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
<start> data = badSource(data) <end> ;"	"data = <start> badSource <end> (data);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	3
9c455197-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE124_Buffer_Underwrite__CWE839_listen_socket_82 { void bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE124_Buffer_Underwrite__CWE839_listen_socket_82_base* baseObject = new CWE124_Buffer_Underwrite__CWE839_listen_socket_82_bad; baseObject->action(data); delete baseObject; }"	where is the vulnerable dataflow from data to action ?	"baseObject->action <start> data <end> );
<start> recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"baseObject->action <start> data <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
baseObject->action <start> data <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
baseObject->action <start> data <end> );"	3
7ae3a719-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int badSource(int data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } return data; } void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_42_bad() { int data; data = -1; data = badSource(data); { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static int <start> badSource <end> (int data);
data = <start> badSource <end> (data);
printLine <start> dest <end> );"	"static int <start> badSource <end> (int data);
<start> printLine(dest) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"<start> memmove(dest, source, data) <end> ;
printLine <start> dest <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
data = <start> badSource <end> (data);"	"static int <start> badSource <end> (int data);
printLine <start> dest <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
if  <start> data < 100 <end> );"	0
b7b09a4b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define NEW_PATH ""%SystemRoot%\\system32"" #define PUTENV _putenv #else #define NEW_PATH ""/bin"" #define PUTENV putenv #endif namespace CWE427_Uncontrolled_Search_Path_Element__char_console_73 { void badSink(list<char *> dataList) { char * data = dataList.back(); PUTENV(data); }"	where is the vulnerable dataflow from data to PUTENV ?	"void badSink(list<char *> <start> dataList <end> );
PUTENV <start> data <end> );"	"<start> PUTENV(data) <end> ;
void badSink(list<char *> <start> dataList <end> );"	"<start> PUTENV(data) <end> ;
PUTENV <start> data <end> );"	"PUTENV <start> data <end> );
void badSink(list<char *> <start> dataList <end> );"	0
a830bfaa-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink(int data) { { int result = data - 1; printIntLine(result); } } void CWE191_Integer_Underflow__int_connect_socket_sub_44_bad() { int data; void (*funcPtr) (int) = badSink; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } funcPtr(data); }"	where is the vulnerable dataflow from result to printIntLine ?	"<start> funcPtr(data) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
funcPtr <start> data <end> );
static void badSink(int <start> data <end> );"	"<start> data = atoi(inputBuffer) <end> ;
printIntLine <start> result <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static void badSink(int <start> data <end> );"	"funcPtr <start> data <end> );
static void badSink(int <start> data <end> );
int <start> result = data - 1 <end> ;
printIntLine <start> result <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
funcPtr <start> data <end> );
static void badSink(int <start> data <end> );
printIntLine <start> result <end> );"	3
c1366269-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif namespace CWE23_Relative_Path_Traversal__char_console_ifstream_15 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; switch(6) { case 6: { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } break; default: printLine(""Benign, fixed string""); break; } { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
inputFile.open((char * <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
dataLen = <start> strlen(data) <end> ;"	"size_t dataLen = <start> strlen(data) <end> ;
inputFile.open((char * <start> data <end> );"	"inputFile.open((char * <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	0
8df421df-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define PATH_SZ 100 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define PATH_SZ PATH_MAX #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 void CWE605_Multiple_Binds_Same_Port__basic_14_bad() { if(globalFive==5) { { char data[100] = """"; #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); #ifdef _WIN32 BOOL bOptVal = TRUE; int bOptLen = sizeof(BOOL); #else int bOptVal = 1; int bOptLen = sizeof(int); #endif do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } if (setsockopt(listenSocket, SOL_SOCKET, SO_REUSEADDR, (char*)&bOptVal, bOptLen) != 0) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, data+dataLen, (int)(100-dataLen-1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[recvResult] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif printLine(data); } } }"	where is the vulnerable dataflow from data to printLine ?	"replace = <start> strchr(data, '\n') <end> ;
printLine <start> data <end> );"	"recvResult = recv(acceptSocket, <start> data+dataLen <end> , (int)(100-dataLen-1), 0);
replace = <start> strchr(data, '\n') <end> ;"	"printLine <start> data <end> );
recvResult = recv(acceptSocket, <start> data+dataLen <end> , (int)(100-dataLen-1), 0);"	"recvResult = recv(acceptSocket, <start> data+dataLen <end> , (int)(100-dataLen-1), 0);
printLine <start> data <end> );"	3
6c938be2-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_64b_badSink(void * dataVoidPtr) { int * dataPtr = (int *)dataVoidPtr; int data = (*dataPtr); { int i; int * buffer = (int *)malloc(10 * sizeof(int)); if (buffer == NULL) {exit(-1);} for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } free(buffer); } }"	where is the vulnerable dataflow from buffer to free ?	"free <start> buffer <end> );
if  <start> buffer == NULL <end> ) {exit(-1);};"	"int <start> * buffer = (int *)malloc(10 * sizeof(int)) <end> ;
free <start> buffer <end> );"	"void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_64b_badSink(void * <start> dataVoidPtr <end> );
free <start> buffer <end> );"	"<start> free(buffer) <end> ;
void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_64b_badSink(void * <start> dataVoidPtr <end> );"	2
b7b09a3a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define NEW_PATH ""%SystemRoot%\\system32"" #define PUTENV _putenv #else #define NEW_PATH ""/bin"" #define PUTENV putenv #endif void CWE427_Uncontrolled_Search_Path_Element__char_console_16_bad() { char * data; char dataBuffer[250] = ""PATH=""; data = dataBuffer; while(1) { { size_t dataLen = strlen(data); if (250-dataLen > 1) { if (fgets(data+dataLen, (int)(250-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } break; } PUTENV(data); }"	where is the vulnerable dataflow from data to PUTENV ?	"<start> PUTENV(data) <end> ;
PUTENV <start> data <end> );"	"PUTENV <start> data <end> );
if (dataLen > 0 && <start> data[dataLen-1] == '\n' <end> );"	"if (fgets <start> data+dataLen <end> , (int)(250-dataLen), stdin) != NULL);
PUTENV <start> data <end> );"	"<start> data = dataBuffer <end> ;
PUTENV <start> data <end> );"	2
99e16a9e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } void CWE124_Buffer_Underwrite__CWE839_connect_socket_08_bad() { int data; data = -1; if(staticReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticReturnsTrue()) { { int i; int buffer[10] = { 0 }; if (data < 10) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } } } }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> buffer[i] <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[i] <end> );"	"<start> printIntLine(buffer[i]) <end> ;
printIntLine <start> buffer[i] <end> );"	"printIntLine <start> buffer[i] <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	1
abc37536-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_listen_socket_postdec_01_bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { data--; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"<start> printIntLine(result) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"printIntLine <start> result <end> );
if  <start> recvResult == SOCKET_ERROR <end>  || recvResult == 0);"	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;"	0
73bc8124-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" void CWE194_Unexpected_Sign_Extension__connect_socket_malloc_41_badSink(short data) { if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } } void CWE194_Unexpected_Sign_Extension__connect_socket_malloc_41_bad() { short data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE194_Unexpected_Sign_Extension__connect_socket_malloc_41_badSink(data); }"	where is the vulnerable dataflow from data to malloc ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
CWE194_Unexpected_Sign_Extension__connect_socket_malloc_41_badSink <start> data <end> );
void CWE194_Unexpected_Sign_Extension__connect_socket_malloc_41_badSink(short <start> data <end> );
char * dataBuffer = (char *)malloc <start> data <end> );"	"if  <start> dataBuffer == NULL <end> ) {exit(-1);};
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
CWE194_Unexpected_Sign_Extension__connect_socket_malloc_41_badSink <start> data <end> );
char * dataBuffer = (char *)malloc <start> data <end> );"	"if  <start> dataBuffer == NULL <end> ) {exit(-1);};
void CWE194_Unexpected_Sign_Extension__connect_socket_malloc_41_badSink(short <start> data <end> );
char * dataBuffer = (char *)malloc <start> data <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"CWE194_Unexpected_Sign_Extension__connect_socket_malloc_41_badSink <start> data <end> );
char * dataBuffer = (char *)malloc <start> data <end> );
char <start> * dataBuffer = (char *)malloc(data) <end> ;
void CWE194_Unexpected_Sign_Extension__connect_socket_malloc_41_badSink(short <start> data <end> );"	0
9c4551a5-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE126_Buffer_Overread__CWE129_connect_socket_14_bad() { int data; data = -1; if(globalFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalFive==5) { { int buffer[10] = { 0 }; if (data >= 0) { printIntLine(buffer[data]); } else { printLine(""ERROR: Array index is negative""); } } } }"	where is the vulnerable dataflow from buffer[data] to printIntLine ?	"<start> printIntLine(buffer[data]) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"printIntLine <start> buffer[data] <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> buffer[data] <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[data] <end> );"	3
5be3a9e3-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int CWE191_Integer_Underflow__int_listen_socket_postdec_45_badData; static int CWE191_Integer_Underflow__int_listen_socket_postdec_45_goodG2BData; static int CWE191_Integer_Underflow__int_listen_socket_postdec_45_goodB2GData; static void badSink() { int data = CWE191_Integer_Underflow__int_listen_socket_postdec_45_badData; { data--; int result = data; printIntLine(result); } } void CWE191_Integer_Underflow__int_listen_socket_postdec_45_bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE191_Integer_Underflow__int_listen_socket_postdec_45_badData = data; badSink(); }"	where is the vulnerable dataflow from data ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> CWE191_Integer_Underflow__int_listen_socket_postdec_45_badData = data <end> ;
static int <start> CWE191_Integer_Underflow__int_listen_socket_postdec_45_badData <end> ;
int data = <start> CWE191_Integer_Underflow__int_listen_socket_postdec_45_badData <end> ;
<start> data <end> --;"	"<start> CWE191_Integer_Underflow__int_listen_socket_postdec_45_badData = data <end> ;
int data = <start> CWE191_Integer_Underflow__int_listen_socket_postdec_45_badData <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static int <start> CWE191_Integer_Underflow__int_listen_socket_postdec_45_badData <end> ;
if  <start> listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static int <start> CWE191_Integer_Underflow__int_listen_socket_postdec_45_badData <end> ;
<start> data <end> --;
<start> CWE191_Integer_Underflow__int_listen_socket_postdec_45_badData = data <end> ;"	"<start> printIntLine(result) <end> ;
int data = <start> CWE191_Integer_Underflow__int_listen_socket_postdec_45_badData <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> CWE191_Integer_Underflow__int_listen_socket_postdec_45_badData = data <end> ;
<start> data <end> --;"	0
7d44fc90-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_17_bad() { int i; int data; data = -1; for(i = 0; i < 1; i++) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> strncpy(dest, source, data) <end> ;
printLine <start> dest <end> );"	"printLine <start> dest <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
char <start> inputBuffer[CHAR_ARRAY_SIZE] = """" <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printLine <start> dest <end> );"	3
c4cd6f48-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_environment_open_44 { static void badSink(char * data) { { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } } void bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } funcPtr(data); }"	where is the vulnerable dataflow from data to funcPtr ?	"funcPtr <start> data <end> );
strncat(data+dataLen, environment, <start> FILENAME_MAX-dataLen-1 <end> );"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
funcPtr <start> data <end> );"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
size_t dataLen = <start> strlen(data) <end> ;"	"fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	1
cf8750ad-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } namespace CWE36_Absolute_Path_Traversal__char_file_fopen_08 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(staticReturnsTrue()) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"size_t dataLen = <start> strlen(data) <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	0
8df4220d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define PATH_SZ 100 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define PATH_SZ PATH_MAX #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; void CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__bind_accept_listen_04_bad() { if(STATIC_CONST_TRUE) { { char data[100] = """"; #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[recvResult] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif printLine(data); } } }"	where is the vulnerable dataflow from data to printLine ?	"recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);
size_t dataLen = <start> strlen(data) <end> ;"	"printLine <start> data <end> );
recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);"	"<start> recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0) <end> ;
printLine <start> data <end> );"	"recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);
printLine <start> data <end> );"	3
4db33f77-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_postinc_17_bad() { int i,j; int data; data = 0; for(i = 0; i < 1; i++) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } for(j = 0; j < 1; j++) { { data++; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int <start> result = data <end> ;"	"<start> data <end> ++;
int <start> result = data <end> ;"	"<start> printIntLine(result) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data <end> ++;"	3
7fa68e36-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_connect_socket_fopen_31 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { char * dataCopy = data; char * data = dataCopy; { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } } }"	where is the vulnerable dataflow from data to FOPEN ?	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	"size_t dataLen = <start> strlen(data) <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - <start> dataLen - 1 <end> ), 0);"	"char <start> * dataCopy = data <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	0
c72d5d73-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; namespace CWE23_Relative_Path_Traversal__char_listen_socket_ifstream_04 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(STATIC_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"recvResult = <start> recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0) <end> ;
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"size_t dataLen = <start> strlen(data) <end> ;
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
inputFile.open((char * <start> data <end> );"	"replace = <start> strchr(data, '\n') <end> ;
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	2
d0b64eda-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif namespace CWE36_Absolute_Path_Traversal__char_file_ifstream_51 { void badSink(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } badSink(data); }"	where is the vulnerable dataflow from data to badSink ?	"badSink <start> data <end> );
<start> data = dataBuffer <end> ;"	"<start> badSink(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
badSink <start> data <end> );"	"size_t dataLen = <start> strlen(data) <end> ;
badSink <start> data <end> );"	2
445c11fd-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int badSource(int data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } return data; } void CWE190_Integer_Overflow__int_connect_socket_add_42_bad() { int data; data = 0; data = badSource(data); { int result = data + 1; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"data = <start> badSource <end> (data);
static int <start> badSource <end> (int data);
data = <start> atoi(inputBuffer) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static int <start> badSource <end> (int data);
data = <start> badSource <end> (data);
int result = <start> data <end>  + 1;"	"static int <start> badSource <end> (int data);
data = <start> badSource <end> (data);
int result = <start> data <end>  + 1;
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"static int <start> badSource <end> (int data);
data = <start> badSource <end> (data);
int <start> result = data + 1 <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	1
761e299a-6c15-11ed-81d4-94e6f77dd552	"namespace CWE194_Unexpected_Sign_Extension__fgets_memmove_74 { void badSink(map<int, short> dataMap) { short data = dataMap[2]; { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"void badSink(map<int, short> <start> dataMap <end> );
printLine <start> dest <end> );"	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	"void badSink(map<int, short> <start> dataMap <end> );
<start> memmove(dest, source, data) <end> ;"	"<start> memmove(dest, source, data) <end> ;
printLine <start> dest <end> );"	0
761e295d-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 8 namespace CWE194_Unexpected_Sign_Extension__fgets_memcpy_43 { static void badSource(short &data) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = (short)atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } void bad() { short data; data = 0; badSource(data); { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"badSource <start> data <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
if  <start> data < 100 <end> );"	"badSource <start> data <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printLine <start> dest <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
badSource <start> data <end> );
printLine <start> dest <end> );"	"if  <start> data < 100 <end> );
printLine <start> dest <end> );
badSource <start> data <end> );"	2
bda4e420-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define EXECL _execl #else #define EXECL execl #endif static int badStatic = 0; static char * badSource(char * data) { if(badStatic) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } return data; } void CWE78_OS_Command_Injection__char_listen_socket_execl_21_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; badStatic = 1; data = badSource(data); EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECL ?	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"data = <start> badSource <end> (data);
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
static char * <start> badSource <end> (char * data);
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"data = <start> badSource <end> (data);
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
<start> EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL) <end> ;
static char * <start> badSource <end> (char * data);"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (100 - dataLen - 1), 0);
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
data = <start> badSource <end> (data);"	0
d0b64efe-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; namespace CWE36_Absolute_Path_Traversal__char_file_open_04 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(STATIC_CONST_TRUE) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
size_t dataLen = <start> strlen(data) <end> ;"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	1
8df421db-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define PATH_SZ 100 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define PATH_SZ PATH_MAX #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 void CWE605_Multiple_Binds_Same_Port__basic_10_bad() { if(globalTrue) { { char data[100] = """"; #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); #ifdef _WIN32 BOOL bOptVal = TRUE; int bOptLen = sizeof(BOOL); #else int bOptVal = 1; int bOptLen = sizeof(int); #endif do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } if (setsockopt(listenSocket, SOL_SOCKET, SO_REUSEADDR, (char*)&bOptVal, bOptLen) != 0) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, data+dataLen, (int)(100-dataLen-1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[recvResult] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif printLine(data); } } }"	where is the vulnerable dataflow from data to printLine ?	"printLine <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	"size_t dataLen = <start> strlen(data) <end> ;
recvResult = recv(acceptSocket, <start> data+dataLen <end> , (int)(100-dataLen-1), 0);"	"recvResult = recv(acceptSocket, <start> data+dataLen <end> , (int)(100-dataLen-1), 0);
printLine <start> data <end> );"	"printLine <start> data <end> );
recvResult = recv(acceptSocket, <start> data+dataLen <end> , (int)(100-dataLen-1), 0);"	2
d0b64ed8-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif namespace CWE36_Absolute_Path_Traversal__char_file_ifstream_44 { static void badSink(char * data) { { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } } void bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } funcPtr(data); }"	where is the vulnerable dataflow from data to funcPtr ?	"<start> data = dataBuffer <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
funcPtr <start> data <end> );"	"<start> funcPtr(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"char <start> dataBuffer[FILENAME_MAX] = """" <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	1
9187cbd8-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define SEARCH_CHAR 'S' void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_14_bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\0'; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } if(globalFive==5) { for (; *data != '\0'; data++) { if (*data == SEARCH_CHAR) { printLine(""We have a match!""); break; } } free(data); } }"	where is the vulnerable dataflow from data to free ?	"replace = <start> strchr(data, '\r') <end> ;
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"for (; *data != '\0'; <start> data++ <end> );
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
free <start> data <end> );"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
<start> free(data) <end> ;"	2
630ae812-6c15-11ed-81d4-94e6f77dd552	static void badSink(short data) { { short result = data * data; printIntLine(result); } } void CWE190_Integer_Overflow__short_rand_square_41_bad() { short data; data = 0; data = (short)RAND32(); badSink(data); }	where is the vulnerable dataflow from data ?	"badSink <start> data <end> );
data = (short <start> RAND32() <end> ;
static void badSink(short <start> data <end> );
short result = <start> data <end>  * data;"	"static void badSink(short <start> data <end> );
badSink <start> data <end> );
short <start> result = data * data <end> ;
data = (short <start> RAND32() <end> ;"	"<start> data = (short)RAND32() <end> ;
data = (short <start> RAND32() <end> ;
badSink <start> data <end> );
static void badSink(short <start> data <end> );"	"data = (short <start> RAND32() <end> ;
badSink <start> data <end> );
static void badSink(short <start> data <end> );
short result = <start> data <end>  * data;"	3
cac216ba-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" namespace CWE36_Absolute_Path_Traversal__char_connect_socket_ofstream_15 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; switch(6) { case 6: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; default: printLine(""Benign, fixed string""); break; } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"size_t dataLen = <start> strlen(data) <end> ;
outputFile.open((char * <start> data <end> );"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
replace = <start> strchr(data, '\r') <end> ;"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
outputFile.open((char * <start> data <end> );"	"<start> data = dataBuffer <end> ;
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	2
87ff9848-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_connect_socket_fopen_14 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(globalFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = FOPEN <start> data <end> , ""wb+"");
char <start> dataBuffer[FILENAME_MAX] = """" <end> ;"	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	2
c99197f4-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_connect_socket_fopen_54 { void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badSink_b(data); }"	where is the vulnerable dataflow from data to badSink_b ?	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
recvResult = recv(connectSocket, (char *)(data + dataLen), <start> sizeof(char) * (FILENAME_MAX - dataLen - 1) <end> , 0);"	"badSink_b <start> data <end> );
char <start> dataBuffer[FILENAME_MAX] = """" <end> ;"	"badSink_b <start> data <end> );
recvResult = recv(connectSocket, (char *)(data + dataLen), <start> sizeof(char) * (FILENAME_MAX - dataLen - 1) <end> , 0);"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
badSink_b <start> data <end> );"	3
cac216da-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_connect_socket_open_16 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; while(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
size_t dataLen = <start> strlen(data) <end> ;"	"replace = <start> strchr(data, '\n') <end> ;
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
char <start> dataBuffer[FILENAME_MAX] = """" <end> ;"	0
5be3a9cb-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_listen_socket_postdec_01_bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { data--; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data <end> --;"	"<start> printIntLine(result) <end> ;
<start> data <end> --;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printIntLine(result) <end> ;"	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
<start> data <end> --;"	0
ce547d35-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_environment_fopen_72 { void badSink(vector<char *> dataVector) { char * data = dataVector[2]; { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"void badSink(vector<char *> <start> dataVector <end> );
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
void badSink(vector<char *> <start> dataVector <end> );"	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
void badSink(vector<char *> <start> dataVector <end> );"	"char <start> * data = dataVector[2] <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	0
61da671e-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__short_rand_add_62 { void badSource(short &data); void bad() { short data; data = 0; badSource(data); { short result = data + 1; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"<start> data = 0 <end> ;
badSource <start> data <end> );"	"badSource <start> data <end> );
<start> printIntLine(result) <end> ;"	"short result = <start> data <end>  + 1;
badSource <start> data <end> );"	"badSource <start> data <end> );
short result = <start> data <end>  + 1;"	3
893217bd-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif static int staticFive = 5; namespace CWE36_Absolute_Path_Traversal__char_console_fopen_07 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(staticFive==5) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"char <start> dataBuffer[FILENAME_MAX] = """" <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
pFile = FOPEN <start> data <end> , ""wb+"");"	"dataLen = <start> strlen(data) <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	1
5be3a9af-6c15-11ed-81d4-94e6f77dd552	"static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } void CWE191_Integer_Underflow__int_fscanf_postdec_08_bad() { int data; data = 0; if(staticReturnsTrue()) { fscanf(stdin, ""%d"", &data); } if(staticReturnsTrue()) { { data--; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"int <start> result = data <end> ;
fscanf(stdin, ""%d"", <start> &data <end> );"	"<start> data <end> --;
int <start> result = data <end> ;"	"<start> printIntLine(result) <end> ;
fscanf(stdin, ""%d"", <start> &data <end> );"	"fscanf(stdin, ""%d"", <start> &data <end> );
<start> data <end> --;"	3
c5fc2345-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif namespace CWE23_Relative_Path_Traversal__char_file_ifstream_52 { void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } badSink_b(data); }"	where is the vulnerable dataflow from data to badSink_b ?	"<start> data = dataBuffer <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"badSink_b <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
badSink_b <start> data <end> );"	"size_t dataLen = <start> strlen(data) <end> ;
badSink_b <start> data <end> );"	2
80d98715-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_console_fopen_64 { void badSink(void * dataVoidPtr) { char * * dataPtr = (char * *)dataVoidPtr; char * data = (*dataPtr); { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"char <start> * data = (*dataPtr) <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"void badSink(void * <start> dataVoidPtr <end> );
pFile = FOPEN <start> data <end> , ""wb+"");"	"void badSink(void * <start> dataVoidPtr <end> );
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	"pFile = FOPEN <start> data <end> , ""wb+"");
void badSink(void * <start> dataVoidPtr <end> );"	1
cac216b2-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" static int staticFive = 5; namespace CWE36_Absolute_Path_Traversal__char_connect_socket_ofstream_07 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(staticFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"outputFile.open((char * <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	"outputFile.open((char * <start> data <end> );
replace = <start> strchr(data, '\r') <end> ;"	"outputFile.open((char * <start> data <end> );
size_t <start> dataLen = strlen(data) <end> ;"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
outputFile.open((char * <start> data <end> );"	3
c1366245-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_console_fopen_17 { void bad() { int i; char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; for(i = 0; i < 1; i++) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
dataLen = <start> strlen(data) <end> ;"	"pFile = FOPEN <start> data <end> , ""wb+"");
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	2
5be3a9a5-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_fgets_postdec_66b_badSink(int dataArray[]) { int data = dataArray[2]; { data--; int result = data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"void CWE191_Integer_Underflow__int_fgets_postdec_66b_badSink(int <start> dataArray <end> []);
int <start> result = data <end> ;"	"<start> printIntLine(result) <end> ;
void CWE191_Integer_Underflow__int_fgets_postdec_66b_badSink(int <start> dataArray <end> []);"	"void CWE191_Integer_Underflow__int_fgets_postdec_66b_badSink(int <start> dataArray <end> []);
<start> data <end> --;"	"int <start> result = data <end> ;
<start> data <end> --;"	2
c39a6579-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_environment_fopen_54 { void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } badSink_b(data); }"	where is the vulnerable dataflow from data to badSink_b ?	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
badSink_b <start> data <end> );"	"badSink_b <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	"badSink_b <start> data <end> );
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"size_t <start> dataLen = strlen(data) <end> ;
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	0
453db04f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_square_54e_badSink(int data) { { int result = data * data; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  * data;"	"void CWE190_Integer_Overflow__int_connect_socket_square_54e_badSink(int <start> data <end> );
int result = <start> data <end>  * data;"	"int result = <start> data <end>  * data;
void CWE190_Integer_Overflow__int_connect_socket_square_54e_badSink(int <start> data <end> );"	"void CWE190_Integer_Overflow__int_connect_socket_square_54e_badSink(int <start> data <end> );
int result = <start> data * data <end> ;"	1
78800feb-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 8 void CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_51b_badSink(short data) { { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"void CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_51b_badSink(short <start> data <end> );
<start> strncpy(dest, source, data) <end> ;"	"void CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_51b_badSink(short <start> data <end> );
printLine <start> dest <end> );"	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	"<start> strncpy(dest, source, data) <end> ;
printLine <start> dest <end> );"	1
55ef4cd6-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int badSource(int data) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } return data; } void CWE191_Integer_Underflow__int_fgets_sub_42_bad() { int data; data = 0; data = badSource(data); { int result = data - 1; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  - 1;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
static int <start> badSource <end> (int data);
data = <start> badSource <end> (data);"	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  - 1;
data = <start> badSource <end> (data);
static int <start> badSource <end> (int data);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
static int <start> badSource <end> (int data);
data = <start> badSource <end> (data);
int result = <start> data <end>  - 1;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
data = <start> badSource <end> (data);
<start> printIntLine(result) <end> ;
static int <start> badSource <end> (int data);"	2
4a021140-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) typedef struct _CWE190_Integer_Overflow__int_listen_socket_square_67_structType { int structFirst; } CWE190_Integer_Overflow__int_listen_socket_square_67_structType; void CWE190_Integer_Overflow__int_listen_socket_square_67b_badSink(CWE190_Integer_Overflow__int_listen_socket_square_67_structType myStruct) { int data = myStruct.structFirst; { int result = data * data; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
int data = <start> myStruct <end> .structFirst;
int result = <start> data <end>  * data;"	"int data = <start> myStruct <end> .structFirst;
<start> printIntLine(result) <end> ;
void CWE190_Integer_Overflow__int_listen_socket_square_67b_badSink(CWE190_Integer_Overflow__int_listen_socket_square_67_structType <start> myStruct <end> );"	"int <start> result = data * data <end> ;
void CWE190_Integer_Overflow__int_listen_socket_square_67b_badSink(CWE190_Integer_Overflow__int_listen_socket_square_67_structType <start> myStruct <end> );
int data = <start> myStruct <end> .structFirst;"	"void CWE190_Integer_Overflow__int_listen_socket_square_67b_badSink(CWE190_Integer_Overflow__int_listen_socket_square_67_structType <start> myStruct <end> );
int data = <start> myStruct <end> .structFirst;
int result = <start> data <end>  * data;"	3
669edabb-6c15-11ed-81d4-94e6f77dd552	"void CWE190_Integer_Overflow__char_rand_postinc_12_bad() { char data; data = ' '; if(globalReturnsTrueOrFalse()) { data = (char)RAND32(); } else { data = 2; } if(globalReturnsTrueOrFalse()) { { data++; char result = data; printHexCharLine(result); } } else { if (data < CHAR_MAX) { data++; char result = data; printHexCharLine(result); } else { printLine(""data value is too large to perform arithmetic safely.""); } } }"	where is the vulnerable dataflow from data ?	"data = (char <start> RAND32() <end> ;
<start> data <end> ++;"	"<start> printHexCharLine(result) <end> ;
data = (char <start> RAND32() <end> ;"	"<start> data = 2 <end> ;
<start> data <end> ++;"	"<start> printHexCharLine(result) <end> ;
<start> data <end> ++;"	0
69161b37-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__int_rand_preinc_17_bad() { int i,j; int data; data = 0; for(i = 0; i < 1; i++) { data = RAND32(); } for(j = 0; j < 1; j++) { { ++data; int result = data; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
+ <start> data <end> ;"	"+ <start> data <end> ;
data = <start> RAND32() <end> ;"	"int <start> result = data <end> ;
data = <start> RAND32() <end> ;"	"data = <start> RAND32() <end> ;
+ <start> data <end> ;"	3
538bfae4-6c15-11ed-81d4-94e6f77dd552	"static int badStatic = 0; static void badSink(unsigned int data) { if(badStatic) { { ++data; unsigned int result = data; printUnsignedLine(result); } } } void CWE190_Integer_Overflow__unsigned_int_fscanf_preinc_21_bad() { unsigned int data; data = 0; fscanf (stdin, ""%u"", &data); badStatic = 1; badSink(data); }"	where is the vulnerable dataflow from data ?	"badSink <start> data <end> );
+ <start> data <end> ;
fscanf (stdin, ""%u"", <start> &data <end> );
static void badSink(unsigned int <start> data <end> );"	"fscanf (stdin, ""%u"", <start> &data <end> );
badSink <start> data <end> );
static void badSink(unsigned int <start> data <end> );
+ <start> data <end> ;"	"badSink <start> data <end> );
<start> badSink(data) <end> ;
static void badSink(unsigned int <start> data <end> );
+ <start> data <end> ;"	"<start> data = 0 <end> ;
badSink <start> data <end> );
+ <start> data <end> ;
static void badSink(unsigned int <start> data <end> );"	1
6b86243c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_connect_socket_64b_badSink(void * dataVoidPtr) { int * dataPtr = (int *)dataVoidPtr; int data = (*dataPtr); { int i; int * buffer = (int *)malloc(10 * sizeof(int)); if (buffer == NULL) {exit(-1);} for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } free(buffer); } }"	where is the vulnerable dataflow from buffer to free ?	"void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_connect_socket_64b_badSink(void * <start> dataVoidPtr <end> );
free <start> buffer <end> );"	"free <start> buffer <end> );
<start> free(buffer) <end> ;"	"<start> printIntLine(buffer[i]) <end> ;
free <start> buffer <end> );"	"int <start> * buffer = (int *)malloc(10 * sizeof(int)) <end> ;
free <start> buffer <end> );"	0
c39a65b4-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif namespace CWE23_Relative_Path_Traversal__char_environment_ofstream_17 { void bad() { int i; char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; for(i = 0; i < 1; i++) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
outputFile.open((char * <start> data <end> );"	"outputFile.open((char * <start> data <end> );
<start> data = dataBuffer <end> ;"	"strncat <start> data+dataLen <end> , environment, FILENAME_MAX-dataLen-1);
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"char <start> dataBuffer[FILENAME_MAX] = BASEPATH <end> ;
outputFile.open((char * <start> data <end> );"	0
54c581f7-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int CWE191_Integer_Underflow__int_connect_socket_multiply_45_badData; static int CWE191_Integer_Underflow__int_connect_socket_multiply_45_goodG2BData; static int CWE191_Integer_Underflow__int_connect_socket_multiply_45_goodB2GData; static void badSink() { int data = CWE191_Integer_Underflow__int_connect_socket_multiply_45_badData; if(data < 0) { int result = data * 2; printIntLine(result); } } void CWE191_Integer_Underflow__int_connect_socket_multiply_45_bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE191_Integer_Underflow__int_connect_socket_multiply_45_badData = data; badSink(); }"	where is the vulnerable dataflow from data ?	"static int <start> CWE191_Integer_Underflow__int_connect_socket_multiply_45_badData <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printIntLine(result) <end> ;
int data = <start> CWE191_Integer_Underflow__int_connect_socket_multiply_45_badData <end> ;
int result = <start> data <end>  * 2;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> CWE191_Integer_Underflow__int_connect_socket_multiply_45_badData = data <end> ;
static int <start> CWE191_Integer_Underflow__int_connect_socket_multiply_45_badData <end> ;
int data = <start> CWE191_Integer_Underflow__int_connect_socket_multiply_45_badData <end> ;
int result = <start> data <end>  * 2;"	"static int <start> CWE191_Integer_Underflow__int_connect_socket_multiply_45_badData <end> ;
int result = <start> data <end>  * 2;
<start> CWE191_Integer_Underflow__int_connect_socket_multiply_45_badData = data <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int data = <start> CWE191_Integer_Underflow__int_connect_socket_multiply_45_badData <end> ;"	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
static int <start> CWE191_Integer_Underflow__int_connect_socket_multiply_45_badData <end> ;
<start> CWE191_Integer_Underflow__int_connect_socket_multiply_45_badData = data <end> ;
int data = <start> CWE191_Integer_Underflow__int_connect_socket_multiply_45_badData <end> ;
int result = <start> data <end>  * 2;"	1
48d25da2-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_FIVE = 5; void CWE190_Integer_Overflow__int_listen_socket_add_06_bad() { int data; data = 0; if(STATIC_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(STATIC_CONST_FIVE==5) { { int result = data + 1; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  + 1;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int <start> result = data + 1 <end> ;"	"<start> data = atoi(inputBuffer) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
int result = <start> data <end>  + 1;"	0
715a3bf6-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif void CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_51b_badSink(char * data) { { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"void CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_51b_badSink(char * <start> data <end> );
printLine <start> dest <end> );"	"printLine <start> dest <end> );
<start> printLine(dest) <end> ;"	"<start> printLine(dest) <end> ;
void CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_51b_badSink(char * <start> data <end> );"	"printLine <start> dest <end> );
void CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_51b_badSink(char * <start> data <end> );"	0
c136627b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif namespace CWE23_Relative_Path_Traversal__char_console_ofstream_02 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(1) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
outputFile.open((char * <start> data <end> );"	"<start> data = dataBuffer <end> ;
outputFile.open((char * <start> data <end> );"	"outputFile.open((char * <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	"outputFile.open((char * <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	0
656cd3e1-6c15-11ed-81d4-94e6f77dd552	static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } void CWE190_Integer_Overflow__int_rand_multiply_08_bad() { int data; data = 0; if(staticReturnsTrue()) { data = RAND32(); } if(staticReturnsTrue()) { if(data > 0) { int result = data * 2; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"int result = <start> data * 2 <end> ;
data = <start> RAND32() <end> ;"	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  * 2;"	"data = <start> RAND32() <end> ;
int result = <start> data <end>  * 2;"	"<start> printIntLine(result) <end> ;
data = <start> RAND32() <end> ;"	2
9187cbd2-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define SEARCH_CHAR 'S' static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_08_bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\0'; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } if(staticReturnsTrue()) { for (; *data != '\0'; data++) { if (*data == SEARCH_CHAR) { printLine(""We have a match!""); break; } } free(data); } }"	where is the vulnerable dataflow from data to free ?	"if  <start> data == NULL <end> ) {exit(-1);};
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
size_t <start> dataLen = strlen(data) <end> ;"	"free <start> data <end> );
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (100 - dataLen - 1), 0);"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
free <start> data <end> );"	3
48d25d7e-6c15-11ed-81d4-94e6f77dd552	"void CWE190_Integer_Overflow__int_fscanf_square_11_bad() { int data; data = 0; if(globalReturnsTrue()) { fscanf(stdin, ""%d"", &data); } if(globalReturnsTrue()) { { int result = data * data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  * data;
fscanf(stdin, ""%d"", <start> &data <end> );"	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  * data;"	"fscanf(stdin, ""%d"", <start> &data <end> );
int result = <start> data <end>  * data;"	"fscanf(stdin, ""%d"", <start> &data <end> );
<start> data = 0 <end> ;"	2
5133a744-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) typedef union { int unionFirst; int unionSecond; } CWE190_Integer_Overflow__int_connect_socket_preinc_34_unionType; void CWE190_Integer_Overflow__int_connect_socket_preinc_34_bad() { int data; CWE190_Integer_Overflow__int_connect_socket_preinc_34_unionType myUnion; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } myUnion.unionFirst = data; { int data = myUnion.unionSecond; { ++data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
+ <start> data <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
+ <start> data <end> ;"	"+ <start> data <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"<start> ++data <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	1
7e74f328-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink(int data) { { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } } void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_44_bad() { int data; void (*funcPtr) (int) = badSink; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } funcPtr(data); }"	where is the vulnerable dataflow from dest to printLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
if  <start> recvResult == SOCKET_ERROR <end>  || recvResult == 0);
funcPtr <start> data <end> );
static void badSink(int <start> data <end> );"	"<start> memcpy(dest, source, data) <end> ;
printLine <start> dest <end> );
static void badSink(int <start> data <end> );
funcPtr <start> data <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
funcPtr <start> data <end> );
static void badSink(int <start> data <end> );
printLine <start> dest <end> );"	"printLine <start> dest <end> );
funcPtr <start> data <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> funcPtr(data) <end> ;"	2
c4cd6f6a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_file_fopen_16 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; while(1) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } break; } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = FOPEN <start> data <end> , ""wb+"");
size_t dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
size_t dataLen = <start> strlen(data) <end> ;"	1
9fe7ad5f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_add_65b_badSink(int data) { { int result = data + 1; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"void CWE190_Integer_Overflow__int_connect_socket_add_65b_badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"int <start> result = data + 1 <end> ;
void CWE190_Integer_Overflow__int_connect_socket_add_65b_badSink(int <start> data <end> );"	"printIntLine <start> result <end> );
void CWE190_Integer_Overflow__int_connect_socket_add_65b_badSink(int <start> data <end> );"	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	0
92bb89e8-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #define SEARCH_CHAR 'S' static char * badSource(char * data) { { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } return data; } void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_file_42_bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\0'; data = badSource(data); for (; *data != '\0'; data++) { if (*data == SEARCH_CHAR) { printLine(""We have a match!""); break; } } free(data); }"	where is the vulnerable dataflow from data to free ?	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
free <start> data <end> );"	"free <start> data <end> );
<start> data = badSource(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
static char * <start> badSource <end> (char * data);"	"free <start> data <end> );
for (; *data != '\0'; <start> data++ <end> );
static char * <start> badSource <end> (char * data);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	"data = <start> badSource(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
static char * <start> badSource <end> (char * data);
free <start> data <end> );"	0
48d25d92-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__int_fscanf_square_62 { void badSource(int &data); void bad() { int data; data = 0; badSource(data); { int result = data * data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"badSource <start> data <end> );
int result = <start> data <end>  * data;"	"<start> printIntLine(result) <end> ;
badSource <start> data <end> );"	"int result = <start> data * data <end> ;
badSource <start> data <end> );"	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  * data;"	0
b41b878f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 namespace CWE23_Relative_Path_Traversal__char_listen_socket_open_82 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE23_Relative_Path_Traversal__char_listen_socket_open_82_base* baseObject = new CWE23_Relative_Path_Traversal__char_listen_socket_open_82_bad; baseObject->action(data); delete baseObject; }"	where is the vulnerable dataflow from data to action ?	"if  <start> listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR <end> );
baseObject->action <start> data <end> );"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
baseObject->action <start> data <end> );"	"baseObject->action <start> data <end> );
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) *  <start> FILENAME_MAX - dataLen - 1 <end> ), 0);"	"baseObject->action <start> data <end> );
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	1
8f278a71-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_03_bad() { int data; data = -1; if(5==5) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } { size_t i; int *intPointer; intPointer = (int*)malloc(data * sizeof(int)); if (intPointer == NULL) {exit(-1);} for (i = 0; i < (size_t)data; i++) { intPointer[i] = 0; } printIntLine(intPointer[0]); free(intPointer); } }"	where is the vulnerable dataflow from data to malloc ?	"<start> data = atoi(inputBuffer) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> data = -1 <end> ;"	"data = <start> atoi(inputBuffer) <end> ;
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	1
af58092f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_45_badData; static int CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_45_goodG2BData; static void badSink() { int data = CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_45_badData; { char charData = (char)data; printHexCharLine(charData); } } void CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_45_bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_45_badData = data; badSink(); }"	where is the vulnerable dataflow from charData to printHexCharLine ?	"<start> CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_45_badData = data <end> ;
static int <start> CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_45_badData <end> ;
printHexCharLine <start> charData <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
int data = <start> CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_45_badData <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_45_badData = data <end> ;
static int <start> CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_45_badData <end> ;
int data = <start> CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_45_badData <end> ;
printHexCharLine <start> charData <end> );"	"int <start> data = CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_45_badData <end> ;
printHexCharLine <start> charData <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_45_badData = data <end> ;
static int <start> CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_45_badData <end> ;"	"int data = <start> CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_45_badData <end> ;
<start> CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_45_badData = data <end> ;
printHexCharLine <start> charData <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	1
584fa8aa-6c15-11ed-81d4-94e6f77dd552	"static void badSink(short data) { if(data < 0) { short result = data * 2; printIntLine(result); } } void CWE191_Integer_Underflow__short_fscanf_multiply_44_bad() { short data; void (*funcPtr) (short) = badSink; data = 0; fscanf (stdin, ""%hd"", &data); funcPtr(data); }"	where is the vulnerable dataflow from data ?	"if <start> data < 0 <end> ) ;
funcPtr <start> data <end> );
fscanf (stdin, ""%hd"", <start> &data <end> );
static void badSink(short <start> data <end> );"	"static void badSink(short <start> data <end> );
short result = <start> data <end>  * 2;
funcPtr <start> data <end> );
<start> printIntLine(result) <end> ;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
funcPtr <start> data <end> );
static void badSink(short <start> data <end> );
short result = <start> data <end>  * 2;"	"static void badSink(short <start> data <end> );
fscanf (stdin, ""%hd"", <start> &data <end> );
short <start> result = data * 2 <end> ;
funcPtr <start> data <end> );"	2
ce547d52-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif namespace CWE36_Absolute_Path_Traversal__char_environment_ifstream_52 { void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } badSink_b(data); }"	where is the vulnerable dataflow from data to badSink_b ?	"size_t dataLen = <start> strlen(data) <end> ;
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"strncat(data+dataLen, environment, FILENAME_MAX <start> dataLen-1 <end> );
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"size_t <start> dataLen = strlen(data) <end> ;
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
badSink_b <start> data <end> );"	3
4ec5d06c-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_postinc_03_bad() { int data; data = 0; if(5==5) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(5==5) { { data++; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
int <start> result = data <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> data++ <end> ;"	"int <start> result = data <end> ;
<start> data <end> ++;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> data <end> ++;"	3
a95fd831-6c15-11ed-81d4-94e6f77dd552	extern int CWE191_Integer_Underflow__int_fgets_multiply_22_badGlobal; void CWE191_Integer_Underflow__int_fgets_multiply_22_badSink(int data) { if(CWE191_Integer_Underflow__int_fgets_multiply_22_badGlobal) { if(data < 0) { int result = data * 2; printIntLine(result); } } }	where is the vulnerable dataflow from result to printIntLine ?	"void CWE191_Integer_Underflow__int_fgets_multiply_22_badSink(int <start> data <end> );
if <start> data < 0 <end> ) ;"	"printIntLine <start> result <end> );
int <start> result = data * 2 <end> ;"	"void CWE191_Integer_Underflow__int_fgets_multiply_22_badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"int result = <start> data * 2 <end> ;
void CWE191_Integer_Underflow__int_fgets_multiply_22_badSink(int <start> data <end> );"	2
c4cd6f5c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_file_fopen_02 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(1) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"<start> data = dataBuffer <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"<start> data = dataBuffer <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
pFile = FOPEN <start> data <end> , ""wb+"");"	3
87ff985b-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_connect_socket_fopen_67 { typedef struct _structType { char * structFirst; } structType; void badSink(structType myStruct) { char * data = myStruct.structFirst; { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"void badSink(structType <start> myStruct <end> );
char * data = <start> myStruct <end> .structFirst;
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
char * data = <start> myStruct <end> .structFirst;
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	"pFile = FOPEN <start> data <end> , ""wb+"");
void badSink(structType <start> myStruct <end> );
char * data = <start> myStruct <end> .structFirst;"	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
char * data = <start> myStruct <end> .structFirst;
void badSink(structType <start> myStruct <end> );"	0
6ef7685d-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif static void badVaSink(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_console_vprintf_31_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } { char * dataCopy = data; char * data = dataCopy; badVaSink(data, data); } }"	where is the vulnerable dataflow from data to vprintf ?	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
dataLen = <start> strlen(data) <end> ;"	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
static void badVaSink(char * <start> data <end> , ...);
badVaSink <start> data <end> , data);"	"badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
vprintf <start> data <end> , args);"	3
70279bf3-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif void CWE134_Uncontrolled_Format_String__char_file_snprintf_03_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; if(5==5) { { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } if(5==5) { { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } } }"	where is the vulnerable dataflow from dest to printLine ?	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
printLine <start> dest <end> );"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
char <start> dest[100] = """" <end> ;"	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	"printLine <start> dest <end> );
char <start> dataBuffer[100] = """" <end> ;"	0
525b6441-6c15-11ed-81d4-94e6f77dd552	"void CWE190_Integer_Overflow__int_fscanf_preinc_14_bad() { int data; data = 0; if(globalFive==5) { fscanf(stdin, ""%d"", &data); } if(globalFive==5) { { ++data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> data = 0 <end> ;
fscanf(stdin, ""%d"", <start> &data <end> );"	"fscanf(stdin, ""%d"", <start> &data <end> );
+ <start> data <end> ;"	"<start> printIntLine(result) <end> ;
+ <start> data <end> ;"	"+ <start> data <end> ;
int <start> result = data <end> ;"	1
d31a24e7-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 namespace CWE36_Absolute_Path_Traversal__char_listen_socket_ifstream_42 { static char * badSource(char * data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } return data; } void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; data = badSource(data); { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"replace = <start> strchr(data, '\n') <end> ;
inputFile.open((char * <start> data <end> );
data = <start> badSource <end> (data);
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"static char * <start> badSource <end> (char * data);
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
inputFile.open((char * <start> data <end> );
data = <start> badSource <end> (data);"	"recvResult = recv(acceptSocket, (char *)(data + dataLen), <start> sizeof(char) * (FILENAME_MAX - dataLen - 1) <end> , 0);
data = <start> badSource <end> (data);
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
static char * <start> badSource <end> (char * data);"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
inputFile.open((char * <start> data <end> );"	3
7fa68e18-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_64b_badSink(void * dataVoidPtr) { int * dataPtr = (int *)dataVoidPtr; int data = (*dataPtr); { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_64b_badSink(void * <start> dataVoidPtr <end> );
<start> strncpy(dest, source, data) <end> ;"	"char <start> dest[100] = """" <end> ;
void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_64b_badSink(void * <start> dataVoidPtr <end> );"	"void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_64b_badSink(void * <start> dataVoidPtr <end> );
printLine <start> dest <end> );"	"printLine <start> dest <end> );
if  <start> data < 100 <end> );"	2
b8e2bda4-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define NEW_PATH ""%SystemRoot%\\system32"" #define PUTENV _putenv #else #define NEW_PATH ""/bin"" #define PUTENV putenv #endif int CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_22_badGlobal = 0; char * CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_22_badSource(char * data); void CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_22_bad() { char * data; char dataBuffer[250] = ""PATH=""; data = dataBuffer; CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_22_badGlobal = 1; data = CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_22_badSource(data); PUTENV(data); }"	where is the vulnerable dataflow from data to PUTENV ?	"data = <start> CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_22_badSource <end> (data);
PUTENV <start> data <end> );"	"PUTENV <start> data <end> );
<start> data = CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_22_badSource(data) <end> ;"	"PUTENV <start> data <end> );
<start> PUTENV(data) <end> ;"	"<start> data = dataBuffer <end> ;
data = <start> CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_22_badSource <end> (data);"	0
8f278a56-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_12_bad() { int data; data = -1; if(globalReturnsTrueOrFalse()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } else { data = 20; } { size_t i; int *intPointer; intPointer = (int*)malloc(data * sizeof(int)); if (intPointer == NULL) {exit(-1);} for (i = 0; i < (size_t)data; i++) { intPointer[i] = 0; } printIntLine(intPointer[0]); free(intPointer); } }"	where is the vulnerable dataflow from data to malloc ?	"<start> data = 20 <end> ;
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data = -1 <end> ;"	"<start> printIntLine(intPointer[0]) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	3
6c938be8-6c15-11ed-81d4-94e6f77dd552	"namespace CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_73 { void badSink(list<int> dataList) { int data = dataList.back(); { int i; int * buffer = (int *)malloc(10 * sizeof(int)); if (buffer == NULL) {exit(-1);} for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } free(buffer); } }"	where is the vulnerable dataflow from buffer to free ?	"void badSink(list<int> <start> dataList <end> );
free <start> buffer <end> );"	"free <start> buffer <end> );
void badSink(list<int> <start> dataList <end> );"	"free <start> buffer <end> );
<start> printIntLine(buffer[i]) <end> ;"	"free <start> buffer <end> );
<start> free(buffer) <end> ;"	0
70279c00-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif void CWE134_Uncontrolled_Format_String__char_file_snprintf_16_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; while(1) { { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } break; } while(1) { { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } break; } }"	where is the vulnerable dataflow from dest to printLine ?	"printLine <start> dest <end> );
size_t dataLen = <start> strlen(data) <end> ;"	"<start> printLine(dest) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
printLine <start> dest <end> );"	"<start> data = dataBuffer <end> ;
printLine <start> dest <end> );"	2
4a02114e-6c15-11ed-81d4-94e6f77dd552	"void CWE190_Integer_Overflow__short_fscanf_add_09_bad() { short data; data = 0; if(GLOBAL_CONST_TRUE) { fscanf (stdin, ""%hd"", &data); } if(GLOBAL_CONST_TRUE) { { short result = data + 1; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"fscanf (stdin, ""%hd"", <start> &data <end> );
<start> printIntLine(result) <end> ;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
<start> data = 0 <end> ;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
short result = <start> data <end>  + 1;"	"short <start> result = data + 1 <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );"	2
55ef4ce6-6c15-11ed-81d4-94e6f77dd552	namespace CWE191_Integer_Underflow__int_fgets_sub_72 { void badSink(vector<int> dataVector) { int data = dataVector[2]; { int result = data - 1; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"int result = <start> data - 1 <end> ;
void badSink(vector<int> <start> dataVector <end> );"	"int <start> data = dataVector[2] <end> ;
void badSink(vector<int> <start> dataVector <end> );"	"void badSink(vector<int> <start> dataVector <end> );
int result = <start> data <end>  - 1;"	"int <start> result = data - 1 <end> ;
void badSink(vector<int> <start> dataVector <end> );"	2
8df42219-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define PATH_SZ 100 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define PATH_SZ PATH_MAX #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 void CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__bind_accept_listen_16_bad() { while(1) { { char data[100] = """"; #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[recvResult] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif printLine(data); } break; } }"	where is the vulnerable dataflow from data to printLine ?	"if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );
printLine <start> data <end> );"	"printLine <start> data <end> );
<start> printLine(data) <end> ;"	"char <start> data[100] = """" <end> ;
printLine <start> data <end> );"	"recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);
printLine <start> data <end> );"	3
7fa68e1a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_66b_badSink(int dataArray[]) { int data = dataArray[2]; { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_66b_badSink(int <start> dataArray <end> []);
printLine <start> dest <end> );"	"if  <start> data < 100 <end> );
void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_66b_badSink(int <start> dataArray <end> []);"	"printLine <start> dest <end> );
void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_66b_badSink(int <start> dataArray <end> []);"	"<start> strncpy(dest, source, data) <end> ;
void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_66b_badSink(int <start> dataArray <end> []);"	0
820a46e6-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_file_open_31 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } { char * dataCopy = data; char * data = dataCopy; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = OPEN(data, O_RDWR|O_CREAT, <start> S_IREAD|S_IWRITE <end> );"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	1
d0b64eef-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif namespace CWE36_Absolute_Path_Traversal__char_file_ofstream_31 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } { char * dataCopy = data; char * data = dataCopy; { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } } }"	where is the vulnerable dataflow from data to open ?	"<start> data = dataBuffer <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
outputFile.open((char * <start> data <end> );"	"outputFile.open((char * <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	2
54c5820d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticTrue = 1; static int staticFalse = 0; void CWE191_Integer_Underflow__int_connect_socket_sub_05_bad() { int data; data = 0; if(staticTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticTrue) { { int result = data - 1; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int <start> result = data - 1 <end> ;"	"int result = <start> data <end>  - 1;
recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  - 1;"	"int result = <start> data <end>  - 1;
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	2
79b2753a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_63b_badSink(int * dataPtr) { int data = *dataPtr; if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }"	where is the vulnerable dataflow from data to malloc ?	"char <start> * dataBuffer = (char *)malloc(data) <end> ;
char * dataBuffer = (char *)malloc <start> data <end> );"	"void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_63b_badSink(int * <start> dataPtr <end> );
<start> memset(dataBuffer, 'A', data-1) <end> ;"	"void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_63b_badSink(int * <start> dataPtr <end> );
char * dataBuffer = (char *)malloc <start> data <end> );"	"char * dataBuffer = (char *)malloc <start> data <end> );
<start> free(dataBuffer) <end> ;"	2
85b15ed7-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE369_Divide_by_Zero__int_connect_socket_modulo_12_bad() { int data; data = -1; if(globalReturnsTrueOrFalse()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } else { data = 7; } if(globalReturnsTrueOrFalse()) { printIntLine(100 % data); } else { if( data != 0 ) { printIntLine(100 % data); } else { printLine(""This would result in a divide by zero""); } } }"	where is the vulnerable dataflow from data to printIntLine ?	"<start> data = 7 <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> 100 % data <end> );"	"printIntLine <start> 100 % data <end> );
recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);"	"<start> data = -1 <end> ;
printIntLine <start> 100 % data <end> );"	1
54c581e0-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_connect_socket_multiply_03_bad() { int data; data = 0; if(5==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(5==5) { if(data < 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  * 2;
<start> data = atoi(inputBuffer) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  * 2;"	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  * 2;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int <start> result = data * 2 <end> ;"	1
4ec5d0aa-6c15-11ed-81d4-94e6f77dd552	int CWE190_Integer_Overflow__int_fscanf_postinc_61b_badSource(int data); void CWE190_Integer_Overflow__int_fscanf_postinc_61_bad() { int data; data = 0; data = CWE190_Integer_Overflow__int_fscanf_postinc_61b_badSource(data); { data++; int result = data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"<start> data <end> ++;
<start> printIntLine(result) <end> ;"	"data = <start> CWE190_Integer_Overflow__int_fscanf_postinc_61b_badSource <end> (data);
<start> printIntLine(result) <end> ;"	"data = <start> CWE190_Integer_Overflow__int_fscanf_postinc_61b_badSource <end> (data);
<start> data <end> ++;"	"<start> data++ <end> ;
data = <start> CWE190_Integer_Overflow__int_fscanf_postinc_61b_badSource <end> (data);"	2
aa91a19f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_listen_socket_sub_53d_badSink(int data) { { int result = data - 1; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"int <start> result = data - 1 <end> ;
void CWE191_Integer_Underflow__int_listen_socket_sub_53d_badSink(int <start> data <end> );"	"printIntLine <start> result <end> );
void CWE191_Integer_Underflow__int_listen_socket_sub_53d_badSink(int <start> data <end> );"	"<start> printIntLine(result) <end> ;
void CWE191_Integer_Underflow__int_listen_socket_sub_53d_badSink(int <start> data <end> );"	"void CWE191_Integer_Underflow__int_listen_socket_sub_53d_badSink(int <start> data <end> );
printIntLine <start> result <end> );"	3
acf67e4d-6c15-11ed-81d4-94e6f77dd552	extern int CWE191_Integer_Underflow__int_fgets_predec_22_badGlobal; void CWE191_Integer_Underflow__int_fgets_predec_22_badSink(int data) { if(CWE191_Integer_Underflow__int_fgets_predec_22_badGlobal) { { --data; int result = data; printIntLine(result); } } }	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
void CWE191_Integer_Underflow__int_fgets_predec_22_badSink(int <start> data <end> );"	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;"	"printIntLine <start> result <end> );
int <start> result = data <end> ;"	"void CWE191_Integer_Underflow__int_fgets_predec_22_badSink(int <start> data <end> );
printIntLine <start> result <end> );"	3
abc37516-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_fgets_postdec_03_bad() { int data; data = 0; if(5==5) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(5==5) { { data--; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> printIntLine(result) <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
int <start> result = data <end> ;"	"data = <start> atoi(inputBuffer) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	1
9fe7ad28-6c15-11ed-81d4-94e6f77dd552	"namespace CWE134_Uncontrolled_Format_String__char_console_vprintf_81 { void bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } const CWE134_Uncontrolled_Format_String__char_console_vprintf_81_base& baseObject = CWE134_Uncontrolled_Format_String__char_console_vprintf_81_bad(); baseObject.action(data); }"	where is the vulnerable dataflow from data to action ?	"dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	"size_t dataLen = <start> strlen(data) <end> ;
baseObject.action <start> data <end> );"	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
baseObject.action <start> data <end> );"	3
8f278a78-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_10_bad() { int data; data = -1; if(globalTrue) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } { size_t i; int *intPointer; intPointer = (int*)malloc(data * sizeof(int)); if (intPointer == NULL) {exit(-1);} for (i = 0; i < (size_t)data; i++) { intPointer[i] = 0; } printIntLine(intPointer[0]); free(intPointer); } }"	where is the vulnerable dataflow from data to malloc ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
data = <start> atoi(inputBuffer) <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	"if  <start> fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) <end>  != NULL);
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"<start> intPointer = (int*)malloc(data * sizeof(int)) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	1
d31a2509-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 namespace CWE36_Absolute_Path_Traversal__char_listen_socket_ofstream_45 { static char * badData; static char * goodG2BData; static void badSink() { char * data = badData; { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } } void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badData = data; badSink(); }"	where is the vulnerable dataflow from data to open ?	"outputFile.open((char * <start> data <end> );
char * data = <start> badData <end> ;
size_t dataLen = <start> strlen(data) <end> ;
<start> badData = data <end> ;
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"size_t dataLen = <start> strlen(data) <end> ;
<start> badData = data <end> ;
static char * <start> badData <end> ;
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
char * data = <start> badData <end> ;"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
<start> badData = data <end> ;
static char * <start> badData <end> ;
char * data = <start> badData <end> ;
outputFile.open((char * <start> data <end> );"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
static char * <start> badData <end> ;
<start> badData = data <end> ;
outputFile.open((char * <start> data <end> );"	2
c72d5d82-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 namespace CWE23_Relative_Path_Traversal__char_listen_socket_ifstream_21 { static int badStatic = 0; static char * badSource(char * data) { if(badStatic) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } return data; } void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; badStatic = 1; data = badSource(data); { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } ; }"	where is the vulnerable dataflow from data to open ?	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
inputFile.open((char * <start> data <end> );"	"<start> recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0) <end> ;
inputFile.open((char * <start> data <end> );
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);"	"<start> recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0) <end> ;
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
inputFile.open((char * <start> data <end> );
data = <start> badSource <end> (data);"	"<start> recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0) <end> ;
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
data = <start> badSource <end> (data);
static char * <start> badSource <end> (char * data);"	0
951c5ea4-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FULL_COMMAND ""dir "" #else #define FULL_COMMAND ""ls "" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define POPEN _popen #define PCLOSE _pclose #else #define POPEN popen #define PCLOSE pclose #endif void CWE78_OS_Command_Injection__char_file_popen_02_bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; if(1) { { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } { FILE *pipe; pipe = POPEN(data, ""w""); if (pipe != NULL) { PCLOSE(pipe); } } }"	where is the vulnerable dataflow from data to POPEN ?	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
<start> data = data_buf <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
pipe = POPEN <start> data <end> , ""w"");"	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	"pipe = POPEN <start> data <end> , ""w"");
pipe = <start> POPEN(data, ""w"") <end> ;"	1
b2ea8da1-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" static short CWE197_Numeric_Truncation_Error__short_connect_socket_45_badData; static short CWE197_Numeric_Truncation_Error__short_connect_socket_45_goodG2BData; static void badSink() { short data = CWE197_Numeric_Truncation_Error__short_connect_socket_45_badData; { char charData = (char)data; printHexCharLine(charData); } } void CWE197_Numeric_Truncation_Error__short_connect_socket_45_bad() { short data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = (short)atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE197_Numeric_Truncation_Error__short_connect_socket_45_badData = data; badSink(); }"	where is the vulnerable dataflow from charData to printHexCharLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> CWE197_Numeric_Truncation_Error__short_connect_socket_45_badData = data <end> ;
static short <start> CWE197_Numeric_Truncation_Error__short_connect_socket_45_badData <end> ;
short data = <start> CWE197_Numeric_Truncation_Error__short_connect_socket_45_badData <end> ;
printHexCharLine <start> charData <end> );"	"printHexCharLine <start> charData <end> );
short data = <start> CWE197_Numeric_Truncation_Error__short_connect_socket_45_badData <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static short <start> CWE197_Numeric_Truncation_Error__short_connect_socket_45_badData <end> ;
<start> CWE197_Numeric_Truncation_Error__short_connect_socket_45_badData = data <end> ;"	"recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);
short data = <start> CWE197_Numeric_Truncation_Error__short_connect_socket_45_badData <end> ;
static short <start> CWE197_Numeric_Truncation_Error__short_connect_socket_45_badData <end> ;
<start> CWE197_Numeric_Truncation_Error__short_connect_socket_45_badData = data <end> ;
printHexCharLine <start> charData <end> );"	"short data = <start> CWE197_Numeric_Truncation_Error__short_connect_socket_45_badData <end> ;
static short <start> CWE197_Numeric_Truncation_Error__short_connect_socket_45_badData <end> ;
<start> CWE197_Numeric_Truncation_Error__short_connect_socket_45_badData = data <end> ;
printHexCharLine <start> charData <end> );"	0
bc721f8c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define EXECLP _execlp #else #define EXECLP execlp #endif static int staticTrue = 1; static int staticFalse = 0; void CWE78_OS_Command_Injection__char_file_execlp_05_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(staticTrue) { { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECLP ?	"<start> data = dataBuffer <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"<start> EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	"EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	1
b08640c5-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) int CWE197_Numeric_Truncation_Error__int_fgets_to_char_61b_badSource(int data); void CWE197_Numeric_Truncation_Error__int_fgets_to_char_61_bad() { int data; data = -1; data = CWE197_Numeric_Truncation_Error__int_fgets_to_char_61b_badSource(data); { char charData = (char)data; printHexCharLine(charData); } }	where is the vulnerable dataflow from charData to printHexCharLine ?	"data = <start> CWE197_Numeric_Truncation_Error__int_fgets_to_char_61b_badSource <end> (data);
printHexCharLine <start> charData <end> );"	"data = <start> CWE197_Numeric_Truncation_Error__int_fgets_to_char_61b_badSource <end> (data);
<start> printHexCharLine(charData) <end> ;"	"printHexCharLine <start> charData <end> );
data = <start> CWE197_Numeric_Truncation_Error__int_fgets_to_char_61b_badSource <end> (data);"	"printHexCharLine <start> charData <end> );
data = <start> CWE197_Numeric_Truncation_Error__int_fgets_to_char_61b_badSource(data) <end> ;"	0
833ac921-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_listen_socket_fopen_44 { static void badSink(char * data) { { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } } void bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } funcPtr(data); }"	where is the vulnerable dataflow from data to FOPEN ?	"static void badSink(char * <start> data <end> );
recvResult = <start> recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0) <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");
funcPtr <start> data <end> );"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
funcPtr <start> data <end> );
static void badSink(char * <start> data <end> );
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
funcPtr <start> data <end> );"	"replace = <start> strchr(data, '\r') <end> ;
static void badSink(char * <start> data <end> );
pFile = FOPEN <start> data <end> , ""wb+"");
funcPtr <start> data <end> );"	1
60db8393-6c15-11ed-81d4-94e6f77dd552	static int staticFive = 5; void CWE190_Integer_Overflow__char_rand_add_07_bad() { char data; data = ' '; if(staticFive==5) { data = (char)RAND32(); } if(staticFive==5) { { char result = data + 1; printHexCharLine(result); } } }	where is the vulnerable dataflow from data ?	"data = (char <start> RAND32() <end> ;
char result = <start> data <end>  + 1;"	"char result = <start> data + 1 <end> ;
data = (char <start> RAND32() <end> ;"	"<start> printHexCharLine(result) <end> ;
char result = <start> data <end>  + 1;"	"char result = <start> data <end>  + 1;
data = (char <start> RAND32() <end> ;"	0
cbf237d8-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif namespace CWE36_Absolute_Path_Traversal__char_console_ifstream_21 { static int badStatic = 0; static char * badSource(char * data) { if(badStatic) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } return data; } void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; badStatic = 1; data = badSource(data); { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } ; }"	where is the vulnerable dataflow from data to open ?	"data = <start> badSource <end> (data);
inputFile.open((char * <start> data <end> );
static char * <start> badSource <end> (char * data);
size_t dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
inputFile.open((char * <start> data <end> );
dataLen = <start> strlen(data) <end> ;
data = <start> badSource <end> (data);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
inputFile.open((char * <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
inputFile.open((char * <start> data <end> );
data = <start> badSource <end> (data);
static char * <start> badSource <end> (char * data);"	2
7ae3a704-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_03_bad() { int data; data = -1; if(5==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);
printLine <start> dest <end> );"	"printLine <start> dest <end> );
<start> memmove(dest, source, data) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> memmove(dest, source, data) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	3
846ad30f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define STAT _stat #define OPEN _open #define WRITE _write #define O_RDWR _O_RDWR #define CLOSE _close #else #define STAT stat #define OPEN open #define WRITE write #define CLOSE close #endif #define BAD_SINK_STRING ""Bad Sink..."" #define GOOD_SINK_STRING ""Good Sink..."" #ifdef _WIN32 #define ACCESS _access #define W_OK 02 #else #define ACCESS access #endif static const int STATIC_CONST_FIVE = 5; void CWE367_TOC_TOU__access_06_bad() { if(STATIC_CONST_FIVE==5) { { char filename[100] = """"; int fileDesc = -1; if (fgets(filename, 100, stdin) == NULL) { printLine(""fgets() failed""); filename[0] = '\0'; } if (strlen(filename) > 0) { filename[strlen(filename)-1] = '\0'; } if (ACCESS(filename, W_OK) == -1) { exit(1); } fileDesc  = OPEN(filename, O_RDWR); if (fileDesc == -1) { exit(1); } if (WRITE(fileDesc, BAD_SINK_STRING, strlen(BAD_SINK_STRING)) == -1) { exit(1); } if (fileDesc != -1) { CLOSE(fileDesc); } } } }"	where is the vulnerable dataflow from filename to OPEN ?	"fileDesc  = OPEN <start> filename <end> , O_RDWR);
fileDesc  = <start> OPEN(filename, O_RDWR) <end> ;"	"fileDesc  = OPEN <start> filename <end> , O_RDWR);
if (fgets <start> filename <end> , 100, stdin) == NULL);"	"if (fgets <start> filename <end> , 100, stdin) == NULL);
fileDesc  = OPEN <start> filename <end> , O_RDWR);"	"fileDesc  = OPEN <start> filename <end> , O_RDWR);
if  <start> strlen(filename) <end>  > 0);"	2
7fa68e32-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_connect_socket_fopen_17 { void bad() { int i; char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; for(i = 0; i < 1; i++) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to sizeof ?	size_t dataLen = <start> strlen(data) <end> ;	char <start> dataBuffer[FILENAME_MAX] = BASEPATH <end> ;	recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);	"pFile = <start> FOPEN(data, ""wb+"") <end> ;"	2
aa91a1a8-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) extern int CWE191_Integer_Underflow__int_listen_socket_sub_68_badData; extern int CWE191_Integer_Underflow__int_listen_socket_sub_68_goodG2BData; extern int CWE191_Integer_Underflow__int_listen_socket_sub_68_goodB2GData; void CWE191_Integer_Underflow__int_listen_socket_sub_68b_badSink() { int data = CWE191_Integer_Underflow__int_listen_socket_sub_68_badData; { int result = data - 1; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"int data = <start> CWE191_Integer_Underflow__int_listen_socket_sub_68_badData <end> ;
<start> printIntLine(result) <end> ;"	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	"int data = <start> CWE191_Integer_Underflow__int_listen_socket_sub_68_badData <end> ;
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
int data = <start> CWE191_Integer_Underflow__int_listen_socket_sub_68_badData <end> ;"	2
73bc8169-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; void CWE194_Unexpected_Sign_Extension__connect_socket_memmove_04_bad() { short data; data = 0; if(STATIC_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	"printLine <start> dest <end> );
if  <start> data < 100 <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"printLine <start> dest <end> );
<start> memmove(dest, source, data) <end> ;"	2
9059f3ab-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_53d_badSink(int data) { { size_t i; int *intPointer; intPointer = (int*)malloc(data * sizeof(int)); if (intPointer == NULL) {exit(-1);} for (i = 0; i < (size_t)data; i++) { intPointer[i] = 0; } printIntLine(intPointer[0]); free(intPointer); } }"	where is the vulnerable dataflow from data to malloc ?	"<start> intPointer = (int*)malloc(data * sizeof(int)) <end> ;
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	"void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_53d_badSink(int <start> data <end> );
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	"<start> intPointer = (int*)malloc(data * sizeof(int)) <end> ;
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_53d_badSink(int <start> data <end> );"	"intPointer = (int*)malloc <start> data * sizeof(int) <end> );
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_53d_badSink(int <start> data <end> );"	1
61da66fa-6c15-11ed-81d4-94e6f77dd552	extern char CWE190_Integer_Overflow__char_rand_square_68_badData; extern char CWE190_Integer_Overflow__char_rand_square_68_goodG2BData; extern char CWE190_Integer_Overflow__char_rand_square_68_goodB2GData; void CWE190_Integer_Overflow__char_rand_square_68b_badSink() { char data = CWE190_Integer_Overflow__char_rand_square_68_badData; { char result = data * data; printHexCharLine(result); } }	where is the vulnerable dataflow from data ?	"char <start> result = data * data <end> ;
char data = <start> CWE190_Integer_Overflow__char_rand_square_68_badData <end> ;"	"char result = <start> data <end>  * data;
<start> printHexCharLine(result) <end> ;"	"char data = <start> CWE190_Integer_Overflow__char_rand_square_68_badData <end> ;
char result = <start> data <end>  * data;"	"char result = <start> data <end>  * data;
char data = <start> CWE190_Integer_Overflow__char_rand_square_68_badData <end> ;"	2
466e7ebc-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink(int data) { { int result = data + 1; printIntLine(result); } } void CWE190_Integer_Overflow__int_fgets_add_44_bad() { int data; void (*funcPtr) (int) = badSink; data = 0; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } funcPtr(data); }"	where is the vulnerable dataflow from data ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
funcPtr <start> data <end> );
static void badSink(int <start> data <end> );
<start> printIntLine(result) <end> ;"	"int result = <start> data <end>  + 1;
static void badSink(int <start> data <end> );
funcPtr <start> data <end> );
<start> data = 0 <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
funcPtr <start> data <end> );
static void badSink(int <start> data <end> );
int result = <start> data <end>  + 1;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
funcPtr <start> data <end> );
static void badSink(int <start> data <end> );"	2
846ad314-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define STAT _stat #define OPEN _open #define WRITE _write #define O_RDWR _O_RDWR #define CLOSE _close #else #define STAT stat #define OPEN open #define WRITE write #define CLOSE close #endif #define BAD_SINK_STRING ""Bad Sink..."" #define GOOD_SINK_STRING ""Good Sink..."" #ifdef _WIN32 #define ACCESS _access #define W_OK 02 #else #define ACCESS access #endif void CWE367_TOC_TOU__access_11_bad() { if(globalReturnsTrue()) { { char filename[100] = """"; int fileDesc = -1; if (fgets(filename, 100, stdin) == NULL) { printLine(""fgets() failed""); filename[0] = '\0'; } if (strlen(filename) > 0) { filename[strlen(filename)-1] = '\0'; } if (ACCESS(filename, W_OK) == -1) { exit(1); } fileDesc  = OPEN(filename, O_RDWR); if (fileDesc == -1) { exit(1); } if (WRITE(fileDesc, BAD_SINK_STRING, strlen(BAD_SINK_STRING)) == -1) { exit(1); } if (fileDesc != -1) { CLOSE(fileDesc); } } } }"	where is the vulnerable dataflow from filename to OPEN ?	"if (fgets <start> filename <end> , 100, stdin) == NULL);
fileDesc  = OPEN <start> filename <end> , O_RDWR);"	"fileDesc  = OPEN <start> filename <end> , O_RDWR);
if  <start> fgets(filename, 100, stdin) <end>  == NULL);"	"fileDesc  = OPEN <start> filename <end> , O_RDWR);
if (fgets <start> filename <end> , 100, stdin) == NULL);"	"if  <start> strlen(filename) <end>  > 0);
fileDesc  = OPEN <start> filename <end> , O_RDWR);"	0
774f57e5-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 8 void CWE194_Unexpected_Sign_Extension__fgets_strncpy_12_bad() { short data; data = 0; if(globalReturnsTrueOrFalse()) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = (short)atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } else { data = 100-1; } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"if  <start> data < 100 <end> );
printLine <start> dest <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> data = (short)atoi(inputBuffer) <end> ;"	"<start> data = (short)atoi(inputBuffer) <end> ;
printLine <start> dest <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printLine <start> dest <end> );"	3
7c1275a7-6c15-11ed-81d4-94e6f77dd552	"namespace CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_73 { void badSink(list<int> dataList) { int data = dataList.back(); { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"void badSink(list<int> <start> dataList <end> );
printLine <start> dest <end> );"	"<start> memcpy(dest, source, data) <end> ;
printLine <start> dest <end> );"	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	"void badSink(list<int> <start> dataList <end> );
char <start> dest[100] = """" <end> ;"	0
c72d5d5f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_listen_socket_fopen_42 { static char * badSource(char * data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } return data; } void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; data = badSource(data); { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
pFile = FOPEN <start> data <end> , ""wb+"");"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
static char * <start> badSource <end> (char * data);
pFile = FOPEN <start> data <end> , ""wb+"");
<start> data = badSource(data) <end> ;"	"static char * <start> badSource <end> (char * data);
pFile = FOPEN <start> data <end> , ""wb+"");
data = <start> badSource <end> (data);
<start> data = dataBuffer <end> ;"	"replace = <start> strchr(data, '\n') <end> ;
static char * <start> badSource <end> (char * data);
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	0
bed4a8c1-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_connect_socket_fopen_15 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; switch(6) { case 6: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; default: printLine(""Benign, fixed string""); break; } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"char <start> dataBuffer[FILENAME_MAX] = BASEPATH <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	"replace = <start> strchr(data, '\n') <end> ;
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	2
8cc3a65d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(count) + 2) #ifdef _WIN32 #define SLEEP Sleep #else #define SLEEP usleep #endif static void badSink(int count) { SLEEP(count); printLine(""Sleep time possibly too long""); } void CWE400_Resource_Exhaustion__connect_socket_sleep_44_bad() { int count; void (*funcPtr) (int) = badSink; count = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; count = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } funcPtr(count); }"	where is the vulnerable dataflow from count to SLEEP ?	"funcPtr <start> count <end> );
SLEEP <start> count <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
static void badSink(int <start> count <end> );"	"funcPtr <start> count <end> );
SLEEP <start> count <end> );
static void badSink(int <start> count <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
funcPtr <start> count <end> );
static void badSink(int <start> count <end> );
SLEEP <start> count <end> );"	"SLEEP <start> count <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> funcPtr(count) <end> ;
static void badSink(int <start> count <end> );"	2
9187cbf8-6c15-11ed-81d4-94e6f77dd552	"#define SEARCH_CHAR 'S' void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_console_09_bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\0'; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } if(GLOBAL_CONST_TRUE) { for (; *data != '\0'; data++) { if (*data == SEARCH_CHAR) { printLine(""We have a match!""); break; } } free(data); } }"	where is the vulnerable dataflow from data to free ?	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
if  <start> data == NULL <end> ) {exit(-1);};"	"if (dataLen > 0 && <start> data[dataLen-1] == '\n' <end> );
free <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
free <start> data <end> );"	"free <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	2
5133a776-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) typedef struct _CWE190_Integer_Overflow__int_fgets_preinc_67_structType { int structFirst; } CWE190_Integer_Overflow__int_fgets_preinc_67_structType; void CWE190_Integer_Overflow__int_fgets_preinc_67b_badSink(CWE190_Integer_Overflow__int_fgets_preinc_67_structType myStruct) { int data = myStruct.structFirst; { ++data; int result = data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"int <start> result = data <end> ;
int data = <start> myStruct <end> .structFirst;
void CWE190_Integer_Overflow__int_fgets_preinc_67b_badSink(CWE190_Integer_Overflow__int_fgets_preinc_67_structType <start> myStruct <end> );"	"void CWE190_Integer_Overflow__int_fgets_preinc_67b_badSink(CWE190_Integer_Overflow__int_fgets_preinc_67_structType <start> myStruct <end> );
int data = <start> myStruct <end> .structFirst;
<start> ++data <end> ;"	"+ <start> data <end> ;
void CWE190_Integer_Overflow__int_fgets_preinc_67b_badSink(CWE190_Integer_Overflow__int_fgets_preinc_67_structType <start> myStruct <end> );
<start> printIntLine(result) <end> ;"	"void CWE190_Integer_Overflow__int_fgets_preinc_67b_badSink(CWE190_Integer_Overflow__int_fgets_preinc_67_structType <start> myStruct <end> );
int data = <start> myStruct <end> .structFirst;
+ <start> data <end> ;"	3
8b91e46a-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif static const int STATIC_CONST_FIVE = 5; namespace CWE36_Absolute_Path_Traversal__char_listen_socket_open_06 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(STATIC_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"size_t dataLen = <start> strlen(data) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	0
cbf237bf-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_console_fopen_63 { void badSink(char * * dataPtr) { char * data = *dataPtr; { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = FOPEN <start> data <end> , ""wb+"");
char <start> * data = *dataPtr <end> ;"	"pFile = FOPEN <start> data <end> , ""wb+"");
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	"void badSink(char * * <start> dataPtr <end> );
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
void badSink(char * * <start> dataPtr <end> );"	2
7ae3a712-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_17_bad() { int i; int data; data = -1; for(i = 0; i < 1; i++) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"<start> printLine(dest) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"char <start> dest[100] = """" <end> ;
printLine <start> dest <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> memmove(dest, source, data) <end> ;"	0
9059f387-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_64b_badSink(void * dataVoidPtr) { int * dataPtr = (int *)dataVoidPtr; int data = (*dataPtr); { size_t i; int *intPointer; intPointer = (int*)malloc(data * sizeof(int)); if (intPointer == NULL) {exit(-1);} for (i = 0; i < (size_t)data; i++) { intPointer[i] = 0; } printIntLine(intPointer[0]); free(intPointer); } }	where is the vulnerable dataflow from data to malloc ?	"void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_64b_badSink(void * <start> dataVoidPtr <end> );
int <start> data = (*dataPtr) <end> ;"	"void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_64b_badSink(void * <start> dataVoidPtr <end> );
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	"intPointer = <start> (int*)malloc(data * sizeof(int)) <end> ;
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	"intPointer = (int*)malloc <start> data * sizeof(int) <end> );
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_64b_badSink(void * <start> dataVoidPtr <end> );"	1
571e981a-6c15-11ed-81d4-94e6f77dd552	typedef struct _CWE191_Integer_Underflow__int_fscanf_multiply_67_structType { int structFirst; } CWE191_Integer_Underflow__int_fscanf_multiply_67_structType; void CWE191_Integer_Underflow__int_fscanf_multiply_67b_badSink(CWE191_Integer_Underflow__int_fscanf_multiply_67_structType myStruct) { int data = myStruct.structFirst; if(data < 0) { int result = data * 2; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"int data = <start> myStruct <end> .structFirst;
void CWE191_Integer_Underflow__int_fscanf_multiply_67b_badSink(CWE191_Integer_Underflow__int_fscanf_multiply_67_structType <start> myStruct <end> );"	"int data = <start> myStruct <end> .structFirst;
int <start> result = data * 2 <end> ;
void CWE191_Integer_Underflow__int_fscanf_multiply_67b_badSink(CWE191_Integer_Underflow__int_fscanf_multiply_67_structType <start> myStruct <end> );"	"void CWE191_Integer_Underflow__int_fscanf_multiply_67b_badSink(CWE191_Integer_Underflow__int_fscanf_multiply_67_structType <start> myStruct <end> );
int data = <start> myStruct <end> .structFirst;
int result = <start> data <end>  * 2;"	"int data = <start> myStruct <end> .structFirst;
int result = <start> data * 2 <end> ;
void CWE191_Integer_Underflow__int_fscanf_multiply_67b_badSink(CWE191_Integer_Underflow__int_fscanf_multiply_67_structType <start> myStruct <end> );"	2
b54bcf02-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 20 void CWE369_Divide_by_Zero__float_fgets_15_bad() { float data; data = 0.0F; switch(6) { case 6: { char inputBuffer[CHAR_ARRAY_SIZE]; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = (float)atof(inputBuffer); } else { printLine(""fgets() failed.""); } } break; default: printLine(""Benign, fixed string""); break; } switch(7) { case 7: { int result = (int)(100.0 / data); printIntLine(result); } break; default: printLine(""Benign, fixed string""); break; } }"	where is the vulnerable dataflow from result to printIntLine ?	"<start> printIntLine(result) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	1
74ee240b-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 8 static short badSource(short data) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = (short)atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } return data; } void CWE194_Unexpected_Sign_Extension__fgets_malloc_42_bad() { short data; data = 0; data = badSource(data); if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }"	where is the vulnerable dataflow from data to malloc ?	"char * dataBuffer = (char * <start> malloc(data) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
data = <start> badSource <end> (data);
char * dataBuffer = (char *)malloc <start> data <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
static short <start> badSource <end> (short data);
data = <start> badSource <end> (data);
char * dataBuffer = (char *)malloc <start> data <end> );"	"memset(dataBuffer, 'A', <start> data-1 <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
static short <start> badSource <end> (short data);
data = <start> badSource <end> (data);"	"char * dataBuffer = (char *)malloc <start> data <end> );
static short <start> badSource <end> (short data);
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
data = <start> badSource(data) <end> ;"	1
6b86241f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_FIVE = 5; void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_connect_socket_06_bad() { int data; data = -1; if(STATIC_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(STATIC_CONST_FIVE==5) { { int i; int * buffer = (int *)malloc(10 * sizeof(int)); if (buffer == NULL) {exit(-1);} for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } free(buffer); } } }"	where is the vulnerable dataflow from buffer to free ?	"<start> printIntLine(buffer[i]) <end> ;
free <start> buffer <end> );"	"free <start> buffer <end> );
<start> free(buffer) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
free <start> buffer <end> );"	"free <start> buffer <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	2
4b34b011-6c15-11ed-81d4-94e6f77dd552	short CWE190_Integer_Overflow__short_fscanf_square_61b_badSource(short data); void CWE190_Integer_Overflow__short_fscanf_square_61_bad() { short data; data = 0; data = CWE190_Integer_Overflow__short_fscanf_square_61b_badSource(data); { short result = data * data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"data = <start> CWE190_Integer_Overflow__short_fscanf_square_61b_badSource <end> (data);
<start> printIntLine(result) <end> ;"	"data = <start> CWE190_Integer_Overflow__short_fscanf_square_61b_badSource <end> (data);
short result = <start> data * data <end> ;"	"short result = <start> data <end>  * data;
<start> printIntLine(result) <end> ;"	"data = <start> CWE190_Integer_Overflow__short_fscanf_square_61b_badSource <end> (data);
short result = <start> data <end>  * data;"	3
af58094b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE197_Numeric_Truncation_Error__int_connect_socket_to_short_09_bad() { int data; data = -1; if(GLOBAL_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { short shortData = (short)data; printShortLine(shortData); } }"	where is the vulnerable dataflow from shortData to printShortLine ?	"printShortLine <start> shortData <end> );
data = <start> atoi(inputBuffer) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printShortLine <start> shortData <end> );"	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printShortLine <start> shortData <end> );"	"printShortLine <start> shortData <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	1
4db33f61-6c15-11ed-81d4-94e6f77dd552	"static void badSink(unsigned int data) { { unsigned int result = data * data; printUnsignedLine(result); } } void CWE190_Integer_Overflow__unsigned_int_fscanf_square_44_bad() { unsigned int data; void (*funcPtr) (unsigned int) = badSink; data = 0; fscanf (stdin, ""%u"", &data); funcPtr(data); }"	where is the vulnerable dataflow from data ?	"unsigned int result = <start> data <end>  * data;
fscanf (stdin, ""%u"", <start> &data <end> );
<start> funcPtr(data) <end> ;
funcPtr <start> data <end> );"	"static void badSink(unsigned int <start> data <end> );
fscanf (stdin, ""%u"", <start> &data <end> );
unsigned int result = <start> data <end>  * data;
funcPtr <start> data <end> );"	"fscanf (stdin, ""%u"", <start> &data <end> );
funcPtr <start> data <end> );
static void badSink(unsigned int <start> data <end> );
unsigned int result = <start> data <end>  * data;"	"fscanf (stdin, ""%u"", <start> &data <end> );
unsigned int result = <start> data <end>  * data;
<start> data = 0 <end> ;
static void badSink(unsigned int <start> data <end> );"	2
7c1275af-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticTrue = 1; static int staticFalse = 0; void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_05_bad() { int data; data = -1; if(staticTrue) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
if  <start> data < 100 <end> );"	"<start> memmove(dest, source, data) <end> ;
printLine <start> dest <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printLine <start> dest <end> );"	"printLine <start> dest <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	2
584fa860-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_listen_socket_multiply_64b_badSink(void * dataVoidPtr) { int * dataPtr = (int *)dataVoidPtr; int data = (*dataPtr); if(data < 0) { int result = data * 2; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"void CWE191_Integer_Underflow__int_listen_socket_multiply_64b_badSink(void * <start> dataVoidPtr <end> );
if <start> data < 0 <end> ) ;"	"int result = <start> data <end>  * 2;
void CWE191_Integer_Underflow__int_listen_socket_multiply_64b_badSink(void * <start> dataVoidPtr <end> );"	"void CWE191_Integer_Underflow__int_listen_socket_multiply_64b_badSink(void * <start> dataVoidPtr <end> );
int result = <start> data <end>  * 2;"	"void CWE191_Integer_Underflow__int_listen_socket_multiply_64b_badSink(void * <start> dataVoidPtr <end> );
<start> printIntLine(result) <end> ;"	2
ae26ae36-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_listen_socket_predec_18_bad() { int data; data = 0; goto source; source: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } goto sink; sink: { --data; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> result <end> );"	"int <start> result = data <end> ;
printIntLine <start> result <end> );"	"<start> data = 0 <end> ;
printIntLine <start> result <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	3
4ec5d09b-6c15-11ed-81d4-94e6f77dd552	"void CWE190_Integer_Overflow__int_fscanf_postinc_16_bad() { int data; data = 0; while(1) { fscanf(stdin, ""%d"", &data); break; } while(1) { { data++; int result = data; printIntLine(result); } break; } }"	where is the vulnerable dataflow from data ?	"int <start> result = data <end> ;
<start> data <end> ++;"	"<start> printIntLine(result) <end> ;
<start> data <end> ++;"	"<start> data <end> ++;
<start> data = 0 <end> ;"	"fscanf(stdin, ""%d"", <start> &data <end> );
<start> data <end> ++;"	3
8f278a6e-6c15-11ed-81d4-94e6f77dd552	namespace CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_81 { void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_81_bad::action(int data) const { { size_t i; int *intPointer; intPointer = (int*)malloc(data * sizeof(int)); if (intPointer == NULL) {exit(-1);} for (i = 0; i < (size_t)data; i++) { intPointer[i] = 0; } printIntLine(intPointer[0]); free(intPointer); } } }	where is the vulnerable dataflow from data to malloc ?	"intPointer = (int*)malloc <start> data * sizeof(int) <end> );
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_81_bad::action(int <start> data <end> ) const;"	"<start> printIntLine(intPointer[0]) <end> ;
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	"void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_81_bad::action(int <start> data <end> ) const;
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	"<start> printIntLine(intPointer[0]) <end> ;
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_81_bad::action(int <start> data <end> ) const;"	2
453db011-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_multiply_11_bad() { int data; data = 0; if(globalReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalReturnsTrue()) { if(data > 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int <start> result = data * 2 <end> ;"	"int result = <start> data <end>  * 2;
data = <start> atoi(inputBuffer) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  * 2;"	"int result = <start> data <end>  * 2;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	2
951c5ea8-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FULL_COMMAND ""dir "" #else #define FULL_COMMAND ""ls "" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define POPEN _popen #define PCLOSE _pclose #else #define POPEN popen #define PCLOSE pclose #endif static const int STATIC_CONST_FIVE = 5; void CWE78_OS_Command_Injection__char_file_popen_06_bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; if(STATIC_CONST_FIVE==5) { { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } { FILE *pipe; pipe = POPEN(data, ""w""); if (pipe != NULL) { PCLOSE(pipe); } } }"	where is the vulnerable dataflow from data to POPEN ?	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
size_t dataLen = <start> strlen(data) <end> ;"	"<start> data = data_buf <end> ;
pipe = POPEN <start> data <end> , ""w"");"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
pipe = POPEN <start> data <end> , ""w"");"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
pipe = <start> POPEN(data, ""w"") <end> ;"	2
761e298c-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 8 void CWE194_Unexpected_Sign_Extension__fgets_memmove_51b_badSink(short data) { { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> printLine(dest) <end> ;
void CWE194_Unexpected_Sign_Extension__fgets_memmove_51b_badSink(short <start> data <end> );"	"void CWE194_Unexpected_Sign_Extension__fgets_memmove_51b_badSink(short <start> data <end> );
printLine <start> dest <end> );"	"<start> memmove(dest, source, data) <end> ;
printLine <start> dest <end> );"	"<start> memmove(dest, source, data) <end> ;
void CWE194_Unexpected_Sign_Extension__fgets_memmove_51b_badSink(short <start> data <end> );"	1
ce547d25-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_environment_fopen_34 { typedef union { char * unionFirst; char * unionSecond; } unionType; void bad() { char * data; unionType myUnion; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } } }"	where is the vulnerable dataflow from data to FOPEN ?	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
strncat(data+dataLen, environment, <start> FILENAME_MAX-dataLen-1 <end> );"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"size_t dataLen = <start> strlen(data) <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	1
99e16a7a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; namespace CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_listen_socket_04 { void bad() { int data; data = -1; if(STATIC_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(STATIC_CONST_TRUE) { { int i; int * buffer = new int[10]; for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } delete[] buffer; } } }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
data = <start> atoi(inputBuffer) <end> ;"	"printIntLine <start> buffer[i] <end> );
if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );"	"printIntLine <start> buffer[i] <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[i] <end> );"	3
c26a7e6c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_environment_fopen_12 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(globalReturnsTrueOrFalse()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } } else { strcat(data, ""file.txt""); } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
pFile = FOPEN <start> data <end> , ""wb+"");"	"size_t dataLen = <start> strlen(data) <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"size_t dataLen = <start> strlen(data) <end> ;
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	0
c26a7e40-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_console_open_11 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(globalReturnsTrue()) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
<start> data = dataBuffer <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
size_t dataLen = <start> strlen(data) <end> ;"	"fileDesc = OPEN(data, O_RDWR|O_CREAT, <start> S_IREAD|S_IWRITE <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	0
715a3be0-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif static const int STATIC_CONST_FIVE = 5; void CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_06_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; if(STATIC_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(STATIC_CONST_FIVE==5) { { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } } }"	where is the vulnerable dataflow from dest to printLine ?	"replace = <start> strchr(data, '\r') <end> ;
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
printLine <start> dest <end> );"	"size_t dataLen = <start> strlen(data) <end> ;
printLine <start> dest <end> );"	"size_t dataLen = <start> strlen(data) <end> ;
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	1
d1e9da54-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 namespace CWE36_Absolute_Path_Traversal__char_listen_socket_ifstream_03 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(5==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
char <start> dataBuffer[FILENAME_MAX] = """" <end> ;"	"if  <start> acceptSocket == SOCKET_ERROR <end> );
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
inputFile.open((char * <start> data <end> );"	"inputFile.open((char * <start> data <end> );
if  <start> acceptSocket == SOCKET_ERROR <end> );"	2
a95fd820-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_fgets_multiply_03_bad() { int data; data = 0; if(5==5) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(5==5) { if(data < 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	"<start> data = 0 <end> ;
printIntLine <start> result <end> );"	"char <start> inputBuffer[CHAR_ARRAY_SIZE] = """" <end> ;
printIntLine <start> result <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );"	3
73bc8174-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" void CWE194_Unexpected_Sign_Extension__connect_socket_memmove_15_bad() { short data; data = 0; switch(6) { case 6: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; default: printLine(""Benign, fixed string""); break; } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	"if  <start> tempInt > SHRT_MAX <end>  || tempInt < SHRT_MIN);
printLine <start> dest <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"<start> memmove(dest, source, data) <end> ;
printLine <start> dest <end> );"	2
8f278a5a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_16_bad() { int data; data = -1; while(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; } { size_t i; int *intPointer; intPointer = (int*)malloc(data * sizeof(int)); if (intPointer == NULL) {exit(-1);} for (i = 0; i < (size_t)data; i++) { intPointer[i] = 0; } printIntLine(intPointer[0]); free(intPointer); } }"	where is the vulnerable dataflow from data to malloc ?	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	"<start> printIntLine(intPointer[0]) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"<start> data = atoi(inputBuffer) <end> ;
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	1
cac216d0-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif static const int STATIC_CONST_FIVE = 5; namespace CWE36_Absolute_Path_Traversal__char_connect_socket_open_06 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(STATIC_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"recvResult = <start> recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0) <end> ;
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"recvResult = recv(connectSocket, (char *)(data + dataLen), <start> sizeof(char) * (FILENAME_MAX - dataLen - 1) <end> , 0);
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"replace = <start> strchr(data, '\r') <end> ;
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	1
4a021131-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) typedef union { int unionFirst; int unionSecond; } CWE190_Integer_Overflow__int_listen_socket_square_34_unionType; void CWE190_Integer_Overflow__int_listen_socket_square_34_bad() { int data; CWE190_Integer_Overflow__int_listen_socket_square_34_unionType myUnion; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } myUnion.unionFirst = data; { int data = myUnion.unionSecond; { int result = data * data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );
int result = <start> data <end>  * data;"	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  * data;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  * data;"	3
7fa68e35-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_connect_socket_fopen_22 { int badGlobal = 0; char * badSource(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; badGlobal = 1; data = badSource(data); { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } ; }"	where is the vulnerable dataflow from data to FOPEN ?	"data = <start> badSource <end> (data);
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
data = <start> badSource(data) <end> ;"	"pFile = FOPEN <start> data <end> , ""wb+"");
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	"pFile = FOPEN <start> data <end> , ""wb+"");
<start> data = badSource(data) <end> ;"	0
4ff78257-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_postinc_52c_badSink(int data) { { data++; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"void CWE190_Integer_Overflow__int_listen_socket_postinc_52c_badSink(int <start> data <end> );
<start> data <end> ++;"	"<start> data <end> ++;
void CWE190_Integer_Overflow__int_listen_socket_postinc_52c_badSink(int <start> data <end> );"	"<start> printIntLine(result) <end> ;
<start> data <end> ++;"	"int <start> result = data <end> ;
void CWE190_Integer_Overflow__int_listen_socket_postinc_52c_badSink(int <start> data <end> );"	0
7c127597-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_43 { static void badSource(int &data) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } void bad() { int data; data = -1; badSource(data); { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"if  <start> data < 100 <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
badSource <start> data <end> );"	"printLine <start> dest <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
badSource <start> data <end> );"	"printLine <start> dest <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> badSource(data) <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
badSource <start> data <end> );
printLine <start> dest <end> );"	3
9ebc76cc-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE127_Buffer_Underread__CWE839_listen_socket_03_bad() { int data; data = -1; if(5==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(5==5) { { int buffer[10] = { 0 }; if (data < 10) { printIntLine(buffer[data]); } else { printLine(""ERROR: Array index is too big.""); } } } }"	where is the vulnerable dataflow from buffer[data] to printIntLine ?	"printIntLine <start> buffer[data] <end> );
int <start> buffer[10] = { 0 } <end> ;"	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> buffer[data] <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[data] <end> );"	3
d1e9da44-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_listen_socket_fopen_45 { static char * badData; static char * goodG2BData; static void badSink() { char * data = badData; { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } } void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badData = data; badSink(); }"	where is the vulnerable dataflow from data to FOPEN ?	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
<start> badData = data <end> ;
char * data = <start> badData <end> ;
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - <start> dataLen - 1 <end> ), 0);
static char * <start> badData <end> ;"	"char * data = <start> badData <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");
static char * <start> badData <end> ;
<start> badData = data <end> ;
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
char * data = <start> badData <end> ;
<start> badData = data <end> ;
static char * <start> badData <end> ;"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
<start> badData = data <end> ;
static char * <start> badData <end> ;
char * data = <start> badData <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	3
b7b09a5f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define NEW_PATH ""%SystemRoot%\\system32"" #define PUTENV _putenv #else #define NEW_PATH ""/bin"" #define PUTENV putenv #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif void CWE427_Uncontrolled_Search_Path_Element__char_file_17_bad() { int i; char * data; char dataBuffer[250] = ""PATH=""; data = dataBuffer; for(i = 0; i < 1; i++) { { size_t dataLen = strlen(data); FILE * pFile; if (250-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(250-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } PUTENV(data); }"	where is the vulnerable dataflow from data to PUTENV ?	"PUTENV <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(250-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(250-dataLen), pFile) == NULL);
PUTENV <start> data <end> );"	"size_t dataLen = <start> strlen(data) <end> ;
PUTENV <start> data <end> );"	"<start> PUTENV(data) <end> ;
PUTENV <start> data <end> );"	1
c8600afe-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_listen_socket_open_09 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(GLOBAL_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	0
85b15edb-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE369_Divide_by_Zero__int_connect_socket_modulo_16_bad() { int data; data = -1; while(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; } while(1) { printIntLine(100 % data); break; } }"	where is the vulnerable dataflow from data to printIntLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> 100 % data <end> );"	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> 100 % data <end> );"	"printIntLine <start> 100 % data <end> );
data = <start> atoi(inputBuffer) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data = -1 <end> ;"	0
74ee240a-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 8 void CWE194_Unexpected_Sign_Extension__fgets_malloc_41_badSink(short data) { if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } } void CWE194_Unexpected_Sign_Extension__fgets_malloc_41_bad() { short data; data = 0; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = (short)atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } CWE194_Unexpected_Sign_Extension__fgets_malloc_41_badSink(data); }"	where is the vulnerable dataflow from data to malloc ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
CWE194_Unexpected_Sign_Extension__fgets_malloc_41_badSink <start> data <end> );
void CWE194_Unexpected_Sign_Extension__fgets_malloc_41_badSink(short <start> data <end> );
char * dataBuffer = (char *)malloc <start> data <end> );"	"CWE194_Unexpected_Sign_Extension__fgets_malloc_41_badSink <start> data <end> );
char * dataBuffer = (char *)malloc <start> data <end> );
void CWE194_Unexpected_Sign_Extension__fgets_malloc_41_badSink(short <start> data <end> );
data = (short <start> atoi(inputBuffer) <end> ;"	"<start> memset(dataBuffer, 'A', data-1) <end> ;
void CWE194_Unexpected_Sign_Extension__fgets_malloc_41_badSink(short <start> data <end> );
char * dataBuffer = (char *)malloc <start> data <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"CWE194_Unexpected_Sign_Extension__fgets_malloc_41_badSink <start> data <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> memset(dataBuffer, 'A', data-1) <end> ;
void CWE194_Unexpected_Sign_Extension__fgets_malloc_41_badSink(short <start> data <end> );"	0
70279c04-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif extern int CWE134_Uncontrolled_Format_String__char_file_snprintf_22_badGlobal; void CWE134_Uncontrolled_Format_String__char_file_snprintf_22_badSink(char * data) { if(CWE134_Uncontrolled_Format_String__char_file_snprintf_22_badGlobal) { { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } } }"	where is the vulnerable dataflow from dest to printLine ?	"void CWE134_Uncontrolled_Format_String__char_file_snprintf_22_badSink(char * <start> data <end> );
<start> SNPRINTF(dest, 100-1, data) <end> ;"	"void CWE134_Uncontrolled_Format_String__char_file_snprintf_22_badSink(char * <start> data <end> );
printLine <start> dest <end> );"	"printLine <start> dest <end> );
void CWE134_Uncontrolled_Format_String__char_file_snprintf_22_badSink(char * <start> data <end> );"	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	1
d1e9da0f-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_file_open_18 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; goto source; source: { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);"	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"fileDesc = OPEN(data, O_RDWR|O_CREAT, <start> S_IREAD|S_IWRITE <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	3
c26a7e2e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif namespace CWE23_Relative_Path_Traversal__char_console_ofstream_43 { void badSource(char * &data) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; badSource(data); { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
dataLen = <start> strlen(data) <end> ;
outputFile.open((char * <start> data <end> );"	"dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
badSource <start> data <end> );"	"badSource <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
badSource <start> data <end> );
outputFile.open((char * <start> data <end> );"	3
6c938be3-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_65b_badSink(int data) { { int i; int * buffer = (int *)malloc(10 * sizeof(int)); if (buffer == NULL) {exit(-1);} for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } free(buffer); } }"	where is the vulnerable dataflow from buffer to free ?	"void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_65b_badSink(int <start> data <end> );
if  <start> buffer == NULL <end> ) {exit(-1);};"	"void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_65b_badSink(int <start> data <end> );
free <start> buffer <end> );"	"<start> free(buffer) <end> ;
free <start> buffer <end> );"	"<start> free(buffer) <end> ;
void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_65b_badSink(int <start> data <end> );"	1
6dc614f9-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" static void badVaSink(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_64b_badSink(void * dataVoidPtr) { char * * dataPtr = (char * *)dataVoidPtr; char * data = (*dataPtr); badVaSink(data, data); }"	where is the vulnerable dataflow from data to vprintf ?	"<start> vprintf(data, args) <end> ;
vprintf <start> data <end> , args);
void CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_64b_badSink(void * <start> dataVoidPtr <end> );
badVaSink <start> data <end> , data);"	"vprintf <start> data <end> , args);
badVaSink <start> data <end> , data);
void CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_64b_badSink(void * <start> dataVoidPtr <end> );"	"badVaSink <start> data <end> , data);
vprintf <start> data <end> , args);
void CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_64b_badSink(void * <start> dataVoidPtr <end> );
static void badVaSink(char * <start> data <end> , ...);"	"void CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_64b_badSink(void * <start> dataVoidPtr <end> );
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
vprintf <start> data <end> , args);"	3
bc721f71-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define EXECL _execl #else #define EXECL execl #endif static int staticFive = 5; void CWE78_OS_Command_Injection__char_file_execl_07_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(staticFive==5) { { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECL ?	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	"<start> EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	"EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	0
4a021148-6c15-11ed-81d4-94e6f77dd552	"void CWE190_Integer_Overflow__short_fscanf_add_02_bad() { short data; data = 0; if(1) { fscanf (stdin, ""%hd"", &data); } if(1) { { short result = data + 1; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
short result = <start> data <end>  + 1;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
short result = <start> data <end>  + 1;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
<start> printIntLine(result) <end> ;"	"short result = <start> data <end>  + 1;
fscanf (stdin, ""%hd"", <start> &data <end> );"	1
a36a78c9-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int badStatic = 0; static void badSink(int data) { if(badStatic) { { int result = data * data; printIntLine(result); } } } void CWE190_Integer_Overflow__int_fgets_square_21_bad() { int data; data = 0; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } badStatic = 1; badSink(data); }"	where is the vulnerable dataflow from result to printIntLine ?	"badSink <start> data <end> );
printIntLine <start> result <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
static void badSink(int <start> data <end> );"	"static void badSink(int <start> data <end> );
printIntLine <start> result <end> );
<start> data = atoi(inputBuffer) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"static void badSink(int <start> data <end> );
<start> printIntLine(result) <end> ;
badSink <start> data <end> );
printIntLine <start> result <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
badSink <start> data <end> );
static void badSink(int <start> data <end> );
printIntLine <start> result <end> );"	3
9ebc76d8-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE127_Buffer_Underread__CWE839_listen_socket_15_bad() { int data; data = -1; switch(6) { case 6: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; default: printLine(""Benign, fixed string""); break; } switch(7) { case 7: { int buffer[10] = { 0 }; if (data < 10) { printIntLine(buffer[data]); } else { printLine(""ERROR: Array index is too big.""); } } break; default: printLine(""Benign, fixed string""); break; } }"	where is the vulnerable dataflow from buffer[data] to printIntLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );"	"printIntLine <start> buffer[data] <end> );
if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );"	"printIntLine <start> buffer[data] <end> );
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[data] <end> );"	3
8a6310ac-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_file_fopen_66 { void badSink(char * dataArray[]) { char * data = dataArray[2]; { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"char <start> * data = dataArray[2] <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
void badSink(char * <start> dataArray <end> []);"	"void badSink(char * <start> dataArray <end> []);
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	2
54c58219-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_connect_socket_sub_18_bad() { int data; data = 0; goto source; source: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } goto sink; sink: { int result = data - 1; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"int <start> result = data - 1 <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  - 1;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printIntLine(result) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data - 1 <end> ;"	1
7fa68e3b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_connect_socket_fopen_44 { static void badSink(char * data) { { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } } void bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } funcPtr(data); }"	where is the vulnerable dataflow from data to FOPEN ?	"size_t <start> dataLen = strlen(data) <end> ;
funcPtr <start> data <end> );
pFile = FOPEN <start> data <end> , ""wb+"");
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
funcPtr <start> data <end> );
static void badSink(char * <start> data <end> );
pFile = FOPEN <start> data <end> , ""wb+"");"	"replace = <start> strchr(data, '\n') <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
static void badSink(char * <start> data <end> );"	"funcPtr <start> data <end> );
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
static void badSink(char * <start> data <end> );
replace = <start> strchr(data, '\n') <end> ;"	1
c01af8e1-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_connect_socket_open_62 { void badSource(char * &data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; badSource(data); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"badSource <start> data <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
<start> badSource(data) <end> ;"	"badSource <start> data <end> );
<start> data = dataBuffer <end> ;"	1
5133a739-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_preinc_09_bad() { int data; data = 0; if(GLOBAL_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(GLOBAL_CONST_TRUE) { { ++data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"data = <start> atoi(inputBuffer) <end> ;
+ <start> data <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
+ <start> data <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printIntLine(result) <end> ;"	"recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);
+ <start> data <end> ;"	1
48d25dac-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_add_17_bad() { int i,j; int data; data = 0; for(i = 0; i < 1; i++) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } for(j = 0; j < 1; j++) { { int result = data + 1; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
int result = <start> data <end>  + 1;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printIntLine(result) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  + 1;"	"<start> data = 0 <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	2
584fa85a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_listen_socket_multiply_51b_badSink(int data) { if(data < 0) { int result = data * 2; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"void CWE191_Integer_Underflow__int_listen_socket_multiply_51b_badSink(int <start> data <end> );
int <start> result = data * 2 <end> ;"	"int result = <start> data * 2 <end> ;
void CWE191_Integer_Underflow__int_listen_socket_multiply_51b_badSink(int <start> data <end> );"	"void CWE191_Integer_Underflow__int_listen_socket_multiply_51b_badSink(int <start> data <end> );
int result = <start> data <end>  * 2;"	"<start> printIntLine(result) <end> ;
void CWE191_Integer_Underflow__int_listen_socket_multiply_51b_badSink(int <start> data <end> );"	2
ba102b94-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define EXECLP _execlp #else #define EXECLP execlp #endif void CWE78_OS_Command_Injection__char_connect_socket_execlp_02_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECLP ?	"EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
recvResult = recv(connectSocket, (char *)(data + dataLen), <start> sizeof(char) * (100 - dataLen - 1) <end> , 0);"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
<start> data = dataBuffer <end> ;"	"EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
char <start> dataBuffer[100] = COMMAND_ARG2 <end> ;"	1
aa91a199-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink(int data) { { int result = data - 1; printIntLine(result); } } void CWE191_Integer_Underflow__int_listen_socket_sub_41_bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badSink(data); }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int <start> result = data - 1 <end> ;
badSink <start> data <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSink <start> data <end> );
static void badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"static void badSink(int <start> data <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSink <start> data <end> );
printIntLine <start> result <end> );"	"static void badSink(int <start> data <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSink <start> data <end> );"	1
a109492a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE190_Integer_Overflow__int_connect_socket_square_81 { void bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } const CWE190_Integer_Overflow__int_connect_socket_square_81_base& baseObject = CWE190_Integer_Overflow__int_connect_socket_square_81_bad(); baseObject.action(data); }"	where is the vulnerable dataflow from data to action ?	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
baseObject.action <start> data <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
baseObject.action <start> data <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
data = <start> atoi(inputBuffer) <end> ;"	"baseObject.action <start> data <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	1
99e16a89-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_listen_socket_21 { static int badStatic = 0; static void badSink(int data) { if(badStatic) { { int i; int * buffer = new int[10]; for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } delete[] buffer; } } } void bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badStatic = 1; badSink(data); }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );
badSink <start> data <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[i] <end> );"	"printIntLine <start> buffer[i] <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static void badSink(int <start> data <end> );
badSink <start> data <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSink <start> data <end> );
static void badSink(int <start> data <end> );
printIntLine <start> buffer[i] <end> );"	"badSink <start> data <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static void badSink(int <start> data <end> );
<start> badSink(data) <end> ;"	2
cbf237ba-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_console_fopen_52 { void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } badSink_b(data); }"	where is the vulnerable dataflow from data to badSink_b ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
badSink_b <start> data <end> );"	"badSink_b <start> data <end> );
dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
<start> badSink_b(data) <end> ;"	"size_t dataLen = <start> strlen(data) <end> ;
badSink_b <start> data <end> );"	0
5133a73e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_preinc_15_bad() { int data; data = 0; switch(6) { case 6: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; default: printLine(""Benign, fixed string""); break; } switch(7) { case 7: { ++data; int result = data; printIntLine(result); } break; default: printLine(""Benign, fixed string""); break; } }"	where is the vulnerable dataflow from data ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
+ <start> data <end> ;"	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
+ <start> data <end> ;"	"data = <start> atoi(inputBuffer) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"<start> printIntLine(result) <end> ;
+ <start> data <end> ;"	0
ce547d1f-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_environment_fopen_16 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; while(1) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } break; } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"size_t dataLen = <start> strlen(data) <end> ;
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"strncat(data+dataLen, environment, <start> FILENAME_MAX-dataLen-1 <end> );
pFile = FOPEN <start> data <end> , ""wb+"");"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
pFile = FOPEN <start> data <end> , ""wb+"");"	3
b68484d5-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" namespace CWE36_Absolute_Path_Traversal__char_connect_socket_open_82 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE36_Absolute_Path_Traversal__char_connect_socket_open_82_base* baseObject = new CWE36_Absolute_Path_Traversal__char_connect_socket_open_82_bad; baseObject->action(data); delete baseObject; }"	where is the vulnerable dataflow from data to action ?	"baseObject->action <start> data <end> );
replace = <start> strchr(data, '\n') <end> ;"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
<start> data = dataBuffer <end> ;"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
baseObject->action <start> data <end> );"	"baseObject->action <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	2
cac216e8-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_connect_socket_open_53 { void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badSink_b(data); }"	where is the vulnerable dataflow from data to badSink_b ?	"replace = <start> strchr(data, '\n') <end> ;
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"<start> badSink_b(data) <end> ;
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
badSink_b <start> data <end> );"	"badSink_b <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	2
c72d5d8a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 namespace CWE23_Relative_Path_Traversal__char_listen_socket_ifstream_51 { void badSink(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badSink(data); }"	where is the vulnerable dataflow from data to badSink ?	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
badSink <start> data <end> );"	"<start> badSink(data) <end> ;
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"badSink <start> data <end> );
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"replace = <start> strchr(data, '\n') <end> ;
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	0
466e7ec7-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) typedef struct _CWE190_Integer_Overflow__int_fgets_add_67_structType { int structFirst; } CWE190_Integer_Overflow__int_fgets_add_67_structType; void CWE190_Integer_Overflow__int_fgets_add_67b_badSink(CWE190_Integer_Overflow__int_fgets_add_67_structType myStruct) { int data = myStruct.structFirst; { int result = data + 1; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"void CWE190_Integer_Overflow__int_fgets_add_67b_badSink(CWE190_Integer_Overflow__int_fgets_add_67_structType <start> myStruct <end> );
int result = <start> data <end>  + 1;
int data = <start> myStruct <end> .structFirst;"	"void CWE190_Integer_Overflow__int_fgets_add_67b_badSink(CWE190_Integer_Overflow__int_fgets_add_67_structType <start> myStruct <end> );
int data = <start> myStruct <end> .structFirst;
int result = <start> data <end>  + 1;"	"int result = <start> data <end>  + 1;
void CWE190_Integer_Overflow__int_fgets_add_67b_badSink(CWE190_Integer_Overflow__int_fgets_add_67_structType <start> myStruct <end> );
int <start> data = myStruct.structFirst <end> ;"	"<start> printIntLine(result) <end> ;
void CWE190_Integer_Overflow__int_fgets_add_67b_badSink(CWE190_Integer_Overflow__int_fgets_add_67_structType <start> myStruct <end> );
int data = <start> myStruct <end> .structFirst;"	1
74ee240f-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE 8 void CWE194_Unexpected_Sign_Extension__fgets_malloc_51b_badSink(short data) { if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }	where is the vulnerable dataflow from data to malloc ?	"<start> free(dataBuffer) <end> ;
void CWE194_Unexpected_Sign_Extension__fgets_malloc_51b_badSink(short <start> data <end> );"	"void CWE194_Unexpected_Sign_Extension__fgets_malloc_51b_badSink(short <start> data <end> );
<start> printLine(dataBuffer) <end> ;"	"void CWE194_Unexpected_Sign_Extension__fgets_malloc_51b_badSink(short <start> data <end> );
char * dataBuffer = (char * <start> malloc(data) <end> ;"	"void CWE194_Unexpected_Sign_Extension__fgets_malloc_51b_badSink(short <start> data <end> );
char * dataBuffer = (char *)malloc <start> data <end> );"	3
a830bf67-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; void CWE191_Integer_Underflow__int_connect_socket_multiply_04_bad() { int data; data = 0; if(STATIC_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(STATIC_CONST_TRUE) { if(data < 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data * 2 <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"data = <start> atoi(inputBuffer) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	2
715a3bf9-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif char * CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_61b_badSource(char * data); void CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_61_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; data = CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_61b_badSource(data); { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"data = <start> CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_61b_badSource <end> (data);
printLine <start> dest <end> );"	"data = <start> CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_61b_badSource <end> (data);
<start> printLine(dest) <end> ;"	"data = <start> CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_61b_badSource <end> (data);
SNPRINTF(dest, <start> 100-1 <end> , data);"	"printLine <start> dest <end> );
<start> SNPRINTF(dest, 100-1, data) <end> ;"	0
964cdbf0-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FULL_COMMAND ""dir "" #else #define FULL_COMMAND ""ls "" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define POPEN _popen #define PCLOSE _pclose #else #define POPEN popen #define PCLOSE pclose #endif static int badStatic = 0; static char * badSource(char * data) { if(badStatic) { { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } return data; } void CWE78_OS_Command_Injection__char_file_popen_21_bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; badStatic = 1; data = badSource(data); { FILE *pipe; pipe = POPEN(data, ""w""); if (pipe != NULL) { PCLOSE(pipe); } } }"	where is the vulnerable dataflow from data to POPEN ?	"static char * <start> badSource <end> (char * data);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
data = <start> badSource <end> (data);
size_t dataLen = <start> strlen(data) <end> ;"	"static char * <start> badSource <end> (char * data);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
data = <start> badSource <end> (data);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
pipe = POPEN <start> data <end> , ""w"");"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
static char * <start> badSource <end> (char * data);"	2
4ec5d070-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticFive = 5; void CWE190_Integer_Overflow__int_fgets_postinc_07_bad() { int data; data = 0; if(staticFive==5) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(staticFive==5) { { data++; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> data <end> ++;"	"<start> data <end> ++;
char <start> inputBuffer[CHAR_ARRAY_SIZE] = """" <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> printIntLine(result) <end> ;"	"<start> data <end> ++;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	0
b1b80819-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE197_Numeric_Truncation_Error__int_listen_socket_to_char_81 { void bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } const CWE197_Numeric_Truncation_Error__int_listen_socket_to_char_81_base& baseObject = CWE197_Numeric_Truncation_Error__int_listen_socket_to_char_81_bad(); baseObject.action(data); }"	where is the vulnerable dataflow from data to action ?	"data = <start> atoi(inputBuffer) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
baseObject.action <start> data <end> );"	"baseObject.action <start> data <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
baseObject.action <start> data <end> );"	3
9c4551ab-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE126_Buffer_Overread__CWE129_connect_socket_31_bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { int dataCopy = data; int data = dataCopy; { int buffer[10] = { 0 }; if (data >= 0) { printIntLine(buffer[data]); } else { printLine(""ERROR: Array index is negative""); } } } }"	where is the vulnerable dataflow from buffer[data] to printIntLine ?	"printIntLine <start> buffer[data] <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[data] <end> );"	"int <start> buffer[10] = { 0 } <end> ;
printIntLine <start> buffer[data] <end> );"	"printIntLine <start> buffer[data] <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	1
80d986fa-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; namespace CWE23_Relative_Path_Traversal__char_console_fopen_04 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(STATIC_CONST_TRUE) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
pFile = FOPEN <start> data <end> , ""wb+"");"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
char <start> dataBuffer[FILENAME_MAX] = BASEPATH <end> ;"	"pFile = FOPEN <start> data <end> , ""wb+"");
dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
size_t dataLen = <start> strlen(data) <end> ;"	0
d1e9da53-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 namespace CWE36_Absolute_Path_Traversal__char_listen_socket_ifstream_02 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"recvResult = recv(acceptSocket, (char *)(data + dataLen), <start> sizeof(char) * (FILENAME_MAX - dataLen - 1) <end> , 0);
inputFile.open((char * <start> data <end> );"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
inputFile.open((char * <start> data <end> );"	"size_t dataLen = <start> strlen(data) <end> ;
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
recvResult = recv(acceptSocket, (char *)(data + dataLen), <start> sizeof(char) * (FILENAME_MAX - dataLen - 1) <end> , 0);"	1
60db83d8-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__char_rand_multiply_72 { void badSink(vector<char> dataVector) { char data = dataVector[2]; if(data > 0) { char result = data * 2; printHexCharLine(result); } }	where is the vulnerable dataflow from data ?	"<start> printHexCharLine(result) <end> ;
void badSink(vector<char> <start> dataVector <end> );"	"char result = <start> data <end>  * 2;
void badSink(vector<char> <start> dataVector <end> );"	"void badSink(vector<char> <start> dataVector <end> );
char result = <start> data <end>  * 2;"	"<start> printHexCharLine(result) <end> ;
char result = <start> data <end>  * 2;"	2
7fa68e23-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_connect_socket_fopen_02 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	"<start> data = dataBuffer <end> ;
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"replace = <start> strchr(data, '\r') <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	0
98b01552-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_connect_socket_21 { static int badStatic = 0; static void badSink(int data) { if(badStatic) { { int i; int * buffer = new int[10]; for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } delete[] buffer; } } } void bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badStatic = 1; badSink(data); }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"<start> badSink(data) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[i] <end> );
badSink <start> data <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSink <start> data <end> );
static void badSink(int <start> data <end> );
printIntLine <start> buffer[i] <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[i] <end> );"	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
static void badSink(int <start> data <end> );
badSink <start> data <end> );
printIntLine <start> buffer[i] <end> );"	1
69161b4a-6c15-11ed-81d4-94e6f77dd552	extern int CWE190_Integer_Overflow__int_rand_preinc_68_badData; extern int CWE190_Integer_Overflow__int_rand_preinc_68_goodG2BData; extern int CWE190_Integer_Overflow__int_rand_preinc_68_goodB2GData; void CWE190_Integer_Overflow__int_rand_preinc_68b_badSink() { int data = CWE190_Integer_Overflow__int_rand_preinc_68_badData; { ++data; int result = data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"int <start> result = data <end> ;
+ <start> data <end> ;"	"int data = <start> CWE190_Integer_Overflow__int_rand_preinc_68_badData <end> ;
int <start> result = data <end> ;"	"int data = <start> CWE190_Integer_Overflow__int_rand_preinc_68_badData <end> ;
+ <start> data <end> ;"	"+ <start> data <end> ;
int data = <start> CWE190_Integer_Overflow__int_rand_preinc_68_badData <end> ;"	2
9059f3c6-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 256 void CWE681_Incorrect_Conversion_Between_Numeric_Types__double2int_02_bad() { if(1) { { char inputBuffer[CHAR_ARRAY_SIZE]; double doubleNumber = 0; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { doubleNumber = atof(inputBuffer); } else { printLine(""fgets() failed.""); } printIntLine((int)doubleNumber); } } }"	where is the vulnerable dataflow from (int)doubleNumber to printIntLine ?	"printIntLine <start> (int)doubleNumber <end> );
doubleNumber = <start> atof(inputBuffer) <end> ;"	"double <start> doubleNumber = 0 <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> (int)doubleNumber <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> doubleNumber = atof(inputBuffer) <end> ;"	2
7fa68e50-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_connect_socket_open_12 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(globalReturnsTrueOrFalse()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } else { strcat(data, ""file.txt""); } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"<start> data = dataBuffer <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
size_t dataLen = <start> strlen(data) <end> ;"	1
5af03dec-6c15-11ed-81d4-94e6f77dd552	"static int64_t CWE191_Integer_Underflow__int64_t_fscanf_postdec_45_badData; static int64_t CWE191_Integer_Underflow__int64_t_fscanf_postdec_45_goodG2BData; static int64_t CWE191_Integer_Underflow__int64_t_fscanf_postdec_45_goodB2GData; static void badSink() { int64_t data = CWE191_Integer_Underflow__int64_t_fscanf_postdec_45_badData; { data--; int64_t result = data; printLongLongLine(result); } } void CWE191_Integer_Underflow__int64_t_fscanf_postdec_45_bad() { int64_t data; data = 0LL; fscanf (stdin, ""%"" SCNd64, &data); CWE191_Integer_Underflow__int64_t_fscanf_postdec_45_badData = data; badSink(); }"	where is the vulnerable dataflow from data ?	"<start> CWE191_Integer_Underflow__int64_t_fscanf_postdec_45_badData = data <end> ;
<start> data <end> --;
fscanf (stdin, ""%"" SCNd64, <start> &data <end> );
int64_t data = <start> CWE191_Integer_Underflow__int64_t_fscanf_postdec_45_badData <end> ;
static int64_t <start> CWE191_Integer_Underflow__int64_t_fscanf_postdec_45_badData <end> ;"	"static int64_t <start> CWE191_Integer_Underflow__int64_t_fscanf_postdec_45_badData <end> ;
fscanf (stdin, ""%"" SCNd64, <start> &data <end> );
<start> CWE191_Integer_Underflow__int64_t_fscanf_postdec_45_badData = data <end> ;
int64_t data = <start> CWE191_Integer_Underflow__int64_t_fscanf_postdec_45_badData <end> ;"	"fscanf (stdin, ""%"" SCNd64, <start> &data <end> );
<start> CWE191_Integer_Underflow__int64_t_fscanf_postdec_45_badData = data <end> ;
static int64_t <start> CWE191_Integer_Underflow__int64_t_fscanf_postdec_45_badData <end> ;"	"fscanf (stdin, ""%"" SCNd64, <start> &data <end> );
<start> CWE191_Integer_Underflow__int64_t_fscanf_postdec_45_badData = data <end> ;
static int64_t <start> CWE191_Integer_Underflow__int64_t_fscanf_postdec_45_badData <end> ;
int64_t data = <start> CWE191_Integer_Underflow__int64_t_fscanf_postdec_45_badData <end> ;
<start> data <end> --;"	3
7fa68e53-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_connect_socket_open_15 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; switch(6) { case 6: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; default: printLine(""Benign, fixed string""); break; } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"replace = <start> strchr(data, '\r') <end> ;
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
<start> data = dataBuffer <end> ;"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - <start> dataLen - 1 <end> ), 0);"	1
b08640de-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE197_Numeric_Truncation_Error__int_fgets_to_short_13_bad() { int data; data = -1; if(GLOBAL_CONST_FIVE==5) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } { short shortData = (short)data; printShortLine(shortData); } }"	where is the vulnerable dataflow from shortData to printShortLine ?	"<start> data = atoi(inputBuffer) <end> ;
printShortLine <start> shortData <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
if  <start> fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) <end>  != NULL);"	"<start> printShortLine(shortData) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printShortLine <start> shortData <end> );"	3
a6fd826d-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int badStatic = 0; static void badSink(int data) { if(badStatic) { { ++data; int result = data; printIntLine(result); } } } void CWE190_Integer_Overflow__int_fgets_preinc_21_bad() { int data; data = 0; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } badStatic = 1; badSink(data); }"	where is the vulnerable dataflow from result to printIntLine ?	"badSink <start> data <end> );
printIntLine <start> result <end> );
<start> badSink(data) <end> ;
static void badSink(int <start> data <end> );"	"printIntLine <start> result <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
static void badSink(int <start> data <end> );
badSink <start> data <end> );"	"printIntLine <start> result <end> );
<start> badSink(data) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
badSink <start> data <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
badSink <start> data <end> );
static void badSink(int <start> data <end> );
printIntLine <start> result <end> );"	3
a830bf6d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_connect_socket_multiply_10_bad() { int data; data = 0; if(globalTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalTrue) { if(data < 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
if <start> data < 0 <end> ) ;"	"printIntLine <start> result <end> );
int result = <start> data * 2 <end> ;"	"<start> data = atoi(inputBuffer) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	0
93ece2ff-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING ""hello"" static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } void CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_08_bad() { size_t data; data = 0; if(staticReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = strtoul(inputBuffer, NULL, 0); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticReturnsTrue()) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); } else { printLine(""Input is less than the length of the source string""); } } } }"	where is the vulnerable dataflow from data to malloc ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
myString = (char *)malloc <start> data*sizeof(char) <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
data = <start> strtoul(inputBuffer, NULL, 0) <end> ;"	"myString = (char *)malloc <start> data*sizeof(char) <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	1
a23a3e4b-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_square_11_bad() { int data; data = 0; if(globalReturnsTrue()) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(globalReturnsTrue()) { { int result = data * data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
int result = <start> data * data <end> ;"	"<start> printIntLine(result) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;"	0
c26a7e53-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_console_open_53 { void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } badSink_b(data); }"	where is the vulnerable dataflow from data to badSink_b ?	"<start> badSink_b(data) <end> ;
badSink_b <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
badSink_b <start> data <end> );"	"size_t dataLen = <start> strlen(data) <end> ;
badSink_b <start> data <end> );"	"badSink_b <start> data <end> );
if (dataLen > 0 && <start> data[dataLen-1] == '\n' <end> );"	1
c4cd6f39-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_environment_open_11 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(globalReturnsTrue()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
<start> data = dataBuffer <end> ;"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"strncat <start> data+dataLen <end> , environment, FILENAME_MAX-dataLen-1);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	1
d0b64ef8-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif namespace CWE36_Absolute_Path_Traversal__char_file_ofstream_53 { void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } badSink_b(data); }"	where is the vulnerable dataflow from data to badSink_b ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
<start> data = dataBuffer <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
badSink_b <start> data <end> );"	"size_t dataLen = <start> strlen(data) <end> ;
badSink_b <start> data <end> );"	"<start> data = dataBuffer <end> ;
badSink_b <start> data <end> );"	1
8b91e459-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_listen_socket_fopen_43 { void badSource(char * &data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; badSource(data); { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"size_t dataLen = <start> strlen(data) <end> ;
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	"<start> badSource(data) <end> ;
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	"badSource <start> data <end> );
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
if  <start> listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR <end> );"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
badSource <start> data <end> );
pFile = FOPEN <start> data <end> , ""wb+"");"	3
c8600ae5-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 namespace CWE23_Relative_Path_Traversal__char_listen_socket_ofstream_15 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; switch(6) { case 6: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; default: printLine(""Benign, fixed string""); break; } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
if  <start> acceptSocket == SOCKET_ERROR <end> );"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
outputFile.open((char * <start> data <end> );"	"outputFile.open((char * <start> data <end> );
<start> data = dataBuffer <end> ;"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
size_t dataLen = <start> strlen(data) <end> ;"	1
60db83c1-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__char_rand_multiply_16_bad() { char data; data = ' '; while(1) { data = (char)RAND32(); break; } while(1) { if(data > 0) { char result = data * 2; printHexCharLine(result); } break; } }	where is the vulnerable dataflow from data ?	"data = (char <start> RAND32() <end> ;
<start> printHexCharLine(result) <end> ;"	"if <start> data > 0 <end> ) ;
char result = <start> data <end>  * 2;"	"data = (char <start> RAND32() <end> ;
char result = <start> data <end>  * 2;"	"<start> printHexCharLine(result) <end> ;
char result = <start> data <end>  * 2;"	2
d1e9da2f-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif static const int STATIC_CONST_FIVE = 5; namespace CWE36_Absolute_Path_Traversal__char_listen_socket_fopen_06 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(STATIC_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	"<start> data = dataBuffer <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
size_t dataLen = <start> strlen(data) <end> ;"	"replace = <start> strchr(data, '\r') <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	0
8f278a69-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_63b_badSink(int * dataPtr) { int data = *dataPtr; { size_t i; int *intPointer; intPointer = (int*)malloc(data * sizeof(int)); if (intPointer == NULL) {exit(-1);} for (i = 0; i < (size_t)data; i++) { intPointer[i] = 0; } printIntLine(intPointer[0]); free(intPointer); } }"	where is the vulnerable dataflow from data to malloc ?	"int <start> data = *dataPtr <end> ;
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	"intPointer = (int*)malloc <start> data * sizeof(int) <end> );
<start> printIntLine(intPointer[0]) <end> ;"	"void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_63b_badSink(int * <start> dataPtr <end> );
<start> printIntLine(intPointer[0]) <end> ;"	"void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_63b_badSink(int * <start> dataPtr <end> );
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	3
c4cd6f6e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_file_fopen_22 { int badGlobal = 0; char * badSource(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; badGlobal = 1; data = badSource(data); { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } ; }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = FOPEN <start> data <end> , ""wb+"");
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	"<start> data = badSource(data) <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"data = <start> badSource <end> (data);
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
data = <start> badSource <end> (data);"	2
761e2965-6c15-11ed-81d4-94e6f77dd552	"namespace CWE194_Unexpected_Sign_Extension__fgets_memcpy_62 { void badSource(short &data); void bad() { short data; data = 0; badSource(data); { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"badSource <start> data <end> );
printLine <start> dest <end> );"	"badSource <start> data <end> );
<start> badSource(data) <end> ;"	"printLine <start> dest <end> );
<start> printLine(dest) <end> ;"	"printLine <start> dest <end> );
<start> memcpy(dest, source, data) <end> ;"	0
d31a250e-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 namespace CWE36_Absolute_Path_Traversal__char_listen_socket_ofstream_65 { void badSink(char * data); void bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } funcPtr(data); }"	where is the vulnerable dataflow from data to funcPtr ?	"funcPtr <start> data <end> );
char <start> dataBuffer[FILENAME_MAX] = """" <end> ;"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
<start> funcPtr(data) <end> ;"	"funcPtr <start> data <end> );
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) *  <start> FILENAME_MAX - dataLen - 1 <end> ), 0);"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
funcPtr <start> data <end> );"	3
74ee23e9-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" void CWE194_Unexpected_Sign_Extension__connect_socket_strncpy_63b_badSink(short * dataPtr) { short data = *dataPtr; { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"char <start> dest[100] = """" <end> ;
printLine <start> dest <end> );"	"printLine <start> dest <end> );
<start> strncpy(dest, source, data) <end> ;"	"printLine <start> dest <end> );
void CWE194_Unexpected_Sign_Extension__connect_socket_strncpy_63b_badSink(short * <start> dataPtr <end> );"	"void CWE194_Unexpected_Sign_Extension__connect_socket_strncpy_63b_badSink(short * <start> dataPtr <end> );
printLine <start> dest <end> );"	3
a5ce1c7a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_postinc_10_bad() { int data; data = 0; if(globalTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalTrue) { { data++; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
<start> data++ <end> ;"	"<start> data = atoi(inputBuffer) <end> ;
printIntLine <start> result <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
int <start> result = data <end> ;"	2
6dc614f3-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" static void badVaSink(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_52c_badSink(char * data) { badVaSink(data, data); }"	where is the vulnerable dataflow from data to vprintf ?	"badVaSink <start> data <end> , data);
vprintf <start> data <end> , args);
static void badVaSink(char * <start> data <end> , ...);
void CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_52c_badSink(char * <start> data <end> );"	"<start> vprintf(data, args) <end> ;
vprintf <start> data <end> , args);
void CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_52c_badSink(char * <start> data <end> );
static void badVaSink(char * <start> data <end> , ...);"	"vprintf <start> data <end> , args);
void CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_52c_badSink(char * <start> data <end> );
static void badVaSink(char * <start> data <end> , ...);
<start> va_start(args, data) <end> ;"	"void CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_52c_badSink(char * <start> data <end> );
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
vprintf <start> data <end> , args);"	3
c8600b04-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_listen_socket_open_15 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; switch(6) { case 6: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; default: printLine(""Benign, fixed string""); break; } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"replace = <start> strchr(data, '\r') <end> ;
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	0
d1e9da14-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_file_open_41 { void badSink(char * data) { { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } } void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } badSink(data); }"	where is the vulnerable dataflow from data to badSink ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
badSink <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
size_t dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
<start> badSink(data) <end> ;"	1
5e44fca6-6c15-11ed-81d4-94e6f77dd552	void CWE191_Integer_Underflow__int_fscanf_predec_51b_badSink(int data) { { --data; int result = data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"void CWE191_Integer_Underflow__int_fscanf_predec_51b_badSink(int <start> data <end> );
- <start> data <end> ;"	"- <start> data <end> ;
<start> printIntLine(result) <end> ;"	"- <start> data <end> ;
void CWE191_Integer_Underflow__int_fscanf_predec_51b_badSink(int <start> data <end> );"	"<start> printIntLine(result) <end> ;
void CWE191_Integer_Underflow__int_fscanf_predec_51b_badSink(int <start> data <end> );"	0
92bb8a01-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define SEARCH_CHAR 'S' void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_13_bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\0'; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } if(GLOBAL_CONST_FIVE==5) { for (; *data != '\0'; data++) { if (*data == SEARCH_CHAR) { printLine(""We have a match!""); break; } } free(data); } }"	where is the vulnerable dataflow from data to free ?	"for (; *data != '\0'; <start> data++ <end> );
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"for (; *data != '\0'; <start> data++ <end> );
free <start> data <end> );"	"replace = <start> strchr(data, '\r') <end> ;
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
free <start> data <end> );"	3
7ae3a724-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_64b_badSink(void * dataVoidPtr) { int * dataPtr = (int *)dataVoidPtr; int data = (*dataPtr); { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_64b_badSink(void * <start> dataVoidPtr <end> );
<start> memmove(dest, source, data) <end> ;"	"printLine <start> dest <end> );
<start> memmove(dest, source, data) <end> ;"	"<start> printLine(dest) <end> ;
void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_64b_badSink(void * <start> dataVoidPtr <end> );"	"void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_64b_badSink(void * <start> dataVoidPtr <end> );
printLine <start> dest <end> );"	3
a49c4f5e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE190_Integer_Overflow__int_listen_socket_multiply_81 { void bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } const CWE190_Integer_Overflow__int_listen_socket_multiply_81_base& baseObject = CWE190_Integer_Overflow__int_listen_socket_multiply_81_bad(); baseObject.action(data); }"	where is the vulnerable dataflow from data to action ?	"baseObject.action <start> data <end> );
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"baseObject.action <start> data <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"if  <start> recvResult == SOCKET_ERROR <end>  || recvResult == 0);
baseObject.action <start> data <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
baseObject.action <start> data <end> );"	3
60db839e-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__char_rand_add_31_bad() { char data; data = ' '; data = (char)RAND32(); { char dataCopy = data; char data = dataCopy; { char result = data + 1; printHexCharLine(result); } } }	where is the vulnerable dataflow from data ?	"data = (char <start> RAND32() <end> ;
char result = <start> data <end>  + 1;"	"char result = <start> data <end>  + 1;
data = (char <start> RAND32() <end> ;"	"char <start> dataCopy = data <end> ;
data = (char <start> RAND32() <end> ;"	"char result = <start> data <end>  + 1;
char <start> dataCopy = data <end> ;"	0
4b34b00d-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__short_fscanf_square_51b_badSink(short data) { { short result = data * data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"void CWE190_Integer_Overflow__short_fscanf_square_51b_badSink(short <start> data <end> );
<start> printIntLine(result) <end> ;"	"<start> printIntLine(result) <end> ;
short result = <start> data <end>  * data;"	"void CWE190_Integer_Overflow__short_fscanf_square_51b_badSink(short <start> data <end> );
short result = <start> data <end>  * data;"	"short result = <start> data <end>  * data;
void CWE190_Integer_Overflow__short_fscanf_square_51b_badSink(short <start> data <end> );"	2
a109492d-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_add_02_bad() { int data; data = 0; if(1) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(1) { { int result = data + 1; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"int <start> result = data + 1 <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"<start> printIntLine(result) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );"	"<start> data = atoi(inputBuffer) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	2
86cea13f-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int badSource(int data) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } return data; } void CWE369_Divide_by_Zero__int_fgets_modulo_42_bad() { int data; data = -1; data = badSource(data); printIntLine(100 % data); }"	where is the vulnerable dataflow from data to printIntLine ?	"static int <start> badSource <end> (int data);
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> 100 % data <end> );"	"data = <start> badSource <end> (data);
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> 100 % data <end> );
static int <start> badSource <end> (int data);"	"printIntLine <start> 100 % data <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
static int <start> badSource <end> (int data);
data = <start> badSource <end> (data);
printIntLine <start> 100 % data <end> );"	3
bb49c5a1-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #define EXECLP _execlp #else #define EXECLP execlp #endif void CWE78_OS_Command_Injection__char_console_execlp_10_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(globalTrue) { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECLP ?	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
if (fgets(data+dataLen, (int) <start> 100-dataLen <end> ), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"<start> data = dataBuffer <end> ;
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
dataLen = <start> strlen(data) <end> ;"	1
bc721f92-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define EXECLP _execlp #else #define EXECLP execlp #endif void CWE78_OS_Command_Injection__char_file_execlp_11_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(globalReturnsTrue()) { { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECLP ?	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	"EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"size_t <start> dataLen = strlen(data) <end> ;
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	2
9d74539c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int badSource(int data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } return data; } void CWE127_Buffer_Underread__CWE839_connect_socket_42_bad() { int data; data = -1; data = badSource(data); { int buffer[10] = { 0 }; if (data < 10) { printIntLine(buffer[data]); } else { printLine(""ERROR: Array index is too big.""); } } }"	where is the vulnerable dataflow from buffer[data] to printIntLine ?	"data = <start> atoi(inputBuffer) <end> ;
printIntLine <start> buffer[data] <end> );
static int <start> badSource <end> (int data);
data = <start> badSource <end> (data);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static int <start> badSource <end> (int data);
data = <start> badSource <end> (data);
printIntLine <start> buffer[data] <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
data = <start> badSource <end> (data);
static int <start> badSource <end> (int data);
printIntLine <start> buffer[data] <end> );"	"data = <start> badSource <end> (data);
static int <start> badSource <end> (int data);
recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);
printIntLine <start> buffer[data] <end> );"	1
7ae3a755-6c15-11ed-81d4-94e6f77dd552	"namespace CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_72 { void badSink(vector<int> dataVector) { int data = dataVector[2]; { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	"<start> strncpy(dest, source, data) <end> ;
printLine <start> dest <end> );"	"void badSink(vector<int> <start> dataVector <end> );
printLine <start> dest <end> );"	"void badSink(vector<int> <start> dataVector <end> );
<start> strncpy(dest, source, data) <end> ;"	2
715a3be5-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif void CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_11_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; if(globalReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalReturnsTrue()) { { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> SNPRINTF(dest, 100-1, data) <end> ;
printLine <start> dest <end> );"	"<start> printLine(dest) <end> ;
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"<start> data = dataBuffer <end> ;
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
printLine <start> dest <end> );"	3
728a5015-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 static void badVaSinkB(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_15_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; switch(6) { case 6: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; default: printLine(""Benign, fixed string""); break; } switch(7) { case 7: badVaSinkB(data, data); break; default: printLine(""Benign, fixed string""); break; } }"	where is the vulnerable dataflow from data to vprintf ?	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);
vprintf <start> data <end> , args);"	"badVaSinkB <start> data <end> , data);
if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
static void badVaSinkB(char * <start> data <end> , ...);"	"if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );
badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);
vprintf <start> data <end> , args);"	"vprintf <start> data <end> , args);
static void badVaSinkB(char * <start> data <end> , ...);
size_t dataLen = <start> strlen(data) <end> ;
badVaSinkB <start> data <end> , data);"	0
cf875087-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_environment_open_14 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(globalFive==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
strncat(data+dataLen, environment, FILENAME_MAX <start> dataLen-1 <end> );"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
char <start> dataBuffer[FILENAME_MAX] = """" <end> ;"	1
5f76fc81-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_listen_socket_predec_10_bad() { int data; data = 0; if(globalTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalTrue) { { --data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"data = <start> atoi(inputBuffer) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"int <start> result = data <end> ;
- <start> data <end> ;"	"data = <start> atoi(inputBuffer) <end> ;
- <start> data <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
- <start> data <end> ;"	3
b08640e6-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE197_Numeric_Truncation_Error__int_fgets_to_short_31_bad() { int data; data = -1; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } { int dataCopy = data; int data = dataCopy; { short shortData = (short)data; printShortLine(shortData); } } }"	where is the vulnerable dataflow from shortData to printShortLine ?	"short <start> shortData = (short)data <end> ;
printShortLine <start> shortData <end> );"	"<start> printShortLine(shortData) <end> ;
printShortLine <start> shortData <end> );"	"printShortLine <start> shortData <end> );
short shortData = <start> (short)data <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printShortLine <start> shortData <end> );"	3
c01af8cd-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_connect_socket_open_13 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(GLOBAL_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
replace = <start> strchr(data, '\n') <end> ;"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
replace = <start> strchr(data, '\r') <end> ;"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);"	2
48d25dc1-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__int_listen_socket_add_72 { void badSink(vector<int> dataVector) { int data = dataVector[2]; { int result = data + 1; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"void badSink(vector<int> <start> dataVector <end> );
int result = <start> data <end>  + 1;"	"int result = <start> data <end>  + 1;
void badSink(vector<int> <start> dataVector <end> );"	"void badSink(vector<int> <start> dataVector <end> );
<start> printIntLine(result) <end> ;"	"int result = <start> data <end>  + 1;
<start> printIntLine(result) <end> ;"	0
47a2a844-6c15-11ed-81d4-94e6f77dd552	"static void badSink(int data) { if(data > 0) { int result = data * 2; printIntLine(result); } } void CWE190_Integer_Overflow__int_fscanf_multiply_44_bad() { int data; void (*funcPtr) (int) = badSink; data = 0; fscanf(stdin, ""%d"", &data); funcPtr(data); }"	where is the vulnerable dataflow from data ?	"int result = <start> data * 2 <end> ;
fscanf(stdin, ""%d"", <start> &data <end> );
funcPtr <start> data <end> );
static void badSink(int <start> data <end> );"	"int <start> result = data * 2 <end> ;
funcPtr <start> data <end> );
fscanf(stdin, ""%d"", <start> &data <end> );
static void badSink(int <start> data <end> );"	"fscanf(stdin, ""%d"", <start> &data <end> );
funcPtr <start> data <end> );
static void badSink(int <start> data <end> );
int result = <start> data <end>  * 2;"	"static void badSink(int <start> data <end> );
int result = <start> data <end>  * 2;
funcPtr <start> data <end> );"	2
820a46b5-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_file_fopen_09 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(GLOBAL_CONST_TRUE) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
size_t dataLen = <start> strlen(data) <end> ;"	"pFile = FOPEN <start> data <end> , ""wb+"");
<start> data = dataBuffer <end> ;"	1
6c938be5-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) typedef struct _CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_67_structType { int structFirst; } CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_67_structType; void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_67b_badSink(CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_67_structType myStruct) { int data = myStruct.structFirst; { int i; int * buffer = (int *)malloc(10 * sizeof(int)); if (buffer == NULL) {exit(-1);} for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } free(buffer); } }"	where is the vulnerable dataflow from buffer to free ?	"void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_67b_badSink(CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_67_structType <start> myStruct <end> );
int data = <start> myStruct <end> .structFirst;
free <start> buffer <end> );"	"void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_67b_badSink(CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_67_structType <start> myStruct <end> );
<start> printIntLine(buffer[i]) <end> ;
int data = <start> myStruct <end> .structFirst;"	"if  <start> buffer == NULL <end> ) {exit(-1);};
free <start> buffer <end> );
void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_67b_badSink(CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_67_structType <start> myStruct <end> );"	"free <start> buffer <end> );
int data = <start> myStruct <end> .structFirst;
<start> free(buffer) <end> ;"	0
951c5e9c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FULL_COMMAND ""dir "" #else #define FULL_COMMAND ""ls "" #endif #ifdef _WIN32 #define POPEN _popen #define PCLOSE _pclose #else #define POPEN popen #define PCLOSE pclose #endif static void badSink(char * data) { { FILE *pipe; pipe = POPEN(data, ""w""); if (pipe != NULL) { PCLOSE(pipe); } } } void CWE78_OS_Command_Injection__char_console_popen_44_bad() { char * data; void (*funcPtr) (char *) = badSink; char data_buf[100] = FULL_COMMAND; data = data_buf; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } funcPtr(data); }"	where is the vulnerable dataflow from data to POPEN ?	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
funcPtr <start> data <end> );
static void badSink(char * <start> data <end> );
pipe = POPEN <start> data <end> , ""w"");"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
static void badSink(char * <start> data <end> );
<start> funcPtr(data) <end> ;
funcPtr <start> data <end> );"	"static void badSink(char * <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	"pipe = POPEN <start> data <end> , ""w"");
size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
static void badSink(char * <start> data <end> );"	0
b8e2bdd9-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define SEARCH_CHAR 'S' namespace CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_81 { void bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\0'; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } const CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_81_base& baseObject = CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_81_bad(); baseObject.action(data); }"	where is the vulnerable dataflow from data to action ?	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (100 - dataLen - 1), 0);
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"size_t <start> dataLen = strlen(data) <end> ;
baseObject.action <start> data <end> );"	"baseObject.action <start> data <end> );
if  <start> data == NULL <end> ) {exit(-1);};"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
baseObject.action <start> data <end> );"	3
abc3750a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_connect_socket_postdec_52c_badSink(int data) { { data--; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	"void CWE191_Integer_Underflow__int_connect_socket_postdec_52c_badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"int <start> result = data <end> ;
void CWE191_Integer_Underflow__int_connect_socket_postdec_52c_badSink(int <start> data <end> );"	"printIntLine <start> result <end> );
void CWE191_Integer_Underflow__int_connect_socket_postdec_52c_badSink(int <start> data <end> );"	1
c26a7e59-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_console_open_65 { void badSink(char * data); void bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } funcPtr(data); }"	where is the vulnerable dataflow from data to funcPtr ?	"<start> funcPtr(data) <end> ;
funcPtr <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
funcPtr <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
<start> data = dataBuffer <end> ;"	1
af580981-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE197_Numeric_Truncation_Error__int_fgets_to_char_17_bad() { int i; int data; data = -1; for(i = 0; i < 1; i++) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } { char charData = (char)data; printHexCharLine(charData); } }"	where is the vulnerable dataflow from charData to printHexCharLine ?	"printHexCharLine <start> charData <end> );
char charData = <start> (char)data <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printHexCharLine <start> charData <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
char charData = <start> (char)data <end> ;"	"printHexCharLine <start> charData <end> );
char <start> charData = (char)data <end> ;"	1
6c938c06-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif namespace CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_43 { static void badSource(char * &data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } void bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; badSource(data); { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"badSource <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"<start> SNPRINTF(dest, 100-1, data) <end> ;
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
badSource <start> data <end> );"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
badSource <start> data <end> );
replace = <start> strchr(data, '\r') <end> ;"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
badSource <start> data <end> );
printLine <start> dest <end> );"	3
656cd3eb-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__int_rand_multiply_18_bad() { int data; data = 0; goto source; source: data = RAND32(); goto sink; sink: if(data > 0) { int result = data * 2; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"if <start> data > 0 <end> ) ;
int result = <start> data <end>  * 2;"	"<start> data = RAND32() <end> ;
int result = <start> data <end>  * 2;"	"data = <start> RAND32() <end> ;
int result = <start> data <end>  * 2;"	"data = <start> RAND32() <end> ;
int <start> result = data * 2 <end> ;"	2
bed4a8be-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_connect_socket_fopen_12 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(globalReturnsTrueOrFalse()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } else { strcat(data, ""file.txt""); } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"replace = <start> strchr(data, '\n') <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
char <start> dataBuffer[FILENAME_MAX] = BASEPATH <end> ;"	"replace = <start> strchr(data, '\r') <end> ;
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	3
bb49c59d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #define EXECLP _execlp #else #define EXECLP execlp #endif static const int STATIC_CONST_FIVE = 5; void CWE78_OS_Command_Injection__char_console_execlp_06_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(STATIC_CONST_FIVE==5) { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECLP ?	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	"EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
<start> EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL) <end> ;"	0
5133a773-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_preinc_64b_badSink(void * dataVoidPtr) { int * dataPtr = (int *)dataVoidPtr; int data = (*dataPtr); { ++data; int result = data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"<start> ++data <end> ;
void CWE190_Integer_Overflow__int_fgets_preinc_64b_badSink(void * <start> dataVoidPtr <end> );"	"void CWE190_Integer_Overflow__int_fgets_preinc_64b_badSink(void * <start> dataVoidPtr <end> );
+ <start> data <end> ;"	"void CWE190_Integer_Overflow__int_fgets_preinc_64b_badSink(void * <start> dataVoidPtr <end> );
<start> printIntLine(result) <end> ;"	"int <start> result = data <end> ;
+ <start> data <end> ;"	1
99e16a74-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fgets_44 { static void badSink(int data) { { int i; int * buffer = new int[10]; for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } delete[] buffer; } } void bad() { int data; void (*funcPtr) (int) = badSink; data = -1; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } funcPtr(data); }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
funcPtr <start> data <end> );
static void badSink(int <start> data <end> );
printIntLine <start> buffer[i] <end> );"	"static void badSink(int <start> data <end> );
printIntLine <start> buffer[i] <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"static void badSink(int <start> data <end> );
printIntLine <start> buffer[i] <end> );
int <start> * buffer = new int[10] <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
static void badSink(int <start> data <end> );
printIntLine <start> buffer[i] <end> );
<start> data = atoi(inputBuffer) <end> ;"	0
5133a762-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_preinc_16_bad() { int data; data = 0; while(1) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } break; } while(1) { { ++data; int result = data; printIntLine(result); } break; } }"	where is the vulnerable dataflow from data ?	"int <start> result = data <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
+ <start> data <end> ;"	"<start> data = atoi(inputBuffer) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"<start> printIntLine(result) <end> ;
+ <start> data <end> ;"	1
598370d1-6c15-11ed-81d4-94e6f77dd552	void CWE191_Integer_Underflow__short_fscanf_sub_52c_badSink(short data) { { short result = data - 1; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"void CWE191_Integer_Underflow__short_fscanf_sub_52c_badSink(short <start> data <end> );
short result = <start> data - 1 <end> ;"	"void CWE191_Integer_Underflow__short_fscanf_sub_52c_badSink(short <start> data <end> );
<start> printIntLine(result) <end> ;"	"void CWE191_Integer_Underflow__short_fscanf_sub_52c_badSink(short <start> data <end> );
short result = <start> data <end>  - 1;"	"short result = <start> data <end>  - 1;
void CWE191_Integer_Underflow__short_fscanf_sub_52c_badSink(short <start> data <end> );"	2
453db052-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_square_63b_badSink(int * dataPtr) { int data = *dataPtr; { int result = data * data; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  * data;
void CWE190_Integer_Overflow__int_connect_socket_square_63b_badSink(int * <start> dataPtr <end> );"	"void CWE190_Integer_Overflow__int_connect_socket_square_63b_badSink(int * <start> dataPtr <end> );
int result = <start> data <end>  * data;"	"int <start> result = data * data <end> ;
void CWE190_Integer_Overflow__int_connect_socket_square_63b_badSink(int * <start> dataPtr <end> );"	"<start> printIntLine(result) <end> ;
void CWE190_Integer_Overflow__int_connect_socket_square_63b_badSink(int * <start> dataPtr <end> );"	1
c99197c2-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define STAT _stat #define OPEN _open #define WRITE _write #define O_RDWR _O_RDWR #define CLOSE _close #else #define STAT stat #define OPEN open #define WRITE write #define CLOSE close #endif #define BAD_SINK_STRING ""Bad Sink..."" #define GOOD_SINK_STRING ""Good Sink..."" #ifdef _WIN32 #define ACCESS _access #define W_OK 02 #else #define ACCESS access #endif void CWE367_TOC_TOU__access_17_bad() { int j; for(j = 0; j < 1; j++) { { char filename[100] = """"; int fileDesc = -1; if (fgets(filename, 100, stdin) == NULL) { printLine(""fgets() failed""); filename[0] = '\0'; } if (strlen(filename) > 0) { filename[strlen(filename)-1] = '\0'; } if (ACCESS(filename, W_OK) == -1) { exit(1); } fileDesc  = OPEN(filename, O_RDWR); if (fileDesc == -1) { exit(1); } if (WRITE(fileDesc, BAD_SINK_STRING, strlen(BAD_SINK_STRING)) == -1) { exit(1); } if (fileDesc != -1) { CLOSE(fileDesc); } } } }"	where is the vulnerable dataflow from filename to OPEN ?	"if (fgets <start> filename <end> , 100, stdin) == NULL);
if (WRITE(fileDesc, BAD_SINK_STRING, <start> strlen(BAD_SINK_STRING) <end> ) == -1);"	"fileDesc  = OPEN <start> filename <end> , O_RDWR);
filename <start> strlen(filename) <end> -1] = '\0'; ;"	"if (fgets <start> filename <end> , 100, stdin) == NULL);
fileDesc  = OPEN <start> filename <end> , O_RDWR);"	"char <start> filename[100] = """" <end> ;
fileDesc  = OPEN <start> filename <end> , O_RDWR);"	2
9059f393-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticTrue = 1; static int staticFalse = 0; void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_05_bad() { int data; data = -1; if(staticTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { size_t i; int *intPointer; intPointer = (int*)malloc(data * sizeof(int)); if (intPointer == NULL) {exit(-1);} for (i = 0; i < (size_t)data; i++) { intPointer[i] = 0; } printIntLine(intPointer[0]); free(intPointer); } }"	where is the vulnerable dataflow from data to malloc ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
intPointer = (int* <start> malloc(data * sizeof(int)) <end> ;"	"<start> data = atoi(inputBuffer) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
data = <start> atoi(inputBuffer) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	3
7fa68e03-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_14_bad() { int data; data = -1; if(globalFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printLine <start> dest <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> strncpy(dest, source, data) <end> ;"	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	0
8b91e4a5-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(count) + 2) #ifdef _WIN32 #define SLEEP Sleep #else #define SLEEP usleep #endif static int staticTrue = 1; static int staticFalse = 0; void CWE400_Resource_Exhaustion__connect_socket_sleep_05_bad() { int count; count = -1; if(staticTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; count = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticTrue) { SLEEP(count); printLine(""Sleep time possibly too long""); } }"	where is the vulnerable dataflow from count to SLEEP ?	"SLEEP <start> count <end> );
<start> count = -1 <end> ;"	"SLEEP <start> count <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"<start> SLEEP(count) <end> ;
SLEEP <start> count <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
SLEEP <start> count <end> );"	3
d1e9da17-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_file_open_44 { static void badSink(char * data) { { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } } void bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } funcPtr(data); }"	where is the vulnerable dataflow from data to funcPtr ?	"funcPtr <start> data <end> );
<start> data = dataBuffer <end> ;"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
funcPtr <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
<start> funcPtr(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
funcPtr <start> data <end> );"	3
9b124d80-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE124_Buffer_Underwrite__CWE839_connect_socket_16_bad() { int data; data = -1; while(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; } while(1) { { int i; int buffer[10] = { 0 }; if (data < 10) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } } break; } }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"printIntLine <start> buffer[i] <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[i] <end> );"	"printIntLine <start> buffer[i] <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"<start> printIntLine(buffer[i]) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	1
846ad2f9-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif void CWE252_Unchecked_Return_Value__char_fgets_18_bad() { goto sink; sink: { char dataBuffer[100] = """"; char * data = dataBuffer; printLine(""Please enter a string: ""); fgets(data, 100, stdin); printLine(data); } }"	where is the vulnerable dataflow from data to printLine ?	"char <start> * data = dataBuffer <end> ;
printLine <start> data <end> );"	"fgets <start> data <end> , 100, stdin);
<start> printLine(data) <end> ;"	"fgets <start> data <end> , 100, stdin);
printLine <start> data <end> );"	"fgets <start> data <end> , 100, stdin);
<start> fgets(data, 100, stdin) <end> ;"	2
d44c3fc0-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_listen_socket_open_65 { void badSink(char * data); void bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } funcPtr(data); }"	where is the vulnerable dataflow from data to funcPtr ?	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
funcPtr <start> data <end> );"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
funcPtr <start> data <end> );"	"size_t <start> dataLen = strlen(data) <end> ;
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
<start> recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0) <end> ;"	1
8a6310cf-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_file_open_61 { char * badSource(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; data = badSource(data); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"<start> data = dataBuffer <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN(data, O_RDWR|O_CREAT, <start> S_IREAD|S_IWRITE <end> );
data = <start> badSource <end> (data);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
<start> data = badSource(data) <end> ;"	"data = <start> badSource <end> (data);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	3
acf67e61-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_listen_socket_predec_03_bad() { int data; data = 0; if(5==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(5==5) { { --data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"<start> --data <end> ;
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
data = <start> atoi(inputBuffer) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
data = <start> atoi(inputBuffer) <end> ;"	2
78800f9f-6c15-11ed-81d4-94e6f77dd552	"namespace CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_72 { void badSink(vector<short> dataVector) { short data = dataVector[2]; { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"void badSink(vector<short> <start> dataVector <end> );
printLine <start> dest <end> );"	"short <start> data = dataVector[2] <end> ;
printLine <start> dest <end> );"	"printLine <start> dest <end> );
void badSink(vector<short> <start> dataVector <end> );"	"<start> memcpy(dest, source, data) <end> ;
printLine <start> dest <end> );"	0
c136626e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif namespace CWE23_Relative_Path_Traversal__char_console_ifstream_31 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } { char * dataCopy = data; char * data = dataCopy; { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } } }"	where is the vulnerable dataflow from data to open ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
inputFile.open((char * <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
dataLen = <start> strlen(data) <end> ;"	"inputFile.open((char * <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	"inputFile.open((char * <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	0
c5fc2378-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_file_open_17 { void bad() { int i; char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; for(i = 0; i < 1; i++) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"size_t dataLen = <start> strlen(data) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	1
79b2750e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 8 void CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_63b_badSink(short * dataPtr) { short data = *dataPtr; { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"void CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_63b_badSink(short * <start> dataPtr <end> );
short <start> data = *dataPtr <end> ;"	"void CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_63b_badSink(short * <start> dataPtr <end> );
<start> strncpy(dest, source, data) <end> ;"	"void CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_63b_badSink(short * <start> dataPtr <end> );
printLine <start> dest <end> );"	"printLine <start> dest <end> );
short <start> data = *dataPtr <end> ;"	2
b8e2bdd2-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 256 void CWE681_Incorrect_Conversion_Between_Numeric_Types__doubleNaN2int_12_bad() { if(globalReturnsTrueOrFalse()) { { char inputBuffer[CHAR_ARRAY_SIZE]; double doubleNumber = 0; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { doubleNumber = atof(inputBuffer); } else { printLine(""fgets() failed.""); } printIntLine((int)(sqrt(doubleNumber))); } } else { { char inputBuffer[CHAR_ARRAY_SIZE]; double doubleNumber = 0; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { doubleNumber = atof(inputBuffer); } else { printLine(""fgets() failed.""); } if (doubleNumber < 0) { printLine(""Value is negative""); } else { printIntLine((int)(sqrt(doubleNumber))); } } } }"	where is the vulnerable dataflow from doubleNumber to printIntLine ?	"printIntLine((int)(sqrt <start> doubleNumber <end> )));
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine((int)(sqrt <start> doubleNumber <end> )));"	"<start> doubleNumber = atof(inputBuffer) <end> ;
printIntLine((int)(sqrt <start> doubleNumber <end> )));"	"printIntLine((int) <start> sqrt(doubleNumber) <end> ));
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	1
453db04b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int CWE190_Integer_Overflow__int_connect_socket_square_45_badData; static int CWE190_Integer_Overflow__int_connect_socket_square_45_goodG2BData; static int CWE190_Integer_Overflow__int_connect_socket_square_45_goodB2GData; static void badSink() { int data = CWE190_Integer_Overflow__int_connect_socket_square_45_badData; { int result = data * data; printIntLine(result); } } void CWE190_Integer_Overflow__int_connect_socket_square_45_bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE190_Integer_Overflow__int_connect_socket_square_45_badData = data; badSink(); }"	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  * data;
<start> CWE190_Integer_Overflow__int_connect_socket_square_45_badData = data <end> ;
int data = <start> CWE190_Integer_Overflow__int_connect_socket_square_45_badData <end> ;
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
static int <start> CWE190_Integer_Overflow__int_connect_socket_square_45_badData <end> ;"	"static int <start> CWE190_Integer_Overflow__int_connect_socket_square_45_badData <end> ;
int data = <start> CWE190_Integer_Overflow__int_connect_socket_square_45_badData <end> ;
<start> CWE190_Integer_Overflow__int_connect_socket_square_45_badData = data <end> ;
int result = <start> data <end>  * data;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> CWE190_Integer_Overflow__int_connect_socket_square_45_badData = data <end> ;
static int <start> CWE190_Integer_Overflow__int_connect_socket_square_45_badData <end> ;
int data = <start> CWE190_Integer_Overflow__int_connect_socket_square_45_badData <end> ;
int result = <start> data <end>  * data;"	"<start> CWE190_Integer_Overflow__int_connect_socket_square_45_badData = data <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static int <start> CWE190_Integer_Overflow__int_connect_socket_square_45_badData <end> ;
int result = <start> data <end>  * data;
int data = <start> CWE190_Integer_Overflow__int_connect_socket_square_45_badData <end> ;"	2
73bc814d-6c15-11ed-81d4-94e6f77dd552	"int CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_22_badGlobal = 0; short CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_22_badSource(short data); void CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_22_bad() { short data; data = 0; CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_22_badGlobal = 1; data = CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_22_badSource(data); { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"data = <start> CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_22_badSource <end> (data);
printLine <start> dest <end> );"	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	"<start> data = 0 <end> ;
printLine <start> dest <end> );"	"data = <start> CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_22_badSource <end> (data);
<start> memcpy(dest, source, data) <end> ;"	0
9c4551a2-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE126_Buffer_Overread__CWE129_connect_socket_11_bad() { int data; data = -1; if(globalReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalReturnsTrue()) { { int buffer[10] = { 0 }; if (data >= 0) { printIntLine(buffer[data]); } else { printLine(""ERROR: Array index is negative""); } } } }"	where is the vulnerable dataflow from buffer[data] to printIntLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[data] <end> );"	"<start> printIntLine(buffer[data]) <end> ;
printIntLine <start> buffer[data] <end> );"	"printIntLine <start> buffer[data] <end> );
recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);"	"data = <start> atoi(inputBuffer) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	0
c9919805-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } namespace CWE36_Absolute_Path_Traversal__char_connect_socket_ifstream_08 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(staticReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"recvResult = <start> recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0) <end> ;
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"inputFile.open((char * <start> data <end> );
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
inputFile.open((char * <start> data <end> );"	"size_t <start> dataLen = strlen(data) <end> ;
inputFile.open((char * <start> data <end> );"	2
61da66ff-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__char_rand_square_82 { void CWE190_Integer_Overflow__char_rand_square_82_bad::action(char data) { { char result = data * data; printHexCharLine(result); } } }	where is the vulnerable dataflow from data ?	"void CWE190_Integer_Overflow__char_rand_square_82_bad::action(char <start> data <end> );
char result = <start> data <end>  * data;"	"<start> printHexCharLine(result) <end> ;
char result = <start> data <end>  * data;"	"void CWE190_Integer_Overflow__char_rand_square_82_bad::action(char <start> data <end> );
<start> printHexCharLine(result) <end> ;"	"char result = <start> data <end>  * data;
void CWE190_Integer_Overflow__char_rand_square_82_bad::action(char <start> data <end> );"	0
6b86245b-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) typedef union { int unionFirst; int unionSecond; } CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_34_unionType; void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_34_bad() { int data; CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_34_unionType myUnion; data = -1; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } myUnion.unionFirst = data; { int data = myUnion.unionSecond; { int i; int * buffer = (int *)malloc(10 * sizeof(int)); if (buffer == NULL) {exit(-1);} for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } free(buffer); } } }"	where is the vulnerable dataflow from buffer to free ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
if  <start> buffer == NULL <end> ) {exit(-1);};"	"free <start> buffer <end> );
<start> printIntLine(buffer[i]) <end> ;"	"free <start> buffer <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
free <start> buffer <end> );"	3
c4cd6f7d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_file_fopen_64 { void badSink(void * dataVoidPtr) { char * * dataPtr = (char * *)dataVoidPtr; char * data = (*dataPtr); { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"char <start> * data = (*dataPtr) <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"void badSink(void * <start> dataVoidPtr <end> );
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
void badSink(void * <start> dataVoidPtr <end> );"	"pFile = FOPEN <start> data <end> , ""wb+"");
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	1
5be3a9c3-6c15-11ed-81d4-94e6f77dd552	void CWE191_Integer_Underflow__int_fscanf_postdec_54e_badSink(int data) { { data--; int result = data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
void CWE191_Integer_Underflow__int_fscanf_postdec_54e_badSink(int <start> data <end> );"	"<start> data <end> --;
void CWE191_Integer_Underflow__int_fscanf_postdec_54e_badSink(int <start> data <end> );"	"void CWE191_Integer_Underflow__int_fscanf_postdec_54e_badSink(int <start> data <end> );
<start> data <end> --;"	"int <start> result = data <end> ;
void CWE191_Integer_Underflow__int_fscanf_postdec_54e_badSink(int <start> data <end> );"	2
80d986f9-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_console_fopen_03 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(5==5) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"dataLen = <start> strlen(data) <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	2
b54bcf44-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 20 typedef struct _CWE369_Divide_by_Zero__float_listenSocket_67_structType { float structFirst; } CWE369_Divide_by_Zero__float_listenSocket_67_structType; void CWE369_Divide_by_Zero__float_listenSocket_67b_badSink(CWE369_Divide_by_Zero__float_listenSocket_67_structType myStruct) { float data = myStruct.structFirst; { int result = (int)(100.0 / data); printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"int <start> result = (int)(100.0 / data) <end> ;
void CWE369_Divide_by_Zero__float_listenSocket_67b_badSink(CWE369_Divide_by_Zero__float_listenSocket_67_structType <start> myStruct <end> );
float data = <start> myStruct <end> .structFirst;"	"float data = <start> myStruct <end> .structFirst;
printIntLine <start> result <end> );
void CWE369_Divide_by_Zero__float_listenSocket_67b_badSink(CWE369_Divide_by_Zero__float_listenSocket_67_structType <start> myStruct <end> );"	"int <start> result = (int)(100.0 / data) <end> ;
printIntLine <start> result <end> );
void CWE369_Divide_by_Zero__float_listenSocket_67b_badSink(CWE369_Divide_by_Zero__float_listenSocket_67_structType <start> myStruct <end> );"	"void CWE369_Divide_by_Zero__float_listenSocket_67b_badSink(CWE369_Divide_by_Zero__float_listenSocket_67_structType <start> myStruct <end> );
float data = <start> myStruct <end> .structFirst;
printIntLine <start> result <end> );"	3
846ad348-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int CWE369_Divide_by_Zero__int_connect_socket_divide_45_badData; static int CWE369_Divide_by_Zero__int_connect_socket_divide_45_goodG2BData; static int CWE369_Divide_by_Zero__int_connect_socket_divide_45_goodB2GData; static void badSink() { int data = CWE369_Divide_by_Zero__int_connect_socket_divide_45_badData; printIntLine(100 / data); } void CWE369_Divide_by_Zero__int_connect_socket_divide_45_bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE369_Divide_by_Zero__int_connect_socket_divide_45_badData = data; badSink(); }"	where is the vulnerable dataflow from data to printIntLine ?	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> 100 / data <end> );
<start> CWE369_Divide_by_Zero__int_connect_socket_divide_45_badData = data <end> ;
static int <start> CWE369_Divide_by_Zero__int_connect_socket_divide_45_badData <end> ;
int data = <start> CWE369_Divide_by_Zero__int_connect_socket_divide_45_badData <end> ;"	"printIntLine <start> 100 / data <end> );
<start> CWE369_Divide_by_Zero__int_connect_socket_divide_45_badData = data <end> ;
static int <start> CWE369_Divide_by_Zero__int_connect_socket_divide_45_badData <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int data = <start> CWE369_Divide_by_Zero__int_connect_socket_divide_45_badData <end> ;"	"static int <start> CWE369_Divide_by_Zero__int_connect_socket_divide_45_badData <end> ;
printIntLine <start> 100 / data <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> CWE369_Divide_by_Zero__int_connect_socket_divide_45_badData = data <end> ;
static int <start> CWE369_Divide_by_Zero__int_connect_socket_divide_45_badData <end> ;
int data = <start> CWE369_Divide_by_Zero__int_connect_socket_divide_45_badData <end> ;
printIntLine <start> 100 / data <end> );"	3
a1094921-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_square_63b_badSink(int * dataPtr) { int data = *dataPtr; { int result = data * data; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"void CWE190_Integer_Overflow__int_connect_socket_square_63b_badSink(int * <start> dataPtr <end> );
printIntLine <start> result <end> );"	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	"int <start> result = data * data <end> ;
void CWE190_Integer_Overflow__int_connect_socket_square_63b_badSink(int * <start> dataPtr <end> );"	"printIntLine <start> result <end> );
void CWE190_Integer_Overflow__int_connect_socket_square_63b_badSink(int * <start> dataPtr <end> );"	0
598370d4-6c15-11ed-81d4-94e6f77dd552	short CWE191_Integer_Underflow__short_fscanf_sub_61b_badSource(short data); void CWE191_Integer_Underflow__short_fscanf_sub_61_bad() { short data; data = 0; data = CWE191_Integer_Underflow__short_fscanf_sub_61b_badSource(data); { short result = data - 1; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"short result = <start> data - 1 <end> ;
data = <start> CWE191_Integer_Underflow__short_fscanf_sub_61b_badSource <end> (data);"	"data = <start> CWE191_Integer_Underflow__short_fscanf_sub_61b_badSource <end> (data);
short result = <start> data <end>  - 1;"	"data = <start> CWE191_Integer_Underflow__short_fscanf_sub_61b_badSource <end> (data);
short <start> result = data - 1 <end> ;"	"short result = <start> data <end>  - 1;
data = <start> CWE191_Integer_Underflow__short_fscanf_sub_61b_badSource <end> (data);"	1
715a3bb5-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } static void badVaSinkB(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_file_vprintf_08_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; if(staticReturnsTrue()) { { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } if(staticReturnsTrue()) { badVaSinkB(data, data); } }"	where is the vulnerable dataflow from data to vprintf ?	"size_t dataLen = <start> strlen(data) <end> ;
static void badVaSinkB(char * <start> data <end> , ...);
vprintf <start> data <end> , args);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);
vprintf <start> data <end> , args);"	"badVaSinkB <start> data <end> , data);
vprintf <start> data <end> , args);
<start> vprintf(data, args) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
vprintf <start> data <end> , args);
static void badVaSinkB(char * <start> data <end> , ...);
badVaSinkB <start> data <end> , data);"	1
cac216d6-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_connect_socket_open_12 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(globalReturnsTrueOrFalse()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } else { #ifdef _WIN32 strcat(data, ""c:\\temp\\file.txt""); #else strcat(data, ""/tmp/file.txt""); #endif } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"<start> strcat(data, ""c:\\temp\\file.txt"") <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	1
4db33f63-6c15-11ed-81d4-94e6f77dd552	"static int badStatic = 0; static void badSink(int64_t data) { if(badStatic) { { data++; int64_t result = data; printLongLongLine(result); } } } void CWE190_Integer_Overflow__int64_t_fscanf_postinc_21_bad() { int64_t data; data = 0LL; fscanf (stdin, ""%"" SCNd64, &data); badStatic = 1; badSink(data); }"	where is the vulnerable dataflow from data ?	"<start> badSink(data) <end> ;
badSink <start> data <end> );
static void badSink(int64_t <start> data <end> );
fscanf (stdin, ""%"" SCNd64, <start> &data <end> );"	"fscanf (stdin, ""%"" SCNd64, <start> &data <end> );
badSink <start> data <end> );
static void badSink(int64_t <start> data <end> );
<start> data <end> ++;"	"<start> data <end> ++;
static void badSink(int64_t <start> data <end> );
badSink <start> data <end> );
fscanf (stdin, ""%"" SCNd64, <start> &data <end> );"	"fscanf (stdin, ""%"" SCNd64, <start> &data <end> );
static void badSink(int64_t <start> data <end> );
<start> data <end> ++;"	1
656cd3bc-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__int_rand_add_10_bad() { int data; data = 0; if(globalTrue) { data = RAND32(); } if(globalTrue) { { int result = data + 1; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"data = <start> RAND32() <end> ;
<start> printIntLine(result) <end> ;"	"data = <start> RAND32() <end> ;
int result = <start> data <end>  + 1;"	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  + 1;"	"data = <start> RAND32() <end> ;
int result = <start> data + 1 <end> ;"	1
acf67e38-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) typedef struct _CWE191_Integer_Underflow__int_connect_socket_predec_67_structType { int structFirst; } CWE191_Integer_Underflow__int_connect_socket_predec_67_structType; void CWE191_Integer_Underflow__int_connect_socket_predec_67b_badSink(CWE191_Integer_Underflow__int_connect_socket_predec_67_structType myStruct) { int data = myStruct.structFirst; { --data; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"<start> --data <end> ;
void CWE191_Integer_Underflow__int_connect_socket_predec_67b_badSink(CWE191_Integer_Underflow__int_connect_socket_predec_67_structType <start> myStruct <end> );
printIntLine <start> result <end> );"	"int data = <start> myStruct <end> .structFirst;
printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;"	"void CWE191_Integer_Underflow__int_connect_socket_predec_67b_badSink(CWE191_Integer_Underflow__int_connect_socket_predec_67_structType <start> myStruct <end> );
int data = <start> myStruct <end> .structFirst;
printIntLine <start> result <end> );"	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );
void CWE191_Integer_Underflow__int_connect_socket_predec_67b_badSink(CWE191_Integer_Underflow__int_connect_socket_predec_67_structType <start> myStruct <end> );"	2
a10948df-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_multiply_12_bad() { int data; data = 0; if(globalReturnsTrueOrFalse()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } else { data = 2; } if(globalReturnsTrueOrFalse()) { if(data > 0) { int result = data * 2; printIntLine(result); } } else { if(data > 0) { if (data < (INT_MAX/2)) { int result = data * 2; printIntLine(result); } else { printLine(""data value is too large to perform arithmetic safely.""); } } } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
int <start> result = data * 2 <end> ;"	"int <start> result = data * 2 <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"printIntLine <start> result <end> );
if <start> data > 0 <end> ) ;"	0
7c12757c-6c15-11ed-81d4-94e6f77dd552	namespace CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_74 { void badSink(map<int, int> dataMap) { int data = dataMap[2]; if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }	where is the vulnerable dataflow from data to malloc ?	"void badSink(map<int, int> <start> dataMap <end> );
char * dataBuffer = (char *)malloc <start> data <end> );"	"void badSink(map<int, int> <start> dataMap <end> );
<start> free(dataBuffer) <end> ;"	"if  <start> data < 100 <end> );
char * dataBuffer = (char *)malloc <start> data <end> );"	"char * dataBuffer = (char *)malloc <start> data <end> );
<start> free(dataBuffer) <end> ;"	0
54c58205-6c15-11ed-81d4-94e6f77dd552	namespace CWE191_Integer_Underflow__int_connect_socket_multiply_73 { void badSink(list<int> dataList) { int data = dataList.back(); if(data < 0) { int result = data * 2; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"void badSink(list<int> <start> dataList <end> );
int result = <start> data <end>  * 2;"	"int result = <start> data <end>  * 2;
void badSink(list<int> <start> dataList <end> );"	"int result = <start> data * 2 <end> ;
void badSink(list<int> <start> dataList <end> );"	"int result = <start> data <end>  * 2;
<start> printIntLine(result) <end> ;"	0
846ad30c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define STAT _stat #define OPEN _open #define WRITE _write #define O_RDWR _O_RDWR #define CLOSE _close #else #define STAT stat #define OPEN open #define WRITE write #define CLOSE close #endif #define BAD_SINK_STRING ""Bad Sink..."" #define GOOD_SINK_STRING ""Good Sink..."" #ifdef _WIN32 #define ACCESS _access #define W_OK 02 #else #define ACCESS access #endif void CWE367_TOC_TOU__access_03_bad() { if(5==5) { { char filename[100] = """"; int fileDesc = -1; if (fgets(filename, 100, stdin) == NULL) { printLine(""fgets() failed""); filename[0] = '\0'; } if (strlen(filename) > 0) { filename[strlen(filename)-1] = '\0'; } if (ACCESS(filename, W_OK) == -1) { exit(1); } fileDesc  = OPEN(filename, O_RDWR); if (fileDesc == -1) { exit(1); } if (WRITE(fileDesc, BAD_SINK_STRING, strlen(BAD_SINK_STRING)) == -1) { exit(1); } if (fileDesc != -1) { CLOSE(fileDesc); } } } }"	where is the vulnerable dataflow from filename to OPEN ?	"if  <start> strlen(filename) <end>  > 0);
if (fgets <start> filename <end> , 100, stdin) == NULL);"	"fileDesc  = OPEN <start> filename <end> , O_RDWR);
if  <start> strlen(filename) <end>  > 0);"	"if (fgets <start> filename <end> , 100, stdin) == NULL);
filename <start> strlen(filename) <end> -1] = '\0'; ;"	"if (fgets <start> filename <end> , 100, stdin) == NULL);
fileDesc  = OPEN <start> filename <end> , O_RDWR);"	3
d31a252e-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_listen_socket_open_61 { char * badSource(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; data = badSource(data); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
data = <start> badSource(data) <end> ;"	"<start> data = dataBuffer <end> ;
data = <start> badSource <end> (data);"	"data = <start> badSource <end> (data);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"<start> data = badSource(data) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	2
67d010e5-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__char_rand_preinc_54e_badSink(char data) { { ++data; char result = data; printHexCharLine(result); } }	where is the vulnerable dataflow from data ?	"void CWE190_Integer_Overflow__char_rand_preinc_54e_badSink(char <start> data <end> );
+ <start> data <end> ;"	"+ <start> data <end> ;
<start> printHexCharLine(result) <end> ;"	"<start> printHexCharLine(result) <end> ;
void CWE190_Integer_Overflow__char_rand_preinc_54e_badSink(char <start> data <end> );"	"<start> ++data <end> ;
void CWE190_Integer_Overflow__char_rand_preinc_54e_badSink(char <start> data <end> );"	0
893217e4-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_console_open_11 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(globalReturnsTrue()) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
dataLen = <start> strlen(data) <end> ;"	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	1
cf87508a-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_environment_open_17 { void bad() { int i; char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; for(i = 0; i < 1; i++) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
<start> data = dataBuffer <end> ;"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"char <start> dataBuffer[FILENAME_MAX] = """" <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	3
c01af8e7-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif extern char * CWE23_Relative_Path_Traversal__char_connect_socket_open_68_badData; extern char * CWE23_Relative_Path_Traversal__char_connect_socket_open_68_goodG2BData; namespace CWE23_Relative_Path_Traversal__char_connect_socket_open_68 { void badSink() { char * data = CWE23_Relative_Path_Traversal__char_connect_socket_open_68_badData; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
char * data = <start> CWE23_Relative_Path_Traversal__char_connect_socket_open_68_badData <end> ;"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
char * data = <start> CWE23_Relative_Path_Traversal__char_connect_socket_open_68_badData <end> ;"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"char * data = <start> CWE23_Relative_Path_Traversal__char_connect_socket_open_68_badData <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	3
4b34afba-6c15-11ed-81d4-94e6f77dd552	"static void badSink(short data) { { short result = data + 1; printIntLine(result); } } void CWE190_Integer_Overflow__short_fscanf_add_44_bad() { short data; void (*funcPtr) (short) = badSink; data = 0; fscanf (stdin, ""%hd"", &data); funcPtr(data); }"	where is the vulnerable dataflow from data ?	"fscanf (stdin, ""%hd"", <start> &data <end> );
funcPtr <start> data <end> );
static void badSink(short <start> data <end> );
short result = <start> data <end>  + 1;"	"<start> funcPtr(data) <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );
short result = <start> data <end>  + 1;
funcPtr <start> data <end> );"	"<start> printIntLine(result) <end> ;
short result = <start> data <end>  + 1;
funcPtr <start> data <end> );
fscanf (stdin, ""%hd"", <start> &data <end> );"	"<start> data = 0 <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );
short result = <start> data <end>  + 1;
static void badSink(short <start> data <end> );"	0
a830bf76-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int badStatic = 0; static void badSink(int data) { if(badStatic) { if(data < 0) { int result = data * 2; printIntLine(result); } } } void CWE191_Integer_Underflow__int_connect_socket_multiply_21_bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badStatic = 1; badSink(data); }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSink <start> data <end> );
static void badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"badSink <start> data <end> );
printIntLine <start> result <end> );
<start> data = atoi(inputBuffer) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"static void badSink(int <start> data <end> );
badSink <start> data <end> );"	"static void badSink(int <start> data <end> );
<start> badSink(data) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSink <start> data <end> );"	0
6b862424-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_connect_socket_11_bad() { int data; data = -1; if(globalReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalReturnsTrue()) { { int i; int * buffer = (int *)malloc(10 * sizeof(int)); if (buffer == NULL) {exit(-1);} for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } free(buffer); } } }"	where is the vulnerable dataflow from buffer to free ?	"if  <start> buffer == NULL <end> ) {exit(-1);};
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"free <start> buffer <end> );
recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);"	"free <start> buffer <end> );
if  <start> buffer == NULL <end> ) {exit(-1);};"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
free <start> buffer <end> );"	3
cac216a5-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" namespace CWE36_Absolute_Path_Traversal__char_connect_socket_ifstream_44 { static void badSink(char * data) { { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } } void bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } funcPtr(data); }"	where is the vulnerable dataflow from data to funcPtr ?	"funcPtr <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	"recvResult = <start> recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0) <end> ;
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
funcPtr <start> data <end> );"	"funcPtr <start> data <end> );
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) *  <start> FILENAME_MAX - dataLen - 1 <end> ), 0);"	2
ce547d34-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_environment_fopen_67 { typedef struct _structType { char * structFirst; } structType; void badSink(structType myStruct) { char * data = myStruct.structFirst; { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"void badSink(structType <start> myStruct <end> );
char * data = <start> myStruct <end> .structFirst;
pFile = FOPEN <start> data <end> , ""wb+"");"	"void badSink(structType <start> myStruct <end> );
char * data = <start> myStruct <end> .structFirst;"	"void badSink(structType <start> myStruct <end> );
char <start> * data = myStruct.structFirst <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"char * data = <start> myStruct <end> .structFirst;
pFile = <start> FOPEN(data, ""wb+"") <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	0
c99197d0-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define STAT _stat #define OPEN _open #define WRITE _write #define O_RDWR _O_RDWR #define CLOSE _close #else #define STAT stat #define OPEN open #define WRITE write #define CLOSE close #endif #define BAD_SINK_STRING ""Bad Sink..."" #define GOOD_SINK_STRING ""Good Sink..."" void CWE367_TOC_TOU__stat_13_bad() { if(GLOBAL_CONST_FIVE==5) { { char filename[100] = """"; struct STAT statBuffer; int fileDesc = -1; if (fgets(filename, 100, stdin) == NULL) { printLine(""fgets() failed""); filename[0] = '\0'; } if (strlen(filename) > 0) { filename[strlen(filename)-1] = '\0'; } if (STAT(filename, &statBuffer) == -1) { exit(1); } fileDesc  = OPEN(filename, O_RDWR); if (fileDesc == -1) { exit(1); } if (WRITE(fileDesc, BAD_SINK_STRING, strlen(BAD_SINK_STRING)) == -1) { exit(1); } if (fileDesc != -1) { CLOSE(fileDesc); } } } }"	where is the vulnerable dataflow from filename to OPEN ?	"fileDesc  = <start> OPEN(filename, O_RDWR) <end> ;
fileDesc  = OPEN <start> filename <end> , O_RDWR);"	"if  <start> strlen(filename) <end>  > 0);
if (fgets <start> filename <end> , 100, stdin) == NULL);"	"if (fgets <start> filename <end> , 100, stdin) == NULL);
fileDesc  = OPEN <start> filename <end> , O_RDWR);"	"fileDesc  = OPEN <start> filename <end> , O_RDWR);
if (fgets <start> filename <end> , 100, stdin) == NULL);"	2
cbf237b2-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_console_fopen_31 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } { char * dataCopy = data; char * data = dataCopy; { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } } }"	where is the vulnerable dataflow from data to FOPEN ?	"dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
if (dataLen > 0 && <start> data[dataLen-1] == '\n' <end> );"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
size_t dataLen = <start> strlen(data) <end> ;"	2
7ae3a71e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_52c_badSink(int data) { { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_52c_badSink(int <start> data <end> );
printLine <start> dest <end> );"	"<start> printLine(dest) <end> ;
void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_52c_badSink(int <start> data <end> );"	"printLine <start> dest <end> );
<start> memmove(dest, source, data) <end> ;"	"<start> memmove(dest, source, data) <end> ;
void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_52c_badSink(int <start> data <end> );"	0
b41b8785-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif namespace CWE23_Relative_Path_Traversal__char_file_ofstream_82 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } CWE23_Relative_Path_Traversal__char_file_ofstream_82_base* baseObject = new CWE23_Relative_Path_Traversal__char_file_ofstream_82_bad; baseObject->action(data); delete baseObject; }"	where is the vulnerable dataflow from data to action ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
baseObject->action <start> data <end> );"	"baseObject->action <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
size_t dataLen = <start> strlen(data) <end> ;"	"size_t dataLen = <start> strlen(data) <end> ;
baseObject->action <start> data <end> );"	0
656cd3cc-6c15-11ed-81d4-94e6f77dd552	static void badSink(int data) { { int result = data + 1; printIntLine(result); } } void CWE190_Integer_Overflow__int_rand_add_44_bad() { int data; void (*funcPtr) (int) = badSink; data = 0; data = RAND32(); funcPtr(data); }	where is the vulnerable dataflow from data ?	"static void badSink(int <start> data <end> );
data = <start> RAND32() <end> ;
int result = <start> data <end>  + 1;
funcPtr <start> data <end> );"	"data = <start> RAND32() <end> ;
funcPtr <start> data <end> );
static void badSink(int <start> data <end> );
int result = <start> data <end>  + 1;"	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  + 1;
funcPtr <start> data <end> );
static void badSink(int <start> data <end> );"	"funcPtr <start> data <end> );
static void badSink(int <start> data <end> );
<start> printIntLine(result) <end> ;
data = <start> RAND32() <end> ;"	1
8a6310c6-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_file_open_34 { typedef union { char * unionFirst; char * unionSecond; } unionType; void bad() { char * data; unionType myUnion; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
size_t dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
char <start> dataBuffer[FILENAME_MAX] = """" <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
char <start> * data = myUnion.unionSecond <end> ;"	2
86cea154-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int badStatic = 0; static void badSink(int data) { if(badStatic) { printIntLine(100 / data); } } void CWE369_Divide_by_Zero__int_listen_socket_divide_21_bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badStatic = 1; badSink(data); }"	where is the vulnerable dataflow from data to printIntLine ?	"<start> badSink(data) <end> ;
static void badSink(int <start> data <end> );
badSink <start> data <end> );
printIntLine <start> 100 / data <end> );"	"<start> badSink(data) <end> ;
static void badSink(int <start> data <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> 100 / data <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSink <start> data <end> );
static void badSink(int <start> data <end> );
printIntLine <start> 100 / data <end> );"	"if  <start> recvResult == SOCKET_ERROR <end>  || recvResult == 0);
badSink <start> data <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static void badSink(int <start> data <end> );"	2
af580943-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE197_Numeric_Truncation_Error__int_connect_socket_to_short_01_bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { short shortData = (short)data; printShortLine(shortData); } }"	where is the vulnerable dataflow from shortData to printShortLine ?	"printShortLine <start> shortData <end> );
<start> data = atoi(inputBuffer) <end> ;"	"data = <start> atoi(inputBuffer) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printShortLine <start> shortData <end> );"	"<start> printShortLine(shortData) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	2
54c58224-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_connect_socket_sub_52c_badSink(int data) { { int result = data - 1; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  - 1;
<start> printIntLine(result) <end> ;"	"void CWE191_Integer_Underflow__int_connect_socket_sub_52c_badSink(int <start> data <end> );
int result = <start> data - 1 <end> ;"	"<start> printIntLine(result) <end> ;
void CWE191_Integer_Underflow__int_connect_socket_sub_52c_badSink(int <start> data <end> );"	"void CWE191_Integer_Underflow__int_connect_socket_sub_52c_badSink(int <start> data <end> );
int result = <start> data <end>  - 1;"	3
bed4a8df-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" static const int STATIC_CONST_FIVE = 5; namespace CWE23_Relative_Path_Traversal__char_connect_socket_ifstream_06 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(STATIC_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"replace = <start> strchr(data, '\n') <end> ;
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"inputFile.open((char * <start> data <end> );
char <start> dataBuffer[FILENAME_MAX] = BASEPATH <end> ;"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
replace = <start> strchr(data, '\r') <end> ;"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
inputFile.open((char * <start> data <end> );"	3
466e7ec0-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_add_54e_badSink(int data) { { int result = data + 1; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"void CWE190_Integer_Overflow__int_fgets_add_54e_badSink(int <start> data <end> );
int result = <start> data <end>  + 1;"	"<start> printIntLine(result) <end> ;
void CWE190_Integer_Overflow__int_fgets_add_54e_badSink(int <start> data <end> );"	"int result = <start> data <end>  + 1;
void CWE190_Integer_Overflow__int_fgets_add_54e_badSink(int <start> data <end> );"	"int <start> result = data + 1 <end> ;
void CWE190_Integer_Overflow__int_fgets_add_54e_badSink(int <start> data <end> );"	0
656cd410-6c15-11ed-81d4-94e6f77dd552	"void CWE190_Integer_Overflow__int_rand_square_12_bad() { int data; data = 0; if(globalReturnsTrueOrFalse()) { data = RAND32(); } else { data = 2; } if(globalReturnsTrueOrFalse()) { { int result = data * data; printIntLine(result); } } else { if (data > INT_MIN && abs(data) < (long)sqrt((double)INT_MAX)) { int result = data * data; printIntLine(result); } else { printLine(""data value is too large to perform arithmetic safely.""); } } }"	where is the vulnerable dataflow from data ?	"int result = <start> data * data <end> ;
data = <start> RAND32() <end> ;"	"data = <start> RAND32() <end> ;
<start> printIntLine(result) <end> ;"	"int <start> result = data * data <end> ;
data = <start> RAND32() <end> ;"	"data = <start> RAND32() <end> ;
int result = <start> data <end>  * data;"	3
9c45519c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticTrue = 1; static int staticFalse = 0; void CWE126_Buffer_Overread__CWE129_connect_socket_05_bad() { int data; data = -1; if(staticTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticTrue) { { int buffer[10] = { 0 }; if (data >= 0) { printIntLine(buffer[data]); } else { printLine(""ERROR: Array index is negative""); } } } }"	where is the vulnerable dataflow from buffer[data] to printIntLine ?	"data = <start> atoi(inputBuffer) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"printIntLine <start> buffer[data] <end> );
int <start> buffer[10] = { 0 } <end> ;"	"data = <start> atoi(inputBuffer) <end> ;
printIntLine <start> buffer[data] <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[data] <end> );"	3
b41b8764-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 8 void CWE197_Numeric_Truncation_Error__short_listen_socket_63b_badSink(short * dataPtr) { short data = *dataPtr; { char charData = (char)data; printHexCharLine(charData); } }"	where is the vulnerable dataflow from charData to printHexCharLine ?	"char <start> charData = (char)data <end> ;
printHexCharLine <start> charData <end> );"	"printHexCharLine <start> charData <end> );
<start> printHexCharLine(charData) <end> ;"	"printHexCharLine <start> charData <end> );
void CWE197_Numeric_Truncation_Error__short_listen_socket_63b_badSink(short * <start> dataPtr <end> );"	"void CWE197_Numeric_Truncation_Error__short_listen_socket_63b_badSink(short * <start> dataPtr <end> );
printHexCharLine <start> charData <end> );"	3
9d745398-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int badStatic = 0; static void badSink(int data) { if(badStatic) { { int buffer[10] = { 0 }; if (data < 10) { printIntLine(buffer[data]); } else { printLine(""ERROR: Array index is too big.""); } } } } void CWE127_Buffer_Underread__CWE839_connect_socket_21_bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badStatic = 1; badSink(data); }"	where is the vulnerable dataflow from buffer[data] to printIntLine ?	"<start> badSink(data) <end> ;
printIntLine <start> buffer[data] <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSink <start> data <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSink <start> data <end> );
static void badSink(int <start> data <end> );
printIntLine <start> buffer[data] <end> );"	"<start> data = -1 <end> ;
badSink <start> data <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[data] <end> );"	"printIntLine <start> buffer[data] <end> );
static void badSink(int <start> data <end> );"	1
728a500a-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; static void badVaSinkB(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_04_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; if(STATIC_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(STATIC_CONST_TRUE) { badVaSinkB(data, data); } }"	where is the vulnerable dataflow from data to vprintf ?	"size_t dataLen = <start> strlen(data) <end> ;
static void badVaSinkB(char * <start> data <end> , ...);
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
vprintf <start> data <end> , args);"	"vprintf <start> data <end> , args);
static void badVaSinkB(char * <start> data <end> , ...);
<start> data = dataBuffer <end> ;
badVaSinkB <start> data <end> , data);"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);
vprintf <start> data <end> , args);"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
badVaSinkB <start> data <end> , data);
if  <start> acceptSocket == SOCKET_ERROR <end> );
vprintf <start> data <end> , args);"	2
92bb8a2c-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING ""hello"" static void badSink(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); } else { printLine(""Input is less than the length of the source string""); } } } void CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_41_bad() { size_t data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = strtoul(inputBuffer, NULL, 0); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badSink(data); }"	where is the vulnerable dataflow from data to malloc ?	"data = <start> strtoul(inputBuffer, NULL, 0) <end> ;
badSink <start> data <end> );
myString = (char *)malloc <start> data*sizeof(char) <end> );
static void badSink(size_t <start> data <end> );"	"myString = (char *)malloc <start> data*sizeof(char) <end> );
badSink <start> data <end> );
static void badSink(size_t <start> data <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static void badSink(size_t <start> data <end> );
<start> badSink(data) <end> ;
myString = (char *)malloc <start> data*sizeof(char) <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSink <start> data <end> );
static void badSink(size_t <start> data <end> );
myString = (char *)malloc <start> data*sizeof(char) <end> );"	3
b7b09a68-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define NEW_PATH ""%SystemRoot%\\system32"" #define PUTENV _putenv #else #define NEW_PATH ""/bin"" #define PUTENV putenv #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif static void badSink(char * data) { PUTENV(data); } void CWE427_Uncontrolled_Search_Path_Element__char_file_44_bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[250] = ""PATH=""; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (250-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(250-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } funcPtr(data); }"	where is the vulnerable dataflow from data to PUTENV ?	"<start> funcPtr(data) <end> ;
static void badSink(char * <start> data <end> );
PUTENV <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(250-dataLen), pFile) == NULL);"	"PUTENV <start> data <end> );
funcPtr <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(250-dataLen), pFile) == NULL);
static void badSink(char * <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(250-dataLen), pFile) == NULL);
funcPtr <start> data <end> );
static void badSink(char * <start> data <end> );
PUTENV <start> data <end> );"	"static void badSink(char * <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(250-dataLen), pFile) == NULL);"	2
c8600afc-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif static int staticFive = 5; namespace CWE23_Relative_Path_Traversal__char_listen_socket_open_07 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(staticFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"<start> data = dataBuffer <end> ;
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"size_t dataLen = <start> strlen(data) <end> ;
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"<start> data = dataBuffer <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	3
c1366287-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif namespace CWE23_Relative_Path_Traversal__char_console_ofstream_14 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(globalFive==5) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
outputFile.open((char * <start> data <end> );"	"char <start> dataBuffer[FILENAME_MAX] = BASEPATH <end> ;
outputFile.open((char * <start> data <end> );"	"size_t dataLen = <start> strlen(data) <end> ;
outputFile.open((char * <start> data <end> );"	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	0
9059f386-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_63b_badSink(int * dataPtr) { int data = *dataPtr; { size_t i; int *intPointer; intPointer = (int*)malloc(data * sizeof(int)); if (intPointer == NULL) {exit(-1);} for (i = 0; i < (size_t)data; i++) { intPointer[i] = 0; } printIntLine(intPointer[0]); free(intPointer); } }	where is the vulnerable dataflow from data to malloc ?	"void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_63b_badSink(int * <start> dataPtr <end> );
intPointer = <start> (int*)malloc(data * sizeof(int)) <end> ;"	"void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_63b_badSink(int * <start> dataPtr <end> );
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	"intPointer = (int*)malloc <start> data * sizeof(int) <end> );
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_63b_badSink(int * <start> dataPtr <end> );"	"intPointer = <start> (int*)malloc(data * sizeof(int)) <end> ;
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	1
9d74536c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE126_Buffer_Overread__CWE129_listen_socket_03_bad() { int data; data = -1; if(5==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(5==5) { { int buffer[10] = { 0 }; if (data >= 0) { printIntLine(buffer[data]); } else { printLine(""ERROR: Array index is negative""); } } } }"	where is the vulnerable dataflow from buffer[data] to printIntLine ?	"printIntLine <start> buffer[data] <end> );
if  <start> acceptSocket == SOCKET_ERROR <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int <start> buffer[10] = { 0 } <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[data] <end> );"	"printIntLine <start> buffer[data] <end> );
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	2
c5fc233a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif namespace CWE23_Relative_Path_Traversal__char_file_ifstream_17 { void bad() { int i; char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; for(i = 0; i < 1; i++) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
inputFile.open((char * <start> data <end> );"	"inputFile.open((char * <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
<start> data = dataBuffer <end> ;"	1
bed4a8e2-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" namespace CWE23_Relative_Path_Traversal__char_connect_socket_ifstream_09 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(GLOBAL_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
inputFile.open((char * <start> data <end> );"	"size_t <start> dataLen = strlen(data) <end> ;
inputFile.open((char * <start> data <end> );"	"char <start> dataBuffer[FILENAME_MAX] = BASEPATH <end> ;
inputFile.open((char * <start> data <end> );"	"replace = <start> strchr(data, '\n') <end> ;
inputFile.open((char * <start> data <end> );"	0
5f76fcc1-6c15-11ed-81d4-94e6f77dd552	"static void badSink(unsigned int data) { { --data; unsigned int result = data; printUnsignedLine(result); } } void CWE191_Integer_Underflow__unsigned_int_fscanf_predec_41_bad() { unsigned int data; data = 0; fscanf (stdin, ""%u"", &data); badSink(data); }"	where is the vulnerable dataflow from data ?	"badSink <start> data <end> );
<start> badSink(data) <end> ;
fscanf (stdin, ""%u"", <start> &data <end> );
static void badSink(unsigned int <start> data <end> );"	"badSink <start> data <end> );
static void badSink(unsigned int <start> data <end> );
- <start> data <end> ;
fscanf (stdin, ""%u"", <start> &data <end> );"	"fscanf (stdin, ""%u"", <start> &data <end> );
badSink <start> data <end> );
static void badSink(unsigned int <start> data <end> );
- <start> data <end> ;"	"static void badSink(unsigned int <start> data <end> );
- <start> data <end> ;"	2
d0b64ec8-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif namespace CWE36_Absolute_Path_Traversal__char_file_ifstream_09 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(GLOBAL_CONST_TRUE) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"<start> data = dataBuffer <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
inputFile.open((char * <start> data <end> );"	"inputFile.open((char * <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"char <start> dataBuffer[FILENAME_MAX] = """" <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	1
c01af8aa-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" namespace CWE23_Relative_Path_Traversal__char_connect_socket_ofstream_09 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(GLOBAL_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"replace = <start> strchr(data, '\n') <end> ;
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
outputFile.open((char * <start> data <end> );"	"recvResult = <start> recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0) <end> ;
outputFile.open((char * <start> data <end> );"	"outputFile.open((char * <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	1
b54bcf3d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 20 void CWE369_Divide_by_Zero__float_listenSocket_54e_badSink(float data) { { int result = (int)(100.0 / data); printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"void CWE369_Divide_by_Zero__float_listenSocket_54e_badSink(float <start> data <end> );
printIntLine <start> result <end> );"	"void CWE369_Divide_by_Zero__float_listenSocket_54e_badSink(float <start> data <end> );
int result = <start> (int)(100.0 / data) <end> ;"	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
void CWE369_Divide_by_Zero__float_listenSocket_54e_badSink(float <start> data <end> );"	0
820a46cc-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_file_fopen_66 { void badSink(char * dataArray[]) { char * data = dataArray[2]; { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = FOPEN <start> data <end> , ""wb+"");
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
void badSink(char * <start> dataArray <end> []);"	"pFile = FOPEN <start> data <end> , ""wb+"");
void badSink(char * <start> dataArray <end> []);"	"void badSink(char * <start> dataArray <end> []);
pFile = FOPEN <start> data <end> , ""wb+"");"	3
9b124d85-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) typedef union { int unionFirst; int unionSecond; } CWE124_Buffer_Underwrite__CWE839_connect_socket_34_unionType; void CWE124_Buffer_Underwrite__CWE839_connect_socket_34_bad() { int data; CWE124_Buffer_Underwrite__CWE839_connect_socket_34_unionType myUnion; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } myUnion.unionFirst = data; { int data = myUnion.unionSecond; { int i; int buffer[10] = { 0 }; if (data < 10) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } } } }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"printIntLine <start> buffer[i] <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[i] <end> );"	"printIntLine <start> buffer[i] <end> );
<start> printIntLine(buffer[i]) <end> ;"	"printIntLine <start> buffer[i] <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	1
ae26ae38-6c15-11ed-81d4-94e6f77dd552	extern int CWE191_Integer_Underflow__int_listen_socket_predec_22_badGlobal; void CWE191_Integer_Underflow__int_listen_socket_predec_22_badSink(int data) { if(CWE191_Integer_Underflow__int_listen_socket_predec_22_badGlobal) { { --data; int result = data; printIntLine(result); } } }	where is the vulnerable dataflow from result to printIntLine ?	"void CWE191_Integer_Underflow__int_listen_socket_predec_22_badSink(int <start> data <end> );
<start> printIntLine(result) <end> ;"	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
void CWE191_Integer_Underflow__int_listen_socket_predec_22_badSink(int <start> data <end> );"	"void CWE191_Integer_Underflow__int_listen_socket_predec_22_badSink(int <start> data <end> );
printIntLine <start> result <end> );"	3
69161b40-6c15-11ed-81d4-94e6f77dd552	static int CWE190_Integer_Overflow__int_rand_preinc_45_badData; static int CWE190_Integer_Overflow__int_rand_preinc_45_goodG2BData; static int CWE190_Integer_Overflow__int_rand_preinc_45_goodB2GData; static void badSink() { int data = CWE190_Integer_Overflow__int_rand_preinc_45_badData; { ++data; int result = data; printIntLine(result); } } void CWE190_Integer_Overflow__int_rand_preinc_45_bad() { int data; data = 0; data = RAND32(); CWE190_Integer_Overflow__int_rand_preinc_45_badData = data; badSink(); }	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
<start> CWE190_Integer_Overflow__int_rand_preinc_45_badData = data <end> ;
static int <start> CWE190_Integer_Overflow__int_rand_preinc_45_badData <end> ;
data = <start> RAND32() <end> ;
+ <start> data <end> ;"	"data = <start> RAND32() <end> ;
<start> CWE190_Integer_Overflow__int_rand_preinc_45_badData = data <end> ;
static int <start> CWE190_Integer_Overflow__int_rand_preinc_45_badData <end> ;
int data = <start> CWE190_Integer_Overflow__int_rand_preinc_45_badData <end> ;
+ <start> data <end> ;"	"<start> CWE190_Integer_Overflow__int_rand_preinc_45_badData = data <end> ;
int data = <start> CWE190_Integer_Overflow__int_rand_preinc_45_badData <end> ;
data = <start> RAND32() <end> ;
static int <start> CWE190_Integer_Overflow__int_rand_preinc_45_badData <end> ;
<start> printIntLine(result) <end> ;"	"static int <start> CWE190_Integer_Overflow__int_rand_preinc_45_badData <end> ;
<start> CWE190_Integer_Overflow__int_rand_preinc_45_badData = data <end> ;
+ <start> data <end> ;
int data = <start> CWE190_Integer_Overflow__int_rand_preinc_45_badData <end> ;
data = <start> RAND32() <end> ;"	1
c72d5d69-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_listen_socket_fopen_64 { void badSink(void * dataVoidPtr) { char * * dataPtr = (char * *)dataVoidPtr; char * data = (*dataPtr); { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"char <start> * data = (*dataPtr) <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"void badSink(void * <start> dataVoidPtr <end> );
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	"pFile = FOPEN <start> data <end> , ""wb+"");
void badSink(void * <start> dataVoidPtr <end> );"	"void badSink(void * <start> dataVoidPtr <end> );
pFile = FOPEN <start> data <end> , ""wb+"");"	3
86cea148-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_FIVE = 5; void CWE369_Divide_by_Zero__int_listen_socket_divide_06_bad() { int data; data = -1; if(STATIC_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(STATIC_CONST_FIVE==5) { printIntLine(100 / data); } }"	where is the vulnerable dataflow from data to printIntLine ?	"printIntLine <start> 100 / data <end> );
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"recvResult = recv(acceptSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);
printIntLine <start> 100 / data <end> );"	"printIntLine <start> 100 / data <end> );
data = <start> atoi(inputBuffer) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> 100 / data <end> );"	3
445c11e8-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_add_02_bad() { int data; data = 0; if(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(1) { { int result = data + 1; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"int <start> result = data + 1 <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  + 1;"	"int result = <start> data <end>  + 1;
<start> data = atoi(inputBuffer) <end> ;"	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  + 1;"	1
69161b2d-6c15-11ed-81d4-94e6f77dd552	static int staticFive = 5; void CWE190_Integer_Overflow__int_rand_preinc_07_bad() { int data; data = 0; if(staticFive==5) { data = RAND32(); } if(staticFive==5) { { ++data; int result = data; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
+ <start> data <end> ;"	"<start> printIntLine(result) <end> ;
data = <start> RAND32() <end> ;"	"+ <start> data <end> ;
data = <start> RAND32() <end> ;"	"data = <start> RAND32() <end> ;
+ <start> data <end> ;"	3
a1094913-6c15-11ed-81d4-94e6f77dd552	extern int CWE190_Integer_Overflow__int_connect_socket_square_22_badGlobal; void CWE190_Integer_Overflow__int_connect_socket_square_22_badSink(int data) { if(CWE190_Integer_Overflow__int_connect_socket_square_22_badGlobal) { { int result = data * data; printIntLine(result); } } }	where is the vulnerable dataflow from result to printIntLine ?	"int result = <start> data * data <end> ;
printIntLine <start> result <end> );"	"void CWE190_Integer_Overflow__int_connect_socket_square_22_badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"int <start> result = data * data <end> ;
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;"	1
951c5e79-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FULL_COMMAND ""dir "" #else #define FULL_COMMAND ""ls "" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define POPEN _popen #define PCLOSE _pclose #else #define POPEN popen #define PCLOSE pclose #endif static void badSink(char * data) { { FILE *pipe; pipe = POPEN(data, ""w""); if (pipe != NULL) { PCLOSE(pipe); } } } void CWE78_OS_Command_Injection__char_connect_socket_popen_44_bad() { char * data; void (*funcPtr) (char *) = badSink; char data_buf[100] = FULL_COMMAND; data = data_buf; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } funcPtr(data); }"	where is the vulnerable dataflow from data to POPEN ?	"funcPtr <start> data <end> );
static void badSink(char * <start> data <end> );
replace = <start> strchr(data, '\n') <end> ;
pipe = POPEN <start> data <end> , ""w"");"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
funcPtr <start> data <end> );
replace = <start> strchr(data, '\n') <end> ;
pipe = POPEN <start> data <end> , ""w"");"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
funcPtr <start> data <end> );
static void badSink(char * <start> data <end> );
pipe = <start> POPEN(data, ""w"") <end> ;"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
funcPtr <start> data <end> );
static void badSink(char * <start> data <end> );
pipe = POPEN <start> data <end> , ""w"");"	3
bb49c5a2-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #define EXECLP _execlp #else #define EXECLP execlp #endif void CWE78_OS_Command_Injection__char_console_execlp_11_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(globalReturnsTrue()) { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECLP ?	"dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	"<start> EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"size_t <start> dataLen = strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	2
c01af8eb-6c15-11ed-81d4-94e6f77dd552	#ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_connect_socket_open_81 { void CWE23_Relative_Path_Traversal__char_connect_socket_open_81_bad::action(char * data) const { { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } } }	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
void CWE23_Relative_Path_Traversal__char_connect_socket_open_81_bad::action(char * <start> data <end> ) const;"	"void CWE23_Relative_Path_Traversal__char_connect_socket_open_81_bad::action(char * <start> data <end> ) const;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
void CWE23_Relative_Path_Traversal__char_connect_socket_open_81_bad::action(char * <start> data <end> ) const;"	1
8cc3a675-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(count) + 2) #ifdef _WIN32 #define SLEEP Sleep #else #define SLEEP usleep #endif void CWE400_Resource_Exhaustion__fgets_sleep_14_bad() { int count; count = -1; if(globalFive==5) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { count = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(globalFive==5) { SLEEP(count); printLine(""Sleep time possibly too long""); } }"	where is the vulnerable dataflow from count to SLEEP ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
SLEEP <start> count <end> );"	"<start> SLEEP(count) <end> ;
SLEEP <start> count <end> );"	"if  <start> fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) <end>  != NULL);
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"SLEEP <start> count <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	0
4a02110f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_multiply_54e_badSink(int data) { if(data > 0) { int result = data * 2; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"if <start> data > 0 <end> ) ;
void CWE190_Integer_Overflow__int_listen_socket_multiply_54e_badSink(int <start> data <end> );"	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  * 2;"	"int result = <start> data <end>  * 2;
void CWE190_Integer_Overflow__int_listen_socket_multiply_54e_badSink(int <start> data <end> );"	"void CWE190_Integer_Overflow__int_listen_socket_multiply_54e_badSink(int <start> data <end> );
int result = <start> data <end>  * 2;"	3
728a4feb-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 static void badVaSinkB(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_15_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; switch(6) { case 6: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; default: printLine(""Benign, fixed string""); break; } switch(7) { case 7: badVaSinkB(data, data); break; default: printLine(""Benign, fixed string""); break; } }"	where is the vulnerable dataflow from data to vfprintf ?	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (100 - dataLen - 1), 0);
vfprintf(stdout, <start> data <end> , args);
badVaSinkB <start> data <end> , data);
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"vfprintf(stdout, <start> data <end> , args);
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"size_t dataLen = <start> strlen(data) <end> ;
static void badVaSinkB(char * <start> data <end> , ...);
badVaSinkB <start> data <end> , data);
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	0
8cc3a65c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(count) + 2) #ifdef _WIN32 #define SLEEP Sleep #else #define SLEEP usleep #endif namespace CWE400_Resource_Exhaustion__connect_socket_sleep_43 { static void badSource(int &count) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; count = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } void bad() { int count; count = -1; badSource(count); SLEEP(count); printLine(""Sleep time possibly too long""); }"	where is the vulnerable dataflow from count to SLEEP ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSource <start> count <end> );
SLEEP <start> count <end> );"	"badSource <start> count <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
SLEEP <start> count <end> );"	"<start> SLEEP(count) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
SLEEP <start> count <end> );"	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
badSource <start> count <end> );
SLEEP <start> count <end> );"	0
6ef7680e-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif void CWE134_Uncontrolled_Format_String__char_console_snprintf_51b_badSink(char * data) { { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"void CWE134_Uncontrolled_Format_String__char_console_snprintf_51b_badSink(char * <start> data <end> );
printLine <start> dest <end> );"	"printLine <start> dest <end> );
void CWE134_Uncontrolled_Format_String__char_console_snprintf_51b_badSink(char * <start> data <end> );"	"printLine <start> dest <end> );
<start> printLine(dest) <end> ;"	"void CWE134_Uncontrolled_Format_String__char_console_snprintf_51b_badSink(char * <start> data <end> );
<start> printLine(dest) <end> ;"	0
9fe7ad43-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticFive = 5; void CWE190_Integer_Overflow__int_connect_socket_add_07_bad() { int data; data = 0; if(staticFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticFive==5) { { int result = data + 1; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"<start> data = atoi(inputBuffer) <end> ;
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	1
d1e9da64-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 namespace CWE36_Absolute_Path_Traversal__char_listen_socket_ifstream_21 { static int badStatic = 0; static char * badSource(char * data) { if(badStatic) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } return data; } void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; badStatic = 1; data = badSource(data); { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } ; }"	where is the vulnerable dataflow from data to open ?	"static char * <start> badSource <end> (char * data);
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
data = <start> badSource <end> (data);
inputFile.open((char * <start> data <end> );"	"replace = <start> strchr(data, '\n') <end> ;
inputFile.open((char * <start> data <end> );
static char * <start> badSource <end> (char * data);
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
inputFile.open((char * <start> data <end> );"	"recvResult = recv(acceptSocket, (char *)(data + dataLen), <start> sizeof(char) * (FILENAME_MAX - dataLen - 1) <end> , 0);
data = <start> badSource <end> (data);
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
inputFile.open((char * <start> data <end> );"	2
73bc8177-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" void CWE194_Unexpected_Sign_Extension__connect_socket_memmove_18_bad() { short data; data = 0; goto source; source: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data = 0 <end> ;"	"<start> data = 0 <end> ;
printLine <start> dest <end> );"	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	3
820a46f0-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_file_open_61 { char * badSource(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; data = badSource(data); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"data = <start> badSource <end> (data);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"data = <start> badSource <end> (data);
fileDesc = OPEN(data, O_RDWR|O_CREAT, <start> S_IREAD|S_IWRITE <end> );"	"data = <start> badSource(data) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
data = <start> badSource <end> (data);"	0
aa91a178-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_listen_socket_multiply_64b_badSink(void * dataVoidPtr) { int * dataPtr = (int *)dataVoidPtr; int data = (*dataPtr); if(data < 0) { int result = data * 2; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"if <start> data < 0 <end> ) ;
void CWE191_Integer_Underflow__int_listen_socket_multiply_64b_badSink(void * <start> dataVoidPtr <end> );"	"void CWE191_Integer_Underflow__int_listen_socket_multiply_64b_badSink(void * <start> dataVoidPtr <end> );
printIntLine <start> result <end> );"	"if <start> data < 0 <end> ) ;
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
void CWE191_Integer_Underflow__int_listen_socket_multiply_64b_badSink(void * <start> dataVoidPtr <end> );"	1
48d25d82-6c15-11ed-81d4-94e6f77dd552	"void CWE190_Integer_Overflow__int_fscanf_square_16_bad() { int data; data = 0; while(1) { fscanf(stdin, ""%d"", &data); break; } while(1) { { int result = data * data; printIntLine(result); } break; } }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
fscanf(stdin, ""%d"", <start> &data <end> );"	"fscanf(stdin, ""%d"", <start> &data <end> );
int <start> result = data * data <end> ;"	"fscanf(stdin, ""%d"", <start> &data <end> );
int result = <start> data <end>  * data;"	"int result = <start> data <end>  * data;
fscanf(stdin, ""%d"", <start> &data <end> );"	2
833ac94a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_listen_socket_open_54 { void badSink_e(char * data) { { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);
void badSink_e(char * <start> data <end> );"	"void badSink_e(char * <start> data <end> );
fileDesc = OPEN(data, O_RDWR|O_CREAT, <start> S_IREAD|S_IWRITE <end> );"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
void badSink_e(char * <start> data <end> );"	"void badSink_e(char * <start> data <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	3
5f76fcbc-6c15-11ed-81d4-94e6f77dd552	void CWE191_Integer_Underflow__short_fscanf_predec_65b_badSink(short data) { { --data; short result = data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"- <start> data <end> ;
short <start> result = data <end> ;"	"- <start> data <end> ;
void CWE191_Integer_Underflow__short_fscanf_predec_65b_badSink(short <start> data <end> );"	"void CWE191_Integer_Underflow__short_fscanf_predec_65b_badSink(short <start> data <end> );
<start> printIntLine(result) <end> ;"	"void CWE191_Integer_Underflow__short_fscanf_predec_65b_badSink(short <start> data <end> );
- <start> data <end> ;"	3
c5fc236b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; namespace CWE23_Relative_Path_Traversal__char_file_open_04 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(STATIC_CONST_TRUE) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
size_t dataLen = <start> strlen(data) <end> ;"	"char <start> dataBuffer[FILENAME_MAX] = BASEPATH <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
fileDesc = OPEN(data, O_RDWR|O_CREAT, <start> S_IREAD|S_IWRITE <end> );"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	3
9187cc1c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #define SEARCH_CHAR 'S' void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_file_09_bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\0'; { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } if(GLOBAL_CONST_TRUE) { for (; *data != '\0'; data++) { if (*data == SEARCH_CHAR) { printLine(""We have a match!""); break; } } free(data); } }"	where is the vulnerable dataflow from data to free ?	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
<start> data = (char *)malloc(100*sizeof(char)) <end> ;"	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
free <start> data <end> );"	"free <start> data <end> );
for (; *data != '\0'; <start> data++ <end> );"	2
92bb89f2-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #define SEARCH_CHAR 'S' extern char * CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_file_68_badDataForBadSink; extern char * CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_file_68_badDataForGoodSink; void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_file_68b_badSink() { char * data = CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_file_68_badDataForBadSink; for (; *data != '\0'; data++) { if (*data == SEARCH_CHAR) { printLine(""We have a match!""); break; } } free(data); }"	where is the vulnerable dataflow from data to free ?	"char * data = <start> CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_file_68_badDataForBadSink <end> ;
<start> free(data) <end> ;"	"free <start> data <end> );
char * data = <start> CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_file_68_badDataForBadSink <end> ;"	"char * data = <start> CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_file_68_badDataForBadSink <end> ;
free <start> data <end> );"	"free <start> data <end> );
<start> free(data) <end> ;"	2
cd228166-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_console_open_34 { typedef union { char * unionFirst; char * unionSecond; } unionType; void bad() { char * data; unionType myUnion; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } } }"	where is the vulnerable dataflow from data to OPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"<start> data = dataBuffer <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
size_t dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
char <start> dataBuffer[FILENAME_MAX] = """" <end> ;"	0
7ae3a732-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticTrue = 1; static int staticFalse = 0; void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_05_bad() { int data; data = -1; if(staticTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"printLine <start> dest <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"data = <start> atoi(inputBuffer) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> strncpy(dest, source, data) <end> ;"	1
55ef4cb5-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_fgets_multiply_63b_badSink(int * dataPtr) { int data = *dataPtr; if(data < 0) { int result = data * 2; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"void CWE191_Integer_Underflow__int_fgets_multiply_63b_badSink(int * <start> dataPtr <end> );
int result = <start> data * 2 <end> ;"	"<start> printIntLine(result) <end> ;
void CWE191_Integer_Underflow__int_fgets_multiply_63b_badSink(int * <start> dataPtr <end> );"	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  * 2;"	"void CWE191_Integer_Underflow__int_fgets_multiply_63b_badSink(int * <start> dataPtr <end> );
int result = <start> data <end>  * 2;"	3
8f278a73-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticTrue = 1; static int staticFalse = 0; void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_05_bad() { int data; data = -1; if(staticTrue) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } { size_t i; int *intPointer; intPointer = (int*)malloc(data * sizeof(int)); if (intPointer == NULL) {exit(-1);} for (i = 0; i < (size_t)data; i++) { intPointer[i] = 0; } printIntLine(intPointer[0]); free(intPointer); } }"	where is the vulnerable dataflow from data to malloc ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> data = atoi(inputBuffer) <end> ;"	"if  <start> fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) <end>  != NULL);
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"data = <start> atoi(inputBuffer) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	3
48d25d78-6c15-11ed-81d4-94e6f77dd552	"static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; void CWE190_Integer_Overflow__int_fscanf_square_04_bad() { int data; data = 0; if(STATIC_CONST_TRUE) { fscanf(stdin, ""%d"", &data); } if(STATIC_CONST_TRUE) { { int result = data * data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  * data;
fscanf(stdin, ""%d"", <start> &data <end> );"	"fscanf(stdin, ""%d"", <start> &data <end> );
int result = <start> data <end>  * data;"	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  * data;"	"<start> printIntLine(result) <end> ;
fscanf(stdin, ""%d"", <start> &data <end> );"	1
5d16c9d5-6c15-11ed-81d4-94e6f77dd552	extern short CWE191_Integer_Underflow__short_fscanf_postdec_68_badData; extern short CWE191_Integer_Underflow__short_fscanf_postdec_68_goodG2BData; extern short CWE191_Integer_Underflow__short_fscanf_postdec_68_goodB2GData; void CWE191_Integer_Underflow__short_fscanf_postdec_68b_badSink() { short data = CWE191_Integer_Underflow__short_fscanf_postdec_68_badData; { data--; short result = data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"short data = <start> CWE191_Integer_Underflow__short_fscanf_postdec_68_badData <end> ;
<start> data <end> --;"	"<start> data <end> --;
short <start> result = data <end> ;"	"<start> printIntLine(result) <end> ;
<start> data <end> --;"	"short <start> result = data <end> ;
short data = <start> CWE191_Integer_Underflow__short_fscanf_postdec_68_badData <end> ;"	0
8df42200-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define PATH_SZ 100 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define PATH_SZ PATH_MAX #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 void CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__accept_listen_bind_09_bad() { if(GLOBAL_CONST_TRUE) { { char data[100] = """"; #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[recvResult] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif printLine(data); } } }"	where is the vulnerable dataflow from data to printLine ?	"recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);
printLine <start> data <end> );"	"recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);
replace = <start> strchr(data, '\n') <end> ;"	"replace = <start> strchr(data, '\n') <end> ;
printLine <start> data <end> );"	"printLine <start> data <end> );
recvResult = recv(acceptSocket, <start> (char *)data <end> +dataLen, (int)(100-dataLen-1), 0);"	0
af580955-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int badStatic = 0; static int badSource(int data) { if(badStatic) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } return data; } void CWE197_Numeric_Truncation_Error__int_connect_socket_to_short_21_bad() { int data; data = -1; badStatic = 1; data = badSource(data); { short shortData = (short)data; printShortLine(shortData); } }"	where is the vulnerable dataflow from shortData to printShortLine ?	"static int <start> badSource <end> (int data);
printShortLine <start> shortData <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
data = <start> badSource <end> (data);"	"data = <start> atoi(inputBuffer) <end> ;
printShortLine <start> shortData <end> );
data = <start> badSource <end> (data);
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"data = <start> badSource <end> (data);
static int <start> badSource <end> (int data);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static int <start> badSource <end> (int data);
data = <start> badSource <end> (data);
printShortLine <start> shortData <end> );"	3
73bc816f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" void CWE194_Unexpected_Sign_Extension__connect_socket_memmove_10_bad() { short data; data = 0; if(globalTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"if  <start> data < 100 <end> );
printLine <start> dest <end> );"	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printLine <start> dest <end> );"	"<start> data = 0 <end> ;
printLine <start> dest <end> );"	0
67d010da-6c15-11ed-81d4-94e6f77dd552	static int badStatic = 0; static void badSink(char data) { if(badStatic) { { ++data; char result = data; printHexCharLine(result); } } } void CWE190_Integer_Overflow__char_rand_preinc_21_bad() { char data; data = ' '; data = (char)RAND32(); badStatic = 1; badSink(data); }	where is the vulnerable dataflow from data ?	"data = (char <start> RAND32() <end> ;
badSink <start> data <end> );
static void badSink(char <start> data <end> );
+ <start> data <end> ;"	"<start> ++data <end> ;
data = (char <start> RAND32() <end> ;
+ <start> data <end> ;
static void badSink(char <start> data <end> );"	"static void badSink(char <start> data <end> );
badSink <start> data <end> );
data = (char <start> RAND32() <end> ;
+ <start> data <end> ;"	"data = (char <start> RAND32() <end> ;
badSink <start> data <end> );
static void badSink(char <start> data <end> );
<start> badSink(data) <end> ;"	0
af580977-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticFive = 5; void CWE197_Numeric_Truncation_Error__int_fgets_to_char_07_bad() { int data; data = -1; if(staticFive==5) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } { char charData = (char)data; printHexCharLine(charData); } }"	where is the vulnerable dataflow from charData to printHexCharLine ?	"char charData = <start> (char)data <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"<start> data = atoi(inputBuffer) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printHexCharLine <start> charData <end> );"	"printHexCharLine <start> charData <end> );
char <start> charData = (char)data <end> ;"	2
9059f3c9-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 256 static int staticFive = 5; void CWE681_Incorrect_Conversion_Between_Numeric_Types__double2int_07_bad() { if(staticFive==5) { { char inputBuffer[CHAR_ARRAY_SIZE]; double doubleNumber = 0; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { doubleNumber = atof(inputBuffer); } else { printLine(""fgets() failed.""); } printIntLine((int)doubleNumber); } } }"	where is the vulnerable dataflow from (int)doubleNumber to printIntLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> (int)doubleNumber <end> );"	"doubleNumber = <start> atof(inputBuffer) <end> ;
printIntLine <start> (int)doubleNumber <end> );"	"double <start> doubleNumber = 0 <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"printIntLine <start> (int)doubleNumber <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	0
93ece314-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING ""hello"" void CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_53d_badSink(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); } else { printLine(""Input is less than the length of the source string""); } } }"	where is the vulnerable dataflow from data to malloc ?	"void CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_53d_badSink(size_t <start> data <end> );
myString = (char *)malloc <start> data*sizeof(char) <end> );"	"<start> printLine(myString) <end> ;
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_53d_badSink(size_t <start> data <end> );"	"<start> printLine(myString) <end> ;
myString = (char *)malloc <start> data*sizeof(char) <end> );"	"myString = (char *)malloc <start> data*sizeof(char) <end> );
if  <start> data > strlen(HELLO_STRING) <end> );"	0
c5fc236a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_file_open_03 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(5==5) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
size_t dataLen = <start> strlen(data) <end> ;"	"<start> data = dataBuffer <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
char <start> dataBuffer[FILENAME_MAX] = BASEPATH <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	3
85b15eef-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE369_Divide_by_Zero__int_fgets_divide_10_bad() { int data; data = -1; if(globalTrue) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(globalTrue) { printIntLine(100 / data); } }"	where is the vulnerable dataflow from data to printIntLine ?	"data = <start> atoi(inputBuffer) <end> ;
printIntLine <start> 100 / data <end> );"	"<start> data = -1 <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"printIntLine <start> 100 / data <end> );
if  <start> fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) <end>  != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> 100 / data <end> );"	3
584fa851-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int badStatic = 0; static void badSink(int data) { if(badStatic) { if(data < 0) { int result = data * 2; printIntLine(result); } } } void CWE191_Integer_Underflow__int_listen_socket_multiply_21_bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badStatic = 1; badSink(data); }"	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  * 2;
if  <start> recvResult == SOCKET_ERROR <end>  || recvResult == 0);
static void badSink(int <start> data <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> badSink(data) <end> ;
static void badSink(int <start> data <end> );
badSink <start> data <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSink <start> data <end> );
static void badSink(int <start> data <end> );
int result = <start> data <end>  * 2;"	"int <start> result = data * 2 <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static void badSink(int <start> data <end> );
badSink <start> data <end> );"	2
7ae3a758-6c15-11ed-81d4-94e6f77dd552	"namespace CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_81 { void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_81_bad::action(int data) const { { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } } }"	where is the vulnerable dataflow from dest to printLine ?	"printLine <start> dest <end> );
void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_81_bad::action(int <start> data <end> ) const;"	"void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_81_bad::action(int <start> data <end> ) const;
<start> strncpy(dest, source, data) <end> ;"	"void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_81_bad::action(int <start> data <end> ) const;
printLine <start> dest <end> );"	"void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_81_bad::action(int <start> data <end> ) const;
<start> printLine(dest) <end> ;"	2
435200eb-6c15-11ed-81d4-94e6f77dd552	"static void badSink(int64_t data) { { int64_t result = data + 1; printLongLongLine(result); } } void CWE190_Integer_Overflow__int64_t_fscanf_add_41_bad() { int64_t data; data = 0LL; fscanf (stdin, ""%"" SCNd64, &data); badSink(data); }"	where is the vulnerable dataflow from data ?	"fscanf (stdin, ""%"" SCNd64, <start> &data <end> );
int64_t result = <start> data <end>  + 1;
badSink <start> data <end> );
static void badSink(int64_t <start> data <end> );"	"fscanf (stdin, ""%"" SCNd64, <start> &data <end> );
badSink <start> data <end> );
static void badSink(int64_t <start> data <end> );"	"static void badSink(int64_t <start> data <end> );
fscanf (stdin, ""%"" SCNd64, <start> &data <end> );
badSink <start> data <end> );
<start> badSink(data) <end> ;"	"fscanf (stdin, ""%"" SCNd64, <start> &data <end> );
badSink <start> data <end> );
static void badSink(int64_t <start> data <end> );
int64_t result = <start> data <end>  + 1;"	3
ba102ba2-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define EXECLP _execlp #else #define EXECLP execlp #endif void CWE78_OS_Command_Injection__char_connect_socket_execlp_16_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; while(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; } EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECLP ?	"EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
recvResult = <start> recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0) <end> ;"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (100 - dataLen - 1), 0);
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"<start> data = dataBuffer <end> ;
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	1
5133a75f-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_preinc_13_bad() { int data; data = 0; if(GLOBAL_CONST_FIVE==5) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(GLOBAL_CONST_FIVE==5) { { ++data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
+ <start> data <end> ;"	"<start> ++data <end> ;
+ <start> data <end> ;"	"+ <start> data <end> ;
int <start> result = data <end> ;"	"<start> ++data <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	0
964cdc1d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FULL_COMMAND ""dir "" #else #define FULL_COMMAND ""ls "" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define POPEN _popen #define PCLOSE _pclose #else #define POPEN popen #define PCLOSE pclose #endif char * CWE78_OS_Command_Injection__char_listen_socket_popen_61b_badSource(char * data); void CWE78_OS_Command_Injection__char_listen_socket_popen_61_bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; data = CWE78_OS_Command_Injection__char_listen_socket_popen_61b_badSource(data); { FILE *pipe; pipe = POPEN(data, ""w""); if (pipe != NULL) { PCLOSE(pipe); } } }"	where is the vulnerable dataflow from data to POPEN ?	"data = <start> CWE78_OS_Command_Injection__char_listen_socket_popen_61b_badSource <end> (data);
pipe = POPEN <start> data <end> , ""w"");"	"pipe = POPEN <start> data <end> , ""w"");
<start> data = CWE78_OS_Command_Injection__char_listen_socket_popen_61b_badSource(data) <end> ;"	"pipe = POPEN <start> data <end> , ""w"");
pipe = <start> POPEN(data, ""w"") <end> ;"	"pipe = POPEN <start> data <end> , ""w"");
data = <start> CWE78_OS_Command_Injection__char_listen_socket_popen_61b_badSource <end> (data);"	0
47a2a82f-6c15-11ed-81d4-94e6f77dd552	"static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; void CWE190_Integer_Overflow__int_fscanf_multiply_04_bad() { int data; data = 0; if(STATIC_CONST_TRUE) { fscanf(stdin, ""%d"", &data); } if(STATIC_CONST_TRUE) { if(data > 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"fscanf(stdin, ""%d"", <start> &data <end> );
int result = <start> data <end>  * 2;"	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  * 2;"	"int result = <start> data <end>  * 2;
if <start> data > 0 <end> ) ;"	"int result = <start> data <end>  * 2;
fscanf(stdin, ""%d"", <start> &data <end> );"	0
571e984a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_listen_socket_multiply_01_bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } if(data < 0) { int result = data * 2; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  * 2;"	"int result = <start> data <end>  * 2;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  * 2;"	1
8b91e472-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_listen_socket_open_14 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(globalFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
char <start> dataBuffer[FILENAME_MAX] = """" <end> ;"	"<start> data = dataBuffer <end> ;
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	0
b41b8781-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif namespace CWE23_Relative_Path_Traversal__char_file_fopen_81 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } const CWE23_Relative_Path_Traversal__char_file_fopen_81_base& baseObject = CWE23_Relative_Path_Traversal__char_file_fopen_81_bad(); baseObject.action(data); }"	where is the vulnerable dataflow from data to action ?	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
baseObject.action <start> data <end> );"	"char <start> dataBuffer[FILENAME_MAX] = BASEPATH <end> ;
baseObject.action <start> data <end> );"	"size_t dataLen = <start> strlen(data) <end> ;
baseObject.action <start> data <end> );"	1
820a46b8-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_file_fopen_12 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(globalReturnsTrueOrFalse()) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } else { strcat(data, ""file.txt""); } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = FOPEN <start> data <end> , ""wb+"");
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
<start> data = dataBuffer <end> ;"	"pFile = FOPEN <start> data <end> , ""wb+"");
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
pFile = FOPEN <start> data <end> , ""wb+"");"	3
cac216db-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_connect_socket_open_17 { void bad() { int i; char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; for(i = 0; i < 1; i++) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"char <start> dataBuffer[FILENAME_MAX] = """" <end> ;
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"size_t dataLen = <start> strlen(data) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	1
820a46f6-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif extern char * CWE23_Relative_Path_Traversal__char_file_open_68_badData; extern char * CWE23_Relative_Path_Traversal__char_file_open_68_goodG2BData; namespace CWE23_Relative_Path_Traversal__char_file_open_68 { void badSink() { char * data = CWE23_Relative_Path_Traversal__char_file_open_68_badData; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
char * data = <start> CWE23_Relative_Path_Traversal__char_file_open_68_badData <end> ;"	"char * data = <start> CWE23_Relative_Path_Traversal__char_file_open_68_badData <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
char * data = <start> CWE23_Relative_Path_Traversal__char_file_open_68_badData <end> ;"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	1
d31a2500-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 namespace CWE36_Absolute_Path_Traversal__char_listen_socket_ofstream_17 { void bad() { int i; char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; for(i = 0; i < 1; i++) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );
outputFile.open((char * <start> data <end> );"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
outputFile.open((char * <start> data <end> );"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
outputFile.open((char * <start> data <end> );"	"outputFile.open((char * <start> data <end> );
replace = <start> strchr(data, '\n') <end> ;"	2
d1e9da56-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 static int staticTrue = 1; static int staticFalse = 0; namespace CWE36_Absolute_Path_Traversal__char_listen_socket_ifstream_05 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(staticTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
recvResult = recv(acceptSocket, (char *)(data + dataLen), <start> sizeof(char) * (FILENAME_MAX - dataLen - 1) <end> , 0);"	"recvResult = recv(acceptSocket, (char *)(data + dataLen), <start> sizeof(char) * (FILENAME_MAX - dataLen - 1) <end> , 0);
inputFile.open((char * <start> data <end> );"	"inputFile.open((char * <start> data <end> );
if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
inputFile.open((char * <start> data <end> );"	3
bb49c5a8-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #define EXECLP _execlp #else #define EXECLP execlp #endif void CWE78_OS_Command_Injection__char_console_execlp_17_bad() { int i; char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; for(i = 0; i < 1; i++) { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECLP ?	"dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
if (dataLen > 0 && <start> data[dataLen-1] == '\n' <end> );"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
size_t dataLen = <start> strlen(data) <end> ;"	2
c01af8e3-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_connect_socket_open_64 { void badSink(void * dataVoidPtr) { char * * dataPtr = (char * *)dataVoidPtr; char * data = (*dataPtr); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"void badSink(void * <start> dataVoidPtr <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
void badSink(void * <start> dataVoidPtr <end> );"	"void badSink(void * <start> dataVoidPtr <end> );
char <start> * data = (*dataPtr) <end> ;"	0
c01af8d9-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_connect_socket_open_43 { void badSource(char * &data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; badSource(data); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
recvResult = recv(connectSocket, (char *)(data + dataLen), <start> sizeof(char) * (FILENAME_MAX - dataLen - 1) <end> , 0);
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
badSource <start> data <end> );"	"fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
badSource <start> data <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	3
cf8750bc-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_file_fopen_41 { void badSink(char * data) { { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } } void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } badSink(data); }"	where is the vulnerable dataflow from data to badSink ?	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
badSink <start> data <end> );"	"<start> badSink(data) <end> ;
badSink <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
badSink <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
<start> badSink(data) <end> ;"	2
ae26ae35-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_listen_socket_predec_17_bad() { int i,j; int data; data = 0; for(i = 0; i < 1; i++) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } for(j = 0; j < 1; j++) { { --data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> --data <end> ;"	"int <start> result = data <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"printIntLine <start> result <end> );
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	0
4a021102-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_multiply_18_bad() { int data; data = 0; goto source; source: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } goto sink; sink: if(data > 0) { int result = data * 2; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"int <start> result = data * 2 <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
int result = <start> data <end>  * 2;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  * 2;"	"int result = <start> data <end>  * 2;
<start> data = atoi(inputBuffer) <end> ;"	2
d0b64ed2-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif namespace CWE36_Absolute_Path_Traversal__char_file_ifstream_21 { static int badStatic = 0; static char * badSource(char * data) { if(badStatic) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } return data; } void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; badStatic = 1; data = badSource(data); { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } ; }"	where is the vulnerable dataflow from data to open ?	"data = <start> badSource <end> (data);
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
inputFile.open((char * <start> data <end> );
static char * <start> badSource <end> (char * data);"	"static char * <start> badSource <end> (char * data);
inputFile.open((char * <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
inputFile.open((char * <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
inputFile.open((char * <start> data <end> );"	2
92bb8a11-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define SEARCH_CHAR 'S' void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_63b_badSink(char * * dataPtr) { char * data = *dataPtr; for (; *data != '\0'; data++) { if (*data == SEARCH_CHAR) { printLine(""We have a match!""); break; } } free(data); }"	where is the vulnerable dataflow from data to free ?	"free <start> data <end> );
void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_63b_badSink(char * * <start> dataPtr <end> );"	"void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_63b_badSink(char * * <start> dataPtr <end> );
for (; *data != '\0'; <start> data++ <end> );"	"void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_63b_badSink(char * * <start> dataPtr <end> );
free <start> data <end> );"	"free <start> data <end> );
for (; *data != '\0'; <start> data++ <end> );"	2
a36a78f6-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_add_31_bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { int dataCopy = data; int data = dataCopy; { int result = data + 1; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"<start> printIntLine(result) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"printIntLine <start> result <end> );
if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );"	0
6b86245e-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_43 { static void badSource(int &data) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } void bad() { int data; data = -1; badSource(data); { int i; int * buffer = (int *)malloc(10 * sizeof(int)); if (buffer == NULL) {exit(-1);} for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } free(buffer); } }"	where is the vulnerable dataflow from buffer to free ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
badSource <start> data <end> );
free <start> buffer <end> );"	"<start> free(buffer) <end> ;
badSource <start> data <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"free <start> buffer <end> );
badSource <start> data <end> );
if  <start> buffer == NULL <end> ) {exit(-1);};"	"badSource <start> data <end> );
<start> free(buffer) <end> ;
free <start> buffer <end> );"	0
aa91a169-6c15-11ed-81d4-94e6f77dd552	extern int CWE191_Integer_Underflow__int_listen_socket_multiply_22_badGlobal; void CWE191_Integer_Underflow__int_listen_socket_multiply_22_badSink(int data) { if(CWE191_Integer_Underflow__int_listen_socket_multiply_22_badGlobal) { if(data < 0) { int result = data * 2; printIntLine(result); } } }	where is the vulnerable dataflow from result to printIntLine ?	"int <start> result = data * 2 <end> ;
void CWE191_Integer_Underflow__int_listen_socket_multiply_22_badSink(int <start> data <end> );"	"void CWE191_Integer_Underflow__int_listen_socket_multiply_22_badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
if <start> data < 0 <end> ) ;"	"int <start> result = data * 2 <end> ;
printIntLine <start> result <end> );"	1
73bc8142-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" void CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_09_bad() { short data; data = 0; if(GLOBAL_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"printLine <start> dest <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"<start> memcpy(dest, source, data) <end> ;
printLine <start> dest <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"if (tempInt > SHRT_MAX || <start> tempInt < SHRT_MIN <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	2
c39a659d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif namespace CWE23_Relative_Path_Traversal__char_environment_ifstream_44 { static void badSink(char * data) { { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } } void bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } funcPtr(data); }"	where is the vulnerable dataflow from data to funcPtr ?	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
strncat(data+dataLen, environment, <start> FILENAME_MAX-dataLen-1 <end> );"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
funcPtr <start> data <end> );"	"funcPtr <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	"funcPtr <start> data <end> );
char <start> dataBuffer[FILENAME_MAX] = BASEPATH <end> ;"	1
60db83c5-6c15-11ed-81d4-94e6f77dd552	extern int CWE190_Integer_Overflow__char_rand_multiply_22_badGlobal; void CWE190_Integer_Overflow__char_rand_multiply_22_badSink(char data) { if(CWE190_Integer_Overflow__char_rand_multiply_22_badGlobal) { if(data > 0) { char result = data * 2; printHexCharLine(result); } } }	where is the vulnerable dataflow from data ?	"char <start> result = data * 2 <end> ;
void CWE190_Integer_Overflow__char_rand_multiply_22_badSink(char <start> data <end> );"	"char result = <start> data * 2 <end> ;
void CWE190_Integer_Overflow__char_rand_multiply_22_badSink(char <start> data <end> );"	"void CWE190_Integer_Overflow__char_rand_multiply_22_badSink(char <start> data <end> );
char result = <start> data <end>  * 2;"	"char result = <start> data <end>  * 2;
if <start> data > 0 <end> ) ;"	2
af580926-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_18_bad() { int data; data = -1; goto source; source: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { char charData = (char)data; printHexCharLine(charData); } }"	where is the vulnerable dataflow from charData to printHexCharLine ?	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printHexCharLine <start> charData <end> );"	"printHexCharLine <start> charData <end> );
char <start> charData = (char)data <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printHexCharLine <start> charData <end> );"	"data = <start> atoi(inputBuffer) <end> ;
printHexCharLine <start> charData <end> );"	2
89321800-6c15-11ed-81d4-94e6f77dd552	#ifndef _WIN32 #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif extern char * CWE36_Absolute_Path_Traversal__char_console_open_68_badData; extern char * CWE36_Absolute_Path_Traversal__char_console_open_68_goodG2BData; namespace CWE36_Absolute_Path_Traversal__char_console_open_68 { void badSink() { char * data = CWE36_Absolute_Path_Traversal__char_console_open_68_badData; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }	where is the vulnerable dataflow from data to OPEN ?	"char * data = <start> CWE36_Absolute_Path_Traversal__char_console_open_68_badData <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"char * data = <start> CWE36_Absolute_Path_Traversal__char_console_open_68_badData <end> ;
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"char * data = <start> CWE36_Absolute_Path_Traversal__char_console_open_68_badData <end> ;
fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);"	0
846ad306-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif void CWE253_Incorrect_Check_of_Function_Return_Value__char_fgets_15_bad() { switch(6) { case 6: { char dataBuffer[100] = """"; char * data = dataBuffer; printLine(""Please enter a string: ""); if (fgets(data, 100, stdin) < 0) { printLine(""fgets failed!""); exit(1); } printLine(data); } break; default: printLine(""Benign, fixed string""); break; } }"	where is the vulnerable dataflow from data to printLine ?	"if (fgets <start> data <end> , 100, stdin) < 0);
printLine <start> data <end> );"	"printLine <start> data <end> );
if (fgets <start> data <end> , 100, stdin) < 0);"	"printLine <start> data <end> );
<start> printLine(data) <end> ;"	"if (fgets <start> data <end> , 100, stdin) < 0);
<start> printLine(data) <end> ;"	0
87ff983e-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; namespace CWE36_Absolute_Path_Traversal__char_connect_socket_fopen_04 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(STATIC_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"replace = <start> strchr(data, '\r') <end> ;
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
size_t <start> dataLen = strlen(data) <end> ;"	"size_t dataLen = <start> strlen(data) <end> ;
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	3
79b27529-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_17_bad() { int i; int data; data = -1; for(i = 0; i < 1; i++) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }"	where is the vulnerable dataflow from data to malloc ?	"char * dataBuffer = (char *)malloc <start> data <end> );
<start> data = atoi(inputBuffer) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
data = <start> atoi(inputBuffer) <end> ;"	"char * dataBuffer = (char *)malloc <start> data <end> );
memset(dataBuffer, 'A', <start> data-1 <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
char * dataBuffer = (char *)malloc <start> data <end> );"	3
54c581e5-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } void CWE191_Integer_Underflow__int_connect_socket_multiply_08_bad() { int data; data = 0; if(staticReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticReturnsTrue()) { if(data < 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  * 2;
recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);"	"int result = <start> data <end>  * 2;
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"int result = <start> data <end>  * 2;
<start> printIntLine(result) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  * 2;"	3
60db83b8-6c15-11ed-81d4-94e6f77dd552	static int staticFive = 5; void CWE190_Integer_Overflow__char_rand_multiply_07_bad() { char data; data = ' '; if(staticFive==5) { data = (char)RAND32(); } if(staticFive==5) { if(data > 0) { char result = data * 2; printHexCharLine(result); } } }	where is the vulnerable dataflow from data ?	"data = (char <start> RAND32() <end> ;
<start> data = ' ' <end> ;"	"data = (char <start> RAND32() <end> ;
char result = <start> data <end>  * 2;"	"data = (char <start> RAND32() <end> ;
if <start> data > 0 <end> ) ;"	"data = (char <start> RAND32() <end> ;
<start> printHexCharLine(result) <end> ;"	1
5133a778-6c15-11ed-81d4-94e6f77dd552	"void CWE190_Integer_Overflow__int_fscanf_preinc_01_bad() { int data; data = 0; fscanf(stdin, ""%d"", &data); { ++data; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"<start> ++data <end> ;
+ <start> data <end> ;"	"fscanf(stdin, ""%d"", <start> &data <end> );
+ <start> data <end> ;"	"+ <start> data <end> ;
<start> printIntLine(result) <end> ;"	"<start> printIntLine(result) <end> ;
fscanf(stdin, ""%d"", <start> &data <end> );"	1
951c5e61-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FULL_COMMAND ""dir "" #else #define FULL_COMMAND ""ls "" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define POPEN _popen #define PCLOSE _pclose #else #define POPEN popen #define PCLOSE pclose #endif void CWE78_OS_Command_Injection__char_connect_socket_popen_01_bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { FILE *pipe; pipe = POPEN(data, ""w""); if (pipe != NULL) { PCLOSE(pipe); } } }"	where is the vulnerable dataflow from data to POPEN ?	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
pipe = <start> POPEN(data, ""w"") <end> ;"	"replace = <start> strchr(data, '\n') <end> ;
pipe = POPEN <start> data <end> , ""w"");"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
pipe = POPEN <start> data <end> , ""w"");"	"pipe = POPEN <start> data <end> , ""w"");
pipe = <start> POPEN(data, ""w"") <end> ;"	2
ce547d45-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif namespace CWE36_Absolute_Path_Traversal__char_environment_ifstream_15 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; switch(6) { case 6: { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } break; default: printLine(""Benign, fixed string""); break; } { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
inputFile.open((char * <start> data <end> );"	"size_t dataLen = <start> strlen(data) <end> ;
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"size_t dataLen = <start> strlen(data) <end> ;
inputFile.open((char * <start> data <end> );"	"strncat(data+dataLen, environment, FILENAME_MAX <start> dataLen-1 <end> );
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	0
d31a2530-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_listen_socket_open_63 { void badSink(char * * dataPtr) { char * data = *dataPtr; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"void badSink(char * * <start> dataPtr <end> );
fileDesc = OPEN(data, O_RDWR|O_CREAT, <start> S_IREAD|S_IWRITE <end> );"	"char <start> * data = *dataPtr <end> ;
void badSink(char * * <start> dataPtr <end> );"	"void badSink(char * * <start> dataPtr <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	2
648a9bf8-6c15-11ed-81d4-94e6f77dd552	static void badSink(int64_t data) { { int64_t result = data * data; printLongLongLine(result); } } void CWE190_Integer_Overflow__int64_t_rand_square_44_bad() { int64_t data; void (*funcPtr) (int64_t) = badSink; data = 0LL; data = (int64_t)RAND64(); funcPtr(data); }	where is the vulnerable dataflow from data ?	"static void badSink(int64_t <start> data <end> );
funcPtr <start> data <end> );
data = (int64_t <start> RAND64() <end> ;"	"data = (int64_t <start> RAND64() <end> ;
funcPtr <start> data <end> );
static void badSink(int64_t <start> data <end> );
int64_t result = <start> data <end>  * data;"	"static void badSink(int64_t <start> data <end> );
data = (int64_t <start> RAND64() <end> ;"	"int64_t result = <start> data <end>  * data;
data = (int64_t <start> RAND64() <end> ;
funcPtr <start> data <end> );
static void badSink(int64_t <start> data <end> );"	1
c01af8e9-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_connect_socket_open_73 { void badSink(list<char *> dataList) { char * data = dataList.back(); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
void badSink(list<char *> <start> dataList <end> );"	"void badSink(list<char *> <start> dataList <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"void badSink(list<char *> <start> dataList <end> );
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	1
b1b8081e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_03_bad() { int data; data = -1; if(5==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { short shortData = (short)data; printShortLine(shortData); } }"	where is the vulnerable dataflow from shortData to printShortLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printShortLine(shortData) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printShortLine <start> shortData <end> );"	"short <start> shortData = (short)data <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"printShortLine <start> shortData <end> );
data = <start> atoi(inputBuffer) <end> ;"	1
47a2a853-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__int_fscanf_multiply_73 { void badSink(list<int> dataList) { int data = dataList.back(); if(data > 0) { int result = data * 2; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  * 2;
if <start> data > 0 <end> ) ;"	"void badSink(list<int> <start> dataList <end> );
<start> printIntLine(result) <end> ;"	"void badSink(list<int> <start> dataList <end> );
if <start> data > 0 <end> ) ;"	"void badSink(list<int> <start> dataList <end> );
int result = <start> data <end>  * 2;"	3
893217d7-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif extern char * CWE36_Absolute_Path_Traversal__char_console_fopen_68_badData; extern char * CWE36_Absolute_Path_Traversal__char_console_fopen_68_goodG2BData; namespace CWE36_Absolute_Path_Traversal__char_console_fopen_68 { void badSink() { char * data = CWE36_Absolute_Path_Traversal__char_console_fopen_68_badData; { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"char * data = <start> CWE36_Absolute_Path_Traversal__char_console_fopen_68_badData <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
char <start> * data = CWE36_Absolute_Path_Traversal__char_console_fopen_68_badData <end> ;"	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
char * data = <start> CWE36_Absolute_Path_Traversal__char_console_fopen_68_badData <end> ;"	0
964cdc2c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticFive = 5; void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_07_bad() { int data; data = -1; if(staticFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticFive==5) { { int i; int buffer[10] = { 0 }; if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } } } }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"printIntLine <start> buffer[i] <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"printIntLine <start> buffer[i] <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[i] <end> );"	"int <start> buffer[10] = { 0 } <end> ;
printIntLine <start> buffer[i] <end> );"	2
bb49c58c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #define EXECL _execl #else #define EXECL execl #endif void CWE78_OS_Command_Injection__char_console_execl_18_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; goto source; source: { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECL ?	"if  <start> fgets(data+dataLen, (int)(100-dataLen), stdin) <end>  != NULL);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
<start> EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
<start> data = dataBuffer <end> ;"	2
8df4220a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define PATH_SZ 100 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define PATH_SZ PATH_MAX #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 void CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__bind_accept_listen_01_bad() { { char data[100] = """"; #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[recvResult] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif printLine(data); } }"	where is the vulnerable dataflow from data to printLine ?	"recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);
<start> printLine(data) <end> ;"	"recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);
replace = <start> strchr(data, '\r') <end> ;"	"printLine <start> data <end> );
recvResult = recv(acceptSocket, <start> (char *)data <end> +dataLen, (int)(100-dataLen-1), 0);"	"recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);
printLine <start> data <end> );"	3
846ad32b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define STAT _stat #define OPEN _open #define WRITE _write #define O_RDWR _O_RDWR #define CLOSE _close #else #define STAT stat #define OPEN open #define WRITE write #define CLOSE close #endif #define BAD_SINK_STRING ""Bad Sink..."" #define GOOD_SINK_STRING ""Good Sink..."" void CWE367_TOC_TOU__stat_16_bad() { while(1) { { char filename[100] = """"; struct STAT statBuffer; int fileDesc = -1; if (fgets(filename, 100, stdin) == NULL) { printLine(""fgets() failed""); filename[0] = '\0'; } if (strlen(filename) > 0) { filename[strlen(filename)-1] = '\0'; } if (STAT(filename, &statBuffer) == -1) { exit(1); } fileDesc  = OPEN(filename, O_RDWR); if (fileDesc == -1) { exit(1); } if (WRITE(fileDesc, BAD_SINK_STRING, strlen(BAD_SINK_STRING)) == -1) { exit(1); } if (fileDesc != -1) { CLOSE(fileDesc); } } break; } }"	where is the vulnerable dataflow from filename to OPEN ?	"filename <start> strlen(filename) <end> -1] = '\0'; ;
if (fgets <start> filename <end> , 100, stdin) == NULL);"	"char <start> filename[100] = """" <end> ;
fileDesc  = OPEN <start> filename <end> , O_RDWR);"	"fileDesc  = OPEN <start> filename <end> , O_RDWR);
if (fgets <start> filename <end> , 100, stdin) == NULL);"	"if (fgets <start> filename <end> , 100, stdin) == NULL);
fileDesc  = OPEN <start> filename <end> , O_RDWR);"	3
584fa88a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_listen_socket_sub_64b_badSink(void * dataVoidPtr) { int * dataPtr = (int *)dataVoidPtr; int data = (*dataPtr); { int result = data - 1; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"void CWE191_Integer_Underflow__int_listen_socket_sub_64b_badSink(void * <start> dataVoidPtr <end> );
int result = <start> data <end>  - 1;"	"int <start> result = data - 1 <end> ;
void CWE191_Integer_Underflow__int_listen_socket_sub_64b_badSink(void * <start> dataVoidPtr <end> );"	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  - 1;"	"int result = <start> data <end>  - 1;
void CWE191_Integer_Underflow__int_listen_socket_sub_64b_badSink(void * <start> dataVoidPtr <end> );"	0
893217f7-6c15-11ed-81d4-94e6f77dd552	#ifndef _WIN32 #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_console_open_53 { void badSink_d(char * data) { { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
void badSink_d(char * <start> data <end> );"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
void badSink_d(char * <start> data <end> );"	"void badSink_d(char * <start> data <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	3
8a6310a8-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_file_fopen_61 { char * badSource(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; data = badSource(data); { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"data = <start> badSource <end> (data);
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
data = <start> badSource <end> (data);"	"char <start> dataBuffer[FILENAME_MAX] = """" <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	0
7fa68e09-6c15-11ed-81d4-94e6f77dd552	"int CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_22_badGlobal = 0; int CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_22_badSource(int data); void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_22_bad() { int data; data = -1; CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_22_badGlobal = 1; data = CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_22_badSource(data); { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"data = <start> CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_22_badSource <end> (data);
if  <start> data < 100 <end> );"	"data = <start> CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_22_badSource <end> (data);
<start> strncpy(dest, source, data) <end> ;"	"data = <start> CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_22_badSource <end> (data);
printLine <start> dest <end> );"	"printLine <start> dest <end> );
<start> strncpy(dest, source, data) <end> ;"	2
9059f3a1-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int badStatic = 0; static int badSource(int data) { if(badStatic) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } return data; } void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_21_bad() { int data; data = -1; badStatic = 1; data = badSource(data); { size_t i; int *intPointer; intPointer = (int*)malloc(data * sizeof(int)); if (intPointer == NULL) {exit(-1);} for (i = 0; i < (size_t)data; i++) { intPointer[i] = 0; } printIntLine(intPointer[0]); free(intPointer); } }"	where is the vulnerable dataflow from data to malloc ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
data = <start> badSource <end> (data);
static int <start> badSource <end> (int data);
data = <start> atoi(inputBuffer) <end> ;"	"intPointer = (int*)malloc <start> data * sizeof(int) <end> );
recvResult = recv(acceptSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);
data = <start> badSource <end> (data);
static int <start> badSource <end> (int data);"	"intPointer = (int*)malloc <start> data * sizeof(int) <end> );
static int <start> badSource <end> (int data);
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data = badSource(data) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static int <start> badSource <end> (int data);
data = <start> badSource <end> (data);
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	3
93ece2dd-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING ""hello"" void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_15_bad() { size_t data; data = 0; switch(6) { case 6: { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = strtoul(inputBuffer, NULL, 0); } else { printLine(""fgets() failed.""); } } break; default: printLine(""Benign, fixed string""); break; } switch(7) { case 7: { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); } else { printLine(""Input is less than the length of the source string""); } } break; default: printLine(""Benign, fixed string""); break; } }"	where is the vulnerable dataflow from data to malloc ?	"myString = (char *)malloc <start> data*sizeof(char) <end> );
if  <start> fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) <end>  != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
if  <start> fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) <end>  != NULL);"	"myString = (char *)malloc <start> data*sizeof(char) <end> );
data = <start> strtoul(inputBuffer, NULL, 0) <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
myString = (char *)malloc <start> data*sizeof(char) <end> );"	3
a6fd8250-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_preinc_51b_badSink(int data) { { ++data; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"void CWE190_Integer_Overflow__int_connect_socket_preinc_51b_badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	"int <start> result = data <end> ;
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
void CWE190_Integer_Overflow__int_connect_socket_preinc_51b_badSink(int <start> data <end> );"	0
466e7eed-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_multiply_63b_badSink(int * dataPtr) { int data = *dataPtr; if(data > 0) { int result = data * 2; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"void CWE190_Integer_Overflow__int_fgets_multiply_63b_badSink(int * <start> dataPtr <end> );
int result = <start> data <end>  * 2;"	"if <start> data > 0 <end> ) ;
int result = <start> data <end>  * 2;"	"void CWE190_Integer_Overflow__int_fgets_multiply_63b_badSink(int * <start> dataPtr <end> );
int <start> result = data * 2 <end> ;"	"int result = <start> data <end>  * 2;
void CWE190_Integer_Overflow__int_fgets_multiply_63b_badSink(int * <start> dataPtr <end> );"	0
5133a763-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_preinc_17_bad() { int i,j; int data; data = 0; for(i = 0; i < 1; i++) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } for(j = 0; j < 1; j++) { { ++data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"int <start> result = data <end> ;
+ <start> data <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
+ <start> data <end> ;"	"<start> printIntLine(result) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> data = 0 <end> ;"	1
445c1211-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; void CWE190_Integer_Overflow__int_connect_socket_multiply_04_bad() { int data; data = 0; if(STATIC_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(STATIC_CONST_TRUE) { if(data > 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  * 2;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int <start> result = data * 2 <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  * 2;"	"int result = <start> data <end>  * 2;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	2
5e44fc7f-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink(int data) { { --data; int result = data; printIntLine(result); } } void CWE191_Integer_Underflow__int_fgets_predec_41_bad() { int data; data = 0; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } badSink(data); }"	where is the vulnerable dataflow from data ?	"- <start> data <end> ;
badSink <start> data <end> );
static void badSink(int <start> data <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
badSink <start> data <end> );
static void badSink(int <start> data <end> );
- <start> data <end> ;"	"static void badSink(int <start> data <end> );
badSink <start> data <end> );
int <start> result = data <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"data = <start> atoi(inputBuffer) <end> ;
- <start> data <end> ;
static void badSink(int <start> data <end> );
badSink <start> data <end> );"	1
c72d5d56-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_listen_socket_fopen_15 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; switch(6) { case 6: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; default: printLine(""Benign, fixed string""); break; } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = FOPEN <start> data <end> , ""wb+"");
size_t <start> dataLen = strlen(data) <end> ;"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
size_t <start> dataLen = strlen(data) <end> ;"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
char <start> dataBuffer[FILENAME_MAX] = BASEPATH <end> ;"	2
a109491a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int CWE190_Integer_Overflow__int_connect_socket_square_45_badData; static int CWE190_Integer_Overflow__int_connect_socket_square_45_goodG2BData; static int CWE190_Integer_Overflow__int_connect_socket_square_45_goodB2GData; static void badSink() { int data = CWE190_Integer_Overflow__int_connect_socket_square_45_badData; { int result = data * data; printIntLine(result); } } void CWE190_Integer_Overflow__int_connect_socket_square_45_bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE190_Integer_Overflow__int_connect_socket_square_45_badData = data; badSink(); }"	where is the vulnerable dataflow from result to printIntLine ?	"int data = <start> CWE190_Integer_Overflow__int_connect_socket_square_45_badData <end> ;
printIntLine <start> result <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int data = <start> CWE190_Integer_Overflow__int_connect_socket_square_45_badData <end> ;
printIntLine <start> result <end> );
static int <start> CWE190_Integer_Overflow__int_connect_socket_square_45_badData <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> CWE190_Integer_Overflow__int_connect_socket_square_45_badData = data <end> ;
static int <start> CWE190_Integer_Overflow__int_connect_socket_square_45_badData <end> ;
int data = <start> CWE190_Integer_Overflow__int_connect_socket_square_45_badData <end> ;
printIntLine <start> result <end> );"	"int <start> data = CWE190_Integer_Overflow__int_connect_socket_square_45_badData <end> ;
<start> CWE190_Integer_Overflow__int_connect_socket_square_45_badData = data <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static int <start> CWE190_Integer_Overflow__int_connect_socket_square_45_badData <end> ;
printIntLine <start> result <end> );"	2
6ef76812-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif char * CWE134_Uncontrolled_Format_String__char_console_snprintf_61b_badSource(char * data); void CWE134_Uncontrolled_Format_String__char_console_snprintf_61_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; data = CWE134_Uncontrolled_Format_String__char_console_snprintf_61b_badSource(data); { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"printLine <start> dest <end> );
data = <start> CWE134_Uncontrolled_Format_String__char_console_snprintf_61b_badSource(data) <end> ;"	"SNPRINTF(dest, <start> 100-1 <end> , data);
data = <start> CWE134_Uncontrolled_Format_String__char_console_snprintf_61b_badSource <end> (data);"	"data = <start> CWE134_Uncontrolled_Format_String__char_console_snprintf_61b_badSource <end> (data);
printLine <start> dest <end> );"	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	2
c99197e0-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_connect_socket_fopen_11 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(globalReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - <start> dataLen - 1 <end> ), 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	"recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - <start> dataLen - 1 <end> ), 0);
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	3
5f76fc9c-6c15-11ed-81d4-94e6f77dd552	"void CWE191_Integer_Underflow__short_fscanf_predec_01_bad() { short data; data = 0; fscanf (stdin, ""%hd"", &data); { --data; short result = data; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"- <start> data <end> ;
<start> printIntLine(result) <end> ;"	"<start> printIntLine(result) <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );"	"fscanf (stdin, ""%hd"", <start> &data <end> );
- <start> data <end> ;"	"short <start> result = data <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );"	2
571e9811-6c15-11ed-81d4-94e6f77dd552	void CWE191_Integer_Underflow__int_fscanf_multiply_51b_badSink(int data) { if(data < 0) { int result = data * 2; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"void CWE191_Integer_Underflow__int_fscanf_multiply_51b_badSink(int <start> data <end> );
int result = <start> data <end>  * 2;"	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  * 2;"	"int result = <start> data <end>  * 2;
void CWE191_Integer_Underflow__int_fscanf_multiply_51b_badSink(int <start> data <end> );"	"<start> printIntLine(result) <end> ;
void CWE191_Integer_Underflow__int_fscanf_multiply_51b_badSink(int <start> data <end> );"	0
8f278a83-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) typedef union { int unionFirst; int unionSecond; } CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_34_unionType; void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_34_bad() { int data; CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_34_unionType myUnion; data = -1; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } myUnion.unionFirst = data; { int data = myUnion.unionSecond; { size_t i; int *intPointer; intPointer = (int*)malloc(data * sizeof(int)); if (intPointer == NULL) {exit(-1);} for (i = 0; i < (size_t)data; i++) { intPointer[i] = 0; } printIntLine(intPointer[0]); free(intPointer); } } }"	where is the vulnerable dataflow from data to malloc ?	"if  <start> fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL <end> );
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	"intPointer = (int*)malloc <start> data * sizeof(int) <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	"<start> printIntLine(intPointer[0]) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	2
c39a657d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_environment_fopen_64 { void badSink(void * dataVoidPtr) { char * * dataPtr = (char * *)dataVoidPtr; char * data = (*dataPtr); { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"char <start> * data = (*dataPtr) <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"void badSink(void * <start> dataVoidPtr <end> );
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
void badSink(void * <start> dataVoidPtr <end> );"	"pFile = FOPEN <start> data <end> , ""wb+"");
void badSink(void * <start> dataVoidPtr <end> );"	1
8df421eb-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define PATH_SZ 100 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define PATH_SZ PATH_MAX #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 static const int STATIC_CONST_FIVE = 5; void CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__accept_bind_listen_06_bad() { if(STATIC_CONST_FIVE==5) { { char data[100] = """"; #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[recvResult] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif printLine(data); } } }"	where is the vulnerable dataflow from data to printLine ?	"size_t dataLen = <start> strlen(data) <end> ;
recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);"	"printLine <start> data <end> );
recvResult = recv(acceptSocket, (char *)data+dataLen, <start> (int)(100-dataLen-1) <end> , 0);"	"recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);
printLine <start> data <end> );"	"printLine <start> data <end> );
<start> printLine(data) <end> ;"	2
715a3bff-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif typedef struct _CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_67_structType { char * structFirst; } CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_67_structType; void CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_67b_badSink(CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_67_structType myStruct) { char * data = myStruct.structFirst; { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"void CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_67b_badSink(CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_67_structType <start> myStruct <end> );
char * data = <start> myStruct <end> .structFirst;
printLine <start> dest <end> );"	"printLine <start> dest <end> );
<start> printLine(dest) <end> ;
void CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_67b_badSink(CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_67_structType <start> myStruct <end> );"	"<start> SNPRINTF(dest, 100-1, data) <end> ;
printLine <start> dest <end> );
char * data = <start> myStruct <end> .structFirst;"	"<start> SNPRINTF(dest, 100-1, data) <end> ;
printLine <start> dest <end> );
void CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_67b_badSink(CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_67_structType <start> myStruct <end> );"	0
977ea78f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_43 { static void badSource(int &data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } void bad() { int data; data = -1; badSource(data); { int i; int buffer[10] = { 0 }; if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } } }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSource <start> data <end> );
printIntLine <start> buffer[i] <end> );"	"badSource <start> data <end> );
printIntLine <start> buffer[i] <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSource <start> data <end> );"	"int <start> buffer[10] = { 0 } <end> ;
badSource <start> data <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	0
7d44fccf-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_65b_badSink(int data) { if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }"	where is the vulnerable dataflow from data to malloc ?	"memset(dataBuffer, 'A', <start> data-1 <end> );
char * dataBuffer = (char *)malloc <start> data <end> );"	"<start> memset(dataBuffer, 'A', data-1) <end> ;
char * dataBuffer = (char *)malloc <start> data <end> );"	"<start> free(dataBuffer) <end> ;
char * dataBuffer = (char *)malloc <start> data <end> );"	"void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_65b_badSink(int <start> data <end> );
char * dataBuffer = (char *)malloc <start> data <end> );"	3
b68484cb-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE369_Divide_by_Zero__int_listen_socket_divide_82 { void bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE369_Divide_by_Zero__int_listen_socket_divide_82_base* baseObject = new CWE369_Divide_by_Zero__int_listen_socket_divide_82_bad; baseObject->action(data); delete baseObject; }"	where is the vulnerable dataflow from data to action ?	"baseObject->action <start> data <end> );
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
baseObject->action <start> data <end> );"	"baseObject->action <start> data <end> );
<start> recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"data = <start> atoi(inputBuffer) <end> ;
baseObject->action <start> data <end> );"	1
69161b2a-6c15-11ed-81d4-94e6f77dd552	static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; void CWE190_Integer_Overflow__int_rand_preinc_04_bad() { int data; data = 0; if(STATIC_CONST_TRUE) { data = RAND32(); } if(STATIC_CONST_TRUE) { { ++data; int result = data; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
+ <start> data <end> ;"	"+ <start> data <end> ;
data = <start> RAND32() <end> ;"	"data = <start> RAND32() <end> ;
+ <start> data <end> ;"	"data = <start> RAND32() <end> ;
<start> printIntLine(result) <end> ;"	2
d1e9da3d-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_listen_socket_fopen_22 { int badGlobal = 0; char * badSource(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; badGlobal = 1; data = badSource(data); { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } ; }"	where is the vulnerable dataflow from data to FOPEN ?	"<start> data = dataBuffer <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"data = <start> badSource <end> (data);
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
data = <start> badSource <end> (data);"	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
data = <start> badSource <end> (data);"	1
630ae7fc-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__short_rand_square_01_bad() { short data; data = 0; data = (short)RAND32(); { short result = data * data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
data = (short <start> RAND32() <end> ;"	"short <start> result = data * data <end> ;
data = (short <start> RAND32() <end> ;"	"short result = <start> data <end>  * data;
data = (short <start> RAND32() <end> ;"	"data = (short <start> RAND32() <end> ;
short result = <start> data <end>  * data;"	3
b54bcf18-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE 20 void CWE369_Divide_by_Zero__float_fgets_66b_badSink(float dataArray[]) { float data = dataArray[2]; { int result = (int)(100.0 / data); printIntLine(result); } }	where is the vulnerable dataflow from result to printIntLine ?	"void CWE369_Divide_by_Zero__float_fgets_66b_badSink(float <start> dataArray <end> []);
int result = (int) <start> 100.0 / data <end> );"	"int result = <start> (int)(100.0 / data) <end> ;
printIntLine <start> result <end> );"	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	"void CWE369_Divide_by_Zero__float_fgets_66b_badSink(float <start> dataArray <end> []);
printIntLine <start> result <end> );"	3
893217c7-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_console_fopen_17 { void bad() { int i; char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; for(i = 0; i < 1; i++) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"if (dataLen > 0 && <start> data[dataLen-1] == '\n' <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
pFile = FOPEN <start> data <end> , ""wb+"");"	3
4ec5d075-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_postinc_13_bad() { int data; data = 0; if(GLOBAL_CONST_FIVE==5) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(GLOBAL_CONST_FIVE==5) { { data++; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
<start> data <end> ++;"	"<start> data = atoi(inputBuffer) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"<start> data <end> ++;
<start> data = atoi(inputBuffer) <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> data <end> ++;"	3
c39a65ae-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif namespace CWE23_Relative_Path_Traversal__char_environment_ofstream_11 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(globalReturnsTrue()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
outputFile.open((char * <start> data <end> );"	"strncat <start> data+dataLen <end> , environment, FILENAME_MAX-dataLen-1);
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"outputFile.open((char * <start> data <end> );
strncat(data+dataLen, environment, FILENAME_MAX <start> dataLen-1 <end> );"	"outputFile.open((char * <start> data <end> );
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	0
598370b0-6c15-11ed-81d4-94e6f77dd552	typedef struct _CWE191_Integer_Underflow__short_fscanf_multiply_67_structType { short structFirst; } CWE191_Integer_Underflow__short_fscanf_multiply_67_structType; void CWE191_Integer_Underflow__short_fscanf_multiply_67b_badSink(CWE191_Integer_Underflow__short_fscanf_multiply_67_structType myStruct) { short data = myStruct.structFirst; if(data < 0) { short result = data * 2; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"void CWE191_Integer_Underflow__short_fscanf_multiply_67b_badSink(CWE191_Integer_Underflow__short_fscanf_multiply_67_structType <start> myStruct <end> );
short data = <start> myStruct <end> .structFirst;
short result = <start> data <end>  * 2;"	"void CWE191_Integer_Underflow__short_fscanf_multiply_67b_badSink(CWE191_Integer_Underflow__short_fscanf_multiply_67_structType <start> myStruct <end> );
short data = <start> myStruct <end> .structFirst;"	"short data = <start> myStruct <end> .structFirst;
short <start> result = data * 2 <end> ;
void CWE191_Integer_Underflow__short_fscanf_multiply_67b_badSink(CWE191_Integer_Underflow__short_fscanf_multiply_67_structType <start> myStruct <end> );"	"<start> printIntLine(result) <end> ;
short data = <start> myStruct <end> .structFirst;
void CWE191_Integer_Underflow__short_fscanf_multiply_67b_badSink(CWE191_Integer_Underflow__short_fscanf_multiply_67_structType <start> myStruct <end> );"	0
7fa68e27-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif static const int STATIC_CONST_FIVE = 5; namespace CWE23_Relative_Path_Traversal__char_connect_socket_fopen_06 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(STATIC_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"size_t dataLen = <start> strlen(data) <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"<start> data = dataBuffer <end> ;
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	2
a49c4f4f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_multiply_52c_badSink(int data) { if(data > 0) { int result = data * 2; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
void CWE190_Integer_Overflow__int_listen_socket_multiply_52c_badSink(int <start> data <end> );"	"void CWE190_Integer_Overflow__int_listen_socket_multiply_52c_badSink(int <start> data <end> );
int <start> result = data * 2 <end> ;"	"void CWE190_Integer_Overflow__int_listen_socket_multiply_52c_badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"void CWE190_Integer_Overflow__int_listen_socket_multiply_52c_badSink(int <start> data <end> );
<start> printIntLine(result) <end> ;"	2
c01af8c0-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" namespace CWE23_Relative_Path_Traversal__char_connect_socket_ofstream_65 { void badSink(char * data); void bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } funcPtr(data); }"	where is the vulnerable dataflow from data to funcPtr ?	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
funcPtr <start> data <end> );"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"funcPtr <start> data <end> );
recvResult = recv(connectSocket, (char *)(data + dataLen), <start> sizeof(char) * (FILENAME_MAX - dataLen - 1) <end> , 0);"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) *  <start> FILENAME_MAX - dataLen - 1 <end> ), 0);"	0
525b6490-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__short_fscanf_preinc_52c_badSink(short data) { { ++data; short result = data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"void CWE190_Integer_Overflow__short_fscanf_preinc_52c_badSink(short <start> data <end> );
+ <start> data <end> ;"	"<start> printIntLine(result) <end> ;
void CWE190_Integer_Overflow__short_fscanf_preinc_52c_badSink(short <start> data <end> );"	"+ <start> data <end> ;
void CWE190_Integer_Overflow__short_fscanf_preinc_52c_badSink(short <start> data <end> );"	"<start> printIntLine(result) <end> ;
+ <start> data <end> ;"	0
73bc8160-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" extern short CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_68_badData; extern short CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_68_goodG2BData; void CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_68b_badSink() { short data = CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_68_badData; { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	"short data = <start> CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_68_badData <end> ;
printLine <start> dest <end> );"	"printLine <start> dest <end> );
<start> memcpy(dest, source, data) <end> ;"	"<start> memcpy(dest, source, data) <end> ;
short data = <start> CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_68_badData <end> ;"	1
cac216ae-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" namespace CWE36_Absolute_Path_Traversal__char_connect_socket_ofstream_03 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(5==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
outputFile.open((char * <start> data <end> );"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
<start> data = dataBuffer <end> ;"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
size_t dataLen = <start> strlen(data) <end> ;"	"outputFile.open((char * <start> data <end> );
replace = <start> strchr(data, '\r') <end> ;"	0
c01af8ec-6c15-11ed-81d4-94e6f77dd552	#ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_connect_socket_open_82 { void CWE23_Relative_Path_Traversal__char_connect_socket_open_82_bad::action(char * data) { { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } } }	where is the vulnerable dataflow from data to OPEN ?	"void CWE23_Relative_Path_Traversal__char_connect_socket_open_82_bad::action(char * <start> data <end> );
fileDesc = OPEN(data, O_RDWR|O_CREAT, <start> S_IREAD|S_IWRITE <end> );"	"void CWE23_Relative_Path_Traversal__char_connect_socket_open_82_bad::action(char * <start> data <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
void CWE23_Relative_Path_Traversal__char_connect_socket_open_82_bad::action(char * <start> data <end> );"	1
7d44fcab-6c15-11ed-81d4-94e6f77dd552	"namespace CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_82 { void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_82_bad::action(int data) { { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> strncpy(dest, source, data) <end> ;
printLine <start> dest <end> );"	"void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_82_bad::action(int <start> data <end> );
printLine <start> dest <end> );"	"void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_82_bad::action(int <start> data <end> );
<start> strncpy(dest, source, data) <end> ;"	"printLine <start> dest <end> );
void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_82_bad::action(int <start> data <end> );"	1
af58094a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } void CWE197_Numeric_Truncation_Error__int_connect_socket_to_short_08_bad() { int data; data = -1; if(staticReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { short shortData = (short)data; printShortLine(shortData); } }"	where is the vulnerable dataflow from shortData to printShortLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printShortLine <start> shortData <end> );"	"printShortLine <start> shortData <end> );
short <start> shortData = (short)data <end> ;"	"<start> printShortLine(shortData) <end> ;
printShortLine <start> shortData <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
short <start> shortData = (short)data <end> ;"	0
728a4ffc-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif namespace CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_62 { void badSource(char * &data); static void badVaSink(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); va_end(args); } } void bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; badSource(data); badVaSink(data, data); }"	where is the vulnerable dataflow from data to vfprintf ?	"badSource <start> data <end> );
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);"	"badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
badSource <start> data <end> );"	"badSource <start> data <end> );
<start> vfprintf(stdout, data, args) <end> ;
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);"	"badSource <start> data <end> );
static void badVaSink(char * <start> data <end> , ...);
badVaSink <start> data <end> , data);
vfprintf(stdout, <start> data <end> , args);"	0
7d44fc94-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_31_bad() { int data; data = -1; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } { int dataCopy = data; int data = dataCopy; { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> printLine(dest) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"int <start> dataCopy = data <end> ;
printLine <start> dest <end> );"	"printLine <start> dest <end> );
<start> data = -1 <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printLine <start> dest <end> );"	3
70279bfe-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif void CWE134_Uncontrolled_Format_String__char_file_snprintf_14_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; if(globalFive==5) { { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } if(globalFive==5) { { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } } }"	where is the vulnerable dataflow from dest to printLine ?	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	"char <start> dataBuffer[100] = """" <end> ;
printLine <start> dest <end> );"	"printLine <start> dest <end> );
size_t dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
printLine <start> dest <end> );"	3
5af03e0f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) extern int CWE191_Integer_Underflow__int_connect_socket_postdec_68_badData; extern int CWE191_Integer_Underflow__int_connect_socket_postdec_68_goodG2BData; extern int CWE191_Integer_Underflow__int_connect_socket_postdec_68_goodB2GData; void CWE191_Integer_Underflow__int_connect_socket_postdec_68b_badSink() { int data = CWE191_Integer_Underflow__int_connect_socket_postdec_68_badData; { data--; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"<start> data-- <end> ;
int data = <start> CWE191_Integer_Underflow__int_connect_socket_postdec_68_badData <end> ;"	"<start> data <end> --;
int data = <start> CWE191_Integer_Underflow__int_connect_socket_postdec_68_badData <end> ;"	"<start> printIntLine(result) <end> ;
<start> data <end> --;"	"int data = <start> CWE191_Integer_Underflow__int_connect_socket_postdec_68_badData <end> ;
<start> data <end> --;"	3
bda4e433-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define EXECLP _execlp #else #define EXECLP execlp #endif void CWE78_OS_Command_Injection__char_listen_socket_execlp_09_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(GLOBAL_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECLP ?	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
replace = <start> strchr(data, '\r') <end> ;"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
<start> EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL) <end> ;"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
size_t dataLen = <start> strlen(data) <end> ;"	0
964cdc32-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_13_bad() { int data; data = -1; if(GLOBAL_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(GLOBAL_CONST_FIVE==5) { { int i; int buffer[10] = { 0 }; if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } } } }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int <start> buffer[10] = { 0 } <end> ;"	"printIntLine <start> buffer[i] <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[i] <end> );"	"printIntLine <start> buffer[i] <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	2
a95fd81a-6c15-11ed-81d4-94e6f77dd552	namespace CWE191_Integer_Underflow__int_connect_socket_sub_81 { void CWE191_Integer_Underflow__int_connect_socket_sub_81_bad::action(int data) const { { int result = data - 1; printIntLine(result); } } }	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
void CWE191_Integer_Underflow__int_connect_socket_sub_81_bad::action(int <start> data <end> ) const;"	"<start> printIntLine(result) <end> ;
void CWE191_Integer_Underflow__int_connect_socket_sub_81_bad::action(int <start> data <end> ) const;"	"int <start> result = data - 1 <end> ;
printIntLine <start> result <end> );"	"void CWE191_Integer_Underflow__int_connect_socket_sub_81_bad::action(int <start> data <end> ) const;
printIntLine <start> result <end> );"	3
69161b45-6c15-11ed-81d4-94e6f77dd552	int CWE190_Integer_Overflow__int_rand_preinc_61b_badSource(int data); void CWE190_Integer_Overflow__int_rand_preinc_61_bad() { int data; data = 0; data = CWE190_Integer_Overflow__int_rand_preinc_61b_badSource(data); { ++data; int result = data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"data = <start> CWE190_Integer_Overflow__int_rand_preinc_61b_badSource <end> (data);
+ <start> data <end> ;"	"+ <start> data <end> ;
data = <start> CWE190_Integer_Overflow__int_rand_preinc_61b_badSource <end> (data);"	"<start> printIntLine(result) <end> ;
data = <start> CWE190_Integer_Overflow__int_rand_preinc_61b_badSource <end> (data);"	"<start> printIntLine(result) <end> ;
+ <start> data <end> ;"	0
9c455194-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int CWE124_Buffer_Underwrite__CWE839_listen_socket_45_badData; static int CWE124_Buffer_Underwrite__CWE839_listen_socket_45_goodG2BData; static int CWE124_Buffer_Underwrite__CWE839_listen_socket_45_goodB2GData; static void badSink() { int data = CWE124_Buffer_Underwrite__CWE839_listen_socket_45_badData; { int i; int buffer[10] = { 0 }; if (data < 10) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } } } void CWE124_Buffer_Underwrite__CWE839_listen_socket_45_bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE124_Buffer_Underwrite__CWE839_listen_socket_45_badData = data; badSink(); }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> CWE124_Buffer_Underwrite__CWE839_listen_socket_45_badData = data <end> ;
static int <start> CWE124_Buffer_Underwrite__CWE839_listen_socket_45_badData <end> ;
int data = <start> CWE124_Buffer_Underwrite__CWE839_listen_socket_45_badData <end> ;
printIntLine <start> buffer[i] <end> );"	"printIntLine <start> buffer[i] <end> );
int <start> buffer[10] = { 0 } <end> ;
<start> CWE124_Buffer_Underwrite__CWE839_listen_socket_45_badData = data <end> ;
static int <start> CWE124_Buffer_Underwrite__CWE839_listen_socket_45_badData <end> ;
int data = <start> CWE124_Buffer_Underwrite__CWE839_listen_socket_45_badData <end> ;"	"<start> CWE124_Buffer_Underwrite__CWE839_listen_socket_45_badData = data <end> ;
printIntLine <start> buffer[i] <end> );
static int <start> CWE124_Buffer_Underwrite__CWE839_listen_socket_45_badData <end> ;
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
int data = <start> CWE124_Buffer_Underwrite__CWE839_listen_socket_45_badData <end> ;"	"static int <start> CWE124_Buffer_Underwrite__CWE839_listen_socket_45_badData <end> ;
<start> CWE124_Buffer_Underwrite__CWE839_listen_socket_45_badData = data <end> ;
int data = <start> CWE124_Buffer_Underwrite__CWE839_listen_socket_45_badData <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[i] <end> );"	0
a830bf7c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE191_Integer_Underflow__int_connect_socket_multiply_43 { static void badSource(int &data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } void bad() { int data; data = 0; badSource(data); if(data < 0) { int result = data * 2; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;
badSource <start> data <end> );"	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSource <start> data <end> );
printIntLine <start> result <end> );"	"badSource <start> data <end> );
printIntLine <start> result <end> );"	2
b54bcf4a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 20 namespace CWE369_Divide_by_Zero__float_listenSocket_81 { void bad() { float data; data = 0.0F; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = (float)atof(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } const CWE369_Divide_by_Zero__float_listenSocket_81_base& baseObject = CWE369_Divide_by_Zero__float_listenSocket_81_bad(); baseObject.action(data); }"	where is the vulnerable dataflow from data to action ?	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
baseObject.action <start> data <end> );"	"baseObject.action <start> data <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
data = (float <start> atof(inputBuffer) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
baseObject.action <start> data <end> );"	3
87ff983a-6c15-11ed-81d4-94e6f77dd552	namespace CWE369_Divide_by_Zero__int_listen_socket_modulo_62 { void badSource(int &data); void bad() { int data; data = -1; badSource(data); printIntLine(100 % data); }	where is the vulnerable dataflow from data to printIntLine ?	"printIntLine <start> 100 % data <end> );
<start> data = -1 <end> ;"	"printIntLine <start> 100 % data <end> );
badSource <start> data <end> );"	"<start> badSource(data) <end> ;
printIntLine <start> 100 % data <end> );"	"badSource <start> data <end> );
printIntLine <start> 100 % data <end> );"	3
977ea78e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int badSource(int data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } return data; } void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_42_bad() { int data; data = -1; data = badSource(data); { int i; int buffer[10] = { 0 }; if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } } }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static int <start> badSource <end> (int data);
data = <start> badSource <end> (data);
printIntLine <start> buffer[i] <end> );"	"data = <start> badSource <end> (data);
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> buffer[i] <end> );
static int <start> badSource <end> (int data);"	"printIntLine <start> buffer[i] <end> );
data = <start> badSource <end> (data);
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static int <start> badSource <end> (int data);"	"data = <start> badSource <end> (data);
printIntLine <start> buffer[i] <end> );"	0
9fe7ad56-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink(int data) { { int result = data + 1; printIntLine(result); } } void CWE190_Integer_Overflow__int_connect_socket_add_44_bad() { int data; void (*funcPtr) (int) = badSink; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } funcPtr(data); }"	where is the vulnerable dataflow from result to printIntLine ?	"data = <start> atoi(inputBuffer) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static void badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"<start> printIntLine(result) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );
static void badSink(int <start> data <end> );"	"funcPtr <start> data <end> );
printIntLine <start> result <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
funcPtr <start> data <end> );
static void badSink(int <start> data <end> );
printIntLine <start> result <end> );"	3
78800fd7-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 8 static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } void CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_08_bad() { short data; data = 0; if(staticReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> strncpy(dest, source, data) <end> ;
printLine <start> dest <end> );"	"if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"recvResult = recv(acceptSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);
printLine <start> dest <end> );"	2
67d010d3-6c15-11ed-81d4-94e6f77dd552	"void CWE190_Integer_Overflow__char_rand_preinc_12_bad() { char data; data = ' '; if(globalReturnsTrueOrFalse()) { data = (char)RAND32(); } else { data = 2; } if(globalReturnsTrueOrFalse()) { { ++data; char result = data; printHexCharLine(result); } } else { if (data < CHAR_MAX) { ++data; char result = data; printHexCharLine(result); } else { printLine(""data value is too large to perform arithmetic safely.""); } } }"	where is the vulnerable dataflow from data ?	"data = (char <start> RAND32() <end> ;
char <start> result = data <end> ;"	"data = (char <start> RAND32() <end> ;
<start> data = (char)RAND32() <end> ;"	"data = (char <start> RAND32() <end> ;
+ <start> data <end> ;"	"if  <start> data < CHAR_MAX <end> );
+ <start> data <end> ;"	2
5f76fc89-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int badStatic = 0; static void badSink(int data) { if(badStatic) { { --data; int result = data; printIntLine(result); } } } void CWE191_Integer_Underflow__int_listen_socket_predec_21_bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badStatic = 1; badSink(data); }"	where is the vulnerable dataflow from data ?	"- <start> data <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static void badSink(int <start> data <end> );
badSink <start> data <end> );"	"int <start> result = data <end> ;
- <start> data <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSink <start> data <end> );"	"<start> data = 0 <end> ;
static void badSink(int <start> data <end> );
badSink <start> data <end> );
- <start> data <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSink <start> data <end> );
static void badSink(int <start> data <end> );
- <start> data <end> ;"	3
bb49c584-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #define EXECL _execl #else #define EXECL execl #endif void CWE78_OS_Command_Injection__char_console_execl_10_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(globalTrue) { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECL ?	"EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
size_t dataLen = <start> strlen(data) <end> ;"	"dataLen = <start> strlen(data) <end> ;
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"if  <start> fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL <end> );
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	2
9b124d9a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticTrue = 1; static int staticFalse = 0; void CWE124_Buffer_Underwrite__CWE839_listen_socket_05_bad() { int data; data = -1; if(staticTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticTrue) { { int i; int buffer[10] = { 0 }; if (data < 10) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } } } }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[i] <end> );"	"<start> recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> buffer[i] <end> );"	"int <start> buffer[10] = { 0 } <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> buffer[i] <end> );"	0
b086410c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE197_Numeric_Truncation_Error__int_listen_socket_to_char_16_bad() { int data; data = -1; while(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; } { char charData = (char)data; printHexCharLine(charData); } }"	where is the vulnerable dataflow from charData to printHexCharLine ?	"<start> data = atoi(inputBuffer) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"data = <start> atoi(inputBuffer) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printHexCharLine <start> charData <end> );"	"data = <start> atoi(inputBuffer) <end> ;
printHexCharLine <start> charData <end> );"	2
445c11f3-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_add_14_bad() { int data; data = 0; if(globalFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalFive==5) { { int result = data + 1; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  + 1;"	"<start> data = atoi(inputBuffer) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"int result = <start> data <end>  + 1;
recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);"	"int result = <start> data <end>  + 1;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	0
5f76fca0-6c15-11ed-81d4-94e6f77dd552	"static int staticTrue = 1; static int staticFalse = 0; void CWE191_Integer_Underflow__short_fscanf_predec_05_bad() { short data; data = 0; if(staticTrue) { fscanf (stdin, ""%hd"", &data); } if(staticTrue) { { --data; short result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
- <start> data <end> ;"	"<start> data = 0 <end> ;
- <start> data <end> ;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
- <start> data <end> ;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
<start> printIntLine(result) <end> ;"	2
4a021116-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) typedef struct _CWE190_Integer_Overflow__int_listen_socket_multiply_67_structType { int structFirst; } CWE190_Integer_Overflow__int_listen_socket_multiply_67_structType; void CWE190_Integer_Overflow__int_listen_socket_multiply_67b_badSink(CWE190_Integer_Overflow__int_listen_socket_multiply_67_structType myStruct) { int data = myStruct.structFirst; if(data > 0) { int result = data * 2; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"void CWE190_Integer_Overflow__int_listen_socket_multiply_67b_badSink(CWE190_Integer_Overflow__int_listen_socket_multiply_67_structType <start> myStruct <end> );
int result = <start> data <end>  * 2;
<start> printIntLine(result) <end> ;"	"int result = <start> data <end>  * 2;
int <start> data = myStruct.structFirst <end> ;
void CWE190_Integer_Overflow__int_listen_socket_multiply_67b_badSink(CWE190_Integer_Overflow__int_listen_socket_multiply_67_structType <start> myStruct <end> );"	"void CWE190_Integer_Overflow__int_listen_socket_multiply_67b_badSink(CWE190_Integer_Overflow__int_listen_socket_multiply_67_structType <start> myStruct <end> );
int data = <start> myStruct <end> .structFirst;
int result = <start> data <end>  * 2;"	"int result = <start> data <end>  * 2;
int data = <start> myStruct <end> .structFirst;
void CWE190_Integer_Overflow__int_listen_socket_multiply_67b_badSink(CWE190_Integer_Overflow__int_listen_socket_multiply_67_structType <start> myStruct <end> );"	2
bed4a8da-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" namespace CWE23_Relative_Path_Traversal__char_connect_socket_ifstream_01 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
inputFile.open((char * <start> data <end> );"	"inputFile.open((char * <start> data <end> );
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
<start> data = dataBuffer <end> ;"	"size_t dataLen = <start> strlen(data) <end> ;
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	0
9187cc01-6c15-11ed-81d4-94e6f77dd552	"#define SEARCH_CHAR 'S' void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_console_18_bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\0'; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } goto sink; sink: for (; *data != '\0'; data++) { if (*data == SEARCH_CHAR) { printLine(""We have a match!""); break; } } free(data); }"	where is the vulnerable dataflow from data to free ?	"<start> free(data) <end> ;
free <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
free <start> data <end> );"	"dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	"free <start> data <end> );
dataLen = <start> strlen(data) <end> ;"	1
669edabf-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__char_rand_postinc_16_bad() { char data; data = ' '; while(1) { data = (char)RAND32(); break; } while(1) { { data++; char result = data; printHexCharLine(result); } break; } }	where is the vulnerable dataflow from data ?	"data = (char <start> RAND32() <end> ;
<start> data <end> ++;"	"<start> data <end> ++;
data = (char <start> RAND32() <end> ;"	"<start> data <end> ++;
<start> printHexCharLine(result) <end> ;"	"<start> data <end> ++;
<start> data = (char)RAND32() <end> ;"	0
ba102b6f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define SEARCH_CHAR 'S' namespace CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_82 { void bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\0'; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_82_base* baseObject = new CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_82_bad; baseObject->action(data); delete baseObject; }"	where is the vulnerable dataflow from data to action ?	"size_t <start> dataLen = strlen(data) <end> ;
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
baseObject->action <start> data <end> );"	"baseObject->action <start> data <end> );
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"size_t dataLen = <start> strlen(data) <end> ;
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	1
656cd3bf-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__int_rand_add_13_bad() { int data; data = 0; if(GLOBAL_CONST_FIVE==5) { data = RAND32(); } if(GLOBAL_CONST_FIVE==5) { { int result = data + 1; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"data = <start> RAND32() <end> ;
<start> printIntLine(result) <end> ;"	"data = <start> RAND32() <end> ;
int result = <start> data <end>  + 1;"	"int result = <start> data <end>  + 1;
<start> printIntLine(result) <end> ;"	"int <start> result = data + 1 <end> ;
data = <start> RAND32() <end> ;"	1
c8600ada-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; namespace CWE23_Relative_Path_Traversal__char_listen_socket_ofstream_04 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(STATIC_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
outputFile.open((char * <start> data <end> );"	"size_t dataLen = <start> strlen(data) <end> ;
outputFile.open((char * <start> data <end> );"	"if  <start> recvResult == SOCKET_ERROR <end>  || recvResult == 0);
outputFile.open((char * <start> data <end> );"	"outputFile.open((char * <start> data <end> );
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	0
86cea153-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE369_Divide_by_Zero__int_listen_socket_divide_18_bad() { int data; data = -1; goto source; source: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } goto sink; sink: printIntLine(100 / data); }"	where is the vulnerable dataflow from data to printIntLine ?	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> 100 / data <end> );"	"<start> recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> 100 / data <end> );"	"printIntLine <start> 100 / data <end> );
recvResult = recv(acceptSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> 100 / data <end> );"	3
453db015-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_multiply_16_bad() { int data; data = 0; while(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; } while(1) { if(data > 0) { int result = data * 2; printIntLine(result); } break; } }"	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  * 2;
recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);"	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
int result = <start> data <end>  * 2;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  * 2;"	"int result = <start> data <end>  * 2;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	2
ba102ba6-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define EXECLP _execlp #else #define EXECLP execlp #endif typedef union { char * unionFirst; char * unionSecond; } CWE78_OS_Command_Injection__char_connect_socket_execlp_34_unionType; void CWE78_OS_Command_Injection__char_connect_socket_execlp_34_bad() { char * data; CWE78_OS_Command_Injection__char_connect_socket_execlp_34_unionType myUnion; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } myUnion.unionFirst = data; { char * data = myUnion.unionSecond; EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL); } }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECLP ?	"<start> EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL) <end> ;
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"replace = <start> strchr(data, '\n') <end> ;
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"size_t dataLen = <start> strlen(data) <end> ;
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	1
54c581ff-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_connect_socket_multiply_64b_badSink(void * dataVoidPtr) { int * dataPtr = (int *)dataVoidPtr; int data = (*dataPtr); if(data < 0) { int result = data * 2; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"void CWE191_Integer_Underflow__int_connect_socket_multiply_64b_badSink(void * <start> dataVoidPtr <end> );
int result = <start> data <end>  * 2;"	"int result = <start> data <end>  * 2;
<start> printIntLine(result) <end> ;"	"<start> printIntLine(result) <end> ;
void CWE191_Integer_Underflow__int_connect_socket_multiply_64b_badSink(void * <start> dataVoidPtr <end> );"	"int <start> result = data * 2 <end> ;
void CWE191_Integer_Underflow__int_connect_socket_multiply_64b_badSink(void * <start> dataVoidPtr <end> );"	0
48d25dca-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticTrue = 1; static int staticFalse = 0; void CWE190_Integer_Overflow__int_listen_socket_multiply_05_bad() { int data; data = 0; if(staticTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticTrue) { if(data > 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int <start> result = data * 2 <end> ;"	"if  <start> acceptSocket == SOCKET_ERROR <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"<start> printIntLine(result) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  * 2;"	3
669edaa5-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__int_rand_square_54e_badSink(int data) { { int result = data * data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  * data;
void CWE190_Integer_Overflow__int_rand_square_54e_badSink(int <start> data <end> );"	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  * data;"	"void CWE190_Integer_Overflow__int_rand_square_54e_badSink(int <start> data <end> );
int result = <start> data * data <end> ;"	"void CWE190_Integer_Overflow__int_rand_square_54e_badSink(int <start> data <end> );
int result = <start> data <end>  * data;"	3
c01af8af-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" namespace CWE23_Relative_Path_Traversal__char_connect_socket_ofstream_14 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(globalFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"replace = <start> strchr(data, '\n') <end> ;
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"outputFile.open((char * <start> data <end> );
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
outputFile.open((char * <start> data <end> );"	"replace = <start> strchr(data, '\r') <end> ;
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	2
c1366262-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } namespace CWE23_Relative_Path_Traversal__char_console_ifstream_08 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(staticReturnsTrue()) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"dataLen = <start> strlen(data) <end> ;
inputFile.open((char * <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
<start> data = dataBuffer <end> ;"	"inputFile.open((char * <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
inputFile.open((char * <start> data <end> );"	3
b2ea8dc6-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 8 void CWE197_Numeric_Truncation_Error__short_fgets_18_bad() { short data; data = -1; goto source; source: { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = (short)atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } { char charData = (char)data; printHexCharLine(charData); } }"	where is the vulnerable dataflow from charData to printHexCharLine ?	"<start> data = (short)atoi(inputBuffer) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
char <start> charData = (char)data <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printHexCharLine <start> charData <end> );"	"printHexCharLine <start> charData <end> );
<start> data = (short)atoi(inputBuffer) <end> ;"	2
af580980-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE197_Numeric_Truncation_Error__int_fgets_to_char_16_bad() { int data; data = -1; while(1) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } break; } { char charData = (char)data; printHexCharLine(charData); } }"	where is the vulnerable dataflow from charData to printHexCharLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
char charData = <start> (char)data <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printHexCharLine <start> charData <end> );"	"data = <start> atoi(inputBuffer) <end> ;
printHexCharLine <start> charData <end> );"	"printHexCharLine <start> charData <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	1
9d74537e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) typedef union { int unionFirst; int unionSecond; } CWE126_Buffer_Overread__CWE129_listen_socket_34_unionType; void CWE126_Buffer_Overread__CWE129_listen_socket_34_bad() { int data; CWE126_Buffer_Overread__CWE129_listen_socket_34_unionType myUnion; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } myUnion.unionFirst = data; { int data = myUnion.unionSecond; { int buffer[10] = { 0 }; if (data >= 0) { printIntLine(buffer[data]); } else { printLine(""ERROR: Array index is negative""); } } } }"	where is the vulnerable dataflow from buffer[data] to printIntLine ?	"if  <start> listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"<start> printIntLine(buffer[data]) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[data] <end> );"	"if  <start> listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR <end> );
printIntLine <start> buffer[data] <end> );"	2
7e74f327-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_43 { static void badSource(int &data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } void bad() { int data; data = -1; badSource(data); { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"data = <start> atoi(inputBuffer) <end> ;
printLine <start> dest <end> );
badSource <start> data <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );
<start> memcpy(dest, source, data) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSource <start> data <end> );
printLine <start> dest <end> );"	"badSource <start> data <end> );
printLine <start> dest <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	2
820a46e4-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_file_open_21 { static int badStatic = 0; static char * badSource(char * data) { if(badStatic) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } return data; } void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; badStatic = 1; data = badSource(data); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } ; }"	where is the vulnerable dataflow from data to OPEN ?	"data = <start> badSource <end> (data);
static char * <start> badSource <end> (char * data);
size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"data = <start> badSource <end> (data);
fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);
static char * <start> badSource <end> (char * data);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN(data, O_RDWR|O_CREAT, <start> S_IREAD|S_IWRITE <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
data = <start> badSource <end> (data);
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	2
b8e2bd9f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define NEW_PATH ""%SystemRoot%\\system32"" #define PUTENV _putenv #else #define NEW_PATH ""/bin"" #define PUTENV putenv #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 void CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_14_bad() { char * data; char dataBuffer[250] = ""PATH=""; data = dataBuffer; if(globalFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (250 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } PUTENV(data); }"	where is the vulnerable dataflow from data to PUTENV ?	"replace = <start> strchr(data, '\r') <end> ;
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (250 - dataLen - 1), 0);"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (250 - dataLen - 1), 0);
if  <start> recvResult == SOCKET_ERROR <end>  || recvResult == 0);"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (250 - dataLen - 1), 0);
<start> data = dataBuffer <end> ;"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (250 - dataLen - 1), 0);
PUTENV <start> data <end> );"	3
8a6310d6-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif extern char * CWE36_Absolute_Path_Traversal__char_file_open_68_badData; extern char * CWE36_Absolute_Path_Traversal__char_file_open_68_goodG2BData; namespace CWE36_Absolute_Path_Traversal__char_file_open_68 { void badSink() { char * data = CWE36_Absolute_Path_Traversal__char_file_open_68_badData; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"char * data = <start> CWE36_Absolute_Path_Traversal__char_file_open_68_badData <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"char * data = <start> CWE36_Absolute_Path_Traversal__char_file_open_68_badData <end> ;
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"char * data = <start> CWE36_Absolute_Path_Traversal__char_file_open_68_badData <end> ;
fileDesc = OPEN(data, O_RDWR|O_CREAT, <start> S_IREAD|S_IWRITE <end> );"	0
99e16a87-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_listen_socket_17 { void bad() { int i,j; int data; data = -1; for(i = 0; i < 1; i++) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } for(j = 0; j < 1; j++) { { int i; int * buffer = new int[10]; for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } delete[] buffer; } } }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"printIntLine <start> buffer[i] <end> );
if  <start> recvResult == SOCKET_ERROR <end>  || recvResult == 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
if  <start> recvResult == SOCKET_ERROR <end>  || recvResult == 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[i] <end> );"	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> buffer[i] <end> );"	2
d1e9da26-6c15-11ed-81d4-94e6f77dd552	#ifndef _WIN32 #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_file_open_73 { void badSink(list<char *> dataList) { char * data = dataList.back(); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }	where is the vulnerable dataflow from data to OPEN ?	"void badSink(list<char *> <start> dataList <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);"	"void badSink(list<char *> <start> dataList <end> );
char <start> * data = dataList.back() <end> ;"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
void badSink(list<char *> <start> dataList <end> );"	0
54c5820e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_FIVE = 5; void CWE191_Integer_Underflow__int_connect_socket_sub_06_bad() { int data; data = 0; if(STATIC_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(STATIC_CONST_FIVE==5) { { int result = data - 1; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
int result = <start> data <end>  - 1;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data = 0 <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  - 1;"	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  - 1;"	2
c01af8dd-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_connect_socket_open_52 { void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badSink_b(data); }"	where is the vulnerable dataflow from data to badSink_b ?	"badSink_b <start> data <end> );
<start> data = dataBuffer <end> ;"	"badSink_b <start> data <end> );
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
badSink_b <start> data <end> );"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	2
525b6442-6c15-11ed-81d4-94e6f77dd552	"void CWE190_Integer_Overflow__int_fscanf_preinc_15_bad() { int data; data = 0; switch(6) { case 6: fscanf(stdin, ""%d"", &data); break; default: printLine(""Benign, fixed string""); break; } switch(7) { case 7: { ++data; int result = data; printIntLine(result); } break; default: printLine(""Benign, fixed string""); break; } }"	where is the vulnerable dataflow from data ?	"fscanf(stdin, ""%d"", <start> &data <end> );
+ <start> data <end> ;"	"<start> printIntLine(result) <end> ;
+ <start> data <end> ;"	"fscanf(stdin, ""%d"", <start> &data <end> );
<start> printIntLine(result) <end> ;"	"+ <start> data <end> ;
fscanf(stdin, ""%d"", <start> &data <end> );"	0
b41b87bc-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 20 void CWE369_Divide_by_Zero__float_fgets_01_bad() { float data; data = 0.0F; { char inputBuffer[CHAR_ARRAY_SIZE]; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = (float)atof(inputBuffer); } else { printLine(""fgets() failed.""); } } { int result = (int)(100.0 / data); printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );"	"data = (float <start> atof(inputBuffer) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"printIntLine <start> result <end> );
int <start> result = (int)(100.0 / data) <end> ;"	1
d0b64eeb-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif namespace CWE36_Absolute_Path_Traversal__char_file_ofstream_16 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; while(1) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } break; } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"outputFile.open((char * <start> data <end> );
<start> data = dataBuffer <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
outputFile.open((char * <start> data <end> );"	"outputFile.open((char * <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"outputFile.open((char * <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	1
c01af8cf-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_connect_socket_open_15 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; switch(6) { case 6: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; default: printLine(""Benign, fixed string""); break; } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"size_t <start> dataLen = strlen(data) <end> ;
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"replace = <start> strchr(data, '\n') <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	1
8b91e48b-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif extern char * CWE36_Absolute_Path_Traversal__char_listen_socket_open_68_badData; extern char * CWE36_Absolute_Path_Traversal__char_listen_socket_open_68_goodG2BData; namespace CWE36_Absolute_Path_Traversal__char_listen_socket_open_68 { void badSink() { char * data = CWE36_Absolute_Path_Traversal__char_listen_socket_open_68_badData; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"char * data = <start> CWE36_Absolute_Path_Traversal__char_listen_socket_open_68_badData <end> ;
fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);"	"char * data = <start> CWE36_Absolute_Path_Traversal__char_listen_socket_open_68_badData <end> ;
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"char * data = <start> CWE36_Absolute_Path_Traversal__char_listen_socket_open_68_badData <end> ;
fileDesc = OPEN(data, O_RDWR|O_CREAT, <start> S_IREAD|S_IWRITE <end> );"	"char * data = <start> CWE36_Absolute_Path_Traversal__char_listen_socket_open_68_badData <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	3
584fa895-6c15-11ed-81d4-94e6f77dd552	"static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; void CWE191_Integer_Underflow__short_fscanf_multiply_04_bad() { short data; data = 0; if(STATIC_CONST_TRUE) { fscanf (stdin, ""%hd"", &data); } if(STATIC_CONST_TRUE) { if(data < 0) { short result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"fscanf (stdin, ""%hd"", <start> &data <end> );
<start> printIntLine(result) <end> ;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
short result = <start> data <end>  * 2;"	"<start> printIntLine(result) <end> ;
short result = <start> data <end>  * 2;"	"short result = <start> data <end>  * 2;
fscanf (stdin, ""%hd"", <start> &data <end> );"	1
7c127582-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_04_bad() { int data; data = -1; if(STATIC_CONST_TRUE) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printLine <start> dest <end> );"	"printLine <start> dest <end> );
if  <start> data < 100 <end> );"	"<start> memcpy(dest, source, data) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if  <start> data < 100 <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	0
b8e2bdda-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define SEARCH_CHAR 'S' namespace CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_82 { void bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\0'; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_82_base* baseObject = new CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_82_bad; baseObject->action(data); delete baseObject; }"	where is the vulnerable dataflow from data to action ?	"if  <start> data == NULL <end> ) {exit(-1);};
baseObject->action <start> data <end> );"	"baseObject->action <start> data <end> );
recvResult = <start> recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0) <end> ;"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
baseObject->action <start> data <end> );"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (100 - dataLen - 1), 0);
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	2
4ec5d07d-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_postinc_31_bad() { int data; data = 0; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } { int dataCopy = data; int data = dataCopy; { data++; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> data <end> ++;
int <start> dataCopy = data <end> ;"	"int <start> data = dataCopy <end> ;
<start> data <end> ++;"	"<start> data = 0 <end> ;
<start> data <end> ++;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> data <end> ++;"	3
55ef4cc5-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_FIVE = 5; void CWE191_Integer_Underflow__int_fgets_sub_06_bad() { int data; data = 0; if(STATIC_CONST_FIVE==5) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(STATIC_CONST_FIVE==5) { { int result = data - 1; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
int result = <start> data - 1 <end> ;"	"int result = <start> data <end>  - 1;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"int result = <start> data <end>  - 1;
<start> data = atoi(inputBuffer) <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
int result = <start> data <end>  - 1;"	3
774f581e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 8 namespace CWE194_Unexpected_Sign_Extension__listen_socket_malloc_43 { static void badSource(short &data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } void bad() { short data; data = 0; badSource(data); if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }"	where is the vulnerable dataflow from data to malloc ?	"<start> memset(dataBuffer, 'A', data-1) <end> ;
char * dataBuffer = (char *)malloc <start> data <end> );
badSource <start> data <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSource <start> data <end> );
char * dataBuffer = (char *)malloc <start> data <end> );"	"badSource <start> data <end> );
if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"<start> data = 0 <end> ;
badSource <start> data <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	1
453db01c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink(int data) { if(data > 0) { int result = data * 2; printIntLine(result); } } void CWE190_Integer_Overflow__int_connect_socket_multiply_41_bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badSink(data); }"	where is the vulnerable dataflow from data ?	"badSink <start> data <end> );
<start> printIntLine(result) <end> ;
static void badSink(int <start> data <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSink <start> data <end> );
static void badSink(int <start> data <end> );
int result = <start> data <end>  * 2;"	"int result = <start> data <end>  * 2;
static void badSink(int <start> data <end> );
badSink <start> data <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"badSink <start> data <end> );
<start> printIntLine(result) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  * 2;"	1
cac216d7-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_connect_socket_open_13 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(GLOBAL_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = OPEN(data, O_RDWR|O_CREAT, <start> S_IREAD|S_IWRITE <end> );"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	3
c72d5d86-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 namespace CWE23_Relative_Path_Traversal__char_listen_socket_ifstream_42 { static char * badSource(char * data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } return data; } void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; data = badSource(data); { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"inputFile.open((char * <start> data <end> );
data = <start> badSource <end> (data);
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
static char * <start> badSource <end> (char * data);"	"static char * <start> badSource <end> (char * data);
inputFile.open((char * <start> data <end> );
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
inputFile.open((char * <start> data <end> );"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
data = <start> badSource <end> (data);
replace = <start> strchr(data, '\n') <end> ;
inputFile.open((char * <start> data <end> );"	2
9fe7ad54-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int badSource(int data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } return data; } void CWE190_Integer_Overflow__int_connect_socket_add_42_bad() { int data; data = 0; data = badSource(data); { int result = data + 1; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static int <start> badSource <end> (int data);
data = <start> badSource <end> (data);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static int <start> badSource <end> (int data);
data = <start> badSource <end> (data);
printIntLine <start> result <end> );"	"int <start> result = data + 1 <end> ;
printIntLine <start> result <end> );
static int <start> badSource <end> (int data);
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"data = <start> badSource <end> (data);
<start> printIntLine(result) <end> ;
static int <start> badSource <end> (int data);
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	1
78800fe2-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 8 static int badStatic = 0; static short badSource(short data) { if(badStatic) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } return data; } void CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_21_bad() { short data; data = 0; badStatic = 1; data = badSource(data); { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"printLine <start> dest <end> );
static short <start> badSource <end> (short data);
<start> printLine(dest) <end> ;
data = <start> badSource <end> (data);"	"printLine <start> dest <end> );
<start> data = badSource(data) <end> ;
static short <start> badSource <end> (short data);
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"data = <start> badSource <end> (data);
printLine <start> dest <end> );
<start> printLine(dest) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static short <start> badSource <end> (short data);
data = <start> badSource <end> (data);
printLine <start> dest <end> );"	3
55ef4ca8-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_fgets_multiply_31_bad() { int data; data = 0; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } { int dataCopy = data; int data = dataCopy; if(data < 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
int result = <start> data * 2 <end> ;"	"int result = <start> data <end>  * 2;
int <start> dataCopy = data <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
int result = <start> data <end>  * 2;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
if  <start> fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) <end>  != NULL);"	2
7d44fc6d-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink(int data) { { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } } void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_44_bad() { int data; void (*funcPtr) (int) = badSink; data = -1; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } funcPtr(data); }"	where is the vulnerable dataflow from dest to printLine ?	"static void badSink(int <start> data <end> );
funcPtr <start> data <end> );
<start> data = atoi(inputBuffer) <end> ;
printLine <start> dest <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
funcPtr <start> data <end> );
static void badSink(int <start> data <end> );
printLine <start> dest <end> );"	"static void badSink(int <start> data <end> );
funcPtr <start> data <end> );
<start> printLine(dest) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"<start> printLine(dest) <end> ;
static void badSink(int <start> data <end> );
printLine <start> dest <end> );
funcPtr <start> data <end> );"	1
774f5800-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 8 extern short CWE194_Unexpected_Sign_Extension__fgets_strncpy_68_badData; extern short CWE194_Unexpected_Sign_Extension__fgets_strncpy_68_goodG2BData; void CWE194_Unexpected_Sign_Extension__fgets_strncpy_68b_badSink() { short data = CWE194_Unexpected_Sign_Extension__fgets_strncpy_68_badData; { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"printLine <start> dest <end> );
short <start> data = CWE194_Unexpected_Sign_Extension__fgets_strncpy_68_badData <end> ;"	"if  <start> data < 100 <end> );
printLine <start> dest <end> );"	"short data = <start> CWE194_Unexpected_Sign_Extension__fgets_strncpy_68_badData <end> ;
printLine <start> dest <end> );"	"<start> strncpy(dest, source, data) <end> ;
short data = <start> CWE194_Unexpected_Sign_Extension__fgets_strncpy_68_badData <end> ;"	2
a23a3e0b-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_add_64b_badSink(void * dataVoidPtr) { int * dataPtr = (int *)dataVoidPtr; int data = (*dataPtr); { int result = data + 1; printIntLine(result); } }	where is the vulnerable dataflow from result to printIntLine ?	"int <start> result = data + 1 <end> ;
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
void CWE190_Integer_Overflow__int_fgets_add_64b_badSink(void * <start> dataVoidPtr <end> );"	"void CWE190_Integer_Overflow__int_fgets_add_64b_badSink(void * <start> dataVoidPtr <end> );
printIntLine <start> result <end> );"	"int <start> data = (*dataPtr) <end> ;
printIntLine <start> result <end> );"	2
c99197d3-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define STAT _stat #define OPEN _open #define WRITE _write #define O_RDWR _O_RDWR #define CLOSE _close #else #define STAT stat #define OPEN open #define WRITE write #define CLOSE close #endif #define BAD_SINK_STRING ""Bad Sink..."" #define GOOD_SINK_STRING ""Good Sink..."" void CWE367_TOC_TOU__stat_16_bad() { while(1) { { char filename[100] = """"; struct STAT statBuffer; int fileDesc = -1; if (fgets(filename, 100, stdin) == NULL) { printLine(""fgets() failed""); filename[0] = '\0'; } if (strlen(filename) > 0) { filename[strlen(filename)-1] = '\0'; } if (STAT(filename, &statBuffer) == -1) { exit(1); } fileDesc  = OPEN(filename, O_RDWR); if (fileDesc == -1) { exit(1); } if (WRITE(fileDesc, BAD_SINK_STRING, strlen(BAD_SINK_STRING)) == -1) { exit(1); } if (fileDesc != -1) { CLOSE(fileDesc); } } break; } }"	where is the vulnerable dataflow from filename to OPEN ?	"if (fgets <start> filename <end> , 100, stdin) == NULL);
fileDesc  = OPEN <start> filename <end> , O_RDWR);"	"fileDesc  = OPEN <start> filename <end> , O_RDWR);
if  <start> STAT(filename, &statBuffer) <end>  == -1);"	"if  <start> strlen(filename) <end>  > 0);
fileDesc  = OPEN <start> filename <end> , O_RDWR);"	"fileDesc  = OPEN <start> filename <end> , O_RDWR);
if (fgets <start> filename <end> , 100, stdin) == NULL);"	0
61da670b-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__short_rand_add_13_bad() { short data; data = 0; if(GLOBAL_CONST_FIVE==5) { data = (short)RAND32(); } if(GLOBAL_CONST_FIVE==5) { { short result = data + 1; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"data = (short <start> RAND32() <end> ;
short <start> result = data + 1 <end> ;"	"data = (short <start> RAND32() <end> ;
<start> data = (short)RAND32() <end> ;"	"<start> printIntLine(result) <end> ;
data = (short <start> RAND32() <end> ;"	"data = (short <start> RAND32() <end> ;
short result = <start> data <end>  + 1;"	3
47a2a82b-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__int_fscanf_add_82 { void CWE190_Integer_Overflow__int_fscanf_add_82_bad::action(int data) { { int result = data + 1; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"void CWE190_Integer_Overflow__int_fscanf_add_82_bad::action(int <start> data <end> );
int result = <start> data <end>  + 1;"	"int <start> result = data + 1 <end> ;
void CWE190_Integer_Overflow__int_fscanf_add_82_bad::action(int <start> data <end> );"	"int result = <start> data <end>  + 1;
void CWE190_Integer_Overflow__int_fscanf_add_82_bad::action(int <start> data <end> );"	"int result = <start> data <end>  + 1;
<start> printIntLine(result) <end> ;"	0
466e7ef8-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_square_01_bad() { int data; data = 0; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } { int result = data * data; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
int <start> result = data * data <end> ;"	"<start> printIntLine(result) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
int result = <start> data <end>  * data;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
int result = <start> data * data <end> ;"	2
571e9808-6c15-11ed-81d4-94e6f77dd552	"static int badStatic = 0; static void badSink(int data) { if(badStatic) { if(data < 0) { int result = data * 2; printIntLine(result); } } } void CWE191_Integer_Underflow__int_fscanf_multiply_21_bad() { int data; data = 0; fscanf(stdin, ""%d"", &data); badStatic = 1; badSink(data); }"	where is the vulnerable dataflow from data ?	"static void badSink(int <start> data <end> );
fscanf(stdin, ""%d"", <start> &data <end> );"	"fscanf(stdin, ""%d"", <start> &data <end> );
badSink <start> data <end> );
static void badSink(int <start> data <end> );
int result = <start> data <end>  * 2;"	"<start> badSink(data) <end> ;
static void badSink(int <start> data <end> );
badSink <start> data <end> );
int result = <start> data <end>  * 2;"	"fscanf(stdin, ""%d"", <start> &data <end> );
<start> printIntLine(result) <end> ;
static void badSink(int <start> data <end> );
int result = <start> data <end>  * 2;"	1
761e295c-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 8 static short badSource(short data) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = (short)atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } return data; } void CWE194_Unexpected_Sign_Extension__fgets_memcpy_42_bad() { short data; data = 0; data = badSource(data); { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> data = badSource(data) <end> ;
static short <start> badSource <end> (short data);
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printLine <start> dest <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printLine <start> dest <end> );
data = <start> badSource <end> (data);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
static short <start> badSource <end> (short data);
data = <start> badSource <end> (data);
printLine <start> dest <end> );"	"static short <start> badSource <end> (short data);
data = <start> badSource <end> (data);
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printLine <start> dest <end> );"	2
951c5e6b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FULL_COMMAND ""dir "" #else #define FULL_COMMAND ""ls "" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define POPEN _popen #define PCLOSE _pclose #else #define POPEN popen #define PCLOSE pclose #endif void CWE78_OS_Command_Injection__char_connect_socket_popen_11_bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; if(globalReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { FILE *pipe; pipe = POPEN(data, ""w""); if (pipe != NULL) { PCLOSE(pipe); } } }"	where is the vulnerable dataflow from data to POPEN ?	"recvResult = recv(connectSocket, (char *)(data + dataLen), <start> sizeof(char) * (100 - dataLen - 1) <end> , 0);
pipe = POPEN <start> data <end> , ""w"");"	"recvResult = <start> recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0) <end> ;
pipe = POPEN <start> data <end> , ""w"");"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
size_t <start> dataLen = strlen(data) <end> ;"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
pipe = POPEN <start> data <end> , ""w"");"	3
47a2a845-6c15-11ed-81d4-94e6f77dd552	"static int CWE190_Integer_Overflow__int_fscanf_multiply_45_badData; static int CWE190_Integer_Overflow__int_fscanf_multiply_45_goodG2BData; static int CWE190_Integer_Overflow__int_fscanf_multiply_45_goodB2GData; static void badSink() { int data = CWE190_Integer_Overflow__int_fscanf_multiply_45_badData; if(data > 0) { int result = data * 2; printIntLine(result); } } void CWE190_Integer_Overflow__int_fscanf_multiply_45_bad() { int data; data = 0; fscanf(stdin, ""%d"", &data); CWE190_Integer_Overflow__int_fscanf_multiply_45_badData = data; badSink(); }"	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  * 2;
static int <start> CWE190_Integer_Overflow__int_fscanf_multiply_45_badData <end> ;
int data = <start> CWE190_Integer_Overflow__int_fscanf_multiply_45_badData <end> ;
<start> CWE190_Integer_Overflow__int_fscanf_multiply_45_badData = data <end> ;
fscanf(stdin, ""%d"", <start> &data <end> );"	"int result = <start> data <end>  * 2;
fscanf(stdin, ""%d"", <start> &data <end> );
static int <start> CWE190_Integer_Overflow__int_fscanf_multiply_45_badData <end> ;"	"fscanf(stdin, ""%d"", <start> &data <end> );
<start> printIntLine(result) <end> ;
int result = <start> data <end>  * 2;
static int <start> CWE190_Integer_Overflow__int_fscanf_multiply_45_badData <end> ;
int data = <start> CWE190_Integer_Overflow__int_fscanf_multiply_45_badData <end> ;"	"fscanf(stdin, ""%d"", <start> &data <end> );
<start> CWE190_Integer_Overflow__int_fscanf_multiply_45_badData = data <end> ;
static int <start> CWE190_Integer_Overflow__int_fscanf_multiply_45_badData <end> ;
int data = <start> CWE190_Integer_Overflow__int_fscanf_multiply_45_badData <end> ;
int result = <start> data <end>  * 2;"	3
48d25da7-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_add_11_bad() { int data; data = 0; if(globalReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalReturnsTrue()) { { int result = data + 1; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  + 1;
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"<start> data = 0 <end> ;
int result = <start> data <end>  + 1;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  + 1;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printIntLine(result) <end> ;"	2
ae26ae59-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_81 { void bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } const CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_81_base& baseObject = CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_81_bad(); baseObject.action(data); }"	where is the vulnerable dataflow from data to action ?	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
baseObject.action <start> data <end> );"	"baseObject.action <start> data <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
baseObject.action <start> data <end> );"	"recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);
baseObject.action <start> data <end> );"	2
b41b87b6-6c15-11ed-81d4-94e6f77dd552	namespace CWE369_Divide_by_Zero__float_connect_socket_72 { void badSink(vector<float> dataVector) { float data = dataVector[2]; { int result = (int)(100.0 / data); printIntLine(result); } }	where is the vulnerable dataflow from result to printIntLine ?	"int result = (int) <start> 100.0 / data <end> );
void badSink(vector<float> <start> dataVector <end> );"	"void badSink(vector<float> <start> dataVector <end> );
<start> printIntLine(result) <end> ;"	"void badSink(vector<float> <start> dataVector <end> );
printIntLine <start> result <end> );"	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	2
656cd3e0-6c15-11ed-81d4-94e6f77dd552	static int staticFive = 5; void CWE190_Integer_Overflow__int_rand_multiply_07_bad() { int data; data = 0; if(staticFive==5) { data = RAND32(); } if(staticFive==5) { if(data > 0) { int result = data * 2; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"data = <start> RAND32() <end> ;
int result = <start> data <end>  * 2;"	"data = <start> RAND32() <end> ;
<start> printIntLine(result) <end> ;"	"int result = <start> data * 2 <end> ;
data = <start> RAND32() <end> ;"	"int result = <start> data <end>  * 2;
data = <start> RAND32() <end> ;"	0
820a46f4-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_file_open_65 { void badSink(char * data) { { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"void badSink(char * <start> data <end> );
fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
void badSink(char * <start> data <end> );"	"fileDesc = OPEN(data, O_RDWR|O_CREAT, <start> S_IREAD|S_IWRITE <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"void badSink(char * <start> data <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	3
728a5022-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 static void badVaSink(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_51b_badSink(char * data) { badVaSink(data, data); }"	where is the vulnerable dataflow from data to vprintf ?	"void CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_51b_badSink(char * <start> data <end> );
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
vprintf <start> data <end> , args);"	"vprintf <start> data <end> , args);
<start> vprintf(data, args) <end> ;
badVaSink <start> data <end> , data);
void CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_51b_badSink(char * <start> data <end> );"	"void CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_51b_badSink(char * <start> data <end> );
vprintf <start> data <end> , args);
static void badVaSink(char * <start> data <end> , ...);
badVaSink <start> data <end> , data);"	"vprintf <start> data <end> , args);
badVaSink <start> data <end> , data);"	0
5e44fc4e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_connect_socket_predec_09_bad() { int data; data = 0; if(GLOBAL_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(GLOBAL_CONST_TRUE) { { --data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"- <start> data <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
- <start> data <end> ;"	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
- <start> data <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int <start> result = data <end> ;"	1
b08640ff-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE197_Numeric_Truncation_Error__int_listen_socket_to_char_03_bad() { int data; data = -1; if(5==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { char charData = (char)data; printHexCharLine(charData); } }"	where is the vulnerable dataflow from charData to printHexCharLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printHexCharLine(charData) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printHexCharLine <start> charData <end> );"	"printHexCharLine <start> charData <end> );
<start> printHexCharLine(charData) <end> ;"	"printHexCharLine <start> charData <end> );
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	1
98b01556-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_connect_socket_42 { static int badSource(int data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } return data; } void bad() { int data; data = -1; data = badSource(data); { int i; int * buffer = new int[10]; for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } delete[] buffer; } }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"data = <start> badSource <end> (data);
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[i] <end> );
static int <start> badSource <end> (int data);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static int <start> badSource <end> (int data);
data = <start> badSource <end> (data);
printIntLine <start> buffer[i] <end> );"	"data = <start> badSource <end> (data);
printIntLine <start> buffer[i] <end> );
static int <start> badSource <end> (int data);
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"data = <start> badSource <end> (data);
printIntLine <start> buffer[i] <end> );
static int <start> badSource <end> (int data);"	1
9059f3ba-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 256 void CWE681_Incorrect_Conversion_Between_Numeric_Types__double2float_03_bad() { if(5==5) { { char inputBuffer[CHAR_ARRAY_SIZE]; double doubleNumber = 0; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { doubleNumber = atof(inputBuffer); } else { printLine(""fgets() failed.""); } printFloatLine((float)doubleNumber); } } }"	where is the vulnerable dataflow from (float)doubleNumber to printFloatLine ?	"printFloatLine <start> (float)doubleNumber <end> );
double <start> doubleNumber = 0 <end> ;"	"<start> doubleNumber = atof(inputBuffer) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"printFloatLine <start> (float)doubleNumber <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printFloatLine <start> (float)doubleNumber <end> );"	3
70279bf4-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; void CWE134_Uncontrolled_Format_String__char_file_snprintf_04_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; if(STATIC_CONST_TRUE) { { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } if(STATIC_CONST_TRUE) { { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> SNPRINTF(dest, 100-1, data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
char <start> dest[100] = """" <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
printLine <start> dest <end> );"	3
69161b48-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__int_rand_preinc_66b_badSink(int dataArray[]) { int data = dataArray[2]; { ++data; int result = data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
void CWE190_Integer_Overflow__int_rand_preinc_66b_badSink(int <start> dataArray <end> []);"	"+ <start> data <end> ;
void CWE190_Integer_Overflow__int_rand_preinc_66b_badSink(int <start> dataArray <end> []);"	"void CWE190_Integer_Overflow__int_rand_preinc_66b_badSink(int <start> dataArray <end> []);
+ <start> data <end> ;"	"+ <start> data <end> ;
<start> ++data <end> ;"	2
48d25d7f-6c15-11ed-81d4-94e6f77dd552	"void CWE190_Integer_Overflow__int_fscanf_square_13_bad() { int data; data = 0; if(GLOBAL_CONST_FIVE==5) { fscanf(stdin, ""%d"", &data); } if(GLOBAL_CONST_FIVE==5) { { int result = data * data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"fscanf(stdin, ""%d"", <start> &data <end> );
int <start> result = data * data <end> ;"	"int result = <start> data <end>  * data;
<start> printIntLine(result) <end> ;"	"<start> printIntLine(result) <end> ;
fscanf(stdin, ""%d"", <start> &data <end> );"	"fscanf(stdin, ""%d"", <start> &data <end> );
int result = <start> data <end>  * data;"	3
79b2754f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_11_bad() { int data; data = -1; if(globalReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"printLine <start> dest <end> );
<start> memcpy(dest, source, data) <end> ;"	"printLine <start> dest <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> memcpy(dest, source, data) <end> ;"	2
6ef7684d-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif static int staticTrue = 1; static int staticFalse = 0; static void badVaSinkB(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_console_vprintf_05_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; if(staticTrue) { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } if(staticTrue) { badVaSinkB(data, data); } }"	where is the vulnerable dataflow from data to vprintf ?	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);
vprintf <start> data <end> , args);"	"vprintf <start> data <end> , args);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	"dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
vprintf <start> data <end> , args);
static void badVaSinkB(char * <start> data <end> , ...);"	"static void badVaSinkB(char * <start> data <end> , ...);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
vprintf <start> data <end> , args);
badVaSinkB <start> data <end> , data);"	0
b1b8083b-6c15-11ed-81d4-94e6f77dd552	namespace CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_62 { void badSource(int &data); void bad() { int data; data = -1; badSource(data); { short shortData = (short)data; printShortLine(shortData); } }	where is the vulnerable dataflow from shortData to printShortLine ?	"short <start> shortData = (short)data <end> ;
badSource <start> data <end> );"	"badSource <start> data <end> );
printShortLine <start> shortData <end> );"	"badSource <start> data <end> );
<start> printShortLine(shortData) <end> ;"	"short <start> shortData = (short)data <end> ;
printShortLine <start> shortData <end> );"	1
c26a7e5a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_console_open_66 { void badSink(char * dataArray[]) { char * data = dataArray[2]; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);
void badSink(char * <start> dataArray <end> []);"	"fileDesc = OPEN(data, O_RDWR|O_CREAT, <start> S_IREAD|S_IWRITE <end> );
void badSink(char * <start> dataArray <end> []);"	"void badSink(char * <start> dataArray <end> []);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN(data, O_RDWR|O_CREAT, <start> S_IREAD|S_IWRITE <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	2
b54bcefc-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 20 static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } void CWE369_Divide_by_Zero__float_fgets_08_bad() { float data; data = 0.0F; if(staticReturnsTrue()) { { char inputBuffer[CHAR_ARRAY_SIZE]; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = (float)atof(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(staticReturnsTrue()) { { int result = (int)(100.0 / data); printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> printIntLine(result) <end> ;"	"int result = (int) <start> 100.0 / data <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"int <start> result = (int)(100.0 / data) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );"	3
a10948e2-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_multiply_15_bad() { int data; data = 0; switch(6) { case 6: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; default: printLine(""Benign, fixed string""); break; } switch(7) { case 7: if(data > 0) { int result = data * 2; printIntLine(result); } break; default: printLine(""Benign, fixed string""); break; } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"if <start> data > 0 <end> ) ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printIntLine(result) <end> ;"	0
79b27563-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_54e_badSink(int data) { { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_54e_badSink(int <start> data <end> );
<start> printLine(dest) <end> ;"	"void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_54e_badSink(int <start> data <end> );
<start> memcpy(dest, source, data) <end> ;"	"printLine <start> dest <end> );
void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_54e_badSink(int <start> data <end> );"	"void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_54e_badSink(int <start> data <end> );
printLine <start> dest <end> );"	3
a36a78fc-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int CWE190_Integer_Overflow__int_listen_socket_add_45_badData; static int CWE190_Integer_Overflow__int_listen_socket_add_45_goodG2BData; static int CWE190_Integer_Overflow__int_listen_socket_add_45_goodB2GData; static void badSink() { int data = CWE190_Integer_Overflow__int_listen_socket_add_45_badData; { int result = data + 1; printIntLine(result); } } void CWE190_Integer_Overflow__int_listen_socket_add_45_bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE190_Integer_Overflow__int_listen_socket_add_45_badData = data; badSink(); }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
<start> CWE190_Integer_Overflow__int_listen_socket_add_45_badData = data <end> ;
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
static int <start> CWE190_Integer_Overflow__int_listen_socket_add_45_badData <end> ;
int data = <start> CWE190_Integer_Overflow__int_listen_socket_add_45_badData <end> ;"	"int data = <start> CWE190_Integer_Overflow__int_listen_socket_add_45_badData <end> ;
<start> CWE190_Integer_Overflow__int_listen_socket_add_45_badData = data <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int <start> result = data + 1 <end> ;
printIntLine <start> result <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> CWE190_Integer_Overflow__int_listen_socket_add_45_badData = data <end> ;
static int <start> CWE190_Integer_Overflow__int_listen_socket_add_45_badData <end> ;
int data = <start> CWE190_Integer_Overflow__int_listen_socket_add_45_badData <end> ;
printIntLine <start> result <end> );"	"<start> printIntLine(result) <end> ;
static int <start> CWE190_Integer_Overflow__int_listen_socket_add_45_badData <end> ;
printIntLine <start> result <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int data = <start> CWE190_Integer_Overflow__int_listen_socket_add_45_badData <end> ;"	2
67d010c0-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__short_rand_postinc_53d_badSink(short data) { { data++; short result = data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"void CWE190_Integer_Overflow__short_rand_postinc_53d_badSink(short <start> data <end> );
<start> data <end> ++;"	"short <start> result = data <end> ;
void CWE190_Integer_Overflow__short_rand_postinc_53d_badSink(short <start> data <end> );"	"<start> printIntLine(result) <end> ;
void CWE190_Integer_Overflow__short_rand_postinc_53d_badSink(short <start> data <end> );"	"void CWE190_Integer_Overflow__short_rand_postinc_53d_badSink(short <start> data <end> );
<start> data++ <end> ;"	0
9187cc0f-6c15-11ed-81d4-94e6f77dd552	"#define SEARCH_CHAR 'S' typedef struct _CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_console_67_structType { char * structFirst; } CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_console_67_structType; void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_console_67b_badSink(CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_console_67_structType myStruct) { char * data = myStruct.structFirst; for (; *data != '\0'; data++) { if (*data == SEARCH_CHAR) { printLine(""We have a match!""); break; } } free(data); }"	where is the vulnerable dataflow from data to free ?	"void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_console_67b_badSink(CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_console_67_structType <start> myStruct <end> );
free <start> data <end> );
char <start> * data = myStruct.structFirst <end> ;"	"void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_console_67b_badSink(CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_console_67_structType <start> myStruct <end> );
char * data = <start> myStruct <end> .structFirst;
free <start> data <end> );"	"char * data = <start> myStruct <end> .structFirst;
free <start> data <end> );
<start> free(data) <end> ;"	"for (; *data != '\0'; <start> data++ <end> );
free <start> data <end> );
char * data = <start> myStruct <end> .structFirst;"	1
93ece2f9-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING ""hello"" void CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_02_bad() { size_t data; data = 0; if(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = strtoul(inputBuffer, NULL, 0); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(1) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); } else { printLine(""Input is less than the length of the source string""); } } } }"	where is the vulnerable dataflow from data to malloc ?	"myString = (char *)malloc <start> data*sizeof(char) <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"if  <start> myString == NULL <end> ) {exit(-1);};
myString = (char *)malloc <start> data*sizeof(char) <end> );"	"myString = <start> (char *)malloc(data*sizeof(char)) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
myString = (char *)malloc <start> data*sizeof(char) <end> );"	3
4a02115c-6c15-11ed-81d4-94e6f77dd552	"namespace CWE190_Integer_Overflow__short_fscanf_add_43 { static void badSource(short &data) { fscanf (stdin, ""%hd"", &data); } void bad() { short data; data = 0; badSource(data); { short result = data + 1; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
badSource <start> data <end> );
fscanf (stdin, ""%hd"", <start> &data <end> );"	"badSource <start> data <end> );
short result = <start> data + 1 <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );"	"badSource <start> data <end> );
short result = <start> data <end>  + 1;
<start> printIntLine(result) <end> ;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
badSource <start> data <end> );
short result = <start> data <end>  + 1;"	3
d1e9da36-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_listen_socket_fopen_13 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(GLOBAL_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"replace = <start> strchr(data, '\n') <end> ;
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"pFile = FOPEN <start> data <end> , ""wb+"");
<start> recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0) <end> ;"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	2
cf875074-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif namespace CWE36_Absolute_Path_Traversal__char_environment_ofstream_45 { static char * badData; static char * goodG2BData; static void badSink() { char * data = badData; { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } } void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } badData = data; badSink(); }"	where is the vulnerable dataflow from data to open ?	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
<start> badData = data <end> ;
static char * <start> badData <end> ;
char * data = <start> badData <end> ;
outputFile.open((char * <start> data <end> );"	"<start> data = dataBuffer <end> ;
static char * <start> badData <end> ;
outputFile.open((char * <start> data <end> );
char * data = <start> badData <end> ;
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"size_t <start> dataLen = strlen(data) <end> ;
outputFile.open((char * <start> data <end> );
char * data = <start> badData <end> ;
char * environment = <start> GETENV <end> (ENV_VARIABLE);
static char * <start> badData <end> ;"	"outputFile.open((char * <start> data <end> );
char * data = <start> badData <end> ;
<start> data = dataBuffer <end> ;
char * environment = <start> GETENV <end> (ENV_VARIABLE);
<start> badData = data <end> ;"	0
b08640f3-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE197_Numeric_Truncation_Error__int_fgets_to_short_64b_badSink(void * dataVoidPtr) { int * dataPtr = (int *)dataVoidPtr; int data = (*dataPtr); { short shortData = (short)data; printShortLine(shortData); } }	where is the vulnerable dataflow from shortData to printShortLine ?	"<start> printShortLine(shortData) <end> ;
void CWE197_Numeric_Truncation_Error__int_fgets_to_short_64b_badSink(void * <start> dataVoidPtr <end> );"	"void CWE197_Numeric_Truncation_Error__int_fgets_to_short_64b_badSink(void * <start> dataVoidPtr <end> );
printShortLine <start> shortData <end> );"	"printShortLine <start> shortData <end> );
int <start> data = (*dataPtr) <end> ;"	"printShortLine <start> shortData <end> );
void CWE197_Numeric_Truncation_Error__int_fgets_to_short_64b_badSink(void * <start> dataVoidPtr <end> );"	1
5e44fc96-6c15-11ed-81d4-94e6f77dd552	"void CWE191_Integer_Underflow__int_fscanf_predec_10_bad() { int data; data = 0; if(globalTrue) { fscanf(stdin, ""%d"", &data); } if(globalTrue) { { --data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"fscanf(stdin, ""%d"", <start> &data <end> );
- <start> data <end> ;"	"fscanf(stdin, ""%d"", <start> &data <end> );
<start> printIntLine(result) <end> ;"	"fscanf(stdin, ""%d"", <start> &data <end> );
<start> data = 0 <end> ;"	"- <start> data <end> ;
int <start> result = data <end> ;"	0
c4cd6f36-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } namespace CWE23_Relative_Path_Traversal__char_environment_open_08 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(staticReturnsTrue()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
<start> data = dataBuffer <end> ;"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
size_t dataLen = <start> strlen(data) <end> ;"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
strncat(data+dataLen, environment, FILENAME_MAX <start> dataLen-1 <end> );"	0
c26a7e50-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_console_open_45 { static char * badData; static char * goodG2BData; static void badSink() { char * data = badData; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } } void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } badData = data; badSink(); }"	where is the vulnerable dataflow from data to OPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
<start> badData = data <end> ;
static char * <start> badData <end> ;
char * data = <start> badData <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
<start> badData = data <end> ;
size_t dataLen = <start> strlen(data) <end> ;
char * data = <start> badData <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
char * data = <start> badData <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
static char * <start> badData <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
static char * <start> badData <end> ;
<start> badData = data <end> ;
char * data = <start> badData <end> ;"	0
4b34b00a-6c15-11ed-81d4-94e6f77dd552	"namespace CWE190_Integer_Overflow__short_fscanf_square_43 { static void badSource(short &data) { fscanf (stdin, ""%hd"", &data); } void bad() { short data; data = 0; badSource(data); { short result = data * data; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"fscanf (stdin, ""%hd"", <start> &data <end> );
badSource <start> data <end> );
short result = <start> data <end>  * data;"	"short result = <start> data <end>  * data;
fscanf (stdin, ""%hd"", <start> &data <end> );
badSource <start> data <end> );"	"fscanf (stdin, ""%hd"", <start> &data <end> );
short result = <start> data <end>  * data;
<start> printIntLine(result) <end> ;"	"short result = <start> data <end>  * data;
fscanf (stdin, ""%hd"", <start> &data <end> );"	0
571e9843-6c15-11ed-81d4-94e6f77dd552	void CWE191_Integer_Underflow__int_fscanf_sub_66b_badSink(int dataArray[]) { int data = dataArray[2]; { int result = data - 1; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
void CWE191_Integer_Underflow__int_fscanf_sub_66b_badSink(int <start> dataArray <end> []);"	"void CWE191_Integer_Underflow__int_fscanf_sub_66b_badSink(int <start> dataArray <end> []);
int <start> result = data - 1 <end> ;"	"void CWE191_Integer_Underflow__int_fscanf_sub_66b_badSink(int <start> dataArray <end> []);
int result = <start> data <end>  - 1;"	"int result = <start> data - 1 <end> ;
void CWE191_Integer_Underflow__int_fscanf_sub_66b_badSink(int <start> dataArray <end> []);"	2
a5ce1c6e-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_postinc_66b_badSink(int dataArray[]) { int data = dataArray[2]; { data++; int result = data; printIntLine(result); } }	where is the vulnerable dataflow from result to printIntLine ?	"int <start> result = data <end> ;
printIntLine <start> result <end> );"	"void CWE190_Integer_Overflow__int_fgets_postinc_66b_badSink(int <start> dataArray <end> []);
int <start> result = data <end> ;"	"void CWE190_Integer_Overflow__int_fgets_postinc_66b_badSink(int <start> dataArray <end> []);
printIntLine <start> result <end> );"	"<start> printIntLine(result) <end> ;
void CWE190_Integer_Overflow__int_fgets_postinc_66b_badSink(int <start> dataArray <end> []);"	2
b2ea8da9-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" void CWE197_Numeric_Truncation_Error__short_connect_socket_64b_badSink(void * dataVoidPtr) { short * dataPtr = (short *)dataVoidPtr; short data = (*dataPtr); { char charData = (char)data; printHexCharLine(charData); } }"	where is the vulnerable dataflow from charData to printHexCharLine ?	"void CWE197_Numeric_Truncation_Error__short_connect_socket_64b_badSink(void * <start> dataVoidPtr <end> );
printHexCharLine <start> charData <end> );"	"printHexCharLine <start> charData <end> );
void CWE197_Numeric_Truncation_Error__short_connect_socket_64b_badSink(void * <start> dataVoidPtr <end> );"	"printHexCharLine <start> charData <end> );
char charData = <start> (char)data <end> ;"	"<start> printHexCharLine(charData) <end> ;
printHexCharLine <start> charData <end> );"	0
7c12755e-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_12_bad() { int data; data = -1; if(globalReturnsTrueOrFalse()) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } else { data = 100-1; } if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }"	where is the vulnerable dataflow from data to malloc ?	"char <start> inputBuffer[CHAR_ARRAY_SIZE] = """" <end> ;
char * dataBuffer = (char *)malloc <start> data <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
if  <start> dataBuffer == NULL <end> ) {exit(-1);};"	"if  <start> dataBuffer == NULL <end> ) {exit(-1);};
char * dataBuffer = (char *)malloc <start> data <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
char * dataBuffer = (char *)malloc <start> data <end> );"	3
a95fd833-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) typedef union { int unionFirst; int unionSecond; } CWE191_Integer_Underflow__int_fgets_multiply_34_unionType; void CWE191_Integer_Underflow__int_fgets_multiply_34_bad() { int data; CWE191_Integer_Underflow__int_fgets_multiply_34_unionType myUnion; data = 0; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } myUnion.unionFirst = data; { int data = myUnion.unionSecond; if(data < 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
int <start> result = data * 2 <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
int <start> data = myUnion.unionSecond <end> ;"	"<start> printIntLine(result) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );"	3
5e44fc6b-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_fgets_predec_02_bad() { int data; data = 0; if(1) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(1) { { --data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"- <start> data <end> ;
<start> printIntLine(result) <end> ;"	"- <start> data <end> ;
<start> --data <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> printIntLine(result) <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
- <start> data <end> ;"	3
598370b8-6c15-11ed-81d4-94e6f77dd552	"void CWE191_Integer_Underflow__short_fscanf_sub_02_bad() { short data; data = 0; if(1) { fscanf (stdin, ""%hd"", &data); } if(1) { { short result = data - 1; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );"	"fscanf (stdin, ""%hd"", <start> &data <end> );
short <start> result = data - 1 <end> ;"	"short result = <start> data <end>  - 1;
fscanf (stdin, ""%hd"", <start> &data <end> );"	"fscanf (stdin, ""%hd"", <start> &data <end> );
short result = <start> data <end>  - 1;"	3
cac216b9-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" namespace CWE36_Absolute_Path_Traversal__char_connect_socket_ofstream_14 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(globalFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
replace = <start> strchr(data, '\n') <end> ;"	"<start> data = dataBuffer <end> ;
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
outputFile.open((char * <start> data <end> );"	3
9187cbda-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define SEARCH_CHAR 'S' void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_16_bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\0'; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } while(1) { for (; *data != '\0'; data++) { if (*data == SEARCH_CHAR) { printLine(""We have a match!""); break; } } free(data); break; } }"	where is the vulnerable dataflow from data to free ?	"<start> data = (char *)malloc(100*sizeof(char)) <end> ;
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
free <start> data <end> );"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
<start> free(data) <end> ;"	"if  <start> data == NULL <end> ) {exit(-1);};
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	1
70279bf9-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif void CWE134_Uncontrolled_Format_String__char_file_snprintf_09_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; if(GLOBAL_CONST_TRUE) { { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } if(GLOBAL_CONST_TRUE) { { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } } }"	where is the vulnerable dataflow from dest to printLine ?	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
printLine <start> dest <end> );"	"printLine <start> dest <end> );
<start> data = dataBuffer <end> ;"	"printLine <start> dest <end> );
<start> printLine(dest) <end> ;"	"SNPRINTF(dest, <start> 100-1 <end> , data);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	0
b08640e0-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE197_Numeric_Truncation_Error__int_fgets_to_short_15_bad() { int data; data = -1; switch(6) { case 6: { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } break; default: printLine(""Benign, fixed string""); break; } { short shortData = (short)data; printShortLine(shortData); } }"	where is the vulnerable dataflow from shortData to printShortLine ?	"short <start> shortData = (short)data <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"<start> data = atoi(inputBuffer) <end> ;
printShortLine <start> shortData <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printShortLine <start> shortData <end> );"	"<start> data = -1 <end> ;
printShortLine <start> shortData <end> );"	2
951c5e84-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FULL_COMMAND ""dir "" #else #define FULL_COMMAND ""ls "" #endif #ifdef _WIN32 #define POPEN _popen #define PCLOSE _pclose #else #define POPEN popen #define PCLOSE pclose #endif void CWE78_OS_Command_Injection__char_console_popen_02_bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; if(1) { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } { FILE *pipe; pipe = POPEN(data, ""w""); if (pipe != NULL) { PCLOSE(pipe); } } }"	where is the vulnerable dataflow from data to POPEN ?	"pipe = POPEN <start> data <end> , ""w"");
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	"size_t dataLen = <start> strlen(data) <end> ;
pipe = POPEN <start> data <end> , ""w"");"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
pipe = POPEN <start> data <end> , ""w"");"	"if (dataLen > 0 && <start> data[dataLen-1] == '\n' <end> );
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	2
acf67e53-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int CWE191_Integer_Underflow__int_fgets_predec_45_badData; static int CWE191_Integer_Underflow__int_fgets_predec_45_goodG2BData; static int CWE191_Integer_Underflow__int_fgets_predec_45_goodB2GData; static void badSink() { int data = CWE191_Integer_Underflow__int_fgets_predec_45_badData; { --data; int result = data; printIntLine(result); } } void CWE191_Integer_Underflow__int_fgets_predec_45_bad() { int data; data = 0; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } CWE191_Integer_Underflow__int_fgets_predec_45_badData = data; badSink(); }"	where is the vulnerable dataflow from result to printIntLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> CWE191_Integer_Underflow__int_fgets_predec_45_badData = data <end> ;
printIntLine <start> result <end> );
int <start> result = data <end> ;
static int <start> CWE191_Integer_Underflow__int_fgets_predec_45_badData <end> ;"	"int data = <start> CWE191_Integer_Underflow__int_fgets_predec_45_badData <end> ;
static int <start> CWE191_Integer_Underflow__int_fgets_predec_45_badData <end> ;
printIntLine <start> result <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> printIntLine(result) <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> CWE191_Integer_Underflow__int_fgets_predec_45_badData = data <end> ;
static int <start> CWE191_Integer_Underflow__int_fgets_predec_45_badData <end> ;
int data = <start> CWE191_Integer_Underflow__int_fgets_predec_45_badData <end> ;
printIntLine <start> result <end> );"	"<start> printIntLine(result) <end> ;
<start> CWE191_Integer_Underflow__int_fgets_predec_45_badData = data <end> ;
static int <start> CWE191_Integer_Underflow__int_fgets_predec_45_badData <end> ;
int data = <start> CWE191_Integer_Underflow__int_fgets_predec_45_badData <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	2
78800fb1-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 8 void CWE194_Unexpected_Sign_Extension__listen_socket_memmove_14_bad() { short data; data = 0; if(globalFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data = tempInt <end> ;"	"tempInt = <start> atoi(inputBuffer) <end> ;
printLine <start> dest <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data = 0 <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	3
a6fd827a-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_preinc_64b_badSink(void * dataVoidPtr) { int * dataPtr = (int *)dataVoidPtr; int data = (*dataPtr); { ++data; int result = data; printIntLine(result); } }	where is the vulnerable dataflow from result to printIntLine ?	"void CWE190_Integer_Overflow__int_fgets_preinc_64b_badSink(void * <start> dataVoidPtr <end> );
printIntLine <start> result <end> );"	"<start> ++data <end> ;
printIntLine <start> result <end> );"	"void CWE190_Integer_Overflow__int_fgets_preinc_64b_badSink(void * <start> dataVoidPtr <end> );
int <start> result = data <end> ;"	"<start> printIntLine(result) <end> ;
void CWE190_Integer_Overflow__int_fgets_preinc_64b_badSink(void * <start> dataVoidPtr <end> );"	0
47a2a801-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__int_fgets_square_81 { void CWE190_Integer_Overflow__int_fgets_square_81_bad::action(int data) const { { int result = data * data; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
void CWE190_Integer_Overflow__int_fgets_square_81_bad::action(int <start> data <end> ) const;"	"int <start> result = data * data <end> ;
void CWE190_Integer_Overflow__int_fgets_square_81_bad::action(int <start> data <end> ) const;"	"int result = <start> data <end>  * data;
void CWE190_Integer_Overflow__int_fgets_square_81_bad::action(int <start> data <end> ) const;"	"void CWE190_Integer_Overflow__int_fgets_square_81_bad::action(int <start> data <end> ) const;
int result = <start> data <end>  * data;"	3
67d010c4-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__short_rand_postinc_65b_badSink(short data) { { data++; short result = data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"void CWE190_Integer_Overflow__short_rand_postinc_65b_badSink(short <start> data <end> );
short <start> result = data <end> ;"	"void CWE190_Integer_Overflow__short_rand_postinc_65b_badSink(short <start> data <end> );
<start> data <end> ++;"	"<start> printIntLine(result) <end> ;
void CWE190_Integer_Overflow__short_rand_postinc_65b_badSink(short <start> data <end> );"	"<start> data <end> ++;
void CWE190_Integer_Overflow__short_rand_postinc_65b_badSink(short <start> data <end> );"	1
964cdbf2-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FULL_COMMAND ""dir "" #else #define FULL_COMMAND ""ls "" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define POPEN _popen #define PCLOSE _pclose #else #define POPEN popen #define PCLOSE pclose #endif void CWE78_OS_Command_Injection__char_file_popen_31_bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } { char * dataCopy = data; char * data = dataCopy; { FILE *pipe; pipe = POPEN(data, ""w""); if (pipe != NULL) { PCLOSE(pipe); } } } }"	where is the vulnerable dataflow from data to POPEN ?	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
pipe = POPEN <start> data <end> , ""w"");"	"char <start> * dataCopy = data <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	"char <start> * dataCopy = data <end> ;
pipe = POPEN <start> data <end> , ""w"");"	"pipe = POPEN <start> data <end> , ""w"");
pipe = <start> POPEN(data, ""w"") <end> ;"	0
c99197f0-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_connect_socket_fopen_45 { static char * badData; static char * goodG2BData; static void badSink() { char * data = badData; { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } } void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badData = data; badSink(); }"	where is the vulnerable dataflow from data to FOPEN ?	"replace = <start> strchr(data, '\n') <end> ;
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
<start> badData = data <end> ;
static char * <start> badData <end> ;
char * data = <start> badData <end> ;"	"pFile = FOPEN <start> data <end> , ""wb+"");
static char * <start> badData <end> ;
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
<start> badData = data <end> ;
char * data = <start> badData <end> ;"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
<start> badData = data <end> ;
static char * <start> badData <end> ;
char * data = <start> badData <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"static char * <start> badData <end> ;
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
<start> badData = data <end> ;
char * data = <start> badData <end> ;
recvResult = <start> recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0) <end> ;"	2
cf8750a7-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_file_fopen_02 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(1) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
<start> data = dataBuffer <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
pFile = FOPEN <start> data <end> , ""wb+"");"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
size_t dataLen = <start> strlen(data) <end> ;"	2
8a6310b5-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif static int staticTrue = 1; static int staticFalse = 0; namespace CWE36_Absolute_Path_Traversal__char_file_open_05 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(staticTrue) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
size_t dataLen = <start> strlen(data) <end> ;"	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	3
78800f95-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 8 void CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_53d_badSink(short data) { { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"void CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_53d_badSink(short <start> data <end> );
char <start> dest[100] = """" <end> ;"	"void CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_53d_badSink(short <start> data <end> );
printLine <start> dest <end> );"	"<start> printLine(dest) <end> ;
void CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_53d_badSink(short <start> data <end> );"	"<start> memcpy(dest, source, data) <end> ;
printLine <start> dest <end> );"	1
6dc61511-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif void CWE134_Uncontrolled_Format_String__char_console_snprintf_15_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; switch(6) { case 6: { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } break; default: printLine(""Benign, fixed string""); break; } switch(7) { case 7: { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } break; default: printLine(""Benign, fixed string""); break; } }"	where is the vulnerable dataflow from dest to printLine ?	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
printLine <start> dest <end> );"	"dataLen = <start> strlen(data) <end> ;
printLine <start> dest <end> );"	"<start> printLine(dest) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	1
7e74f33d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_03_bad() { int data; data = -1; if(5==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> memmove(dest, source, data) <end> ;
printLine <start> dest <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> memmove(dest, source, data) <end> ;"	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printLine <start> dest <end> );"	1
d31a250f-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_listen_socket_open_01 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
size_t dataLen = <start> strlen(data) <end> ;"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
replace = <start> strchr(data, '\n') <end> ;"	"size_t dataLen = <start> strlen(data) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	0
99e16aa5-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE124_Buffer_Underwrite__CWE839_connect_socket_15_bad() { int data; data = -1; switch(6) { case 6: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; default: printLine(""Benign, fixed string""); break; } switch(7) { case 7: { int i; int buffer[10] = { 0 }; if (data < 10) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } } break; default: printLine(""Benign, fixed string""); break; } }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"printIntLine <start> buffer[i] <end> );
<start> printIntLine(buffer[i]) <end> ;"	"data = <start> atoi(inputBuffer) <end> ;
printIntLine <start> buffer[i] <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[i] <end> );"	"data = <start> atoi(inputBuffer) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	2
4ec5d0a2-6c15-11ed-81d4-94e6f77dd552	"static void badSink(int data) { { data++; int result = data; printIntLine(result); } } void CWE190_Integer_Overflow__int_fscanf_postinc_41_bad() { int data; data = 0; fscanf(stdin, ""%d"", &data); badSink(data); }"	where is the vulnerable dataflow from data ?	"fscanf(stdin, ""%d"", <start> &data <end> );
badSink <start> data <end> );
static void badSink(int <start> data <end> );
<start> data <end> ++;"	"<start> data <end> ++;
fscanf(stdin, ""%d"", <start> &data <end> );
static void badSink(int <start> data <end> );
badSink <start> data <end> );"	"fscanf(stdin, ""%d"", <start> &data <end> );
<start> data <end> ++;
static void badSink(int <start> data <end> );"	"static void badSink(int <start> data <end> );
fscanf(stdin, ""%d"", <start> &data <end> );
<start> printIntLine(result) <end> ;
badSink <start> data <end> );"	0
525b6448-6c15-11ed-81d4-94e6f77dd552	"static int badSource(int data) { fscanf(stdin, ""%d"", &data); return data; } void CWE190_Integer_Overflow__int_fscanf_preinc_42_bad() { int data; data = 0; data = badSource(data); { ++data; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"<start> ++data <end> ;
data = <start> badSource <end> (data);
fscanf(stdin, ""%d"", <start> &data <end> );
static int <start> badSource <end> (int data);"	"data = <start> badSource <end> (data);
fscanf(stdin, ""%d"", <start> &data <end> );
+ <start> data <end> ;"	"data = <start> badSource <end> (data);
+ <start> data <end> ;
static int <start> badSource <end> (int data);
fscanf(stdin, ""%d"", <start> &data <end> );"	"fscanf(stdin, ""%d"", <start> &data <end> );
static int <start> badSource <end> (int data);
data = <start> badSource <end> (data);
+ <start> data <end> ;"	3
a1094933-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } void CWE190_Integer_Overflow__int_fgets_add_08_bad() { int data; data = 0; if(staticReturnsTrue()) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(staticReturnsTrue()) { { int result = data + 1; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
char <start> inputBuffer[CHAR_ARRAY_SIZE] = """" <end> ;"	"int result = <start> data + 1 <end> ;
printIntLine <start> result <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> printIntLine(result) <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );"	3
598370b5-6c15-11ed-81d4-94e6f77dd552	namespace CWE191_Integer_Underflow__short_fscanf_multiply_81 { void CWE191_Integer_Underflow__short_fscanf_multiply_81_bad::action(short data) const { if(data < 0) { short result = data * 2; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"void CWE191_Integer_Underflow__short_fscanf_multiply_81_bad::action(short <start> data <end> ) const;
short result = <start> data <end>  * 2;"	"short result = <start> data <end>  * 2;
void CWE191_Integer_Underflow__short_fscanf_multiply_81_bad::action(short <start> data <end> ) const;"	"short result = <start> data <end>  * 2;
if <start> data < 0 <end> ) ;"	"void CWE191_Integer_Underflow__short_fscanf_multiply_81_bad::action(short <start> data <end> ) const;
<start> printIntLine(result) <end> ;"	0
774f5824-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 8 void CWE194_Unexpected_Sign_Extension__listen_socket_malloc_54e_badSink(short data) { if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }"	where is the vulnerable dataflow from data to malloc ?	"void CWE194_Unexpected_Sign_Extension__listen_socket_malloc_54e_badSink(short <start> data <end> );
char * dataBuffer = (char * <start> malloc(data) <end> ;"	"<start> memset(dataBuffer, 'A', data-1) <end> ;
char * dataBuffer = (char *)malloc <start> data <end> );"	"void CWE194_Unexpected_Sign_Extension__listen_socket_malloc_54e_badSink(short <start> data <end> );
char * dataBuffer = (char *)malloc <start> data <end> );"	"char * dataBuffer = (char *)malloc <start> data <end> );
char * dataBuffer = <start> (char *)malloc(data) <end> ;"	2
9187cc15-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #define SEARCH_CHAR 'S' void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_file_02_bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\0'; { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } if(1) { for (; *data != '\0'; data++) { if (*data == SEARCH_CHAR) { printLine(""We have a match!""); break; } } free(data); } }"	where is the vulnerable dataflow from data to free ?	"free <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	"free <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
free <start> data <end> );"	"<start> free(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	2
669edab6-6c15-11ed-81d4-94e6f77dd552	static int staticFive = 5; void CWE190_Integer_Overflow__char_rand_postinc_07_bad() { char data; data = ' '; if(staticFive==5) { data = (char)RAND32(); } if(staticFive==5) { { data++; char result = data; printHexCharLine(result); } } }	where is the vulnerable dataflow from data ?	"<start> printHexCharLine(result) <end> ;
data = (char <start> RAND32() <end> ;"	"data = (char <start> RAND32() <end> ;
char <start> result = data <end> ;"	"data = (char <start> RAND32() <end> ;
<start> data <end> ++;"	"<start> data <end> ++;
data = (char <start> RAND32() <end> ;"	2
7e74f312-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_04_bad() { int data; data = -1; if(STATIC_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> memcpy(dest, source, data) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"printLine <start> dest <end> );
if  <start> recvResult == SOCKET_ERROR <end>  || recvResult == 0);"	"printLine <start> dest <end> );
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	3
774f5814-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 8 void CWE194_Unexpected_Sign_Extension__listen_socket_malloc_15_bad() { short data; data = 0; switch(6) { case 6: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; default: printLine(""Benign, fixed string""); break; } if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }"	where is the vulnerable dataflow from data to malloc ?	"char * dataBuffer = (char *)malloc <start> data <end> );
char * dataBuffer = (char * <start> malloc(data) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
char * dataBuffer = (char *)malloc <start> data <end> );"	"<start> printLine(dataBuffer) <end> ;
char * dataBuffer = (char *)malloc <start> data <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> free(dataBuffer) <end> ;"	1
525b6481-6c15-11ed-81d4-94e6f77dd552	"void CWE190_Integer_Overflow__short_fscanf_preinc_13_bad() { short data; data = 0; if(GLOBAL_CONST_FIVE==5) { fscanf (stdin, ""%hd"", &data); } if(GLOBAL_CONST_FIVE==5) { { ++data; short result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );"	"short <start> result = data <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );"	"+ <start> data <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );"	"fscanf (stdin, ""%hd"", <start> &data <end> );
+ <start> data <end> ;"	3
aa91a1a9-6c15-11ed-81d4-94e6f77dd552	namespace CWE191_Integer_Underflow__int_listen_socket_sub_72 { void badSink(vector<int> dataVector) { int data = dataVector[2]; { int result = data - 1; printIntLine(result); } }	where is the vulnerable dataflow from result to printIntLine ?	"int <start> data = dataVector[2] <end> ;
printIntLine <start> result <end> );"	"void badSink(vector<int> <start> dataVector <end> );
int <start> result = data - 1 <end> ;"	"printIntLine <start> result <end> );
void badSink(vector<int> <start> dataVector <end> );"	"void badSink(vector<int> <start> dataVector <end> );
printIntLine <start> result <end> );"	3
6ef7681d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif namespace CWE134_Uncontrolled_Format_String__char_console_snprintf_81 { void CWE134_Uncontrolled_Format_String__char_console_snprintf_81_bad::action(char * data) const { { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> SNPRINTF(dest, 100-1, data) <end> ;
printLine <start> dest <end> );"	"void CWE134_Uncontrolled_Format_String__char_console_snprintf_81_bad::action(char * <start> data <end> ) const;
<start> SNPRINTF(dest, 100-1, data) <end> ;"	"void CWE134_Uncontrolled_Format_String__char_console_snprintf_81_bad::action(char * <start> data <end> ) const;
<start> printLine(dest) <end> ;"	"void CWE134_Uncontrolled_Format_String__char_console_snprintf_81_bad::action(char * <start> data <end> ) const;
printLine <start> dest <end> );"	3
a95fd830-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int badStatic = 0; static void badSink(int data) { if(badStatic) { if(data < 0) { int result = data * 2; printIntLine(result); } } } void CWE191_Integer_Underflow__int_fgets_multiply_21_bad() { int data; data = 0; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } badStatic = 1; badSink(data); }"	where is the vulnerable dataflow from result to printIntLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
badSink <start> data <end> );
static void badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"badSink <start> data <end> );
printIntLine <start> result <end> );
static void badSink(int <start> data <end> );
<start> badSink(data) <end> ;"	"static void badSink(int <start> data <end> );
if  <start> fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) <end>  != NULL);
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
badSink <start> data <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
badSink <start> data <end> );
<start> data = 0 <end> ;
printIntLine <start> result <end> );"	0
4ec5d08a-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_postinc_65b_badSink(int data) { { data++; int result = data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"void CWE190_Integer_Overflow__int_fgets_postinc_65b_badSink(int <start> data <end> );
<start> data++ <end> ;"	"int <start> result = data <end> ;
void CWE190_Integer_Overflow__int_fgets_postinc_65b_badSink(int <start> data <end> );"	"<start> data <end> ++;
void CWE190_Integer_Overflow__int_fgets_postinc_65b_badSink(int <start> data <end> );"	"void CWE190_Integer_Overflow__int_fgets_postinc_65b_badSink(int <start> data <end> );
<start> data <end> ++;"	3
abc37502-6c15-11ed-81d4-94e6f77dd552	extern int CWE191_Integer_Underflow__int_connect_socket_postdec_22_badGlobal; void CWE191_Integer_Underflow__int_connect_socket_postdec_22_badSink(int data) { if(CWE191_Integer_Underflow__int_connect_socket_postdec_22_badGlobal) { { data--; int result = data; printIntLine(result); } } }	where is the vulnerable dataflow from result to printIntLine ?	"void CWE191_Integer_Underflow__int_connect_socket_postdec_22_badSink(int <start> data <end> );
int <start> result = data <end> ;"	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	"void CWE191_Integer_Underflow__int_connect_socket_postdec_22_badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"int <start> result = data <end> ;
printIntLine <start> result <end> );"	2
99e16a85-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_listen_socket_15 { void bad() { int data; data = -1; switch(6) { case 6: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; default: printLine(""Benign, fixed string""); break; } switch(7) { case 7: { int i; int * buffer = new int[10]; for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } delete[] buffer; } break; default: printLine(""Benign, fixed string""); break; } }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"recvResult = recv(acceptSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);
printIntLine <start> buffer[i] <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printIntLine(buffer[i]) <end> ;"	"if  <start> recvResult == SOCKET_ERROR <end>  || recvResult == 0);
printIntLine <start> buffer[i] <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[i] <end> );"	3
5e44fc90-6c15-11ed-81d4-94e6f77dd552	"void CWE191_Integer_Underflow__int_fscanf_predec_03_bad() { int data; data = 0; if(5==5) { fscanf(stdin, ""%d"", &data); } if(5==5) { { --data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"- <start> data <end> ;
fscanf(stdin, ""%d"", <start> &data <end> );"	"fscanf(stdin, ""%d"", <start> &data <end> );
- <start> data <end> ;"	"<start> data = 0 <end> ;
- <start> data <end> ;"	"- <start> data <end> ;
<start> --data <end> ;"	1
9c45519a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE126_Buffer_Overread__CWE129_connect_socket_03_bad() { int data; data = -1; if(5==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(5==5) { { int buffer[10] = { 0 }; if (data >= 0) { printIntLine(buffer[data]); } else { printLine(""ERROR: Array index is negative""); } } } }"	where is the vulnerable dataflow from buffer[data] to printIntLine ?	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> buffer[data] <end> );"	"int <start> buffer[10] = { 0 } <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[data] <end> );"	"printIntLine <start> buffer[data] <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	2
7c127571-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_54e_badSink(int data) { if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }	where is the vulnerable dataflow from data to malloc ?	"void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_54e_badSink(int <start> data <end> );
if  <start> dataBuffer == NULL <end> ) {exit(-1);};"	"char * dataBuffer = (char *)malloc <start> data <end> );
char * dataBuffer = (char * <start> malloc(data) <end> ;"	"void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_54e_badSink(int <start> data <end> );
char * dataBuffer = (char *)malloc <start> data <end> );"	"void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_54e_badSink(int <start> data <end> );
<start> printLine(dataBuffer) <end> ;"	2
80d98732-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_console_open_42 { static char * badSource(char * data) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } return data; } void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; data = badSource(data); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"static char * <start> badSource <end> (char * data);
data = <start> badSource(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
data = <start> badSource <end> (data);
size_t dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
data = <start> badSource <end> (data);
fileDesc = OPEN(data, O_RDWR|O_CREAT, <start> S_IREAD|S_IWRITE <end> );
static char * <start> badSource <end> (char * data);"	0
b8e2bdd6-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 256 void CWE681_Incorrect_Conversion_Between_Numeric_Types__doubleNaN2int_16_bad() { while(1) { { char inputBuffer[CHAR_ARRAY_SIZE]; double doubleNumber = 0; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { doubleNumber = atof(inputBuffer); } else { printLine(""fgets() failed.""); } printIntLine((int)(sqrt(doubleNumber))); } break; } }"	where is the vulnerable dataflow from doubleNumber to printIntLine ?	"printIntLine <start> (int)(sqrt(doubleNumber)) <end> );
printIntLine((int)(sqrt <start> doubleNumber <end> )));"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine((int)(sqrt <start> doubleNumber <end> )));"	"doubleNumber = <start> atof(inputBuffer) <end> ;
printIntLine((int)(sqrt <start> doubleNumber <end> )));"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
double <start> doubleNumber = 0 <end> ;"	1
6b862464-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_54e_badSink(int data) { { int i; int * buffer = (int *)malloc(10 * sizeof(int)); if (buffer == NULL) {exit(-1);} for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } free(buffer); } }"	where is the vulnerable dataflow from buffer to free ?	"free <start> buffer <end> );
<start> printIntLine(buffer[i]) <end> ;"	"void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_54e_badSink(int <start> data <end> );
free <start> buffer <end> );"	"free <start> buffer <end> );
void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_54e_badSink(int <start> data <end> );"	"<start> printIntLine(buffer[i]) <end> ;
void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_54e_badSink(int <start> data <end> );"	1
893217fd-6c15-11ed-81d4-94e6f77dd552	#ifndef _WIN32 #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_console_open_65 { void badSink(char * data) { { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN(data, O_RDWR|O_CREAT, <start> S_IREAD|S_IWRITE <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"void badSink(char * <start> data <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
void badSink(char * <start> data <end> );"	1
b54bcf14-6c15-11ed-81d4-94e6f77dd552	namespace CWE369_Divide_by_Zero__float_fgets_62 { void badSource(float &data); void bad() { float data; data = 0.0F; badSource(data); { int result = (int)(100.0 / data); printIntLine(result); } }	where is the vulnerable dataflow from result to printIntLine ?	"badSource <start> data <end> );
printIntLine <start> result <end> );"	"int <start> result = (int)(100.0 / data) <end> ;
badSource <start> data <end> );"	"badSource <start> data <end> );
<start> printIntLine(result) <end> ;"	"int <start> result = (int)(100.0 / data) <end> ;
printIntLine <start> result <end> );"	0
669edab1-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__char_rand_postinc_01_bad() { char data; data = ' '; data = (char)RAND32(); { data++; char result = data; printHexCharLine(result); } }	where is the vulnerable dataflow from data ?	"<start> data = (char)RAND32() <end> ;
<start> data <end> ++;"	"<start> printHexCharLine(result) <end> ;
data = (char <start> RAND32() <end> ;"	"data = (char <start> RAND32() <end> ;
<start> data <end> ++;"	"<start> data++ <end> ;
data = (char <start> RAND32() <end> ;"	2
aa91a1a0-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_listen_socket_sub_54e_badSink(int data) { { int result = data - 1; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
void CWE191_Integer_Underflow__int_listen_socket_sub_54e_badSink(int <start> data <end> );"	"printIntLine <start> result <end> );
int result = <start> data - 1 <end> ;"	"void CWE191_Integer_Underflow__int_listen_socket_sub_54e_badSink(int <start> data <end> );
<start> printIntLine(result) <end> ;"	"void CWE191_Integer_Underflow__int_listen_socket_sub_54e_badSink(int <start> data <end> );
printIntLine <start> result <end> );"	3
7d44fc89-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_10_bad() { int data; data = -1; if(globalTrue) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"if  <start> data < 100 <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printLine <start> dest <end> );"	"<start> printLine(dest) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if  <start> data < 100 <end> );
printLine <start> dest <end> );"	1
c4cd6f34-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif static const int STATIC_CONST_FIVE = 5; namespace CWE23_Relative_Path_Traversal__char_environment_open_06 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(STATIC_CONST_FIVE==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"strncat(data+dataLen, environment, <start> FILENAME_MAX-dataLen-1 <end> );
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"size_t dataLen = <start> strlen(data) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"strncat(data+dataLen, environment, <start> FILENAME_MAX-dataLen-1 <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	2
87ff986e-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_connect_socket_open_14 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(globalFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
char <start> dataBuffer[FILENAME_MAX] = """" <end> ;"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
size_t dataLen = <start> strlen(data) <end> ;"	"replace = <start> strchr(data, '\n') <end> ;
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	0
c99197f9-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_connect_socket_fopen_66 { void badSink(char * dataArray[]) { char * data = dataArray[2]; { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"void badSink(char * <start> dataArray <end> []);
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	"pFile = FOPEN <start> data <end> , ""wb+"");
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	"void badSink(char * <start> dataArray <end> []);
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
void badSink(char * <start> dataArray <end> []);"	2
6ef76828-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif static void badVaSinkB(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_console_vfprintf_10_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; if(globalTrue) { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } if(globalTrue) { badVaSinkB(data, data); } }"	where is the vulnerable dataflow from data to vfprintf ?	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);"	"static void badVaSinkB(char * <start> data <end> , ...);
dataLen = <start> strlen(data) <end> ;
vfprintf(stdout, <start> data <end> , args);
badVaSinkB <start> data <end> , data);"	"badVaSinkB <start> data <end> , data);
vfprintf(stdout, <start> data <end> , args);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
static void badVaSinkB(char * <start> data <end> , ...);"	"<start> vfprintf(stdout, data, args) <end> ;
badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	0
7ae3a73b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_14_bad() { int data; data = -1; if(globalFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"data = <start> atoi(inputBuffer) <end> ;
printLine <start> dest <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printLine(dest) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data = -1 <end> ;"	2
ce547d4e-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif namespace CWE36_Absolute_Path_Traversal__char_environment_ifstream_43 { void badSource(char * &data) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } } void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; badSource(data); { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"inputFile.open((char * <start> data <end> );
char * environment = <start> GETENV <end> (ENV_VARIABLE);
strncat(data+dataLen, environment, FILENAME_MAX <start> dataLen-1 <end> );"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
badSource <start> data <end> );
inputFile.open((char * <start> data <end> );"	"badSource <start> data <end> );
char * environment = <start> GETENV <end> (ENV_VARIABLE);
inputFile.open((char * <start> data <end> );"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
badSource <start> data <end> );"	1
60db83a3-6c15-11ed-81d4-94e6f77dd552	static void badSink(char data) { { char result = data + 1; printHexCharLine(result); } } void CWE190_Integer_Overflow__char_rand_add_44_bad() { char data; void (*funcPtr) (char) = badSink; data = ' '; data = (char)RAND32(); funcPtr(data); }	where is the vulnerable dataflow from data ?	"data = (char <start> RAND32() <end> ;
funcPtr <start> data <end> );
static void badSink(char <start> data <end> );
char result = <start> data <end>  + 1;"	"<start> printHexCharLine(result) <end> ;
data = (char <start> RAND32() <end> ;
funcPtr <start> data <end> );
static void badSink(char <start> data <end> );"	"data = (char <start> RAND32() <end> ;
char result = <start> data <end>  + 1;"	"static void badSink(char <start> data <end> );
data = (char <start> RAND32() <end> ;
char result = <start> data <end>  + 1;
<start> data = (char)RAND32() <end> ;"	0
598370d0-6c15-11ed-81d4-94e6f77dd552	void CWE191_Integer_Underflow__short_fscanf_sub_51b_badSink(short data) { { short result = data - 1; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"void CWE191_Integer_Underflow__short_fscanf_sub_51b_badSink(short <start> data <end> );
short result = <start> data <end>  - 1;"	"<start> printIntLine(result) <end> ;
void CWE191_Integer_Underflow__short_fscanf_sub_51b_badSink(short <start> data <end> );"	"<start> printIntLine(result) <end> ;
short result = <start> data <end>  - 1;"	"short result = <start> data <end>  - 1;
void CWE191_Integer_Underflow__short_fscanf_sub_51b_badSink(short <start> data <end> );"	0
466e7f0f-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE190_Integer_Overflow__int_fgets_square_43 { static void badSource(int &data) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } void bad() { int data; data = 0; badSource(data); { int result = data * data; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"badSource <start> data <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
int result = <start> data <end>  * data;"	"badSource <start> data <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> printIntLine(result) <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
badSource <start> data <end> );
int result = <start> data <end>  * data;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
int result = <start> data <end>  * data;"	2
54c581e4-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticFive = 5; void CWE191_Integer_Underflow__int_connect_socket_multiply_07_bad() { int data; data = 0; if(staticFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticFive==5) { if(data < 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  * 2;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
data = <start> atoi(inputBuffer) <end> ;"	"int result = <start> data * 2 <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"if <start> data < 0 <end> ) ;
int result = <start> data <end>  * 2;"	0
a49c4f4a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int badSource(int data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } return data; } void CWE190_Integer_Overflow__int_listen_socket_multiply_42_bad() { int data; data = 0; data = badSource(data); if(data > 0) { int result = data * 2; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );
static int <start> badSource <end> (int data);
data = <start> badSource(data) <end> ;"	"if  <start> recvResult == SOCKET_ERROR <end>  || recvResult == 0);
printIntLine <start> result <end> );
static int <start> badSource <end> (int data);
data = <start> badSource <end> (data);"	"static int <start> badSource <end> (int data);
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
data = <start> badSource <end> (data);
int result = <start> data * 2 <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static int <start> badSource <end> (int data);
data = <start> badSource <end> (data);
printIntLine <start> result <end> );"	3
a1094918-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE190_Integer_Overflow__int_connect_socket_square_43 { static void badSource(int &data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } void bad() { int data; data = 0; badSource(data); { int result = data * data; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSource <start> data <end> );
printIntLine <start> result <end> );"	"data = <start> atoi(inputBuffer) <end> ;
printIntLine <start> result <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printIntLine(result) <end> ;
badSource <start> data <end> );"	"int result = <start> data * data <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	0
8a6310bf-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_file_open_15 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; switch(6) { case 6: { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } break; default: printLine(""Benign, fixed string""); break; } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
<start> data = dataBuffer <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = OPEN(data, O_RDWR|O_CREAT, <start> S_IREAD|S_IWRITE <end> );"	2
9059f3ca-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 256 void CWE681_Incorrect_Conversion_Between_Numeric_Types__double2int_09_bad() { if(GLOBAL_CONST_TRUE) { { char inputBuffer[CHAR_ARRAY_SIZE]; double doubleNumber = 0; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { doubleNumber = atof(inputBuffer); } else { printLine(""fgets() failed.""); } printIntLine((int)doubleNumber); } } }"	where is the vulnerable dataflow from (int)doubleNumber to printIntLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> (int)doubleNumber <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
doubleNumber = <start> atof(inputBuffer) <end> ;"	"printIntLine <start> (int)doubleNumber <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"<start> doubleNumber = atof(inputBuffer) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	0
a23a3e48-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } void CWE190_Integer_Overflow__int_fgets_square_08_bad() { int data; data = 0; if(staticReturnsTrue()) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(staticReturnsTrue()) { { int result = data * data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
int <start> result = data * data <end> ;"	"<start> printIntLine(result) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;"	2
4b34afce-6c15-11ed-81d4-94e6f77dd552	"static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; void CWE190_Integer_Overflow__short_fscanf_multiply_04_bad() { short data; data = 0; if(STATIC_CONST_TRUE) { fscanf (stdin, ""%hd"", &data); } if(STATIC_CONST_TRUE) { if(data > 0) { short result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
short result = <start> data <end>  * 2;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
short result = <start> data <end>  * 2;"	"<start> printIntLine(result) <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );"	"short result = <start> data <end>  * 2;
if <start> data > 0 <end> ) ;"	1
af580927-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int badStatic = 0; static int badSource(int data) { if(badStatic) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } return data; } void CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_21_bad() { int data; data = -1; badStatic = 1; data = badSource(data); { char charData = (char)data; printHexCharLine(charData); } }"	where is the vulnerable dataflow from charData to printHexCharLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static int <start> badSource <end> (int data);
data = <start> badSource <end> (data);
printHexCharLine <start> charData <end> );"	"<start> printHexCharLine(charData) <end> ;
data = <start> badSource <end> (data);
printHexCharLine <start> charData <end> );
static int <start> badSource <end> (int data);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printHexCharLine <start> charData <end> );
static int <start> badSource <end> (int data);"	"recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);
printHexCharLine <start> charData <end> );
static int <start> badSource <end> (int data);
data = <start> badSource <end> (data);"	0
c39a65b6-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif namespace CWE23_Relative_Path_Traversal__char_environment_ofstream_21 { static int badStatic = 0; static char * badSource(char * data) { if(badStatic) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } } return data; } void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; badStatic = 1; data = badSource(data); { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } ; }"	where is the vulnerable dataflow from data to open ?	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
size_t <start> dataLen = strlen(data) <end> ;"	"outputFile.open((char * <start> data <end> );
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
outputFile.open((char * <start> data <end> );"	"size_t dataLen = <start> strlen(data) <end> ;
outputFile.open((char * <start> data <end> );
data = <start> badSource <end> (data);
static char * <start> badSource <end> (char * data);"	2
4a021147-6c15-11ed-81d4-94e6f77dd552	"void CWE190_Integer_Overflow__short_fscanf_add_01_bad() { short data; data = 0; fscanf (stdin, ""%hd"", &data); { short result = data + 1; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"short result = <start> data <end>  + 1;
fscanf (stdin, ""%hd"", <start> &data <end> );"	"fscanf (stdin, ""%hd"", <start> &data <end> );
short result = <start> data <end>  + 1;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
<start> printIntLine(result) <end> ;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
short result = <start> data + 1 <end> ;"	1
acf67e56-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_fgets_predec_53d_badSink(int data) { { --data; int result = data; printIntLine(result); } }	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;"	"void CWE191_Integer_Underflow__int_fgets_predec_53d_badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
int <start> result = data <end> ;"	"printIntLine <start> result <end> );
void CWE191_Integer_Underflow__int_fgets_predec_53d_badSink(int <start> data <end> );"	1
a49c4f5a-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__int_listen_socket_multiply_72 { void badSink(vector<int> dataVector) { int data = dataVector[2]; if(data > 0) { int result = data * 2; printIntLine(result); } }	where is the vulnerable dataflow from result to printIntLine ?	"void badSink(vector<int> <start> dataVector <end> );
printIntLine <start> result <end> );"	"int <start> result = data * 2 <end> ;
printIntLine <start> result <end> );"	"void badSink(vector<int> <start> dataVector <end> );
int <start> result = data * 2 <end> ;"	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;"	0
b68484e4-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif namespace CWE36_Absolute_Path_Traversal__char_file_open_81 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } const CWE36_Absolute_Path_Traversal__char_file_open_81_base& baseObject = CWE36_Absolute_Path_Traversal__char_file_open_81_bad(); baseObject.action(data); }"	where is the vulnerable dataflow from data to action ?	"baseObject.action <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
baseObject.action <start> data <end> );"	"char <start> dataBuffer[FILENAME_MAX] = """" <end> ;
baseObject.action <start> data <end> );"	"size_t dataLen = <start> strlen(data) <end> ;
baseObject.action <start> data <end> );"	1
a49c4f8c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE190_Integer_Overflow__int_listen_socket_square_81 { void bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } const CWE190_Integer_Overflow__int_listen_socket_square_81_base& baseObject = CWE190_Integer_Overflow__int_listen_socket_square_81_bad(); baseObject.action(data); }"	where is the vulnerable dataflow from data to action ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
baseObject.action <start> data <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
if  <start> recvResult == SOCKET_ERROR <end>  || recvResult == 0);"	"baseObject.action <start> data <end> );
recvResult = recv(acceptSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
data = <start> atoi(inputBuffer) <end> ;"	0
b6848506-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define NEW_PATH ""%SystemRoot%\\system32"" #define PUTENV _putenv #else #define NEW_PATH ""/bin"" #define PUTENV putenv #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" void CWE427_Uncontrolled_Search_Path_Element__char_connect_socket_15_bad() { char * data; char dataBuffer[250] = ""PATH=""; data = dataBuffer; switch(6) { case 6: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (250 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; default: printLine(""Benign, fixed string""); break; } PUTENV(data); }"	where is the vulnerable dataflow from data to PUTENV ?	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (250 - dataLen - 1), 0);
PUTENV <start> data <end> );"	"<start> PUTENV(data) <end> ;
PUTENV <start> data <end> );"	"char <start> dataBuffer[250] = ""PATH="" <end> ;
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (250 - dataLen - 1), 0);"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (250 - dataLen - 1), 0);
size_t dataLen = <start> strlen(data) <end> ;"	0
453db03b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_square_10_bad() { int data; data = 0; if(globalTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalTrue) { { int result = data * data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  * data;
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"data = <start> atoi(inputBuffer) <end> ;
int result = <start> data <end>  * data;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  * data;"	"int result = <start> data <end>  * data;
recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);"	2
a6fd8284-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_FIVE = 5; void CWE190_Integer_Overflow__int_listen_socket_preinc_06_bad() { int data; data = 0; if(STATIC_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(STATIC_CONST_FIVE==5) { { ++data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
int <start> result = data <end> ;"	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> result <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	2
9d74537f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink(int data) { { int buffer[10] = { 0 }; if (data >= 0) { printIntLine(buffer[data]); } else { printLine(""ERROR: Array index is negative""); } } } void CWE126_Buffer_Overread__CWE129_listen_socket_41_bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badSink(data); }"	where is the vulnerable dataflow from buffer[data] to printIntLine ?	"badSink <start> data <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[data] <end> );
<start> badSink(data) <end> ;"	"<start> printIntLine(buffer[data]) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[data] <end> );
static void badSink(int <start> data <end> );"	"badSink <start> data <end> );
printIntLine <start> buffer[data] <end> );
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
static void badSink(int <start> data <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSink <start> data <end> );
static void badSink(int <start> data <end> );
printIntLine <start> buffer[data] <end> );"	3
b7b09a54-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define NEW_PATH ""%SystemRoot%\\system32"" #define PUTENV _putenv #else #define NEW_PATH ""/bin"" #define PUTENV putenv #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif static const int STATIC_CONST_FIVE = 5; void CWE427_Uncontrolled_Search_Path_Element__char_file_06_bad() { char * data; char dataBuffer[250] = ""PATH=""; data = dataBuffer; if(STATIC_CONST_FIVE==5) { { size_t dataLen = strlen(data); FILE * pFile; if (250-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(250-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } PUTENV(data); }"	where is the vulnerable dataflow from data to PUTENV ?	"PUTENV <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(250-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(250-dataLen), pFile) == NULL);
PUTENV <start> data <end> );"	"size_t dataLen = <start> strlen(data) <end> ;
PUTENV <start> data <end> );"	"<start> PUTENV(data) <end> ;
PUTENV <start> data <end> );"	1
6dc614d2-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" extern char * CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_68_badData; extern char * CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_68_goodG2BData; extern char * CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_68_goodB2GData; static void badVaSink(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_68b_badSink() { char * data = CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_68_badData; badVaSink(data, data); }"	where is the vulnerable dataflow from data to vfprintf ?	"badVaSink <start> data <end> , data);
<start> vfprintf(stdout, data, args) <end> ;
static void badVaSink(char * <start> data <end> , ...);
char * data = <start> CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_68_badData <end> ;"	"char * data = <start> CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_68_badData <end> ;
static void badVaSink(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);
badVaSink <start> data <end> , data);"	"char * data = <start> CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_68_badData <end> ;
badVaSink <start> data <end> , data);"	"char * data = <start> CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_68_badData <end> ;
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);"	3
525b644a-6c15-11ed-81d4-94e6f77dd552	"static int CWE190_Integer_Overflow__int_fscanf_preinc_45_badData; static int CWE190_Integer_Overflow__int_fscanf_preinc_45_goodG2BData; static int CWE190_Integer_Overflow__int_fscanf_preinc_45_goodB2GData; static void badSink() { int data = CWE190_Integer_Overflow__int_fscanf_preinc_45_badData; { ++data; int result = data; printIntLine(result); } } void CWE190_Integer_Overflow__int_fscanf_preinc_45_bad() { int data; data = 0; fscanf(stdin, ""%d"", &data); CWE190_Integer_Overflow__int_fscanf_preinc_45_badData = data; badSink(); }"	where is the vulnerable dataflow from data ?	"int data = <start> CWE190_Integer_Overflow__int_fscanf_preinc_45_badData <end> ;
+ <start> data <end> ;
<start> CWE190_Integer_Overflow__int_fscanf_preinc_45_badData = data <end> ;"	"<start> CWE190_Integer_Overflow__int_fscanf_preinc_45_badData = data <end> ;
+ <start> data <end> ;
int data = <start> CWE190_Integer_Overflow__int_fscanf_preinc_45_badData <end> ;
static int <start> CWE190_Integer_Overflow__int_fscanf_preinc_45_badData <end> ;
fscanf(stdin, ""%d"", <start> &data <end> );"	"<start> CWE190_Integer_Overflow__int_fscanf_preinc_45_badData = data <end> ;
+ <start> data <end> ;
int data = <start> CWE190_Integer_Overflow__int_fscanf_preinc_45_badData <end> ;
fscanf(stdin, ""%d"", <start> &data <end> );"	"fscanf(stdin, ""%d"", <start> &data <end> );
<start> CWE190_Integer_Overflow__int_fscanf_preinc_45_badData = data <end> ;
static int <start> CWE190_Integer_Overflow__int_fscanf_preinc_45_badData <end> ;
int data = <start> CWE190_Integer_Overflow__int_fscanf_preinc_45_badData <end> ;
+ <start> data <end> ;"	3
833ac933-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif static int staticFive = 5; namespace CWE23_Relative_Path_Traversal__char_listen_socket_open_07 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(staticFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
size_t dataLen = <start> strlen(data) <end> ;"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN(data, O_RDWR|O_CREAT, <start> S_IREAD|S_IWRITE <end> );"	1
c5fc2376-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_file_open_15 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; switch(6) { case 6: { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } break; default: printLine(""Benign, fixed string""); break; } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
char <start> dataBuffer[FILENAME_MAX] = BASEPATH <end> ;"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = OPEN(data, O_RDWR|O_CREAT, <start> S_IREAD|S_IWRITE <end> );"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
size_t dataLen = <start> strlen(data) <end> ;"	2
acf67e20-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_connect_socket_predec_12_bad() { int data; data = 0; if(globalReturnsTrueOrFalse()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } else { data = -2; } if(globalReturnsTrueOrFalse()) { { --data; int result = data; printIntLine(result); } } else { if (data > INT_MIN) { --data; int result = data; printIntLine(result); } else { printLine(""data value is too large to perform arithmetic safely.""); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printIntLine(result) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"if  <start> data > INT_MIN <end> );
printIntLine <start> result <end> );"	"<start> data = atoi(inputBuffer) <end> ;
printIntLine <start> result <end> );"	1
48d25d95-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__int_fscanf_square_66b_badSink(int dataArray[]) { int data = dataArray[2]; { int result = data * data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
void CWE190_Integer_Overflow__int_fscanf_square_66b_badSink(int <start> dataArray <end> []);"	"int <start> result = data * data <end> ;
void CWE190_Integer_Overflow__int_fscanf_square_66b_badSink(int <start> dataArray <end> []);"	"void CWE190_Integer_Overflow__int_fscanf_square_66b_badSink(int <start> dataArray <end> []);
int result = <start> data * data <end> ;"	"void CWE190_Integer_Overflow__int_fscanf_square_66b_badSink(int <start> dataArray <end> []);
int result = <start> data <end>  * data;"	3
669edac1-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__char_rand_postinc_18_bad() { char data; data = ' '; goto source; source: data = (char)RAND32(); goto sink; sink: { data++; char result = data; printHexCharLine(result); } }	where is the vulnerable dataflow from data ?	"<start> printHexCharLine(result) <end> ;
<start> data <end> ++;"	"char <start> result = data <end> ;
data = (char <start> RAND32() <end> ;"	"<start> data <end> ++;
data = (char <start> RAND32() <end> ;"	"data = (char <start> RAND32() <end> ;
<start> data <end> ++;"	3
cbf237cb-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif static const int STATIC_CONST_FIVE = 5; namespace CWE36_Absolute_Path_Traversal__char_console_ifstream_06 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(STATIC_CONST_FIVE==5) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
inputFile.open((char * <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
size_t dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
<start> data = dataBuffer <end> ;"	"inputFile.open((char * <start> data <end> );
dataLen = <start> strlen(data) <end> ;"	0
af58093f-6c15-11ed-81d4-94e6f77dd552	namespace CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_81 { void CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_81_bad::action(int data) const { { char charData = (char)data; printHexCharLine(charData); } } }	where is the vulnerable dataflow from charData to printHexCharLine ?	"void CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_81_bad::action(int <start> data <end> ) const;
printHexCharLine <start> charData <end> );"	"printHexCharLine <start> charData <end> );
char <start> charData = (char)data <end> ;"	"<start> printHexCharLine(charData) <end> ;
void CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_81_bad::action(int <start> data <end> ) const;"	"printHexCharLine <start> charData <end> );
void CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_81_bad::action(int <start> data <end> ) const;"	0
bed4a8f3-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" namespace CWE23_Relative_Path_Traversal__char_connect_socket_ifstream_45 { static char * badData; static char * goodG2BData; static void badSink() { char * data = badData; { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } } void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badData = data; badSink(); }"	where is the vulnerable dataflow from data to open ?	"inputFile.open((char * <start> data <end> );
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
static char * <start> badData <end> ;
char * data = <start> badData <end> ;
<start> badData = data <end> ;"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
<start> badData = data <end> ;
static char * <start> badData <end> ;
char * data = <start> badData <end> ;
inputFile.open((char * <start> data <end> );"	"inputFile.open((char * <start> data <end> );
char * data = <start> badData <end> ;"	"char * data = <start> badData <end> ;
<start> badData = data <end> ;
inputFile.open((char * <start> data <end> );
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	1
87ff9844-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_connect_socket_fopen_10 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(globalTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
<start> data = dataBuffer <end> ;"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
replace = <start> strchr(data, '\n') <end> ;"	1
c4cd6f64-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_file_fopen_10 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(globalTrue) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = FOPEN <start> data <end> , ""wb+"");
<start> data = dataBuffer <end> ;"	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"size_t dataLen = <start> strlen(data) <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
pFile = FOPEN <start> data <end> , ""wb+"");"	3
a49c4f64-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; void CWE190_Integer_Overflow__int_listen_socket_square_04_bad() { int data; data = 0; if(STATIC_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(STATIC_CONST_TRUE) { { int result = data * data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"if  <start> acceptSocket == SOCKET_ERROR <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;"	"if  <start> acceptSocket == SOCKET_ERROR <end> );
printIntLine <start> result <end> );"	1
bb49c591-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #define EXECL _execl #else #define EXECL execl #endif static char * badSource(char * data) { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } return data; } void CWE78_OS_Command_Injection__char_console_execl_42_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; data = badSource(data); EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECL ?	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
static char * <start> badSource <end> (char * data);
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
static char * <start> badSource <end> (char * data);
<start> EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL) <end> ;
data = <start> badSource <end> (data);"	"EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
data = <start> badSource <end> (data);
dataLen = <start> strlen(data) <end> ;
static char * <start> badSource <end> (char * data);"	1
598370d8-6c15-11ed-81d4-94e6f77dd552	void CWE191_Integer_Underflow__short_fscanf_sub_65b_badSink(short data) { { short result = data - 1; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
void CWE191_Integer_Underflow__short_fscanf_sub_65b_badSink(short <start> data <end> );"	"void CWE191_Integer_Underflow__short_fscanf_sub_65b_badSink(short <start> data <end> );
short <start> result = data - 1 <end> ;"	"void CWE191_Integer_Underflow__short_fscanf_sub_65b_badSink(short <start> data <end> );
short result = <start> data <end>  - 1;"	"short result = <start> data <end>  - 1;
<start> printIntLine(result) <end> ;"	2
c4cd6f83-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif namespace CWE23_Relative_Path_Traversal__char_file_ifstream_01 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
inputFile.open((char * <start> data <end> );"	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"inputFile.open((char * <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"inputFile.open((char * <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	0
48d25d8b-6c15-11ed-81d4-94e6f77dd552	"static void badSink(int data) { { int result = data * data; printIntLine(result); } } void CWE190_Integer_Overflow__int_fscanf_square_44_bad() { int data; void (*funcPtr) (int) = badSink; data = 0; fscanf(stdin, ""%d"", &data); funcPtr(data); }"	where is the vulnerable dataflow from data ?	"fscanf(stdin, ""%d"", <start> &data <end> );
static void badSink(int <start> data <end> );
<start> printIntLine(result) <end> ;
int result = <start> data <end>  * data;"	"int result = <start> data <end>  * data;
fscanf(stdin, ""%d"", <start> &data <end> );
<start> funcPtr(data) <end> ;
funcPtr <start> data <end> );"	"fscanf(stdin, ""%d"", <start> &data <end> );
funcPtr <start> data <end> );
static void badSink(int <start> data <end> );
int result = <start> data <end>  * data;"	"fscanf(stdin, ""%d"", <start> &data <end> );
int result = <start> data <end>  * data;
funcPtr <start> data <end> );
<start> printIntLine(result) <end> ;"	2
c8600b0c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_listen_socket_open_41 { void badSink(char * data) { { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } } void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badSink(data); }"	where is the vulnerable dataflow from data to badSink ?	"badSink <start> data <end> );
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"badSink <start> data <end> );
replace = <start> strchr(data, '\n') <end> ;"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
<start> badSink(data) <end> ;"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
badSink <start> data <end> );"	3
8b91e45a-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_listen_socket_fopen_44 { static void badSink(char * data) { { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } } void bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } funcPtr(data); }"	where is the vulnerable dataflow from data to FOPEN ?	"size_t dataLen = <start> strlen(data) <end> ;
funcPtr <start> data <end> );
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	"static void badSink(char * <start> data <end> );
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = <start> FOPEN(data, ""wb+"") <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
funcPtr <start> data <end> );"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
funcPtr <start> data <end> );
static void badSink(char * <start> data <end> );
pFile = FOPEN <start> data <end> , ""wb+"");"	3
5e44fc9d-6c15-11ed-81d4-94e6f77dd552	"void CWE191_Integer_Underflow__int_fscanf_predec_18_bad() { int data; data = 0; goto source; source: fscanf(stdin, ""%d"", &data); goto sink; sink: { --data; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"fscanf(stdin, ""%d"", <start> &data <end> );
- <start> data <end> ;"	"fscanf(stdin, ""%d"", <start> &data <end> );
<start> printIntLine(result) <end> ;"	"int <start> result = data <end> ;
- <start> data <end> ;"	"<start> --data <end> ;
fscanf(stdin, ""%d"", <start> &data <end> );"	0
630ae808-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__short_rand_square_13_bad() { short data; data = 0; if(GLOBAL_CONST_FIVE==5) { data = (short)RAND32(); } if(GLOBAL_CONST_FIVE==5) { { short result = data * data; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"short result = <start> data <end>  * data;
<start> printIntLine(result) <end> ;"	"short <start> result = data * data <end> ;
data = (short <start> RAND32() <end> ;"	"data = (short <start> RAND32() <end> ;
short result = <start> data <end>  * data;"	"short result = <start> data <end>  * data;
data = (short <start> RAND32() <end> ;"	2
445c11ff-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink(int data) { { int result = data + 1; printIntLine(result); } } void CWE190_Integer_Overflow__int_connect_socket_add_44_bad() { int data; void (*funcPtr) (int) = badSink; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } funcPtr(data); }"	where is the vulnerable dataflow from data ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
funcPtr <start> data <end> );
static void badSink(int <start> data <end> );
int result = <start> data <end>  + 1;"	"<start> funcPtr(data) <end> ;
funcPtr <start> data <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static void badSink(int <start> data <end> );"	"funcPtr <start> data <end> );
int result = <start> data <end>  + 1;
recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);
static void badSink(int <start> data <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
funcPtr <start> data <end> );
data = <start> atoi(inputBuffer) <end> ;
static void badSink(int <start> data <end> );"	0
584fa889-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_listen_socket_sub_63b_badSink(int * dataPtr) { int data = *dataPtr; { int result = data - 1; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"void CWE191_Integer_Underflow__int_listen_socket_sub_63b_badSink(int * <start> dataPtr <end> );
int <start> result = data - 1 <end> ;"	"void CWE191_Integer_Underflow__int_listen_socket_sub_63b_badSink(int * <start> dataPtr <end> );
int result = <start> data <end>  - 1;"	"int result = <start> data <end>  - 1;
void CWE191_Integer_Underflow__int_listen_socket_sub_63b_badSink(int * <start> dataPtr <end> );"	"void CWE191_Integer_Underflow__int_listen_socket_sub_63b_badSink(int * <start> dataPtr <end> );
<start> printIntLine(result) <end> ;"	1
6dc61508-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif static const int STATIC_CONST_FIVE = 5; void CWE134_Uncontrolled_Format_String__char_console_snprintf_06_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; if(STATIC_CONST_FIVE==5) { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } if(STATIC_CONST_FIVE==5) { { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } } }"	where is the vulnerable dataflow from dest to printLine ?	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
printLine <start> dest <end> );"	"printLine <start> dest <end> );
dataLen = <start> strlen(data) <end> ;"	"char <start> dest[100] = """" <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	"printLine <start> dest <end> );
<start> data = dataBuffer <end> ;"	0
7ae3a74c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_54e_badSink(int data) { { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"printLine <start> dest <end> );
if  <start> data < 100 <end> );"	"printLine <start> dest <end> );
<start> strncpy(dest, source, data) <end> ;"	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	"void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_54e_badSink(int <start> data <end> );
printLine <start> dest <end> );"	3
774f5807-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 8 void CWE194_Unexpected_Sign_Extension__listen_socket_malloc_02_bad() { short data; data = 0; if(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }"	where is the vulnerable dataflow from data to malloc ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
char * dataBuffer = (char *)malloc <start> data <end> );"	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
char * dataBuffer = (char *)malloc <start> data <end> );"	"char * dataBuffer = (char *)malloc <start> data <end> );
<start> printLine(dataBuffer) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data = -1 <end> ;"	0
a5ce1c55-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_postinc_10_bad() { int data; data = 0; if(globalTrue) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(globalTrue) { { data++; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;"	"<start> data = 0 <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"int <start> result = data <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );"	3
715a3c08-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 static void badVaSinkB(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_03_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; if(5==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(5==5) { badVaSinkB(data, data); } }"	where is the vulnerable dataflow from data to vfprintf ?	"badVaSinkB <start> data <end> , data);
vfprintf(stdout, <start> data <end> , args);
static void badVaSinkB(char * <start> data <end> , ...);
recvResult = <start> recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0) <end> ;"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);"	"size_t dataLen = <start> strlen(data) <end> ;
static void badVaSinkB(char * <start> data <end> , ...);
badVaSinkB <start> data <end> , data);
vfprintf(stdout, <start> data <end> , args);"	"replace = <start> strchr(data, '\r') <end> ;
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);"	1
453db04c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_square_51b_badSink(int data) { { int result = data * data; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  * data;"	"void CWE190_Integer_Overflow__int_connect_socket_square_51b_badSink(int <start> data <end> );
int result = <start> data <end>  * data;"	"int result = <start> data * data <end> ;
void CWE190_Integer_Overflow__int_connect_socket_square_51b_badSink(int <start> data <end> );"	"int <start> result = data * data <end> ;
void CWE190_Integer_Overflow__int_connect_socket_square_51b_badSink(int <start> data <end> );"	1
79b27549-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticTrue = 1; static int staticFalse = 0; void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_05_bad() { int data; data = -1; if(staticTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"<start> memcpy(dest, source, data) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	"printLine <start> dest <end> );
recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);"	0
6dc614dd-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" static const int STATIC_CONST_FIVE = 5; static void badVaSinkB(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_06_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; if(STATIC_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(STATIC_CONST_FIVE==5) { badVaSinkB(data, data); } }"	where is the vulnerable dataflow from data to vprintf ?	"vprintf <start> data <end> , args);
badVaSinkB <start> data <end> , data);"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
vprintf <start> data <end> , args);
badVaSinkB <start> data <end> , data);
size_t dataLen = <start> strlen(data) <end> ;"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);
vprintf <start> data <end> , args);"	"static void badVaSinkB(char * <start> data <end> , ...);
vprintf <start> data <end> , args);
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
badVaSinkB <start> data <end> , data);"	2
cd228135-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; namespace CWE36_Absolute_Path_Traversal__char_console_ofstream_04 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(STATIC_CONST_TRUE) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
outputFile.open((char * <start> data <end> );"	"outputFile.open((char * <start> data <end> );
<start> data = dataBuffer <end> ;"	"outputFile.open((char * <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
dataLen = <start> strlen(data) <end> ;"	0
4ec5d083-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_postinc_51b_badSink(int data) { { data++; int result = data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"void CWE190_Integer_Overflow__int_fgets_postinc_51b_badSink(int <start> data <end> );
<start> printIntLine(result) <end> ;"	"<start> data <end> ++;
void CWE190_Integer_Overflow__int_fgets_postinc_51b_badSink(int <start> data <end> );"	"int <start> result = data <end> ;
<start> data <end> ++;"	"void CWE190_Integer_Overflow__int_fgets_postinc_51b_badSink(int <start> data <end> );
<start> data <end> ++;"	3
b41b8765-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 8 void CWE197_Numeric_Truncation_Error__short_listen_socket_64b_badSink(void * dataVoidPtr) { short * dataPtr = (short *)dataVoidPtr; short data = (*dataPtr); { char charData = (char)data; printHexCharLine(charData); } }"	where is the vulnerable dataflow from charData to printHexCharLine ?	"<start> printHexCharLine(charData) <end> ;
void CWE197_Numeric_Truncation_Error__short_listen_socket_64b_badSink(void * <start> dataVoidPtr <end> );"	"void CWE197_Numeric_Truncation_Error__short_listen_socket_64b_badSink(void * <start> dataVoidPtr <end> );
char charData = <start> (char)data <end> ;"	"printHexCharLine <start> charData <end> );
void CWE197_Numeric_Truncation_Error__short_listen_socket_64b_badSink(void * <start> dataVoidPtr <end> );"	"void CWE197_Numeric_Truncation_Error__short_listen_socket_64b_badSink(void * <start> dataVoidPtr <end> );
printHexCharLine <start> charData <end> );"	3
92bb8a30-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING ""hello"" static size_t CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_45_badData; static size_t CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_45_goodG2BData; static size_t CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_45_goodB2GData; static void badSink() { size_t data = CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_45_badData; { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); } else { printLine(""Input is less than the length of the source string""); } } } void CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_45_bad() { size_t data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = strtoul(inputBuffer, NULL, 0); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_45_badData = data; badSink(); }"	where is the vulnerable dataflow from data to malloc ?	"<start> CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_45_badData = data <end> ;
static size_t <start> CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_45_badData <end> ;
myString = (char *)malloc <start> data*sizeof(char) <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
myString = (char * <start> malloc(data*sizeof(char)) <end> ;"	"size_t data = <start> CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_45_badData <end> ;
myString = (char *)malloc <start> data*sizeof(char) <end> );
<start> CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_45_badData = data <end> ;
static size_t <start> CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_45_badData <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
size_t data = <start> CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_45_badData <end> ;
<start> CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_45_badData = data <end> ;
static size_t <start> CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_45_badData <end> ;
data = <start> strtoul(inputBuffer, NULL, 0) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_45_badData = data <end> ;
static size_t <start> CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_45_badData <end> ;
size_t data = <start> CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_45_badData <end> ;
myString = (char *)malloc <start> data*sizeof(char) <end> );"	3
7e74f34a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_16_bad() { int data; data = -1; while(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> data = atoi(inputBuffer) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"if  <start> data < 100 <end> );
printLine <start> dest <end> );"	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	3
61da66e5-6c15-11ed-81d4-94e6f77dd552	"void CWE190_Integer_Overflow__char_rand_square_15_bad() { char data; data = ' '; switch(6) { case 6: data = (char)RAND32(); break; default: printLine(""Benign, fixed string""); break; } switch(7) { case 7: { char result = data * data; printHexCharLine(result); } break; default: printLine(""Benign, fixed string""); break; } }"	where is the vulnerable dataflow from data ?	"data = (char <start> RAND32() <end> ;
char result = <start> data <end>  * data;"	"char <start> result = data * data <end> ;
data = (char <start> RAND32() <end> ;"	"data = (char <start> RAND32() <end> ;
char result = <start> data * data <end> ;"	"char result = <start> data <end>  * data;
<start> printHexCharLine(result) <end> ;"	0
55ef4cd4-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) typedef union { int unionFirst; int unionSecond; } CWE191_Integer_Underflow__int_fgets_sub_34_unionType; void CWE191_Integer_Underflow__int_fgets_sub_34_bad() { int data; CWE191_Integer_Underflow__int_fgets_sub_34_unionType myUnion; data = 0; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } myUnion.unionFirst = data; { int data = myUnion.unionSecond; { int result = data - 1; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  - 1;"	"int result = <start> data <end>  - 1;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
int result = <start> data <end>  - 1;"	"int result = <start> data - 1 <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	2
4b34b012-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__short_fscanf_square_62 { void badSource(short &data); void bad() { short data; data = 0; badSource(data); { short result = data * data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"badSource <start> data <end> );
short result = <start> data <end>  * data;"	"short result = <start> data <end>  * data;
<start> printIntLine(result) <end> ;"	"badSource <start> data <end> );
short <start> result = data * data <end> ;"	"badSource <start> data <end> );
short result = <start> data * data <end> ;"	0
453db041-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_square_17_bad() { int i,j; int data; data = 0; for(i = 0; i < 1; i++) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } for(j = 0; j < 1; j++) { { int result = data * data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"<start> data = 0 <end> ;
int result = <start> data <end>  * data;"	"int <start> result = data * data <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  * data;"	3
6c938bce-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_15_bad() { int data; data = -1; switch(6) { case 6: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; default: printLine(""Benign, fixed string""); break; } switch(7) { case 7: { int i; int * buffer = (int *)malloc(10 * sizeof(int)); if (buffer == NULL) {exit(-1);} for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } free(buffer); } break; default: printLine(""Benign, fixed string""); break; } }"	where is the vulnerable dataflow from buffer to free ?	"if  <start> listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR <end> );
free <start> buffer <end> );"	"<start> free(buffer) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
free <start> buffer <end> );"	"<start> printIntLine(buffer[i]) <end> ;
free <start> buffer <end> );"	2
b8e2bd93-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define NEW_PATH ""%SystemRoot%\\system32"" #define PUTENV _putenv #else #define NEW_PATH ""/bin"" #define PUTENV putenv #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 void CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_02_bad() { char * data; char dataBuffer[250] = ""PATH=""; data = dataBuffer; if(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (250 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } PUTENV(data); }"	where is the vulnerable dataflow from data to PUTENV ?	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (250 - dataLen - 1), 0);
size_t dataLen = <start> strlen(data) <end> ;"	"size_t dataLen = <start> strlen(data) <end> ;
PUTENV <start> data <end> );"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (250 - dataLen - 1), 0);
PUTENV <start> data <end> );"	"PUTENV <start> data <end> );
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (250 - dataLen - 1), 0);"	2
cf875084-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_environment_open_11 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(globalReturnsTrue()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"<start> data = dataBuffer <end> ;
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
fileDesc = OPEN(data, O_RDWR|O_CREAT, <start> S_IREAD|S_IWRITE <end> );"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
size_t dataLen = <start> strlen(data) <end> ;"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	3
47a2a80a-6c15-11ed-81d4-94e6f77dd552	"static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } void CWE190_Integer_Overflow__int_fscanf_add_08_bad() { int data; data = 0; if(staticReturnsTrue()) { fscanf(stdin, ""%d"", &data); } if(staticReturnsTrue()) { { int result = data + 1; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  + 1;"	"fscanf(stdin, ""%d"", <start> &data <end> );
int result = <start> data <end>  + 1;"	"fscanf(stdin, ""%d"", <start> &data <end> );
<start> printIntLine(result) <end> ;"	"int result = <start> data <end>  + 1;
fscanf(stdin, ""%d"", <start> &data <end> );"	1
87ff9856-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_connect_socket_fopen_61 { char * badSource(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; data = badSource(data); { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
data = <start> badSource <end> (data);"	"data = <start> badSource <end> (data);
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
data = <start> badSource(data) <end> ;"	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	1
d1e9da11-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_file_open_22 { int badGlobal = 0; char * badSource(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; badGlobal = 1; data = badSource(data); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } ; }"	where is the vulnerable dataflow from data to OPEN ?	"data = <start> badSource <end> (data);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"data = <start> badSource <end> (data);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
<start> data = badSource(data) <end> ;"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	1
73bc8139-6c15-11ed-81d4-94e6f77dd552	namespace CWE194_Unexpected_Sign_Extension__connect_socket_malloc_82 { void CWE194_Unexpected_Sign_Extension__connect_socket_malloc_82_bad::action(short data) { if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } } }	where is the vulnerable dataflow from data to malloc ?	"void CWE194_Unexpected_Sign_Extension__connect_socket_malloc_82_bad::action(short <start> data <end> );
char * dataBuffer = (char * <start> malloc(data) <end> ;"	"void CWE194_Unexpected_Sign_Extension__connect_socket_malloc_82_bad::action(short <start> data <end> );
char * dataBuffer = (char *)malloc <start> data <end> );"	"<start> memset(dataBuffer, 'A', data-1) <end> ;
void CWE194_Unexpected_Sign_Extension__connect_socket_malloc_82_bad::action(short <start> data <end> );"	"<start> printLine(dataBuffer) <end> ;
void CWE194_Unexpected_Sign_Extension__connect_socket_malloc_82_bad::action(short <start> data <end> );"	1
7e74f351-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_41_badSink(int data) { { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } } void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_41_bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_41_badSink(data); }"	where is the vulnerable dataflow from dest to printLine ?	"data = <start> atoi(inputBuffer) <end> ;
CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_41_badSink <start> data <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_41_badSink(int <start> data <end> );"	"if  <start> acceptSocket == SOCKET_ERROR <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );
void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_41_badSink(int <start> data <end> );"	"char <start> dest[100] = """" <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );
void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_41_badSink(int <start> data <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_41_badSink <start> data <end> );
void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_41_badSink(int <start> data <end> );
printLine <start> dest <end> );"	3
aa91a19e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_listen_socket_sub_52c_badSink(int data) { { int result = data - 1; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;"	"void CWE191_Integer_Underflow__int_listen_socket_sub_52c_badSink(int <start> data <end> );
<start> printIntLine(result) <end> ;"	"void CWE191_Integer_Underflow__int_listen_socket_sub_52c_badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"int <start> result = data - 1 <end> ;
void CWE191_Integer_Underflow__int_listen_socket_sub_52c_badSink(int <start> data <end> );"	2
93ece2cc-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #define HELLO_STRING ""hello"" namespace CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_73 { void badSink(list<size_t> dataList) { size_t data = dataList.back(); { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); } else { printLine(""Input is less than the length of the source string""); } } }"	where is the vulnerable dataflow from data to malloc ?	"myString = (char *)malloc <start> data*sizeof(char) <end> );
void badSink(list<size_t> <start> dataList <end> );"	"void badSink(list<size_t> <start> dataList <end> );
myString = (char *)malloc <start> data*sizeof(char) <end> );"	"void badSink(list<size_t> <start> dataList <end> );
<start> printLine(myString) <end> ;"	"<start> printLine(myString) <end> ;
myString = (char *)malloc <start> data*sizeof(char) <end> );"	1
abc3751d-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_fgets_postdec_10_bad() { int data; data = 0; if(globalTrue) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(globalTrue) { { data--; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );"	"<start> data = 0 <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"<start> data = atoi(inputBuffer) <end> ;
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
<start> data-- <end> ;"	0
a95fd835-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int badSource(int data) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } return data; } void CWE191_Integer_Underflow__int_fgets_multiply_42_bad() { int data; data = 0; data = badSource(data); if(data < 0) { int result = data * 2; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );
int result = <start> data * 2 <end> ;
static int <start> badSource <end> (int data);"	"printIntLine <start> result <end> );
data = <start> badSource <end> (data);
static int <start> badSource <end> (int data);
<start> printIntLine(result) <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
static int <start> badSource <end> (int data);
printIntLine <start> result <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
static int <start> badSource <end> (int data);
data = <start> badSource <end> (data);
printIntLine <start> result <end> );"	3
4a021104-6c15-11ed-81d4-94e6f77dd552	extern int CWE190_Integer_Overflow__int_listen_socket_multiply_22_badGlobal; void CWE190_Integer_Overflow__int_listen_socket_multiply_22_badSink(int data) { if(CWE190_Integer_Overflow__int_listen_socket_multiply_22_badGlobal) { if(data > 0) { int result = data * 2; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"int <start> result = data * 2 <end> ;
void CWE190_Integer_Overflow__int_listen_socket_multiply_22_badSink(int <start> data <end> );"	"void CWE190_Integer_Overflow__int_listen_socket_multiply_22_badSink(int <start> data <end> );
int result = <start> data <end>  * 2;"	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  * 2;"	"int result = <start> data <end>  * 2;
void CWE190_Integer_Overflow__int_listen_socket_multiply_22_badSink(int <start> data <end> );"	1
656cd412-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__int_rand_square_14_bad() { int data; data = 0; if(globalFive==5) { data = RAND32(); } if(globalFive==5) { { int result = data * data; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"int result = <start> data * data <end> ;
data = <start> RAND32() <end> ;"	"data = <start> RAND32() <end> ;
int result = <start> data <end>  * data;"	"int <start> result = data * data <end> ;
data = <start> RAND32() <end> ;"	"int result = <start> data <end>  * data;
<start> printIntLine(result) <end> ;"	1
d31a24fc-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 namespace CWE36_Absolute_Path_Traversal__char_listen_socket_ofstream_13 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(GLOBAL_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
if  <start> recvResult == SOCKET_ERROR <end>  || recvResult == 0);"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
outputFile.open((char * <start> data <end> );"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
<start> data = dataBuffer <end> ;"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
char <start> dataBuffer[FILENAME_MAX] = """" <end> ;"	1
47a2a851-6c15-11ed-81d4-94e6f77dd552	extern int CWE190_Integer_Overflow__int_fscanf_multiply_68_badData; extern int CWE190_Integer_Overflow__int_fscanf_multiply_68_goodG2BData; extern int CWE190_Integer_Overflow__int_fscanf_multiply_68_goodB2GData; void CWE190_Integer_Overflow__int_fscanf_multiply_68b_badSink() { int data = CWE190_Integer_Overflow__int_fscanf_multiply_68_badData; if(data > 0) { int result = data * 2; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"int data = <start> CWE190_Integer_Overflow__int_fscanf_multiply_68_badData <end> ;
int result = <start> data <end>  * 2;"	"int result = <start> data <end>  * 2;
int data = <start> CWE190_Integer_Overflow__int_fscanf_multiply_68_badData <end> ;"	"int result = <start> data <end>  * 2;
if <start> data > 0 <end> ) ;"	"int <start> result = data * 2 <end> ;
int data = <start> CWE190_Integer_Overflow__int_fscanf_multiply_68_badData <end> ;"	0
b1b80816-6c15-11ed-81d4-94e6f77dd552	namespace CWE197_Numeric_Truncation_Error__int_listen_socket_to_char_73 { void badSink(list<int> dataList) { int data = dataList.back(); { char charData = (char)data; printHexCharLine(charData); } }	where is the vulnerable dataflow from charData to printHexCharLine ?	"void badSink(list<int> <start> dataList <end> );
printHexCharLine <start> charData <end> );"	"char charData = <start> (char)data <end> ;
printHexCharLine <start> charData <end> );"	"printHexCharLine <start> charData <end> );
void badSink(list<int> <start> dataList <end> );"	"char charData = <start> (char)data <end> ;
void badSink(list<int> <start> dataList <end> );"	0
846ad329-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define STAT _stat #define OPEN _open #define WRITE _write #define O_RDWR _O_RDWR #define CLOSE _close #else #define STAT stat #define OPEN open #define WRITE write #define CLOSE close #endif #define BAD_SINK_STRING ""Bad Sink..."" #define GOOD_SINK_STRING ""Good Sink..."" void CWE367_TOC_TOU__stat_14_bad() { if(globalFive==5) { { char filename[100] = """"; struct STAT statBuffer; int fileDesc = -1; if (fgets(filename, 100, stdin) == NULL) { printLine(""fgets() failed""); filename[0] = '\0'; } if (strlen(filename) > 0) { filename[strlen(filename)-1] = '\0'; } if (STAT(filename, &statBuffer) == -1) { exit(1); } fileDesc  = OPEN(filename, O_RDWR); if (fileDesc == -1) { exit(1); } if (WRITE(fileDesc, BAD_SINK_STRING, strlen(BAD_SINK_STRING)) == -1) { exit(1); } if (fileDesc != -1) { CLOSE(fileDesc); } } } }"	where is the vulnerable dataflow from filename to OPEN ?	"if (fgets <start> filename <end> , 100, stdin) == NULL);
fileDesc  = OPEN <start> filename <end> , O_RDWR);"	"fileDesc  = OPEN <start> filename <end> , O_RDWR);
if  <start> strlen(filename) <end>  > 0);"	"if  <start> strlen(filename) <end>  > 0);
if (fgets <start> filename <end> , 100, stdin) == NULL);"	"if (fgets <start> filename <end> , 100, stdin) == NULL);
if  <start> STAT(filename, &statBuffer) <end>  == -1);"	0
c99197d5-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define STAT _stat #define OPEN _open #define WRITE _write #define O_RDWR _O_RDWR #define CLOSE _close #else #define STAT stat #define OPEN open #define WRITE write #define CLOSE close #endif #define BAD_SINK_STRING ""Bad Sink..."" #define GOOD_SINK_STRING ""Good Sink..."" void CWE367_TOC_TOU__stat_18_bad() { goto sink; sink: { char filename[100] = """"; struct STAT statBuffer; int fileDesc = -1; if (fgets(filename, 100, stdin) == NULL) { printLine(""fgets() failed""); filename[0] = '\0'; } if (strlen(filename) > 0) { filename[strlen(filename)-1] = '\0'; } if (STAT(filename, &statBuffer) == -1) { exit(1); } fileDesc  = OPEN(filename, O_RDWR); if (fileDesc == -1) { exit(1); } if (WRITE(fileDesc, BAD_SINK_STRING, strlen(BAD_SINK_STRING)) == -1) { exit(1); } if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from filename to OPEN ?	"filename <start> strlen(filename) <end> -1] = '\0'; ;
fileDesc  = OPEN <start> filename <end> , O_RDWR);"	"if (fgets <start> filename <end> , 100, stdin) == NULL);
fileDesc  = OPEN <start> filename <end> , O_RDWR);"	"if (fgets <start> filename <end> , 100, stdin) == NULL);
filename <start> strlen(filename) <end> -1] = '\0'; ;"	"if (fgets <start> filename <end> , 100, stdin) == NULL);
fileDesc  = <start> OPEN(filename, O_RDWR) <end> ;"	1
8b91e473-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_listen_socket_open_15 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; switch(6) { case 6: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; default: printLine(""Benign, fixed string""); break; } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
if  <start> listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR <end> );"	"replace = <start> strchr(data, '\n') <end> ;
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	0
a36a78dd-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__int_fgets_square_72 { void badSink(vector<int> dataVector) { int data = dataVector[2]; { int result = data * data; printIntLine(result); } }	where is the vulnerable dataflow from result to printIntLine ?	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
void badSink(vector<int> <start> dataVector <end> );"	"void badSink(vector<int> <start> dataVector <end> );
<start> printIntLine(result) <end> ;"	"void badSink(vector<int> <start> dataVector <end> );
printIntLine <start> result <end> );"	3
715a3bba-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif static void badVaSinkB(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_file_vprintf_13_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; if(GLOBAL_CONST_FIVE==5) { { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } if(GLOBAL_CONST_FIVE==5) { badVaSinkB(data, data); } }"	where is the vulnerable dataflow from data to vprintf ?	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
size_t dataLen = <start> strlen(data) <end> ;
badVaSinkB <start> data <end> , data);
vprintf <start> data <end> , args);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
vprintf <start> data <end> , args);
char <start> dataBuffer[100] = """" <end> ;
static void badVaSinkB(char * <start> data <end> , ...);"	"static void badVaSinkB(char * <start> data <end> , ...);
badVaSinkB <start> data <end> , data);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);
vprintf <start> data <end> , args);"	3
7ae3a721-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) int CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_61b_badSource(int data); void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_61_bad() { int data; data = -1; data = CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_61b_badSource(data); { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"data = <start> CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_61b_badSource <end> (data);
printLine <start> dest <end> );"	"if  <start> data < 100 <end> );
data = <start> CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_61b_badSource <end> (data);"	"printLine <start> dest <end> );
char <start> dest[100] = """" <end> ;"	"printLine <start> dest <end> );
<start> printLine(dest) <end> ;"	0
c01af8de-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_connect_socket_open_53 { void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badSink_b(data); }"	where is the vulnerable dataflow from data to badSink_b ?	"badSink_b <start> data <end> );
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - <start> dataLen - 1 <end> ), 0);"	"replace = <start> strchr(data, '\n') <end> ;
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"badSink_b <start> data <end> );
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
badSink_b <start> data <end> );"	3
b1b8083e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_65b_badSink(int data) { { short shortData = (short)data; printShortLine(shortData); } }"	where is the vulnerable dataflow from shortData to printShortLine ?	"void CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_65b_badSink(int <start> data <end> );
short <start> shortData = (short)data <end> ;"	"void CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_65b_badSink(int <start> data <end> );
printShortLine <start> shortData <end> );"	"printShortLine <start> shortData <end> );
void CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_65b_badSink(int <start> data <end> );"	"<start> printShortLine(shortData) <end> ;
printShortLine <start> shortData <end> );"	1
453db044-6c15-11ed-81d4-94e6f77dd552	extern int CWE190_Integer_Overflow__int_connect_socket_square_22_badGlobal; void CWE190_Integer_Overflow__int_connect_socket_square_22_badSink(int data) { if(CWE190_Integer_Overflow__int_connect_socket_square_22_badGlobal) { { int result = data * data; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"int <start> result = data * data <end> ;
void CWE190_Integer_Overflow__int_connect_socket_square_22_badSink(int <start> data <end> );"	"int result = <start> data * data <end> ;
void CWE190_Integer_Overflow__int_connect_socket_square_22_badSink(int <start> data <end> );"	"void CWE190_Integer_Overflow__int_connect_socket_square_22_badSink(int <start> data <end> );
int result = <start> data <end>  * data;"	"int result = <start> data <end>  * data;
<start> printIntLine(result) <end> ;"	2
8cc3a692-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(count) + 2) #ifdef _WIN32 #define SLEEP Sleep #else #define SLEEP usleep #endif void CWE400_Resource_Exhaustion__listen_socket_sleep_13_bad() { int count; count = -1; if(GLOBAL_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; count = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(GLOBAL_CONST_FIVE==5) { SLEEP(count); printLine(""Sleep time possibly too long""); } }"	where is the vulnerable dataflow from count to SLEEP ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
SLEEP <start> count <end> );"	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
SLEEP <start> count <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
if  <start> listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR <end> );"	"count = <start> atoi(inputBuffer) <end> ;
SLEEP <start> count <end> );"	0
b2ea8dbc-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 8 static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } void CWE197_Numeric_Truncation_Error__short_fgets_08_bad() { short data; data = -1; if(staticReturnsTrue()) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = (short)atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } { char charData = (char)data; printHexCharLine(charData); } }"	where is the vulnerable dataflow from charData to printHexCharLine ?	"printHexCharLine <start> charData <end> );
<start> printHexCharLine(charData) <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printHexCharLine <start> charData <end> );"	"char charData = <start> (char)data <end> ;
printHexCharLine <start> charData <end> );"	"<start> printHexCharLine(charData) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	1
80d9870a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_console_fopen_22 { int badGlobal = 0; char * badSource(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; badGlobal = 1; data = badSource(data); { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } ; }"	where is the vulnerable dataflow from data to FOPEN ?	"data = <start> badSource <end> (data);
pFile = FOPEN <start> data <end> , ""wb+"");"	"data = <start> badSource <end> (data);
<start> data = dataBuffer <end> ;"	"pFile = FOPEN <start> data <end> , ""wb+"");
<start> data = badSource(data) <end> ;"	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
data = <start> badSource <end> (data);"	0
6ef7683f-6c15-11ed-81d4-94e6f77dd552	#ifndef _WIN32 #endif static void badVaSink(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_console_vfprintf_63b_badSink(char * * dataPtr) { char * data = *dataPtr; badVaSink(data, data); }	where is the vulnerable dataflow from data to vfprintf ?	"void CWE134_Uncontrolled_Format_String__char_console_vfprintf_63b_badSink(char * * <start> dataPtr <end> );
static void badVaSink(char * <start> data <end> , ...);
badVaSink <start> data <end> , data);
vfprintf(stdout, <start> data <end> , args);"	"badVaSink <start> data <end> , data);
void CWE134_Uncontrolled_Format_String__char_console_vfprintf_63b_badSink(char * * <start> dataPtr <end> );
vfprintf(stdout, <start> data <end> , args);"	"badVaSink <start> data <end> , data);
void CWE134_Uncontrolled_Format_String__char_console_vfprintf_63b_badSink(char * * <start> dataPtr <end> );"	"void CWE134_Uncontrolled_Format_String__char_console_vfprintf_63b_badSink(char * * <start> dataPtr <end> );
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);"	3
7e74f331-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_64b_badSink(void * dataVoidPtr) { int * dataPtr = (int *)dataVoidPtr; int data = (*dataPtr); { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"printLine <start> dest <end> );
<start> memcpy(dest, source, data) <end> ;"	"void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_64b_badSink(void * <start> dataVoidPtr <end> );
<start> printLine(dest) <end> ;"	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	"void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_64b_badSink(void * <start> dataVoidPtr <end> );
printLine <start> dest <end> );"	3
a49c4f7b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int CWE190_Integer_Overflow__int_listen_socket_square_45_badData; static int CWE190_Integer_Overflow__int_listen_socket_square_45_goodG2BData; static int CWE190_Integer_Overflow__int_listen_socket_square_45_goodB2GData; static void badSink() { int data = CWE190_Integer_Overflow__int_listen_socket_square_45_badData; { int result = data * data; printIntLine(result); } } void CWE190_Integer_Overflow__int_listen_socket_square_45_bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE190_Integer_Overflow__int_listen_socket_square_45_badData = data; badSink(); }"	where is the vulnerable dataflow from result to printIntLine ?	"int result = <start> data * data <end> ;
printIntLine <start> result <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int data = <start> CWE190_Integer_Overflow__int_listen_socket_square_45_badData <end> ;
<start> CWE190_Integer_Overflow__int_listen_socket_square_45_badData = data <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> CWE190_Integer_Overflow__int_listen_socket_square_45_badData = data <end> ;
static int <start> CWE190_Integer_Overflow__int_listen_socket_square_45_badData <end> ;
int data = <start> CWE190_Integer_Overflow__int_listen_socket_square_45_badData <end> ;
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
static int <start> CWE190_Integer_Overflow__int_listen_socket_square_45_badData <end> ;
<start> CWE190_Integer_Overflow__int_listen_socket_square_45_badData = data <end> ;
int data = <start> CWE190_Integer_Overflow__int_listen_socket_square_45_badData <end> ;
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"static int <start> CWE190_Integer_Overflow__int_listen_socket_square_45_badData <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	1
cd228158-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } namespace CWE36_Absolute_Path_Traversal__char_console_open_08 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(staticReturnsTrue()) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"size_t dataLen = <start> strlen(data) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	1
a5ce1c57-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_postinc_12_bad() { int data; data = 0; if(globalReturnsTrueOrFalse()) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } else { data = 2; } if(globalReturnsTrueOrFalse()) { { data++; int result = data; printIntLine(result); } } else { if (data < INT_MAX) { data++; int result = data; printIntLine(result); } else { printLine(""data value is too large to perform arithmetic safely.""); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
<start> data = 2 <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
int <start> result = data <end> ;"	"<start> data++ <end> ;
printIntLine <start> result <end> );"	0
55ef4cd1-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int badStatic = 0; static void badSink(int data) { if(badStatic) { { int result = data - 1; printIntLine(result); } } } void CWE191_Integer_Underflow__int_fgets_sub_21_bad() { int data; data = 0; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } badStatic = 1; badSink(data); }"	where is the vulnerable dataflow from data ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
badSink <start> data <end> );
static void badSink(int <start> data <end> );
int result = <start> data <end>  - 1;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
static void badSink(int <start> data <end> );
<start> badSink(data) <end> ;
badSink <start> data <end> );"	"badSink <start> data <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> badSink(data) <end> ;
int result = <start> data <end>  - 1;"	"<start> data = atoi(inputBuffer) <end> ;
static void badSink(int <start> data <end> );
badSink <start> data <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	0
6ef76837-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif static void badVaSink(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_console_vfprintf_44_bad() { char * data; void (*funcPtr) (char *, ...) = badVaSink; char dataBuffer[100] = """"; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } funcPtr(data, data); }"	where is the vulnerable dataflow from data to vfprintf ?	"static void badVaSink(char * <start> data <end> , ...);
funcPtr <start> data <end> , data);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
<start> vfprintf(stdout, data, args) <end> ;"	"<start> funcPtr(data, data) <end> ;
vfprintf(stdout, <start> data <end> , args);
funcPtr <start> data <end> , data);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	"funcPtr <start> data <end> , data);
dataLen = <start> strlen(data) <end> ;
vfprintf(stdout, <start> data <end> , args);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
funcPtr <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);"	3
a23a3e24-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_multiply_16_bad() { int data; data = 0; while(1) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } break; } while(1) { if(data > 0) { int result = data * 2; printIntLine(result); } break; } }"	where is the vulnerable dataflow from result to printIntLine ?	"<start> data = atoi(inputBuffer) <end> ;
printIntLine <start> result <end> );"	"int result = <start> data * 2 <end> ;
printIntLine <start> result <end> );"	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );"	3
7e74f324-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) typedef union { int unionFirst; int unionSecond; } CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_34_unionType; void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_34_bad() { int data; CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_34_unionType myUnion; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } myUnion.unionFirst = data; { int data = myUnion.unionSecond; { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } } }"	where is the vulnerable dataflow from dest to printLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"if  <start> recvResult == SOCKET_ERROR <end>  || recvResult == 0);
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"printLine <start> dest <end> );
if  <start> recvResult == SOCKET_ERROR <end>  || recvResult == 0);"	"printLine <start> dest <end> );
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	0
78800fea-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 8 static short CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_45_badData; static short CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_45_goodG2BData; static void badSink() { short data = CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_45_badData; { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } } void CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_45_bad() { short data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_45_badData = data; badSink(); }"	where is the vulnerable dataflow from dest to printLine ?	"<start> CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_45_badData = data <end> ;
printLine <start> dest <end> );"	"<start> strncpy(dest, source, data) <end> ;
printLine <start> dest <end> );
short data = <start> CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_45_badData <end> ;
<start> CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_45_badData = data <end> ;
static short <start> CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_45_badData <end> ;"	"short <start> data = CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_45_badData <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static short <start> CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_45_badData <end> ;
<start> CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_45_badData = data <end> ;
printLine <start> dest <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_45_badData = data <end> ;
static short <start> CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_45_badData <end> ;
short data = <start> CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_45_badData <end> ;
printLine <start> dest <end> );"	3
c8600ad7-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 namespace CWE23_Relative_Path_Traversal__char_listen_socket_ofstream_01 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"if  <start> acceptSocket == SOCKET_ERROR <end> );
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
size_t dataLen = <start> strlen(data) <end> ;"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
outputFile.open((char * <start> data <end> );"	"outputFile.open((char * <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	2
453db064-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_add_09_bad() { int data; data = 0; if(GLOBAL_CONST_TRUE) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(GLOBAL_CONST_TRUE) { { int result = data + 1; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  + 1;
<start> data = 0 <end> ;"	"int <start> result = data + 1 <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  + 1;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
int result = <start> data <end>  + 1;"	3
c26a7e36-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_console_open_01 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
size_t dataLen = <start> strlen(data) <end> ;"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = OPEN(data, O_RDWR|O_CREAT, <start> S_IREAD|S_IWRITE <end> );"	0
af580949-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticFive = 5; void CWE197_Numeric_Truncation_Error__int_connect_socket_to_short_07_bad() { int data; data = -1; if(staticFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { short shortData = (short)data; printShortLine(shortData); } }"	where is the vulnerable dataflow from shortData to printShortLine ?	"data = <start> atoi(inputBuffer) <end> ;
printShortLine <start> shortData <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printShortLine <start> shortData <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printShortLine(shortData) <end> ;"	"recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);
printShortLine <start> shortData <end> );"	1
7fa68e48-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; namespace CWE23_Relative_Path_Traversal__char_connect_socket_open_04 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(STATIC_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
char <start> dataBuffer[FILENAME_MAX] = BASEPATH <end> ;"	"recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) *  <start> FILENAME_MAX - dataLen - 1 <end> ), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	3
774f57fc-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 8 void CWE194_Unexpected_Sign_Extension__fgets_strncpy_64b_badSink(void * dataVoidPtr) { short * dataPtr = (short *)dataVoidPtr; short data = (*dataPtr); { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"if  <start> data < 100 <end> );
void CWE194_Unexpected_Sign_Extension__fgets_strncpy_64b_badSink(void * <start> dataVoidPtr <end> );"	"void CWE194_Unexpected_Sign_Extension__fgets_strncpy_64b_badSink(void * <start> dataVoidPtr <end> );
printLine <start> dest <end> );"	"<start> strncpy(dest, source, data) <end> ;
void CWE194_Unexpected_Sign_Extension__fgets_strncpy_64b_badSink(void * <start> dataVoidPtr <end> );"	"<start> strncpy(dest, source, data) <end> ;
printLine <start> dest <end> );"	1
453db056-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) extern int CWE190_Integer_Overflow__int_connect_socket_square_68_badData; extern int CWE190_Integer_Overflow__int_connect_socket_square_68_goodG2BData; extern int CWE190_Integer_Overflow__int_connect_socket_square_68_goodB2GData; void CWE190_Integer_Overflow__int_connect_socket_square_68b_badSink() { int data = CWE190_Integer_Overflow__int_connect_socket_square_68_badData; { int result = data * data; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"int data = <start> CWE190_Integer_Overflow__int_connect_socket_square_68_badData <end> ;
<start> printIntLine(result) <end> ;"	"int result = <start> data <end>  * data;
<start> printIntLine(result) <end> ;"	"int data = <start> CWE190_Integer_Overflow__int_connect_socket_square_68_badData <end> ;
int result = <start> data <end>  * data;"	"int data = <start> CWE190_Integer_Overflow__int_connect_socket_square_68_badData <end> ;
int <start> result = data * data <end> ;"	2
b0864105-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE197_Numeric_Truncation_Error__int_listen_socket_to_char_09_bad() { int data; data = -1; if(GLOBAL_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { char charData = (char)data; printHexCharLine(charData); } }"	where is the vulnerable dataflow from charData to printHexCharLine ?	"char <start> charData = (char)data <end> ;
printHexCharLine <start> charData <end> );"	"<start> printHexCharLine(charData) <end> ;
printHexCharLine <start> charData <end> );"	"printHexCharLine <start> charData <end> );
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printHexCharLine <start> charData <end> );"	3
b41b87a0-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 20 #define IP_ADDRESS ""127.0.0.1"" void CWE369_Divide_by_Zero__float_connect_socket_18_bad() { float data; data = 0.0F; goto source; source: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = (float)atof(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } goto sink; sink: { int result = (int)(100.0 / data); printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
<start> data = 0.0F <end> ;"	"printIntLine <start> result <end> );
recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
data = (float <start> atof(inputBuffer) <end> ;"	0
b1b8084c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; void CWE197_Numeric_Truncation_Error__short_connect_socket_04_bad() { short data; data = -1; if(STATIC_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = (short)atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { char charData = (char)data; printHexCharLine(charData); } }"	where is the vulnerable dataflow from charData to printHexCharLine ?	"data = (short <start> atoi(inputBuffer) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printHexCharLine <start> charData <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
char charData = <start> (char)data <end> ;"	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printHexCharLine <start> charData <end> );"	1
584fa881-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink(int data) { { int result = data - 1; printIntLine(result); } } void CWE191_Integer_Underflow__int_listen_socket_sub_44_bad() { int data; void (*funcPtr) (int) = badSink; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } funcPtr(data); }"	where is the vulnerable dataflow from data ?	"if  <start> listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  - 1;
funcPtr <start> data <end> );"	"if  <start> listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR <end> );
int result = <start> data <end>  - 1;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static void badSink(int <start> data <end> );"	"funcPtr <start> data <end> );
int result = <start> data <end>  - 1;
static void badSink(int <start> data <end> );
<start> printIntLine(result) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
funcPtr <start> data <end> );
static void badSink(int <start> data <end> );
int result = <start> data <end>  - 1;"	3
cbf23794-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_connect_socket_open_62 { void badSource(char * &data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; badSource(data); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"badSource <start> data <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
badSource <start> data <end> );"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
<start> badSource(data) <end> ;"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	0
acf67e52-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink(int data) { { --data; int result = data; printIntLine(result); } } void CWE191_Integer_Underflow__int_fgets_predec_44_bad() { int data; void (*funcPtr) (int) = badSink; data = 0; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } funcPtr(data); }"	where is the vulnerable dataflow from result to printIntLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
funcPtr <start> data <end> );
static void badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
funcPtr <start> data <end> );
data = <start> atoi(inputBuffer) <end> ;
printIntLine <start> result <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
funcPtr <start> data <end> );
printIntLine <start> result <end> );
static void badSink(int <start> data <end> );"	"int <start> result = data <end> ;
printIntLine <start> result <end> );
funcPtr <start> data <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	0
acf67e24-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_connect_socket_predec_16_bad() { int data; data = 0; while(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; } while(1) { { --data; int result = data; printIntLine(result); } break; } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"int <start> result = data <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"printIntLine <start> result <end> );
<start> data = atoi(inputBuffer) <end> ;"	"printIntLine <start> result <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	0
55ef4ca7-6c15-11ed-81d4-94e6f77dd552	extern int CWE191_Integer_Underflow__int_fgets_multiply_22_badGlobal; void CWE191_Integer_Underflow__int_fgets_multiply_22_badSink(int data) { if(CWE191_Integer_Underflow__int_fgets_multiply_22_badGlobal) { if(data < 0) { int result = data * 2; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"void CWE191_Integer_Underflow__int_fgets_multiply_22_badSink(int <start> data <end> );
int result = <start> data <end>  * 2;"	"void CWE191_Integer_Underflow__int_fgets_multiply_22_badSink(int <start> data <end> );
int result = <start> data * 2 <end> ;"	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  * 2;"	"int result = <start> data <end>  * 2;
void CWE191_Integer_Underflow__int_fgets_multiply_22_badSink(int <start> data <end> );"	0
7d44fca5-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) typedef struct _CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_67_structType { int structFirst; } CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_67_structType; void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_67b_badSink(CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_67_structType myStruct) { int data = myStruct.structFirst; { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"int data = <start> myStruct <end> .structFirst;
printLine <start> dest <end> );
<start> strncpy(dest, source, data) <end> ;"	"printLine <start> dest <end> );
void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_67b_badSink(CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_67_structType <start> myStruct <end> );
<start> strncpy(dest, source, data) <end> ;"	"printLine <start> dest <end> );
int data = <start> myStruct <end> .structFirst;
void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_67b_badSink(CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_67_structType <start> myStruct <end> );"	"void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_67b_badSink(CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_67_structType <start> myStruct <end> );
int data = <start> myStruct <end> .structFirst;
printLine <start> dest <end> );"	3
598370bd-6c15-11ed-81d4-94e6f77dd552	"static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } void CWE191_Integer_Underflow__short_fscanf_sub_08_bad() { short data; data = 0; if(staticReturnsTrue()) { fscanf (stdin, ""%hd"", &data); } if(staticReturnsTrue()) { { short result = data - 1; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );"	"<start> printIntLine(result) <end> ;
short result = <start> data <end>  - 1;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
short result = <start> data <end>  - 1;"	"<start> data = 0 <end> ;
short result = <start> data <end>  - 1;"	2
c26a7e2f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif namespace CWE23_Relative_Path_Traversal__char_console_ofstream_44 { static void badSink(char * data) { { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } } void bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } funcPtr(data); }"	where is the vulnerable dataflow from data to funcPtr ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
<start> funcPtr(data) <end> ;"	"funcPtr <start> data <end> );
dataLen = <start> strlen(data) <end> ;"	"dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
funcPtr <start> data <end> );"	3
b2ea8dbe-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 8 void CWE197_Numeric_Truncation_Error__short_fgets_10_bad() { short data; data = -1; if(globalTrue) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = (short)atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } { char charData = (char)data; printHexCharLine(charData); } }"	where is the vulnerable dataflow from charData to printHexCharLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printHexCharLine <start> charData <end> );"	"<start> printHexCharLine(charData) <end> ;
printHexCharLine <start> charData <end> );"	"char <start> charData = (char)data <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"printHexCharLine <start> charData <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	0
b7b09a5b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define NEW_PATH ""%SystemRoot%\\system32"" #define PUTENV _putenv #else #define NEW_PATH ""/bin"" #define PUTENV putenv #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif void CWE427_Uncontrolled_Search_Path_Element__char_file_13_bad() { char * data; char dataBuffer[250] = ""PATH=""; data = dataBuffer; if(GLOBAL_CONST_FIVE==5) { { size_t dataLen = strlen(data); FILE * pFile; if (250-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(250-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } PUTENV(data); }"	where is the vulnerable dataflow from data to PUTENV ?	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(250-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(250-dataLen), pFile) == NULL);
<start> PUTENV(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(250-dataLen), pFile) == NULL);
PUTENV <start> data <end> );"	"PUTENV <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(250-dataLen), pFile) == NULL);"	2
d44c3fc7-6c15-11ed-81d4-94e6f77dd552	#ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_listen_socket_open_81 { void CWE36_Absolute_Path_Traversal__char_listen_socket_open_81_bad::action(char * data) const { { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } } }	where is the vulnerable dataflow from data to OPEN ?	"void CWE36_Absolute_Path_Traversal__char_listen_socket_open_81_bad::action(char * <start> data <end> ) const;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
void CWE36_Absolute_Path_Traversal__char_listen_socket_open_81_bad::action(char * <start> data <end> ) const;"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);"	"void CWE36_Absolute_Path_Traversal__char_listen_socket_open_81_bad::action(char * <start> data <end> ) const;
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	0
715a3be3-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif void CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_09_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; if(GLOBAL_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(GLOBAL_CONST_TRUE) { { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } } }"	where is the vulnerable dataflow from dest to printLine ?	"size_t dataLen = <start> strlen(data) <end> ;
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"replace = <start> strchr(data, '\r') <end> ;
printLine <start> dest <end> );"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
printLine <start> dest <end> );"	"replace = <start> strchr(data, '\n') <end> ;
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	2
820a46e0-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_file_open_15 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; switch(6) { case 6: { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } break; default: printLine(""Benign, fixed string""); break; } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"<start> data = dataBuffer <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
size_t dataLen = <start> strlen(data) <end> ;"	1
d31a24f9-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 namespace CWE36_Absolute_Path_Traversal__char_listen_socket_ofstream_10 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(globalTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
outputFile.open((char * <start> data <end> );"	"replace = <start> strchr(data, '\n') <end> ;
outputFile.open((char * <start> data <end> );"	"recvResult = recv(acceptSocket, (char *)(data + dataLen), <start> sizeof(char) * (FILENAME_MAX - dataLen - 1) <end> , 0);
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"size_t dataLen = <start> strlen(data) <end> ;
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	0
c72d5d7f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 namespace CWE23_Relative_Path_Traversal__char_listen_socket_ifstream_16 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; while(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; } { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"size_t dataLen = <start> strlen(data) <end> ;
inputFile.open((char * <start> data <end> );"	"inputFile.open((char * <start> data <end> );
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
replace = <start> strchr(data, '\n') <end> ;"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
inputFile.open((char * <start> data <end> );"	3
70279c1b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif namespace CWE134_Uncontrolled_Format_String__char_file_snprintf_82 { void CWE134_Uncontrolled_Format_String__char_file_snprintf_82_bad::action(char * data) { { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> SNPRINTF(dest, 100-1, data) <end> ;
void CWE134_Uncontrolled_Format_String__char_file_snprintf_82_bad::action(char * <start> data <end> );"	"printLine <start> dest <end> );
<start> printLine(dest) <end> ;"	"void CWE134_Uncontrolled_Format_String__char_file_snprintf_82_bad::action(char * <start> data <end> );
printLine <start> dest <end> );"	"SNPRINTF(dest, <start> 100-1 <end> , data);
void CWE134_Uncontrolled_Format_String__char_file_snprintf_82_bad::action(char * <start> data <end> );"	2
b68484e2-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif namespace CWE36_Absolute_Path_Traversal__char_file_ofstream_81 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } const CWE36_Absolute_Path_Traversal__char_file_ofstream_81_base& baseObject = CWE36_Absolute_Path_Traversal__char_file_ofstream_81_bad(); baseObject.action(data); }"	where is the vulnerable dataflow from data to action ?	"baseObject.action <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	"<start> data = dataBuffer <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"baseObject.action <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
baseObject.action <start> data <end> );"	3
7ae3a726-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_66b_badSink(int dataArray[]) { int data = dataArray[2]; { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_66b_badSink(int <start> dataArray <end> []);
char <start> dest[100] = """" <end> ;"	"void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_66b_badSink(int <start> dataArray <end> []);
<start> memmove(dest, source, data) <end> ;"	"printLine <start> dest <end> );
<start> memmove(dest, source, data) <end> ;"	"void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_66b_badSink(int <start> dataArray <end> []);
printLine <start> dest <end> );"	3
70279c06-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif typedef union { char * unionFirst; char * unionSecond; } CWE134_Uncontrolled_Format_String__char_file_snprintf_34_unionType; void CWE134_Uncontrolled_Format_String__char_file_snprintf_34_bad() { char * data; CWE134_Uncontrolled_Format_String__char_file_snprintf_34_unionType myUnion; char dataBuffer[100] = """"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } } }"	where is the vulnerable dataflow from dest to printLine ?	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
printLine <start> dest <end> );"	"<start> printLine(dest) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	"<start> data = dataBuffer <end> ;
printLine <start> dest <end> );"	"<start> data = dataBuffer <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	0
c72d5d7b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 namespace CWE23_Relative_Path_Traversal__char_listen_socket_ifstream_12 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(globalReturnsTrueOrFalse()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } else { strcat(data, ""file.txt""); } { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"size_t dataLen = <start> strlen(data) <end> ;
inputFile.open((char * <start> data <end> );"	"inputFile.open((char * <start> data <end> );
if  <start> recvResult == SOCKET_ERROR <end>  || recvResult == 0);"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
if  <start> recvResult == SOCKET_ERROR <end>  || recvResult == 0);"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
inputFile.open((char * <start> data <end> );"	3
7d44fca7-6c15-11ed-81d4-94e6f77dd552	"namespace CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_72 { void badSink(vector<int> dataVector) { int data = dataVector[2]; { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"if  <start> data < 100 <end> );
printLine <start> dest <end> );"	"<start> strncpy(dest, source, data) <end> ;
void badSink(vector<int> <start> dataVector <end> );"	"void badSink(vector<int> <start> dataVector <end> );
if  <start> data < 100 <end> );"	"void badSink(vector<int> <start> dataVector <end> );
printLine <start> dest <end> );"	3
4a021155-6c15-11ed-81d4-94e6f77dd552	"void CWE190_Integer_Overflow__short_fscanf_add_17_bad() { int i,j; short data; data = 0; for(i = 0; i < 1; i++) { fscanf (stdin, ""%hd"", &data); } for(j = 0; j < 1; j++) { { short result = data + 1; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"fscanf (stdin, ""%hd"", <start> &data <end> );
<start> printIntLine(result) <end> ;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
short result = <start> data <end>  + 1;"	"<start> printIntLine(result) <end> ;
short result = <start> data <end>  + 1;"	"short result = <start> data <end>  + 1;
fscanf (stdin, ""%hd"", <start> &data <end> );"	1
d1e9da0e-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_file_open_17 { void bad() { int i; char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; for(i = 0; i < 1; i++) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
char <start> dataBuffer[FILENAME_MAX] = """" <end> ;"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);"	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	0
a23a3e19-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticTrue = 1; static int staticFalse = 0; void CWE190_Integer_Overflow__int_fgets_multiply_05_bad() { int data; data = 0; if(staticTrue) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(staticTrue) { if(data > 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"int result = <start> data * 2 <end> ;
printIntLine <start> result <end> );"	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	"data = <start> atoi(inputBuffer) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );"	3
c4cd6f4e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_environment_open_61 { char * badSource(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; data = badSource(data); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN(data, O_RDWR|O_CREAT, <start> S_IREAD|S_IWRITE <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"data = <start> badSource <end> (data);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
data = <start> badSource <end> (data);"	1
c5fc236e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif static int staticFive = 5; namespace CWE23_Relative_Path_Traversal__char_file_open_07 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(staticFive==5) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
size_t dataLen = <start> strlen(data) <end> ;"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	2
b2ea8dad-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" extern short CWE197_Numeric_Truncation_Error__short_connect_socket_68_badData; extern short CWE197_Numeric_Truncation_Error__short_connect_socket_68_goodG2BData; void CWE197_Numeric_Truncation_Error__short_connect_socket_68b_badSink() { short data = CWE197_Numeric_Truncation_Error__short_connect_socket_68_badData; { char charData = (char)data; printHexCharLine(charData); } }"	where is the vulnerable dataflow from charData to printHexCharLine ?	"short data = <start> CWE197_Numeric_Truncation_Error__short_connect_socket_68_badData <end> ;
<start> printHexCharLine(charData) <end> ;"	"char <start> charData = (char)data <end> ;
short data = <start> CWE197_Numeric_Truncation_Error__short_connect_socket_68_badData <end> ;"	"short data = <start> CWE197_Numeric_Truncation_Error__short_connect_socket_68_badData <end> ;
printHexCharLine <start> charData <end> );"	"short <start> data = CWE197_Numeric_Truncation_Error__short_connect_socket_68_badData <end> ;
printHexCharLine <start> charData <end> );"	2
7d44fca8-6c15-11ed-81d4-94e6f77dd552	"namespace CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_73 { void badSink(list<int> dataList) { int data = dataList.back(); { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"void badSink(list<int> <start> dataList <end> );
printLine <start> dest <end> );"	"printLine <start> dest <end> );
void badSink(list<int> <start> dataList <end> );"	"<start> printLine(dest) <end> ;
void badSink(list<int> <start> dataList <end> );"	"void badSink(list<int> <start> dataList <end> );
int <start> data = dataList.back() <end> ;"	0
951c5e7c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FULL_COMMAND ""dir "" #else #define FULL_COMMAND ""ls "" #endif #ifdef _WIN32 #define POPEN _popen #define PCLOSE _pclose #else #define POPEN popen #define PCLOSE pclose #endif namespace CWE78_OS_Command_Injection__char_connect_socket_popen_62 { void badSource(char * &data); void bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; badSource(data); { FILE *pipe; pipe = POPEN(data, ""w""); if (pipe != NULL) { PCLOSE(pipe); } } }"	where is the vulnerable dataflow from data to POPEN ?	"badSource <start> data <end> );
pipe = POPEN <start> data <end> , ""w"");"	"badSource <start> data <end> );
<start> badSource(data) <end> ;"	"pipe = POPEN <start> data <end> , ""w"");
badSource <start> data <end> );"	"pipe = POPEN <start> data <end> , ""w"");
<start> data = data_buf <end> ;"	0
c72d5d49-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_listen_socket_fopen_02 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"pFile = FOPEN <start> data <end> , ""wb+"");
size_t dataLen = <start> strlen(data) <end> ;"	"if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );
pFile = FOPEN <start> data <end> , ""wb+"");"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	3
7e74f325-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_41_badSink(int data) { { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } } void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_41_bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_41_badSink(data); }"	where is the vulnerable dataflow from dest to printLine ?	"<start> CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_41_badSink(data) <end> ;
CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_41_badSink <start> data <end> );
printLine <start> dest <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"char <start> dest[100] = """" <end> ;
void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_41_badSink(int <start> data <end> );
CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_41_badSink <start> data <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"printLine <start> dest <end> );
void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_41_badSink(int <start> data <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_41_badSink <start> data <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_41_badSink <start> data <end> );
void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_41_badSink(int <start> data <end> );
printLine <start> dest <end> );"	3
b08640f1-6c15-11ed-81d4-94e6f77dd552	namespace CWE197_Numeric_Truncation_Error__int_fgets_to_short_62 { void badSource(int &data); void bad() { int data; data = -1; badSource(data); { short shortData = (short)data; printShortLine(shortData); } }	where is the vulnerable dataflow from shortData to printShortLine ?	"printShortLine <start> shortData <end> );
<start> printShortLine(shortData) <end> ;"	"printShortLine <start> shortData <end> );
short shortData = <start> (short)data <end> ;"	"badSource <start> data <end> );
printShortLine <start> shortData <end> );"	"printShortLine <start> shortData <end> );
badSource <start> data <end> );"	2
c26a7e5d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_console_open_72 { void badSink(vector<char *> dataVector) { char * data = dataVector[2]; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"void badSink(vector<char *> <start> dataVector <end> );
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
void badSink(vector<char *> <start> dataVector <end> );"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"void badSink(vector<char *> <start> dataVector <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	3
cbf237c4-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_console_fopen_73 { void badSink(list<char *> dataList) { char * data = dataList.back(); { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = FOPEN <start> data <end> , ""wb+"");
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	"pFile = FOPEN <start> data <end> , ""wb+"");
void badSink(list<char *> <start> dataList <end> );"	"void badSink(list<char *> <start> dataList <end> );
pFile = FOPEN <start> data <end> , ""wb+"");"	"char <start> * data = dataList.back() <end> ;
void badSink(list<char *> <start> dataList <end> );"	2
70279c3b-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif namespace CWE134_Uncontrolled_Format_String__char_file_vfprintf_62 { void badSource(char * &data); static void badVaSink(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); va_end(args); } } void bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; badSource(data); badVaSink(data, data); }"	where is the vulnerable dataflow from data to vfprintf ?	"static void badVaSink(char * <start> data <end> , ...);
badVaSink <start> data <end> , data);
<start> vfprintf(stdout, data, args) <end> ;
badSource <start> data <end> );"	"vfprintf(stdout, <start> data <end> , args);
static void badVaSink(char * <start> data <end> , ...);
badSource <start> data <end> );
badVaSink <start> data <end> , data);"	"badSource <start> data <end> );
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);"	"<start> va_start(args, data) <end> ;
badSource <start> data <end> );
vfprintf(stdout, <start> data <end> , args);
static void badVaSink(char * <start> data <end> , ...);"	2
acf67e1e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_connect_socket_predec_10_bad() { int data; data = 0; if(globalTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalTrue) { { --data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"<start> printIntLine(result) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"int <start> result = data <end> ;
printIntLine <start> result <end> );"	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> result <end> );"	0
445c1212-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticTrue = 1; static int staticFalse = 0; void CWE190_Integer_Overflow__int_connect_socket_multiply_05_bad() { int data; data = 0; if(staticTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticTrue) { if(data > 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data * 2 <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
data = <start> atoi(inputBuffer) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  * 2;"	3
69161b43-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__int_rand_preinc_53d_badSink(int data) { { ++data; int result = data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"+ <start> data <end> ;
<start> ++data <end> ;"	"+ <start> data <end> ;
int <start> result = data <end> ;"	"+ <start> data <end> ;
<start> printIntLine(result) <end> ;"	"void CWE190_Integer_Overflow__int_rand_preinc_53d_badSink(int <start> data <end> );
+ <start> data <end> ;"	3
5be3a9aa-6c15-11ed-81d4-94e6f77dd552	"void CWE191_Integer_Underflow__int_fscanf_postdec_03_bad() { int data; data = 0; if(5==5) { fscanf(stdin, ""%d"", &data); } if(5==5) { { data--; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
<start> data <end> --;"	"fscanf(stdin, ""%d"", <start> &data <end> );
<start> data <end> --;"	"<start> printIntLine(result) <end> ;
fscanf(stdin, ""%d"", <start> &data <end> );"	"<start> data <end> --;
fscanf(stdin, ""%d"", <start> &data <end> );"	1
715a3bbc-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif static void badVaSinkB(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_file_vprintf_15_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; switch(6) { case 6: { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } break; default: printLine(""Benign, fixed string""); break; } switch(7) { case 7: badVaSinkB(data, data); break; default: printLine(""Benign, fixed string""); break; } }"	where is the vulnerable dataflow from data to vprintf ?	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
vprintf <start> data <end> , args);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);
vprintf <start> data <end> , args);"	"vprintf <start> data <end> , args);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
badVaSinkB <start> data <end> , data);
<start> data = dataBuffer <end> ;"	"vprintf <start> data <end> , args);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
static void badVaSinkB(char * <start> data <end> , ...);"	1
a23a3e03-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int CWE190_Integer_Overflow__int_fgets_add_45_badData; static int CWE190_Integer_Overflow__int_fgets_add_45_goodG2BData; static int CWE190_Integer_Overflow__int_fgets_add_45_goodB2GData; static void badSink() { int data = CWE190_Integer_Overflow__int_fgets_add_45_badData; { int result = data + 1; printIntLine(result); } } void CWE190_Integer_Overflow__int_fgets_add_45_bad() { int data; data = 0; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } CWE190_Integer_Overflow__int_fgets_add_45_badData = data; badSink(); }"	where is the vulnerable dataflow from result to printIntLine ?	"<start> CWE190_Integer_Overflow__int_fgets_add_45_badData = data <end> ;
printIntLine <start> result <end> );
int data = <start> CWE190_Integer_Overflow__int_fgets_add_45_badData <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> CWE190_Integer_Overflow__int_fgets_add_45_badData = data <end> ;
static int <start> CWE190_Integer_Overflow__int_fgets_add_45_badData <end> ;
int data = <start> CWE190_Integer_Overflow__int_fgets_add_45_badData <end> ;
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
<start> CWE190_Integer_Overflow__int_fgets_add_45_badData = data <end> ;
int data = <start> CWE190_Integer_Overflow__int_fgets_add_45_badData <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
static int <start> CWE190_Integer_Overflow__int_fgets_add_45_badData <end> ;"	"static int <start> CWE190_Integer_Overflow__int_fgets_add_45_badData <end> ;
int data = <start> CWE190_Integer_Overflow__int_fgets_add_45_badData <end> ;
printIntLine <start> result <end> );
<start> CWE190_Integer_Overflow__int_fgets_add_45_badData = data <end> ;"	1
7fa68e58-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_connect_socket_open_22 { int badGlobal = 0; char * badSource(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; badGlobal = 1; data = badSource(data); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } ; }"	where is the vulnerable dataflow from data to OPEN ?	"data = <start> badSource <end> (data);
<start> data = dataBuffer <end> ;"	"data = <start> badSource <end> (data);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
data = <start> badSource <end> (data);"	"fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);
data = <start> badSource <end> (data);"	1
833ac92b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 namespace CWE23_Relative_Path_Traversal__char_listen_socket_ifstream_17 { void bad() { int i; char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; for(i = 0; i < 1; i++) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to sizeof ?	recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);	size_t <start> dataLen = strlen(data) <end> ;	size_t dataLen = <start> strlen(data) <end> ;	char <start> dataBuffer[FILENAME_MAX] = BASEPATH <end> ;	0
74ee23f0-6c15-11ed-81d4-94e6f77dd552	"namespace CWE194_Unexpected_Sign_Extension__connect_socket_strncpy_73 { void badSink(list<short> dataList) { short data = dataList.back(); { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"printLine <start> dest <end> );
<start> strncpy(dest, source, data) <end> ;"	"void badSink(list<short> <start> dataList <end> );
<start> strncpy(dest, source, data) <end> ;"	"if  <start> data < 100 <end> );
printLine <start> dest <end> );"	"void badSink(list<short> <start> dataList <end> );
printLine <start> dest <end> );"	3
4b34afcf-6c15-11ed-81d4-94e6f77dd552	"static int staticTrue = 1; static int staticFalse = 0; void CWE190_Integer_Overflow__short_fscanf_multiply_05_bad() { short data; data = 0; if(staticTrue) { fscanf (stdin, ""%hd"", &data); } if(staticTrue) { if(data > 0) { short result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"short result = <start> data <end>  * 2;
fscanf (stdin, ""%hd"", <start> &data <end> );"	"<start> data = 0 <end> ;
short result = <start> data <end>  * 2;"	"short <start> result = data * 2 <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );"	"fscanf (stdin, ""%hd"", <start> &data <end> );
short result = <start> data <end>  * 2;"	3
8cc3a672-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(count) + 2) #ifdef _WIN32 #define SLEEP Sleep #else #define SLEEP usleep #endif void CWE400_Resource_Exhaustion__fgets_sleep_11_bad() { int count; count = -1; if(globalReturnsTrue()) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { count = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(globalReturnsTrue()) { SLEEP(count); printLine(""Sleep time possibly too long""); } }"	where is the vulnerable dataflow from count to SLEEP ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
SLEEP <start> count <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> count = atoi(inputBuffer) <end> ;"	"SLEEP <start> count <end> );
<start> SLEEP(count) <end> ;"	"count = <start> atoi(inputBuffer) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	0
cbf237c8-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif namespace CWE36_Absolute_Path_Traversal__char_console_ifstream_03 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(5==5) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
inputFile.open((char * <start> data <end> );"	"inputFile.open((char * <start> data <end> );
char <start> dataBuffer[FILENAME_MAX] = """" <end> ;"	"<start> data = dataBuffer <end> ;
inputFile.open((char * <start> data <end> );"	"dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	0
c5fc2338-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif namespace CWE23_Relative_Path_Traversal__char_file_ifstream_15 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; switch(6) { case 6: { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } break; default: printLine(""Benign, fixed string""); break; } { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
inputFile.open((char * <start> data <end> );"	"char <start> dataBuffer[FILENAME_MAX] = BASEPATH <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"size_t dataLen = <start> strlen(data) <end> ;
inputFile.open((char * <start> data <end> );"	"inputFile.open((char * <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	0
b7b09a2c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define NEW_PATH ""%SystemRoot%\\system32"" #define PUTENV _putenv #else #define NEW_PATH ""/bin"" #define PUTENV putenv #endif void CWE427_Uncontrolled_Search_Path_Element__char_console_02_bad() { char * data; char dataBuffer[250] = ""PATH=""; data = dataBuffer; if(1) { { size_t dataLen = strlen(data); if (250-dataLen > 1) { if (fgets(data+dataLen, (int)(250-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } PUTENV(data); }"	where is the vulnerable dataflow from data to PUTENV ?	"if (fgets <start> data+dataLen <end> , (int)(250-dataLen), stdin) != NULL);
if (dataLen > 0 && <start> data[dataLen-1] == '\n' <end> );"	"<start> data = dataBuffer <end> ;
PUTENV <start> data <end> );"	"char <start> dataBuffer[250] = ""PATH="" <end> ;
PUTENV <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(250-dataLen), stdin) != NULL);
PUTENV <start> data <end> );"	3
4db33f65-6c15-11ed-81d4-94e6f77dd552	"static int64_t badSource(int64_t data) { fscanf (stdin, ""%"" SCNd64, &data); return data; } void CWE190_Integer_Overflow__int64_t_fscanf_postinc_42_bad() { int64_t data; data = 0LL; data = badSource(data); { data++; int64_t result = data; printLongLongLine(result); } }"	where is the vulnerable dataflow from data ?	"fscanf (stdin, ""%"" SCNd64, <start> &data <end> );
static int64_t <start> badSource <end> (int64_t data);
<start> data <end> ++;
data = <start> badSource <end> (data);"	"static int64_t <start> badSource <end> (int64_t data);
fscanf (stdin, ""%"" SCNd64, <start> &data <end> );"	"fscanf (stdin, ""%"" SCNd64, <start> &data <end> );
static int64_t <start> badSource <end> (int64_t data);
data = <start> badSource <end> (data);
<start> data <end> ++;"	"fscanf (stdin, ""%"" SCNd64, <start> &data <end> );
static int64_t <start> badSource <end> (int64_t data);
data = <start> badSource <end> (data);"	2
9fe7ad62-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) extern int CWE190_Integer_Overflow__int_connect_socket_add_68_badData; extern int CWE190_Integer_Overflow__int_connect_socket_add_68_goodG2BData; extern int CWE190_Integer_Overflow__int_connect_socket_add_68_goodB2GData; void CWE190_Integer_Overflow__int_connect_socket_add_68b_badSink() { int data = CWE190_Integer_Overflow__int_connect_socket_add_68_badData; { int result = data + 1; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
int <start> data = CWE190_Integer_Overflow__int_connect_socket_add_68_badData <end> ;"	"int data = <start> CWE190_Integer_Overflow__int_connect_socket_add_68_badData <end> ;
printIntLine <start> result <end> );"	"<start> printIntLine(result) <end> ;
int data = <start> CWE190_Integer_Overflow__int_connect_socket_add_68_badData <end> ;"	"printIntLine <start> result <end> );
int data = <start> CWE190_Integer_Overflow__int_connect_socket_add_68_badData <end> ;"	1
951c5e75-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FULL_COMMAND ""dir "" #else #define FULL_COMMAND ""ls "" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define POPEN _popen #define PCLOSE _pclose #else #define POPEN popen #define PCLOSE pclose #endif typedef union { char * unionFirst; char * unionSecond; } CWE78_OS_Command_Injection__char_connect_socket_popen_34_unionType; void CWE78_OS_Command_Injection__char_connect_socket_popen_34_bad() { char * data; CWE78_OS_Command_Injection__char_connect_socket_popen_34_unionType myUnion; char data_buf[100] = FULL_COMMAND; data = data_buf; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { FILE *pipe; pipe = POPEN(data, ""w""); if (pipe != NULL) { PCLOSE(pipe); } } } }"	where is the vulnerable dataflow from data to POPEN ?	"size_t dataLen = <start> strlen(data) <end> ;
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
pipe = POPEN <start> data <end> , ""w"");"	"pipe = POPEN <start> data <end> , ""w"");
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"replace = <start> strchr(data, '\n') <end> ;
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	1
5be3a9f8-6c15-11ed-81d4-94e6f77dd552	"void CWE191_Integer_Underflow__short_fscanf_postdec_13_bad() { short data; data = 0; if(GLOBAL_CONST_FIVE==5) { fscanf (stdin, ""%hd"", &data); } if(GLOBAL_CONST_FIVE==5) { { data--; short result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> data <end> --;
<start> data = 0 <end> ;"	"<start> data <end> --;
<start> printIntLine(result) <end> ;"	"<start> data <end> --;
fscanf (stdin, ""%hd"", <start> &data <end> );"	"fscanf (stdin, ""%hd"", <start> &data <end> );
<start> data <end> --;"	3
833ac91f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_listen_socket_fopen_42 { static char * badSource(char * data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } return data; } void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; data = badSource(data); { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
static char * <start> badSource <end> (char * data);
data = <start> badSource(data) <end> ;
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"static char * <start> badSource <end> (char * data);
pFile = FOPEN <start> data <end> , ""wb+"");
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
<start> data = badSource(data) <end> ;"	"if  <start> recvResult == SOCKET_ERROR <end>  || recvResult == 0);
pFile = FOPEN <start> data <end> , ""wb+"");
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
data = <start> badSource <end> (data);"	0
b1b8084b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" void CWE197_Numeric_Truncation_Error__short_connect_socket_03_bad() { short data; data = -1; if(5==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = (short)atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { char charData = (char)data; printHexCharLine(charData); } }"	where is the vulnerable dataflow from charData to printHexCharLine ?	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printHexCharLine <start> charData <end> );"	"printHexCharLine <start> charData <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"char charData = <start> (char)data <end> ;
printHexCharLine <start> charData <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printHexCharLine <start> charData <end> );"	3
67d010ac-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__short_rand_postinc_09_bad() { short data; data = 0; if(GLOBAL_CONST_TRUE) { data = (short)RAND32(); } if(GLOBAL_CONST_TRUE) { { data++; short result = data; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
data = (short <start> RAND32() <end> ;"	"<start> data <end> ++;
<start> printIntLine(result) <end> ;"	"data = (short <start> RAND32() <end> ;
<start> data <end> ++;"	"data = (short <start> RAND32() <end> ;
<start> data++ <end> ;"	2
8df42209-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define PATH_SZ 100 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define PATH_SZ PATH_MAX #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 void CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__accept_listen_bind_18_bad() { goto sink; sink: { char data[100] = """"; #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[recvResult] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif printLine(data); } }"	where is the vulnerable dataflow from data to printLine ?	"recvResult = <start> recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0) <end> ;
printLine <start> data <end> );"	"printLine <start> data <end> );
recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);"	"recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);
size_t dataLen = <start> strlen(data) <end> ;"	"recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);
printLine <start> data <end> );"	3
47a2a817-6c15-11ed-81d4-94e6f77dd552	"static void badSink(int data) { { int result = data + 1; printIntLine(result); } } void CWE190_Integer_Overflow__int_fscanf_add_41_bad() { int data; data = 0; fscanf(stdin, ""%d"", &data); badSink(data); }"	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  + 1;
static void badSink(int <start> data <end> );"	"fscanf(stdin, ""%d"", <start> &data <end> );
badSink <start> data <end> );
static void badSink(int <start> data <end> );
int result = <start> data <end>  + 1;"	"<start> printIntLine(result) <end> ;
fscanf(stdin, ""%d"", <start> &data <end> );
static void badSink(int <start> data <end> );
badSink <start> data <end> );"	"badSink <start> data <end> );
int result = <start> data <end>  + 1;
<start> printIntLine(result) <end> ;
static void badSink(int <start> data <end> );"	1
a49c4f72-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_square_18_bad() { int data; data = 0; goto source; source: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } goto sink; sink: { int result = data * data; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"int <start> result = data * data <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"printIntLine <start> result <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"data = <start> atoi(inputBuffer) <end> ;
printIntLine <start> result <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	3
656cd3cd-6c15-11ed-81d4-94e6f77dd552	static int CWE190_Integer_Overflow__int_rand_add_45_badData; static int CWE190_Integer_Overflow__int_rand_add_45_goodG2BData; static int CWE190_Integer_Overflow__int_rand_add_45_goodB2GData; static void badSink() { int data = CWE190_Integer_Overflow__int_rand_add_45_badData; { int result = data + 1; printIntLine(result); } } void CWE190_Integer_Overflow__int_rand_add_45_bad() { int data; data = 0; data = RAND32(); CWE190_Integer_Overflow__int_rand_add_45_badData = data; badSink(); }	where is the vulnerable dataflow from data ?	"data = <start> RAND32() <end> ;
<start> CWE190_Integer_Overflow__int_rand_add_45_badData = data <end> ;
static int <start> CWE190_Integer_Overflow__int_rand_add_45_badData <end> ;
int data = <start> CWE190_Integer_Overflow__int_rand_add_45_badData <end> ;
int result = <start> data <end>  + 1;"	"<start> CWE190_Integer_Overflow__int_rand_add_45_badData = data <end> ;
int data = <start> CWE190_Integer_Overflow__int_rand_add_45_badData <end> ;
<start> printIntLine(result) <end> ;
int result = <start> data <end>  + 1;
static int <start> CWE190_Integer_Overflow__int_rand_add_45_badData <end> ;"	"data = <start> RAND32() <end> ;
<start> CWE190_Integer_Overflow__int_rand_add_45_badData = data <end> ;
int result = <start> data <end>  + 1;
static int <start> CWE190_Integer_Overflow__int_rand_add_45_badData <end> ;
int data = <start> CWE190_Integer_Overflow__int_rand_add_45_badData <end> ;"	"static int <start> CWE190_Integer_Overflow__int_rand_add_45_badData <end> ;
int data = <start> CWE190_Integer_Overflow__int_rand_add_45_badData <end> ;
<start> CWE190_Integer_Overflow__int_rand_add_45_badData = data <end> ;
int result = <start> data <end>  + 1;"	0
833ac94f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_listen_socket_open_66 { void badSink(char * dataArray[]) { char * data = dataArray[2]; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN(data, O_RDWR|O_CREAT, <start> S_IREAD|S_IWRITE <end> );
void badSink(char * <start> dataArray <end> []);"	"void badSink(char * <start> dataArray <end> []);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
void badSink(char * <start> dataArray <end> []);"	1
4b34afd4-6c15-11ed-81d4-94e6f77dd552	"void CWE190_Integer_Overflow__short_fscanf_multiply_10_bad() { short data; data = 0; if(globalTrue) { fscanf (stdin, ""%hd"", &data); } if(globalTrue) { if(data > 0) { short result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"short result = <start> data <end>  * 2;
<start> printIntLine(result) <end> ;"	"short result = <start> data <end>  * 2;
fscanf (stdin, ""%hd"", <start> &data <end> );"	"fscanf (stdin, ""%hd"", <start> &data <end> );
short result = <start> data <end>  * 2;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
if <start> data > 0 <end> ) ;"	2
6c938c1d-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; static void badVaSinkB(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_04_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; if(STATIC_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(STATIC_CONST_TRUE) { badVaSinkB(data, data); } }"	where is the vulnerable dataflow from data to vfprintf ?	"size_t dataLen = <start> strlen(data) <end> ;
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
vfprintf(stdout, <start> data <end> , args);
static void badVaSinkB(char * <start> data <end> , ...);"	"badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"<start> vfprintf(stdout, data, args) <end> ;
badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);"	3
cac216a1-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" namespace CWE36_Absolute_Path_Traversal__char_connect_socket_ifstream_34 { typedef union { char * unionFirst; char * unionSecond; } unionType; void bad() { char * data; unionType myUnion; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } } }"	where is the vulnerable dataflow from data to open ?	"inputFile.open((char * <start> data <end> );
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"inputFile.open((char * <start> data <end> );
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"size_t dataLen = <start> strlen(data) <end> ;
inputFile.open((char * <start> data <end> );"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
inputFile.open((char * <start> data <end> );"	3
60db83a2-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__char_rand_add_43 { static void badSource(char &data) { data = (char)RAND32(); } void bad() { char data; data = ' '; badSource(data); { char result = data + 1; printHexCharLine(result); } }	where is the vulnerable dataflow from data ?	"data = (char <start> RAND32() <end> ;
badSource <start> data <end> );
char result = <start> data <end>  + 1;"	"char result = <start> data + 1 <end> ;
data = (char <start> RAND32() <end> ;
badSource <start> data <end> );"	"<start> printHexCharLine(result) <end> ;
badSource <start> data <end> );
data = (char <start> RAND32() <end> ;"	"char <start> result = data + 1 <end> ;
badSource <start> data <end> );
data = (char <start> RAND32() <end> ;"	0
a6fd8236-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) extern int CWE190_Integer_Overflow__int_listen_socket_postinc_68_badData; extern int CWE190_Integer_Overflow__int_listen_socket_postinc_68_goodG2BData; extern int CWE190_Integer_Overflow__int_listen_socket_postinc_68_goodB2GData; void CWE190_Integer_Overflow__int_listen_socket_postinc_68b_badSink() { int data = CWE190_Integer_Overflow__int_listen_socket_postinc_68_badData; { data++; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"int <start> result = data <end> ;
printIntLine <start> result <end> );"	"int data = <start> CWE190_Integer_Overflow__int_listen_socket_postinc_68_badData <end> ;
printIntLine <start> result <end> );"	"int data = <start> CWE190_Integer_Overflow__int_listen_socket_postinc_68_badData <end> ;
<start> data++ <end> ;"	"<start> printIntLine(result) <end> ;
int data = <start> CWE190_Integer_Overflow__int_listen_socket_postinc_68_badData <end> ;"	1
b08640ea-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE197_Numeric_Truncation_Error__int_fgets_to_short_43 { static void badSource(int &data) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } void bad() { int data; data = -1; badSource(data); { short shortData = (short)data; printShortLine(shortData); } }"	where is the vulnerable dataflow from shortData to printShortLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
badSource <start> data <end> );
printShortLine <start> shortData <end> );"	"<start> printShortLine(shortData) <end> ;
printShortLine <start> shortData <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"<start> printShortLine(shortData) <end> ;
badSource <start> data <end> );
printShortLine <start> shortData <end> );"	"printShortLine <start> shortData <end> );
badSource <start> data <end> );"	0
bc721f74-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define EXECL _execl #else #define EXECL execl #endif void CWE78_OS_Command_Injection__char_file_execl_10_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(globalTrue) { { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECL ?	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	"<start> data = dataBuffer <end> ;
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"size_t dataLen = <start> strlen(data) <end> ;
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	2
a830bf6e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_connect_socket_multiply_11_bad() { int data; data = 0; if(globalReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalReturnsTrue()) { if(data < 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"int result = <start> data * 2 <end> ;
printIntLine <start> result <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	2
5af03e19-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_fgets_postdec_10_bad() { int data; data = 0; if(globalTrue) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(globalTrue) { { data--; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> printIntLine(result) <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> data <end> --;"	"<start> data <end> --;
int <start> result = data <end> ;"	"<start> data <end> --;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	1
8cc3a66f-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(count) + 2) #ifdef _WIN32 #define SLEEP Sleep #else #define SLEEP usleep #endif static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } void CWE400_Resource_Exhaustion__fgets_sleep_08_bad() { int count; count = -1; if(staticReturnsTrue()) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { count = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(staticReturnsTrue()) { SLEEP(count); printLine(""Sleep time possibly too long""); } }"	where is the vulnerable dataflow from count to SLEEP ?	"if  <start> fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) <end>  != NULL);
SLEEP <start> count <end> );"	"SLEEP <start> count <end> );
<start> SLEEP(count) <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
SLEEP <start> count <end> );"	"SLEEP <start> count <end> );
<start> count = atoi(inputBuffer) <end> ;"	2
a6fd828c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_preinc_14_bad() { int data; data = 0; if(globalFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalFive==5) { { ++data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"int <start> result = data <end> ;
printIntLine <start> result <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	3
d1e9da63-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 namespace CWE36_Absolute_Path_Traversal__char_listen_socket_ifstream_18 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; goto source; source: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
inputFile.open((char * <start> data <end> );"	"size_t dataLen = <start> strlen(data) <end> ;
inputFile.open((char * <start> data <end> );"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
size_t <start> dataLen = strlen(data) <end> ;"	"inputFile.open((char * <start> data <end> );
<start> data = dataBuffer <end> ;"	0
70279c1e-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif static void badVaSinkB(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_file_vfprintf_03_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; if(5==5) { { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } if(5==5) { badVaSinkB(data, data); } }"	where is the vulnerable dataflow from data to vfprintf ?	"static void badVaSinkB(char * <start> data <end> , ...);
badVaSinkB <start> data <end> , data);
<start> vfprintf(stdout, data, args) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	"vfprintf(stdout, <start> data <end> , args);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
badVaSinkB <start> data <end> , data);"	"vfprintf(stdout, <start> data <end> , args);
badVaSinkB <start> data <end> , data);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);"	3
9187cbea-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define SEARCH_CHAR 'S' void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_66b_badSink(char * dataArray[]) { char * data = dataArray[2]; for (; *data != '\0'; data++) { if (*data == SEARCH_CHAR) { printLine(""We have a match!""); break; } } free(data); }"	where is the vulnerable dataflow from data to free ?	"char <start> * data = dataArray[2] <end> ;
free <start> data <end> );"	"<start> free(data) <end> ;
void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_66b_badSink(char * <start> dataArray <end> []);"	"free <start> data <end> );
void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_66b_badSink(char * <start> dataArray <end> []);"	"void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_66b_badSink(char * <start> dataArray <end> []);
free <start> data <end> );"	3
67d010df-6c15-11ed-81d4-94e6f77dd552	static char badSource(char data) { data = (char)RAND32(); return data; } void CWE190_Integer_Overflow__char_rand_preinc_42_bad() { char data; data = ' '; data = badSource(data); { ++data; char result = data; printHexCharLine(result); } }	where is the vulnerable dataflow from data ?	"data = (char <start> RAND32() <end> ;
+ <start> data <end> ;
static char <start> badSource <end> (char data);
data = <start> badSource <end> (data);"	"data = (char <start> RAND32() <end> ;
static char <start> badSource <end> (char data);
data = <start> badSource <end> (data);
+ <start> data <end> ;"	"<start> printHexCharLine(result) <end> ;
static char <start> badSource <end> (char data);
data = (char <start> RAND32() <end> ;
+ <start> data <end> ;"	"<start> printHexCharLine(result) <end> ;
data = <start> badSource <end> (data);
static char <start> badSource <end> (char data);
data = (char <start> RAND32() <end> ;"	1
d44c3fc5-6c15-11ed-81d4-94e6f77dd552	#ifndef _WIN32 #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_listen_socket_open_73 { void badSink(list<char *> dataList) { char * data = dataList.back(); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
void badSink(list<char *> <start> dataList <end> );"	"void badSink(list<char *> <start> dataList <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN(data, O_RDWR|O_CREAT, <start> S_IREAD|S_IWRITE <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	2
4b34afc4-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__short_fscanf_add_65b_badSink(short data) { { short result = data + 1; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
short result = <start> data <end>  + 1;"	"short <start> result = data + 1 <end> ;
void CWE190_Integer_Overflow__short_fscanf_add_65b_badSink(short <start> data <end> );"	"void CWE190_Integer_Overflow__short_fscanf_add_65b_badSink(short <start> data <end> );
short result = <start> data <end>  + 1;"	"short result = <start> data <end>  + 1;
void CWE190_Integer_Overflow__short_fscanf_add_65b_badSink(short <start> data <end> );"	2
b1b80830-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_31_bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { int dataCopy = data; int data = dataCopy; { short shortData = (short)data; printShortLine(shortData); } } }"	where is the vulnerable dataflow from shortData to printShortLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printShortLine <start> shortData <end> );"	"printShortLine <start> shortData <end> );
int <start> data = dataCopy <end> ;"	"printShortLine <start> shortData <end> );
<start> recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printShortLine(shortData) <end> ;"	0
656cd3e7-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__int_rand_multiply_14_bad() { int data; data = 0; if(globalFive==5) { data = RAND32(); } if(globalFive==5) { if(data > 0) { int result = data * 2; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  * 2;
data = <start> RAND32() <end> ;"	"if <start> data > 0 <end> ) ;
data = <start> RAND32() <end> ;"	"data = <start> RAND32() <end> ;
int result = <start> data <end>  * 2;"	"int result = <start> data <end>  * 2;
if <start> data > 0 <end> ) ;"	2
cbf237a7-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_console_fopen_10 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(globalTrue) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
dataLen = <start> strlen(data) <end> ;"	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"dataLen = <start> strlen(data) <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
pFile = FOPEN <start> data <end> , ""wb+"");"	3
99e16a8c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_listen_socket_41 { static void badSink(int data) { { int i; int * buffer = new int[10]; for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } delete[] buffer; } } void bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badSink(data); }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"<start> data = atoi(inputBuffer) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[i] <end> );
static void badSink(int <start> data <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSink <start> data <end> );
static void badSink(int <start> data <end> );
printIntLine <start> buffer[i] <end> );"	"static void badSink(int <start> data <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[i] <end> );
badSink <start> data <end> );"	"static void badSink(int <start> data <end> );
<start> recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> buffer[i] <end> );
badSink <start> data <end> );"	1
47a2a7fa-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_square_64b_badSink(void * dataVoidPtr) { int * dataPtr = (int *)dataVoidPtr; int data = (*dataPtr); { int result = data * data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"void CWE190_Integer_Overflow__int_fgets_square_64b_badSink(void * <start> dataVoidPtr <end> );
int result = <start> data <end>  * data;"	"int result = <start> data * data <end> ;
void CWE190_Integer_Overflow__int_fgets_square_64b_badSink(void * <start> dataVoidPtr <end> );"	"int result = <start> data <end>  * data;
<start> printIntLine(result) <end> ;"	"void CWE190_Integer_Overflow__int_fgets_square_64b_badSink(void * <start> dataVoidPtr <end> );
<start> printIntLine(result) <end> ;"	0
b7b09a56-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define NEW_PATH ""%SystemRoot%\\system32"" #define PUTENV _putenv #else #define NEW_PATH ""/bin"" #define PUTENV putenv #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } void CWE427_Uncontrolled_Search_Path_Element__char_file_08_bad() { char * data; char dataBuffer[250] = ""PATH=""; data = dataBuffer; if(staticReturnsTrue()) { { size_t dataLen = strlen(data); FILE * pFile; if (250-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(250-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } PUTENV(data); }"	where is the vulnerable dataflow from data to PUTENV ?	"<start> PUTENV(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(250-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(250-dataLen), pFile) == NULL);
PUTENV <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(250-dataLen), pFile) == NULL);
size_t dataLen = <start> strlen(data) <end> ;"	"PUTENV <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(250-dataLen), pFile) == NULL);"	1
ba102b8f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define EXECL _execl #else #define EXECL execl #endif static char * CWE78_OS_Command_Injection__char_connect_socket_execl_45_badData; static char * CWE78_OS_Command_Injection__char_connect_socket_execl_45_goodG2BData; static void badSink() { char * data = CWE78_OS_Command_Injection__char_connect_socket_execl_45_badData; EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL); } void CWE78_OS_Command_Injection__char_connect_socket_execl_45_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE78_OS_Command_Injection__char_connect_socket_execl_45_badData = data; badSink(); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECL ?	"recvResult = recv(connectSocket, (char *)(data + dataLen), <start> sizeof(char) * (100 - dataLen - 1) <end> , 0);
char * data = <start> CWE78_OS_Command_Injection__char_connect_socket_execl_45_badData <end> ;
static char * <start> CWE78_OS_Command_Injection__char_connect_socket_execl_45_badData <end> ;
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
<start> CWE78_OS_Command_Injection__char_connect_socket_execl_45_badData = data <end> ;"	"replace = <start> strchr(data, '\r') <end> ;
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
<start> CWE78_OS_Command_Injection__char_connect_socket_execl_45_badData = data <end> ;
char * data = <start> CWE78_OS_Command_Injection__char_connect_socket_execl_45_badData <end> ;
static char * <start> CWE78_OS_Command_Injection__char_connect_socket_execl_45_badData <end> ;"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
<start> CWE78_OS_Command_Injection__char_connect_socket_execl_45_badData = data <end> ;
static char * <start> CWE78_OS_Command_Injection__char_connect_socket_execl_45_badData <end> ;
char * data = <start> CWE78_OS_Command_Injection__char_connect_socket_execl_45_badData <end> ;
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"static char * <start> CWE78_OS_Command_Injection__char_connect_socket_execl_45_badData <end> ;
char * data = <start> CWE78_OS_Command_Injection__char_connect_socket_execl_45_badData <end> ;
<start> CWE78_OS_Command_Injection__char_connect_socket_execl_45_badData = data <end> ;
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	2
bda4e416-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define EXECL _execl #else #define EXECL execl #endif static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } void CWE78_OS_Command_Injection__char_listen_socket_execl_08_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(staticReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECL ?	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
size_t dataLen = <start> strlen(data) <end> ;"	"char <start> dataBuffer[100] = COMMAND_ARG2 <end> ;
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
<start> EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL) <end> ;"	0
bb49c5a6-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #define EXECLP _execlp #else #define EXECLP execlp #endif void CWE78_OS_Command_Injection__char_console_execlp_15_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; switch(6) { case 6: { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } break; default: printLine(""Benign, fixed string""); break; } EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECLP ?	"EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
<start> data = dataBuffer <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	"size_t dataLen = <start> strlen(data) <end> ;
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	1
6ef76841-6c15-11ed-81d4-94e6f77dd552	#ifndef _WIN32 #endif static void badVaSink(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_console_vfprintf_66b_badSink(char * dataArray[]) { char * data = dataArray[2]; badVaSink(data, data); }	where is the vulnerable dataflow from data to vfprintf ?	"void CWE134_Uncontrolled_Format_String__char_console_vfprintf_66b_badSink(char * <start> dataArray <end> []);
badVaSink <start> data <end> , data);"	"<start> vfprintf(stdout, data, args) <end> ;
void CWE134_Uncontrolled_Format_String__char_console_vfprintf_66b_badSink(char * <start> dataArray <end> []);
static void badVaSink(char * <start> data <end> , ...);
badVaSink <start> data <end> , data);"	"void CWE134_Uncontrolled_Format_String__char_console_vfprintf_66b_badSink(char * <start> dataArray <end> []);
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);"	"badVaSink <start> data <end> , data);
vfprintf(stdout, <start> data <end> , args);
void CWE134_Uncontrolled_Format_String__char_console_vfprintf_66b_badSink(char * <start> dataArray <end> []);"	2
598370ce-6c15-11ed-81d4-94e6f77dd552	"static void badSink(short data) { { short result = data - 1; printIntLine(result); } } void CWE191_Integer_Underflow__short_fscanf_sub_44_bad() { short data; void (*funcPtr) (short) = badSink; data = 0; fscanf (stdin, ""%hd"", &data); funcPtr(data); }"	where is the vulnerable dataflow from data ?	"fscanf (stdin, ""%hd"", <start> &data <end> );
static void badSink(short <start> data <end> );
funcPtr <start> data <end> );
<start> data = 0 <end> ;"	"static void badSink(short <start> data <end> );
<start> printIntLine(result) <end> ;
short result = <start> data <end>  - 1;
fscanf (stdin, ""%hd"", <start> &data <end> );"	"static void badSink(short <start> data <end> );
short result = <start> data <end>  - 1;
funcPtr <start> data <end> );
fscanf (stdin, ""%hd"", <start> &data <end> );"	"fscanf (stdin, ""%hd"", <start> &data <end> );
funcPtr <start> data <end> );
static void badSink(short <start> data <end> );
short result = <start> data <end>  - 1;"	3
a5ce1c90-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_postinc_64b_badSink(void * dataVoidPtr) { int * dataPtr = (int *)dataVoidPtr; int data = (*dataPtr); { data++; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"<start> data++ <end> ;
void CWE190_Integer_Overflow__int_listen_socket_postinc_64b_badSink(void * <start> dataVoidPtr <end> );"	"printIntLine <start> result <end> );
void CWE190_Integer_Overflow__int_listen_socket_postinc_64b_badSink(void * <start> dataVoidPtr <end> );"	"<start> data++ <end> ;
printIntLine <start> result <end> );"	"void CWE190_Integer_Overflow__int_listen_socket_postinc_64b_badSink(void * <start> dataVoidPtr <end> );
printIntLine <start> result <end> );"	3
47a2a833-6c15-11ed-81d4-94e6f77dd552	"static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } void CWE190_Integer_Overflow__int_fscanf_multiply_08_bad() { int data; data = 0; if(staticReturnsTrue()) { fscanf(stdin, ""%d"", &data); } if(staticReturnsTrue()) { if(data > 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  * 2;
fscanf(stdin, ""%d"", <start> &data <end> );"	"int result = <start> data <end>  * 2;
<start> printIntLine(result) <end> ;"	"fscanf(stdin, ""%d"", <start> &data <end> );
int result = <start> data <end>  * 2;"	"<start> printIntLine(result) <end> ;
fscanf(stdin, ""%d"", <start> &data <end> );"	2
6dc614f8-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" static void badVaSink(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_63b_badSink(char * * dataPtr) { char * data = *dataPtr; badVaSink(data, data); }"	where is the vulnerable dataflow from data to vprintf ?	"void CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_63b_badSink(char * * <start> dataPtr <end> );
badVaSink <start> data <end> , data);
<start> va_start(args, data) <end> ;
vprintf <start> data <end> , args);"	"<start> vprintf(data, args) <end> ;
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
void CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_63b_badSink(char * * <start> dataPtr <end> );"	"vprintf <start> data <end> , args);
void CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_63b_badSink(char * * <start> dataPtr <end> );
static void badVaSink(char * <start> data <end> , ...);
badVaSink <start> data <end> , data);"	"void CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_63b_badSink(char * * <start> dataPtr <end> );
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
vprintf <start> data <end> , args);"	3
c991980e-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" namespace CWE36_Absolute_Path_Traversal__char_connect_socket_ifstream_17 { void bad() { int i; char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; for(i = 0; i < 1; i++) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"inputFile.open((char * <start> data <end> );
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
inputFile.open((char * <start> data <end> );"	"size_t <start> dataLen = strlen(data) <end> ;
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"replace = <start> strchr(data, '\n') <end> ;
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	1
ba102b9c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define EXECLP _execlp #else #define EXECLP execlp #endif void CWE78_OS_Command_Injection__char_connect_socket_execlp_10_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(globalTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECLP ?	"EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
size_t <start> dataLen = strlen(data) <end> ;"	"<start> EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL) <end> ;
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (100 - dataLen - 1), 0);"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	3
7fa68e30-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_connect_socket_fopen_15 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; switch(6) { case 6: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; default: printLine(""Benign, fixed string""); break; } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"<start> data = dataBuffer <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	"size_t <start> dataLen = strlen(data) <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"size_t <start> dataLen = strlen(data) <end> ;
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	1
6ef7680c-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif static void badSink(char * data) { { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } } void CWE134_Uncontrolled_Format_String__char_console_snprintf_44_bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[100] = """"; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } funcPtr(data); }"	where is the vulnerable dataflow from dest to printLine ?	"printLine <start> dest <end> );
static void badSink(char * <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	"printLine <start> dest <end> );
<start> funcPtr(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
funcPtr <start> data <end> );"	"size_t dataLen = <start> strlen(data) <end> ;
static void badSink(char * <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
funcPtr <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
funcPtr <start> data <end> );
static void badSink(char * <start> data <end> );
printLine <start> dest <end> );"	3
54c58213-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_connect_socket_sub_11_bad() { int data; data = 0; if(globalReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalReturnsTrue()) { { int result = data - 1; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  - 1;
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"<start> printIntLine(result) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"int result = <start> data <end>  - 1;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  - 1;"	3
b2ea8dc9-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 8 void CWE197_Numeric_Truncation_Error__short_fgets_31_bad() { short data; data = -1; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = (short)atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } { short dataCopy = data; short data = dataCopy; { char charData = (char)data; printHexCharLine(charData); } } }"	where is the vulnerable dataflow from charData to printHexCharLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
char <start> inputBuffer[CHAR_ARRAY_SIZE] = """" <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
short <start> dataCopy = data <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printHexCharLine <start> charData <end> );"	"<start> data = (short)atoi(inputBuffer) <end> ;
printHexCharLine <start> charData <end> );"	2
abc37501-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int badStatic = 0; static void badSink(int data) { if(badStatic) { { data--; int result = data; printIntLine(result); } } } void CWE191_Integer_Underflow__int_connect_socket_postdec_21_bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badStatic = 1; badSink(data); }"	where is the vulnerable dataflow from result to printIntLine ?	"<start> data = atoi(inputBuffer) <end> ;
badSink <start> data <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static void badSink(int <start> data <end> );"	"<start> badSink(data) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSink <start> data <end> );
static void badSink(int <start> data <end> );"	"printIntLine <start> result <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
static void badSink(int <start> data <end> );
badSink <start> data <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSink <start> data <end> );
static void badSink(int <start> data <end> );
printIntLine <start> result <end> );"	3
92bb8a1c-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING ""hello"" static int staticFive = 5; void CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_07_bad() { size_t data; data = 0; if(staticFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = strtoul(inputBuffer, NULL, 0); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticFive==5) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); } else { printLine(""Input is less than the length of the source string""); } } } }"	where is the vulnerable dataflow from data to malloc ?	"<start> printLine(myString) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
myString = (char *)malloc <start> data*sizeof(char) <end> );"	"<start> data = 0 <end> ;
myString = (char *)malloc <start> data*sizeof(char) <end> );"	"data = <start> strtoul(inputBuffer, NULL, 0) <end> ;
myString = (char *)malloc <start> data*sizeof(char) <end> );"	1
70279bef-6c15-11ed-81d4-94e6f77dd552	namespace CWE134_Uncontrolled_Format_String__char_console_vprintf_81 { static void badVaSink(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_console_vprintf_81_bad::action(char * data) const { badVaSink(data, data); } }	where is the vulnerable dataflow from data to vprintf ?	"void CWE134_Uncontrolled_Format_String__char_console_vprintf_81_bad::action(char * <start> data <end> ) const;
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
vprintf <start> data <end> , args);"	"vprintf <start> data <end> , args);
<start> vprintf(data, args) <end> ;
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);"	"vprintf <start> data <end> , args);
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);"	"vprintf <start> data <end> , args);
static void badVaSink(char * <start> data <end> , ...);"	0
b68484d4-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" namespace CWE36_Absolute_Path_Traversal__char_connect_socket_open_81 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } const CWE36_Absolute_Path_Traversal__char_connect_socket_open_81_base& baseObject = CWE36_Absolute_Path_Traversal__char_connect_socket_open_81_bad(); baseObject.action(data); }"	where is the vulnerable dataflow from data to action ?	"char <start> dataBuffer[FILENAME_MAX] = """" <end> ;
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"size_t <start> dataLen = strlen(data) <end> ;
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
baseObject.action <start> data <end> );"	"baseObject.action <start> data <end> );
<start> data = dataBuffer <end> ;"	2
b2ea8dc2-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 8 void CWE197_Numeric_Truncation_Error__short_fgets_14_bad() { short data; data = -1; if(globalFive==5) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = (short)atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } { char charData = (char)data; printHexCharLine(charData); } }"	where is the vulnerable dataflow from charData to printHexCharLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
char <start> charData = (char)data <end> ;"	"<start> data = -1 <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printHexCharLine <start> charData <end> );"	"char <start> charData = (char)data <end> ;
printHexCharLine <start> charData <end> );"	2
bb49c582-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #define EXECL _execl #else #define EXECL execl #endif static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } void CWE78_OS_Command_Injection__char_console_execl_08_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(staticReturnsTrue()) { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECL ?	"EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
size_t dataLen = <start> strlen(data) <end> ;"	"EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
char <start> dataBuffer[100] = COMMAND_ARG2 <end> ;"	2
6c938bea-6c15-11ed-81d4-94e6f77dd552	"namespace CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_81 { void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_81_bad::action(int data) const { { int i; int * buffer = (int *)malloc(10 * sizeof(int)); if (buffer == NULL) {exit(-1);} for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } free(buffer); } } }"	where is the vulnerable dataflow from buffer to free ?	"void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_81_bad::action(int <start> data <end> ) const;
if  <start> buffer == NULL <end> ) {exit(-1);};"	"void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_81_bad::action(int <start> data <end> ) const;
free <start> buffer <end> );"	"<start> free(buffer) <end> ;
void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_81_bad::action(int <start> data <end> ) const;"	"free <start> buffer <end> );
void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_81_bad::action(int <start> data <end> ) const;"	1
a5ce1c5a-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_postinc_15_bad() { int data; data = 0; switch(6) { case 6: { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } break; default: printLine(""Benign, fixed string""); break; } switch(7) { case 7: { data++; int result = data; printIntLine(result); } break; default: printLine(""Benign, fixed string""); break; } }"	where is the vulnerable dataflow from result to printIntLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
int <start> result = data <end> ;"	"<start> data++ <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"<start> data = atoi(inputBuffer) <end> ;
printIntLine <start> result <end> );"	0
b7b09a29-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" namespace CWE427_Uncontrolled_Search_Path_Element__char_connect_socket_81 { void bad() { char * data; char dataBuffer[250] = ""PATH=""; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (250 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } const CWE427_Uncontrolled_Search_Path_Element__char_connect_socket_81_base& baseObject = CWE427_Uncontrolled_Search_Path_Element__char_connect_socket_81_bad(); baseObject.action(data); }"	where is the vulnerable dataflow from data to action ?	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (250 - dataLen - 1), 0);
baseObject.action <start> data <end> );"	"baseObject.action <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	"replace = <start> strchr(data, '\r') <end> ;
baseObject.action <start> data <end> );"	"replace = <start> strchr(data, '\n') <end> ;
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (250 - dataLen - 1), 0);"	0
6ef76840-6c15-11ed-81d4-94e6f77dd552	#ifndef _WIN32 #endif static void badVaSink(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_console_vfprintf_64b_badSink(void * dataVoidPtr) { char * * dataPtr = (char * *)dataVoidPtr; char * data = (*dataPtr); badVaSink(data, data); }	where is the vulnerable dataflow from data to vfprintf ?	"void CWE134_Uncontrolled_Format_String__char_console_vfprintf_64b_badSink(void * <start> dataVoidPtr <end> );
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);"	"void CWE134_Uncontrolled_Format_String__char_console_vfprintf_64b_badSink(void * <start> dataVoidPtr <end> );
<start> vfprintf(stdout, data, args) <end> ;
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);"	"vfprintf(stdout, <start> data <end> , args);
void CWE134_Uncontrolled_Format_String__char_console_vfprintf_64b_badSink(void * <start> dataVoidPtr <end> );
static void badVaSink(char * <start> data <end> , ...);
badVaSink <start> data <end> , data);"	"void CWE134_Uncontrolled_Format_String__char_console_vfprintf_64b_badSink(void * <start> dataVoidPtr <end> );
static void badVaSink(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);"	0
6b86243b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_connect_socket_63b_badSink(int * dataPtr) { int data = *dataPtr; { int i; int * buffer = (int *)malloc(10 * sizeof(int)); if (buffer == NULL) {exit(-1);} for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } free(buffer); } }"	where is the vulnerable dataflow from buffer to free ?	"free <start> buffer <end> );
if  <start> buffer == NULL <end> ) {exit(-1);};"	"free <start> buffer <end> );
void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_connect_socket_63b_badSink(int * <start> dataPtr <end> );"	"void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_connect_socket_63b_badSink(int * <start> dataPtr <end> );
free <start> buffer <end> );"	"<start> printIntLine(buffer[i]) <end> ;
free <start> buffer <end> );"	2
c39a65c1-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif namespace CWE23_Relative_Path_Traversal__char_environment_ofstream_54 { void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } badSink_b(data); }"	where is the vulnerable dataflow from data to badSink_b ?	"size_t dataLen = <start> strlen(data) <end> ;
badSink_b <start> data <end> );"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
badSink_b <start> data <end> );"	"strncat(data+dataLen, environment, <start> FILENAME_MAX-dataLen-1 <end> );
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"size_t dataLen = <start> strlen(data) <end> ;
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	1
70279c29-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif static void badVaSinkB(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_file_vfprintf_14_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; if(globalFive==5) { { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } if(globalFive==5) { badVaSinkB(data, data); } }"	where is the vulnerable dataflow from data to vfprintf ?	"badVaSinkB <start> data <end> , data);
vfprintf(stdout, <start> data <end> , args);
static void badVaSinkB(char * <start> data <end> , ...);
<start> va_start(args, data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);"	"static void badVaSinkB(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	"char <start> dataBuffer[100] = """" <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
vfprintf(stdout, <start> data <end> , args);
static void badVaSinkB(char * <start> data <end> , ...);"	1
b41b8790-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 20 #define IP_ADDRESS ""127.0.0.1"" void CWE369_Divide_by_Zero__float_connect_socket_01_bad() { float data; data = 0.0F; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = (float)atof(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { int result = (int)(100.0 / data); printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"data = <start> (float)atof(inputBuffer) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"printIntLine <start> result <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"printIntLine <start> result <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	0
a6fd827e-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) extern int CWE190_Integer_Overflow__int_fgets_preinc_68_badData; extern int CWE190_Integer_Overflow__int_fgets_preinc_68_goodG2BData; extern int CWE190_Integer_Overflow__int_fgets_preinc_68_goodB2GData; void CWE190_Integer_Overflow__int_fgets_preinc_68b_badSink() { int data = CWE190_Integer_Overflow__int_fgets_preinc_68_badData; { ++data; int result = data; printIntLine(result); } }	where is the vulnerable dataflow from result to printIntLine ?	"int data = <start> CWE190_Integer_Overflow__int_fgets_preinc_68_badData <end> ;
int <start> result = data <end> ;"	"int data = <start> CWE190_Integer_Overflow__int_fgets_preinc_68_badData <end> ;
printIntLine <start> result <end> );"	"int data = <start> CWE190_Integer_Overflow__int_fgets_preinc_68_badData <end> ;
<start> ++data <end> ;"	"printIntLine <start> result <end> );
int data = <start> CWE190_Integer_Overflow__int_fgets_preinc_68_badData <end> ;"	1
47a2a7fc-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) typedef struct _CWE190_Integer_Overflow__int_fgets_square_67_structType { int structFirst; } CWE190_Integer_Overflow__int_fgets_square_67_structType; void CWE190_Integer_Overflow__int_fgets_square_67b_badSink(CWE190_Integer_Overflow__int_fgets_square_67_structType myStruct) { int data = myStruct.structFirst; { int result = data * data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  * data;
void CWE190_Integer_Overflow__int_fgets_square_67b_badSink(CWE190_Integer_Overflow__int_fgets_square_67_structType <start> myStruct <end> );
<start> printIntLine(result) <end> ;"	"int result = <start> data <end>  * data;
void CWE190_Integer_Overflow__int_fgets_square_67b_badSink(CWE190_Integer_Overflow__int_fgets_square_67_structType <start> myStruct <end> );"	"int data = <start> myStruct <end> .structFirst;
void CWE190_Integer_Overflow__int_fgets_square_67b_badSink(CWE190_Integer_Overflow__int_fgets_square_67_structType <start> myStruct <end> );
int result = <start> data <end>  * data;"	"void CWE190_Integer_Overflow__int_fgets_square_67b_badSink(CWE190_Integer_Overflow__int_fgets_square_67_structType <start> myStruct <end> );
int data = <start> myStruct <end> .structFirst;
int result = <start> data <end>  * data;"	3
4ec5d077-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_postinc_15_bad() { int data; data = 0; switch(6) { case 6: { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } break; default: printLine(""Benign, fixed string""); break; } switch(7) { case 7: { data++; int result = data; printIntLine(result); } break; default: printLine(""Benign, fixed string""); break; } }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> data++ <end> ;"	"<start> printIntLine(result) <end> ;
<start> data <end> ++;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> data <end> ++;"	3
aa91a164-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_listen_socket_multiply_15_bad() { int data; data = 0; switch(6) { case 6: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; default: printLine(""Benign, fixed string""); break; } switch(7) { case 7: if(data < 0) { int result = data * 2; printIntLine(result); } break; default: printLine(""Benign, fixed string""); break; } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
data = <start> atoi(inputBuffer) <end> ;"	"printIntLine <start> result <end> );
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"printIntLine <start> result <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	3
ce547d40-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif namespace CWE36_Absolute_Path_Traversal__char_environment_ifstream_10 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(globalTrue) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } } { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"strncat(data+dataLen, environment, FILENAME_MAX <start> dataLen-1 <end> );
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
inputFile.open((char * <start> data <end> );"	"inputFile.open((char * <start> data <end> );
strncat(data+dataLen, environment, <start> FILENAME_MAX-dataLen-1 <end> );"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
<start> data = dataBuffer <end> ;"	1
6ef7682a-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif static void badVaSinkB(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); va_end(args); } } static void badVaSinkG(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, ""%s"", args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_console_vfprintf_12_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; if(globalReturnsTrueOrFalse()) { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } else { strcpy(data, ""fixedstringtest""); } if(globalReturnsTrueOrFalse()) { badVaSinkB(data, data); } else { badVaSinkG(data, data); } }"	where is the vulnerable dataflow from data to vfprintf ?	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
static void badVaSinkB(char * <start> data <end> , ...);
dataLen = <start> strlen(data) <end> ;
vfprintf(stdout, <start> data <end> , args);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
vfprintf(stdout, <start> data <end> , args);
badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);"	"vfprintf(stdout, <start> data <end> , args);
static void badVaSinkB(char * <start> data <end> , ...);
badVaSinkB <start> data <end> , data);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);"	3
728a4fef-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 static int badStatic = 0; static void badVaSink(char * data, ...) { if(badStatic) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); va_end(args); } } } void CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_21_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badStatic = 1; badVaSink(data, data); }"	where is the vulnerable dataflow from data to vfprintf ?	"vfprintf(stdout, <start> data <end> , args);
static void badVaSink(char * <start> data <end> , ...);
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (100 - dataLen - 1), 0);
badVaSink <start> data <end> , data);"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);"	"vfprintf(stdout, <start> data <end> , args);
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);"	"size_t <start> dataLen = strlen(data) <end> ;
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
static void badVaSink(char * <start> data <end> , ...);
badVaSink <start> data <end> , data);"	1
a95fd868-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) int CWE191_Integer_Underflow__int_fgets_sub_61b_badSource(int data); void CWE191_Integer_Underflow__int_fgets_sub_61_bad() { int data; data = 0; data = CWE191_Integer_Underflow__int_fgets_sub_61b_badSource(data); { int result = data - 1; printIntLine(result); } }	where is the vulnerable dataflow from result to printIntLine ?	"data = <start> CWE191_Integer_Underflow__int_fgets_sub_61b_badSource <end> (data);
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
data = <start> CWE191_Integer_Underflow__int_fgets_sub_61b_badSource <end> (data);"	"data = <start> CWE191_Integer_Underflow__int_fgets_sub_61b_badSource <end> (data);
int result = <start> data - 1 <end> ;"	"data = <start> CWE191_Integer_Underflow__int_fgets_sub_61b_badSource <end> (data);
<start> printIntLine(result) <end> ;"	0
70279c30-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif typedef union { char * unionFirst; char * unionSecond; } CWE134_Uncontrolled_Format_String__char_file_vfprintf_34_unionType; static void badVaSink(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_file_vfprintf_34_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } { char * dataCopy = data; char * data = dataCopy; badVaSink(data, data); } }"	where is the vulnerable dataflow from data to vfprintf ?	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);"	"static void badVaSink(char * <start> data <end> , ...);
size_t dataLen = <start> strlen(data) <end> ;
badVaSink <start> data <end> , data);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	"badVaSink <start> data <end> , data);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
vfprintf(stdout, <start> data <end> , args);
static void badVaSink(char * <start> data <end> , ...);"	"<start> data = dataBuffer <end> ;
static void badVaSink(char * <start> data <end> , ...);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
vfprintf(stdout, <start> data <end> , args);"	0
9059f399-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_11_bad() { int data; data = -1; if(globalReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { size_t i; int *intPointer; intPointer = (int*)malloc(data * sizeof(int)); if (intPointer == NULL) {exit(-1);} for (i = 0; i < (size_t)data; i++) { intPointer[i] = 0; } printIntLine(intPointer[0]); free(intPointer); } }"	where is the vulnerable dataflow from data to malloc ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	"intPointer = (int*)malloc <start> data * sizeof(int) <end> );
if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );"	"<start> printIntLine(intPointer[0]) <end> ;
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	"intPointer = (int*)malloc <start> data * sizeof(int) <end> );
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	0
7d44fccc-6c15-11ed-81d4-94e6f77dd552	namespace CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_62 { void badSource(int &data); void bad() { int data; data = -1; badSource(data); if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }	where is the vulnerable dataflow from data to malloc ?	"badSource <start> data <end> );
if  <start> dataBuffer == NULL <end> ) {exit(-1);};"	"badSource <start> data <end> );
char * dataBuffer = (char *)malloc <start> data <end> );"	"<start> memset(dataBuffer, 'A', data-1) <end> ;
char * dataBuffer = (char *)malloc <start> data <end> );"	"char * dataBuffer = (char *)malloc <start> data <end> );
if  <start> dataBuffer == NULL <end> ) {exit(-1);};"	1
a5ce1c4a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) typedef struct _CWE190_Integer_Overflow__int_connect_socket_postinc_67_structType { int structFirst; } CWE190_Integer_Overflow__int_connect_socket_postinc_67_structType; void CWE190_Integer_Overflow__int_connect_socket_postinc_67b_badSink(CWE190_Integer_Overflow__int_connect_socket_postinc_67_structType myStruct) { int data = myStruct.structFirst; { data++; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"void CWE190_Integer_Overflow__int_connect_socket_postinc_67b_badSink(CWE190_Integer_Overflow__int_connect_socket_postinc_67_structType <start> myStruct <end> );
int data = <start> myStruct <end> .structFirst;
printIntLine <start> result <end> );"	"<start> data++ <end> ;
int data = <start> myStruct <end> .structFirst;
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
void CWE190_Integer_Overflow__int_connect_socket_postinc_67b_badSink(CWE190_Integer_Overflow__int_connect_socket_postinc_67_structType <start> myStruct <end> );
int <start> data = myStruct.structFirst <end> ;"	"int data = <start> myStruct <end> .structFirst;
printIntLine <start> result <end> );
void CWE190_Integer_Overflow__int_connect_socket_postinc_67b_badSink(CWE190_Integer_Overflow__int_connect_socket_postinc_67_structType <start> myStruct <end> );"	0
bda4e42a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 namespace CWE78_OS_Command_Injection__char_listen_socket_execl_82 { void bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE78_OS_Command_Injection__char_listen_socket_execl_82_base* baseObject = new CWE78_OS_Command_Injection__char_listen_socket_execl_82_bad; baseObject->action(data); delete baseObject; }"	where is the vulnerable dataflow from data to action ?	"<start> data = dataBuffer <end> ;
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"<start> data = dataBuffer <end> ;
baseObject->action <start> data <end> );"	"baseObject->action <start> data <end> );
size_t <start> dataLen = strlen(data) <end> ;"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
baseObject->action <start> data <end> );"	3
a95fd86d-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_fgets_sub_66b_badSink(int dataArray[]) { int data = dataArray[2]; { int result = data - 1; printIntLine(result); } }	where is the vulnerable dataflow from result to printIntLine ?	"void CWE191_Integer_Underflow__int_fgets_sub_66b_badSink(int <start> dataArray <end> []);
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;"	"int result = <start> data - 1 <end> ;
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
void CWE191_Integer_Underflow__int_fgets_sub_66b_badSink(int <start> dataArray <end> []);"	0
c1366251-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_console_fopen_52 { void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } badSink_b(data); }"	where is the vulnerable dataflow from data to badSink_b ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
<start> data = dataBuffer <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
badSink_b <start> data <end> );"	"badSink_b <start> data <end> );
dataLen = <start> strlen(data) <end> ;"	"badSink_b <start> data <end> );
<start> badSink_b(data) <end> ;"	1
c39a65bc-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif namespace CWE23_Relative_Path_Traversal__char_environment_ofstream_44 { static void badSink(char * data) { { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } } void bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } funcPtr(data); }"	where is the vulnerable dataflow from data to funcPtr ?	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
funcPtr <start> data <end> );"	"char <start> dataBuffer[FILENAME_MAX] = BASEPATH <end> ;
funcPtr <start> data <end> );"	"char <start> dataBuffer[FILENAME_MAX] = BASEPATH <end> ;
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"size_t <start> dataLen = strlen(data) <end> ;
funcPtr <start> data <end> );"	0
774f583e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 8 void CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_13_bad() { short data; data = 0; if(GLOBAL_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> memcpy(dest, source, data) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"printLine <start> dest <end> );
if  <start> listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR <end> );"	"printLine <start> dest <end> );
<start> printLine(dest) <end> ;"	1
833ac948-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_listen_socket_open_51 { void badSink(char * data) { { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN(data, O_RDWR|O_CREAT, <start> S_IREAD|S_IWRITE <end> );
void badSink(char * <start> data <end> );"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
void badSink(char * <start> data <end> );"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
void badSink(char * <start> data <end> );"	"void badSink(char * <start> data <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	3
6ef7682d-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif static void badVaSinkB(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_console_vfprintf_15_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; switch(6) { case 6: { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } break; default: printLine(""Benign, fixed string""); break; } switch(7) { case 7: badVaSinkB(data, data); break; default: printLine(""Benign, fixed string""); break; } }"	where is the vulnerable dataflow from data to vfprintf ?	"badVaSinkB <start> data <end> , data);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
size_t dataLen = <start> strlen(data) <end> ;
static void badVaSinkB(char * <start> data <end> , ...);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
badVaSinkB <start> data <end> , data);"	"badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
dataLen = <start> strlen(data) <end> ;"	1
73bc8179-6c15-11ed-81d4-94e6f77dd552	"int CWE194_Unexpected_Sign_Extension__connect_socket_memmove_22_badGlobal = 0; short CWE194_Unexpected_Sign_Extension__connect_socket_memmove_22_badSource(short data); void CWE194_Unexpected_Sign_Extension__connect_socket_memmove_22_bad() { short data; data = 0; CWE194_Unexpected_Sign_Extension__connect_socket_memmove_22_badGlobal = 1; data = CWE194_Unexpected_Sign_Extension__connect_socket_memmove_22_badSource(data); { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"printLine <start> dest <end> );
data = <start> CWE194_Unexpected_Sign_Extension__connect_socket_memmove_22_badSource <end> (data);"	"data = <start> CWE194_Unexpected_Sign_Extension__connect_socket_memmove_22_badSource <end> (data);
<start> memmove(dest, source, data) <end> ;"	"data = <start> CWE194_Unexpected_Sign_Extension__connect_socket_memmove_22_badSource <end> (data);
printLine <start> dest <end> );"	"data = <start> CWE194_Unexpected_Sign_Extension__connect_socket_memmove_22_badSource <end> (data);
<start> printLine(dest) <end> ;"	2
73bc817d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" static short badSource(short data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } return data; } void CWE194_Unexpected_Sign_Extension__connect_socket_memmove_42_bad() { short data; data = 0; data = badSource(data); { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"if  <start> data < 100 <end> );
printLine <start> dest <end> );
static short <start> badSource <end> (short data);
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
if  <start> data < 100 <end> );
data = <start> badSource <end> (data);
printLine <start> dest <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static short <start> badSource <end> (short data);
data = <start> badSource <end> (data);
printLine <start> dest <end> );"	"data = <start> badSource <end> (data);
static short <start> badSource <end> (short data);
<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	2
70279c17-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif namespace CWE134_Uncontrolled_Format_String__char_file_snprintf_72 { void badSink(vector<char *> dataVector) { char * data = dataVector[2]; { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	"printLine <start> dest <end> );
void badSink(vector<char *> <start> dataVector <end> );"	"void badSink(vector<char *> <start> dataVector <end> );
<start> printLine(dest) <end> ;"	"void badSink(vector<char *> <start> dataVector <end> );
printLine <start> dest <end> );"	3
6c938be7-6c15-11ed-81d4-94e6f77dd552	"namespace CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_72 { void badSink(vector<int> dataVector) { int data = dataVector[2]; { int i; int * buffer = (int *)malloc(10 * sizeof(int)); if (buffer == NULL) {exit(-1);} for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } free(buffer); } }"	where is the vulnerable dataflow from buffer to free ?	"free <start> buffer <end> );
if  <start> buffer == NULL <end> ) {exit(-1);};"	"void badSink(vector<int> <start> dataVector <end> );
free <start> buffer <end> );"	"free <start> buffer <end> );
int <start> * buffer = (int *)malloc(10 * sizeof(int)) <end> ;"	"free <start> buffer <end> );
<start> free(buffer) <end> ;"	1
7fa68e2d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_connect_socket_fopen_12 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(globalReturnsTrueOrFalse()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } else { strcat(data, ""file.txt""); } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	"size_t dataLen = <start> strlen(data) <end> ;
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	3
9fe7ad58-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_add_52c_badSink(int data) { { int result = data + 1; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
void CWE190_Integer_Overflow__int_connect_socket_add_52c_badSink(int <start> data <end> );"	"void CWE190_Integer_Overflow__int_connect_socket_add_52c_badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	"void CWE190_Integer_Overflow__int_connect_socket_add_52c_badSink(int <start> data <end> );
<start> printIntLine(result) <end> ;"	1
b8e2bdc1-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_82 { void bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_82_base* baseObject = new CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_82_bad; baseObject->action(data); delete baseObject; }"	where is the vulnerable dataflow from data to action ?	"baseObject->action <start> data <end> );
data = <start> atoi(inputBuffer) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
baseObject->action <start> data <end> );"	"recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);
baseObject->action <start> data <end> );"	"baseObject->action <start> data <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	1
8df421c8-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(count) + 2) #ifdef _WIN32 #define SLEEP Sleep #else #define SLEEP usleep #endif static int CWE400_Resource_Exhaustion__listen_socket_sleep_45_badData; static int CWE400_Resource_Exhaustion__listen_socket_sleep_45_goodG2BData; static int CWE400_Resource_Exhaustion__listen_socket_sleep_45_goodB2GData; static void badSink() { int count = CWE400_Resource_Exhaustion__listen_socket_sleep_45_badData; SLEEP(count); printLine(""Sleep time possibly too long""); } void CWE400_Resource_Exhaustion__listen_socket_sleep_45_bad() { int count; count = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; count = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE400_Resource_Exhaustion__listen_socket_sleep_45_badData = count; badSink(); }"	where is the vulnerable dataflow from count to SLEEP ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> CWE400_Resource_Exhaustion__listen_socket_sleep_45_badData = count <end> ;
static int <start> CWE400_Resource_Exhaustion__listen_socket_sleep_45_badData <end> ;
int count = <start> CWE400_Resource_Exhaustion__listen_socket_sleep_45_badData <end> ;
SLEEP <start> count <end> );"	"<start> CWE400_Resource_Exhaustion__listen_socket_sleep_45_badData = count <end> ;
int count = <start> CWE400_Resource_Exhaustion__listen_socket_sleep_45_badData <end> ;
if  <start> acceptSocket == SOCKET_ERROR <end> );
static int <start> CWE400_Resource_Exhaustion__listen_socket_sleep_45_badData <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"if  <start> acceptSocket == SOCKET_ERROR <end> );
int count = <start> CWE400_Resource_Exhaustion__listen_socket_sleep_45_badData <end> ;
<start> CWE400_Resource_Exhaustion__listen_socket_sleep_45_badData = count <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
SLEEP <start> count <end> );"	"SLEEP <start> count <end> );
static int <start> CWE400_Resource_Exhaustion__listen_socket_sleep_45_badData <end> ;
<start> CWE400_Resource_Exhaustion__listen_socket_sleep_45_badData = count <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> SLEEP(count) <end> ;"	0
d0b64ec2-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif namespace CWE36_Absolute_Path_Traversal__char_file_ifstream_03 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(5==5) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"inputFile.open((char * <start> data <end> );
<start> data = dataBuffer <end> ;"	"size_t dataLen = <start> strlen(data) <end> ;
inputFile.open((char * <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
inputFile.open((char * <start> data <end> );"	3
c136628a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif namespace CWE23_Relative_Path_Traversal__char_console_ofstream_17 { void bad() { int i; char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; for(i = 0; i < 1; i++) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"if (dataLen > 0 && <start> data[dataLen-1] == '\n' <end> );
outputFile.open((char * <start> data <end> );"	"char <start> dataBuffer[FILENAME_MAX] = BASEPATH <end> ;
outputFile.open((char * <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
outputFile.open((char * <start> data <end> );"	3
af580939-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_66b_badSink(int dataArray[]) { int data = dataArray[2]; { char charData = (char)data; printHexCharLine(charData); } }"	where is the vulnerable dataflow from charData to printHexCharLine ?	"void CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_66b_badSink(int <start> dataArray <end> []);
<start> printHexCharLine(charData) <end> ;"	"printHexCharLine <start> charData <end> );
void CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_66b_badSink(int <start> dataArray <end> []);"	"<start> printHexCharLine(charData) <end> ;
printHexCharLine <start> charData <end> );"	"void CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_66b_badSink(int <start> dataArray <end> []);
printHexCharLine <start> charData <end> );"	3
a6fd825b-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_preinc_01_bad() { int data; data = 0; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } { ++data; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"int <start> result = data <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	2
715a3bd8-6c15-11ed-81d4-94e6f77dd552	namespace CWE134_Uncontrolled_Format_String__char_file_vprintf_82 { static void badVaSink(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_file_vprintf_82_bad::action(char * data) { badVaSink(data, data); } }	where is the vulnerable dataflow from data to vprintf ?	"void CWE134_Uncontrolled_Format_String__char_file_vprintf_82_bad::action(char * <start> data <end> );
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
vprintf <start> data <end> , args);"	"void CWE134_Uncontrolled_Format_String__char_file_vprintf_82_bad::action(char * <start> data <end> );
vprintf <start> data <end> , args);
<start> vprintf(data, args) <end> ;
static void badVaSink(char * <start> data <end> , ...);"	"static void badVaSink(char * <start> data <end> , ...);
vprintf <start> data <end> , args);
void CWE134_Uncontrolled_Format_String__char_file_vprintf_82_bad::action(char * <start> data <end> );
badVaSink <start> data <end> , data);"	"<start> vprintf(data, args) <end> ;
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
vprintf <start> data <end> , args);"	0
656cd415-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__int_rand_square_17_bad() { int i,j; int data; data = 0; for(i = 0; i < 1; i++) { data = RAND32(); } for(j = 0; j < 1; j++) { { int result = data * data; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  * data;"	"data = <start> RAND32() <end> ;
int <start> result = data * data <end> ;"	"int result = <start> data <end>  * data;
data = <start> RAND32() <end> ;"	"data = <start> RAND32() <end> ;
int result = <start> data <end>  * data;"	3
b41b87a9-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 20 #define IP_ADDRESS ""127.0.0.1"" static float CWE369_Divide_by_Zero__float_connect_socket_45_badData; static float CWE369_Divide_by_Zero__float_connect_socket_45_goodG2BData; static float CWE369_Divide_by_Zero__float_connect_socket_45_goodB2GData; static void badSink() { float data = CWE369_Divide_by_Zero__float_connect_socket_45_badData; { int result = (int)(100.0 / data); printIntLine(result); } } void CWE369_Divide_by_Zero__float_connect_socket_45_bad() { float data; data = 0.0F; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = (float)atof(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE369_Divide_by_Zero__float_connect_socket_45_badData = data; badSink(); }"	where is the vulnerable dataflow from result to printIntLine ?	"float data = <start> CWE369_Divide_by_Zero__float_connect_socket_45_badData <end> ;
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> result <end> );
static float <start> CWE369_Divide_by_Zero__float_connect_socket_45_badData <end> ;
<start> CWE369_Divide_by_Zero__float_connect_socket_45_badData = data <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> CWE369_Divide_by_Zero__float_connect_socket_45_badData = data <end> ;
static float <start> CWE369_Divide_by_Zero__float_connect_socket_45_badData <end> ;
float data = <start> CWE369_Divide_by_Zero__float_connect_socket_45_badData <end> ;
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
float data = <start> CWE369_Divide_by_Zero__float_connect_socket_45_badData <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> CWE369_Divide_by_Zero__float_connect_socket_45_badData = data <end> ;
int <start> result = (int)(100.0 / data) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> CWE369_Divide_by_Zero__float_connect_socket_45_badData = data <end> ;"	1
6dc614d6-6c15-11ed-81d4-94e6f77dd552	namespace CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_81 { static void badVaSink(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_81_bad::action(char * data) const { badVaSink(data, data); } }	where is the vulnerable dataflow from data to vfprintf ?	"void CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_81_bad::action(char * <start> data <end> ) const;
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);"	"vfprintf(stdout, <start> data <end> , args);
void CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_81_bad::action(char * <start> data <end> ) const;
badVaSink <start> data <end> , data);"	"vfprintf(stdout, <start> data <end> , args);
void CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_81_bad::action(char * <start> data <end> ) const;"	"badVaSink <start> data <end> , data);
<start> vfprintf(stdout, data, args) <end> ;
static void badVaSink(char * <start> data <end> , ...);
void CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_81_bad::action(char * <start> data <end> ) const;"	0
466e7ee1-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) typedef union { int unionFirst; int unionSecond; } CWE190_Integer_Overflow__int_fgets_multiply_34_unionType; void CWE190_Integer_Overflow__int_fgets_multiply_34_bad() { int data; CWE190_Integer_Overflow__int_fgets_multiply_34_unionType myUnion; data = 0; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } myUnion.unionFirst = data; { int data = myUnion.unionSecond; if(data > 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
int result = <start> data <end>  * 2;"	"int <start> result = data * 2 <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"int result = <start> data <end>  * 2;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"int result = <start> data * 2 <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	0
b54bcf0a-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 20 static void badSink(float data) { { int result = (int)(100.0 / data); printIntLine(result); } } void CWE369_Divide_by_Zero__float_fgets_41_bad() { float data; data = 0.0F; { char inputBuffer[CHAR_ARRAY_SIZE]; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = (float)atof(inputBuffer); } else { printLine(""fgets() failed.""); } } badSink(data); }"	where is the vulnerable dataflow from result to printIntLine ?	"data = <start> (float)atof(inputBuffer) <end> ;
static void badSink(float <start> data <end> );
badSink <start> data <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"badSink <start> data <end> );
printIntLine <start> result <end> );
<start> badSink(data) <end> ;
static void badSink(float <start> data <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
badSink <start> data <end> );
static void badSink(float <start> data <end> );
printIntLine <start> result <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> data = 0.0F <end> ;
static void badSink(float <start> data <end> );
printIntLine <start> result <end> );"	2
846ad2f2-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif void CWE252_Unchecked_Return_Value__char_fgets_11_bad() { if(globalReturnsTrue()) { { char dataBuffer[100] = """"; char * data = dataBuffer; printLine(""Please enter a string: ""); fgets(data, 100, stdin); printLine(data); } } }"	where is the vulnerable dataflow from data to printLine ?	"fgets <start> data <end> , 100, stdin);
<start> printLine(data) <end> ;"	"printLine <start> data <end> );
<start> printLine(data) <end> ;"	"fgets <start> data <end> , 100, stdin);
printLine <start> data <end> );"	"printLine <start> data <end> );
fgets <start> data <end> , 100, stdin);"	2
c99197c9-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define STAT _stat #define OPEN _open #define WRITE _write #define O_RDWR _O_RDWR #define CLOSE _close #else #define STAT stat #define OPEN open #define WRITE write #define CLOSE close #endif #define BAD_SINK_STRING ""Bad Sink..."" #define GOOD_SINK_STRING ""Good Sink..."" static const int STATIC_CONST_FIVE = 5; void CWE367_TOC_TOU__stat_06_bad() { if(STATIC_CONST_FIVE==5) { { char filename[100] = """"; struct STAT statBuffer; int fileDesc = -1; if (fgets(filename, 100, stdin) == NULL) { printLine(""fgets() failed""); filename[0] = '\0'; } if (strlen(filename) > 0) { filename[strlen(filename)-1] = '\0'; } if (STAT(filename, &statBuffer) == -1) { exit(1); } fileDesc  = OPEN(filename, O_RDWR); if (fileDesc == -1) { exit(1); } if (WRITE(fileDesc, BAD_SINK_STRING, strlen(BAD_SINK_STRING)) == -1) { exit(1); } if (fileDesc != -1) { CLOSE(fileDesc); } } } }"	where is the vulnerable dataflow from filename to OPEN ?	"fileDesc  = OPEN <start> filename <end> , O_RDWR);
if  <start> fgets(filename, 100, stdin) <end>  == NULL);"	"if (fgets <start> filename <end> , 100, stdin) == NULL);
fileDesc  = OPEN <start> filename <end> , O_RDWR);"	"if (fgets <start> filename <end> , 100, stdin) == NULL);
if  <start> STAT(filename, &statBuffer) <end>  == -1);"	"fileDesc  = OPEN <start> filename <end> , O_RDWR);
if  <start> STAT(filename, &statBuffer) <end>  == -1);"	1
598370e5-6c15-11ed-81d4-94e6f77dd552	"static unsigned int CWE191_Integer_Underflow__unsigned_int_fscanf_sub_45_badData; static unsigned int CWE191_Integer_Underflow__unsigned_int_fscanf_sub_45_goodG2BData; static unsigned int CWE191_Integer_Underflow__unsigned_int_fscanf_sub_45_goodB2GData; static void badSink() { unsigned int data = CWE191_Integer_Underflow__unsigned_int_fscanf_sub_45_badData; { unsigned int result = data - 1; printUnsignedLine(result); } } void CWE191_Integer_Underflow__unsigned_int_fscanf_sub_45_bad() { unsigned int data; data = 0; fscanf (stdin, ""%u"", &data); CWE191_Integer_Underflow__unsigned_int_fscanf_sub_45_badData = data; badSink(); }"	where is the vulnerable dataflow from data ?	"<start> CWE191_Integer_Underflow__unsigned_int_fscanf_sub_45_badData = data <end> ;
unsigned int data = <start> CWE191_Integer_Underflow__unsigned_int_fscanf_sub_45_badData <end> ;
static unsigned int <start> CWE191_Integer_Underflow__unsigned_int_fscanf_sub_45_badData <end> ;
fscanf (stdin, ""%u"", <start> &data <end> );
unsigned int result = <start> data <end>  - 1;"	"<start> CWE191_Integer_Underflow__unsigned_int_fscanf_sub_45_badData = data <end> ;
fscanf (stdin, ""%u"", <start> &data <end> );"	"fscanf (stdin, ""%u"", <start> &data <end> );
<start> CWE191_Integer_Underflow__unsigned_int_fscanf_sub_45_badData = data <end> ;
static unsigned int <start> CWE191_Integer_Underflow__unsigned_int_fscanf_sub_45_badData <end> ;
unsigned int data = <start> CWE191_Integer_Underflow__unsigned_int_fscanf_sub_45_badData <end> ;"	"fscanf (stdin, ""%u"", <start> &data <end> );
<start> CWE191_Integer_Underflow__unsigned_int_fscanf_sub_45_badData = data <end> ;
static unsigned int <start> CWE191_Integer_Underflow__unsigned_int_fscanf_sub_45_badData <end> ;
unsigned int data = <start> CWE191_Integer_Underflow__unsigned_int_fscanf_sub_45_badData <end> ;
unsigned int result = <start> data <end>  - 1;"	3
54c5820a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_connect_socket_sub_02_bad() { int data; data = 0; if(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(1) { { int result = data - 1; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  - 1;
recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data - 1 <end> ;"	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
int result = <start> data <end>  - 1;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  - 1;"	3
54c58215-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_connect_socket_sub_14_bad() { int data; data = 0; if(globalFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalFive==5) { { int result = data - 1; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  - 1;
recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  - 1;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data = 0 <end> ;"	"int result = <start> data <end>  - 1;
<start> printIntLine(result) <end> ;"	1
87ff9853-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_connect_socket_fopen_43 { void badSource(char * &data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; badSource(data); { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"recvResult = <start> recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0) <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");
badSource <start> data <end> );"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
badSource <start> data <end> );
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
badSource <start> data <end> );
char <start> dataBuffer[FILENAME_MAX] = """" <end> ;"	"pFile = FOPEN <start> data <end> , ""wb+"");
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
replace = <start> strchr(data, '\n') <end> ;"	1
630ae7e9-6c15-11ed-81d4-94e6f77dd552	static short badSource(short data) { data = (short)RAND32(); return data; } void CWE190_Integer_Overflow__short_rand_multiply_42_bad() { short data; data = 0; data = badSource(data); if(data > 0) { short result = data * 2; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
short result = <start> data <end>  * 2;
data = <start> badSource <end> (data);
data = (short <start> RAND32() <end> ;"	"data = (short <start> RAND32() <end> ;
static short <start> badSource <end> (short data);
data = <start> badSource <end> (data);
short result = <start> data <end>  * 2;"	"short result = <start> data * 2 <end> ;
static short <start> badSource <end> (short data);
data = <start> badSource <end> (data);
data = (short <start> RAND32() <end> ;"	"<start> printIntLine(result) <end> ;
short result = <start> data <end>  * 2;
data = <start> badSource <end> (data);
static short <start> badSource <end> (short data);"	1
715a3bdb-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif void CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_01_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
printLine <start> dest <end> );"	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	"printLine <start> dest <end> );
size_t dataLen = <start> strlen(data) <end> ;"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );"	0
47a2a819-6c15-11ed-81d4-94e6f77dd552	"namespace CWE190_Integer_Overflow__int_fscanf_add_43 { static void badSource(int &data) { fscanf(stdin, ""%d"", &data); } void bad() { int data; data = 0; badSource(data); { int result = data + 1; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"badSource <start> data <end> );
<start> data = 0 <end> ;
fscanf(stdin, ""%d"", <start> &data <end> );"	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  + 1;
fscanf(stdin, ""%d"", <start> &data <end> );"	"fscanf(stdin, ""%d"", <start> &data <end> );
badSource <start> data <end> );
int result = <start> data <end>  + 1;"	"badSource <start> data <end> );
<start> printIntLine(result) <end> ;
fscanf(stdin, ""%d"", <start> &data <end> );"	2
728a501d-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 static void badVaSink(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); va_end(args); } } static void badSink(char * data) { badVaSink(data, data); } void CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_41_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badSink(data); }"	where is the vulnerable dataflow from data to vprintf ?	"static void badSink(char * <start> data <end> );
vprintf <start> data <end> , args);
badSink <start> data <end> );
static void badVaSink(char * <start> data <end> , ...);
size_t dataLen = <start> strlen(data) <end> ;
badVaSink <start> data <end> , data);"	"static void badSink(char * <start> data <end> );
<start> badSink(data) <end> ;
badSink <start> data <end> );
vprintf <start> data <end> , args);
static void badVaSink(char * <start> data <end> , ...);
badVaSink <start> data <end> , data);"	"size_t dataLen = <start> strlen(data) <end> ;
vprintf <start> data <end> , args);
static void badVaSink(char * <start> data <end> , ...);
badVaSink <start> data <end> , data);
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
badSink <start> data <end> );"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
badSink <start> data <end> );
static void badSink(char * <start> data <end> );
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
vprintf <start> data <end> , args);"	3
89321801-6c15-11ed-81d4-94e6f77dd552	#ifndef _WIN32 #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_console_open_72 { void badSink(vector<char *> dataVector) { char * data = dataVector[2]; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
void badSink(vector<char *> <start> dataVector <end> );"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
void badSink(vector<char *> <start> dataVector <end> );"	"void badSink(vector<char *> <start> dataVector <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN(data, O_RDWR|O_CREAT, <start> S_IREAD|S_IWRITE <end> );
void badSink(vector<char *> <start> dataVector <end> );"	2
bda4e432-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define EXECLP _execlp #else #define EXECLP execlp #endif static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } void CWE78_OS_Command_Injection__char_listen_socket_execlp_08_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(staticReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECLP ?	"EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
<start> data = dataBuffer <end> ;"	"EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
recvResult = recv(acceptSocket, (char *)(data + dataLen), <start> sizeof(char) * (100 - dataLen - 1) <end> , 0);"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (100 - dataLen - 1), 0);"	2
538bfae2-6c15-11ed-81d4-94e6f77dd552	typedef struct _CWE190_Integer_Overflow__short_fscanf_preinc_67_structType { short structFirst; } CWE190_Integer_Overflow__short_fscanf_preinc_67_structType; void CWE190_Integer_Overflow__short_fscanf_preinc_67b_badSink(CWE190_Integer_Overflow__short_fscanf_preinc_67_structType myStruct) { short data = myStruct.structFirst; { ++data; short result = data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"void CWE190_Integer_Overflow__short_fscanf_preinc_67b_badSink(CWE190_Integer_Overflow__short_fscanf_preinc_67_structType <start> myStruct <end> );
+ <start> data <end> ;
short <start> result = data <end> ;"	"+ <start> data <end> ;
void CWE190_Integer_Overflow__short_fscanf_preinc_67b_badSink(CWE190_Integer_Overflow__short_fscanf_preinc_67_structType <start> myStruct <end> );
<start> printIntLine(result) <end> ;"	"void CWE190_Integer_Overflow__short_fscanf_preinc_67b_badSink(CWE190_Integer_Overflow__short_fscanf_preinc_67_structType <start> myStruct <end> );
short data = <start> myStruct <end> .structFirst;
+ <start> data <end> ;"	"short <start> result = data <end> ;
void CWE190_Integer_Overflow__short_fscanf_preinc_67b_badSink(CWE190_Integer_Overflow__short_fscanf_preinc_67_structType <start> myStruct <end> );
short data = <start> myStruct <end> .structFirst;"	2
9ebc76c4-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink(int data) { { int buffer[10] = { 0 }; if (data < 10) { printIntLine(buffer[data]); } else { printLine(""ERROR: Array index is too big.""); } } } void CWE127_Buffer_Underread__CWE839_fgets_41_bad() { int data; data = -1; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } badSink(data); }"	where is the vulnerable dataflow from buffer[data] to printIntLine ?	"<start> badSink(data) <end> ;
badSink <start> data <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> buffer[data] <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
badSink <start> data <end> );
static void badSink(int <start> data <end> );
printIntLine <start> buffer[data] <end> );"	"int <start> buffer[10] = { 0 } <end> ;
static void badSink(int <start> data <end> );
badSink <start> data <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"badSink <start> data <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> buffer[data] <end> );
static void badSink(int <start> data <end> );"	1
85b15ee7-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE369_Divide_by_Zero__int_fgets_divide_02_bad() { int data; data = -1; if(1) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(1) { printIntLine(100 / data); } }"	where is the vulnerable dataflow from data to printIntLine ?	"<start> data = atoi(inputBuffer) <end> ;
printIntLine <start> 100 / data <end> );"	"<start> data = atoi(inputBuffer) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"printIntLine <start> 100 / data <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> 100 / data <end> );"	3
a6fd8280-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_preinc_02_bad() { int data; data = 0; if(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(1) { { ++data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data = atoi(inputBuffer) <end> ;"	"if  <start> listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR <end> );
printIntLine <start> result <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;"	2
c5fc235e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif namespace CWE23_Relative_Path_Traversal__char_file_ofstream_41 { void badSink(char * data) { { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } } void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } badSink(data); }"	where is the vulnerable dataflow from data to badSink ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
badSink <start> data <end> );"	"badSink <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"<start> badSink(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"<start> data = dataBuffer <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	0
5d16c9e0-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_connect_socket_predec_02_bad() { int data; data = 0; if(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(1) { { --data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"int <start> result = data <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
- <start> data <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data = atoi(inputBuffer) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
- <start> data <end> ;"	3
55ef4cd3-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_fgets_sub_31_bad() { int data; data = 0; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } { int dataCopy = data; int data = dataCopy; { int result = data - 1; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  - 1;"	"int result = <start> data <end>  - 1;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
int result = <start> data <end>  - 1;"	"int result = <start> data <end>  - 1;
data = <start> atoi(inputBuffer) <end> ;"	2
6b86241d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_connect_socket_04_bad() { int data; data = -1; if(STATIC_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(STATIC_CONST_TRUE) { { int i; int * buffer = (int *)malloc(10 * sizeof(int)); if (buffer == NULL) {exit(-1);} for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } free(buffer); } } }"	where is the vulnerable dataflow from buffer to free ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
free <start> buffer <end> );"	"free <start> buffer <end> );
if  <start> buffer == NULL <end> ) {exit(-1);};"	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
free <start> buffer <end> );"	"free <start> buffer <end> );
<start> free(buffer) <end> ;"	0
a23a3e33-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_multiply_54e_badSink(int data) { if(data > 0) { int result = data * 2; printIntLine(result); } }	where is the vulnerable dataflow from result to printIntLine ?	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	"void CWE190_Integer_Overflow__int_fgets_multiply_54e_badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"int <start> result = data * 2 <end> ;
printIntLine <start> result <end> );"	"<start> printIntLine(result) <end> ;
void CWE190_Integer_Overflow__int_fgets_multiply_54e_badSink(int <start> data <end> );"	1
a49c4f62-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_square_02_bad() { int data; data = 0; if(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(1) { { int result = data * data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int <start> result = data * data <end> ;"	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
int <start> result = data * data <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	3
833ac922-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_listen_socket_fopen_45 { static char * badData; static char * goodG2BData; static void badSink() { char * data = badData; { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } } void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badData = data; badSink(); }"	where is the vulnerable dataflow from data to FOPEN ?	"recvResult = recv(acceptSocket, (char *)(data + dataLen), <start> sizeof(char) * (FILENAME_MAX - dataLen - 1) <end> , 0);
char * data = <start> badData <end> ;
static char * <start> badData <end> ;
<start> badData = data <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"size_t dataLen = <start> strlen(data) <end> ;
char * data = <start> badData <end> ;
<start> badData = data <end> ;
static char * <start> badData <end> ;
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
<start> badData = data <end> ;
static char * <start> badData <end> ;
char * data = <start> badData <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"char * data = <start> badData <end> ;
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
static char * <start> badData <end> ;
pFile = <start> FOPEN(data, ""wb+"") <end> ;
<start> badData = data <end> ;"	2
ce547d4a-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif namespace CWE36_Absolute_Path_Traversal__char_environment_ifstream_31 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } { char * dataCopy = data; char * data = dataCopy; { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } } }"	where is the vulnerable dataflow from data to open ?	"inputFile.open((char * <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
strncat(data+dataLen, environment, FILENAME_MAX <start> dataLen-1 <end> );"	"inputFile.open((char * <start> data <end> );
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
inputFile.open((char * <start> data <end> );"	3
cbf23798-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif extern char * CWE36_Absolute_Path_Traversal__char_connect_socket_open_68_badData; extern char * CWE36_Absolute_Path_Traversal__char_connect_socket_open_68_goodG2BData; namespace CWE36_Absolute_Path_Traversal__char_connect_socket_open_68 { void badSink() { char * data = CWE36_Absolute_Path_Traversal__char_connect_socket_open_68_badData; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
char * data = <start> CWE36_Absolute_Path_Traversal__char_connect_socket_open_68_badData <end> ;"	"char * data = <start> CWE36_Absolute_Path_Traversal__char_connect_socket_open_68_badData <end> ;
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"char * data = <start> CWE36_Absolute_Path_Traversal__char_connect_socket_open_68_badData <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	2
55ef4c92-6c15-11ed-81d4-94e6f77dd552	namespace CWE191_Integer_Underflow__int_connect_socket_sub_74 { void badSink(map<int, int> dataMap) { int data = dataMap[2]; { int result = data - 1; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"void badSink(map<int, int> <start> dataMap <end> );
int result = <start> data <end>  - 1;"	"void badSink(map<int, int> <start> dataMap <end> );
int <start> result = data - 1 <end> ;"	"int result = <start> data <end>  - 1;
void badSink(map<int, int> <start> dataMap <end> );"	"<start> printIntLine(result) <end> ;
void badSink(map<int, int> <start> dataMap <end> );"	0
a6fd826f-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_preinc_31_bad() { int data; data = 0; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } { int dataCopy = data; int data = dataCopy; { ++data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"<start> printIntLine(result) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"printIntLine <start> result <end> );
int <start> result = data <end> ;"	"printIntLine <start> result <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );"	3
acf67e31-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_connect_socket_predec_53d_badSink(int data) { { --data; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"<start> printIntLine(result) <end> ;
void CWE191_Integer_Underflow__int_connect_socket_predec_53d_badSink(int <start> data <end> );"	"int <start> result = data <end> ;
void CWE191_Integer_Underflow__int_connect_socket_predec_53d_badSink(int <start> data <end> );"	"<start> --data <end> ;
printIntLine <start> result <end> );"	"void CWE191_Integer_Underflow__int_connect_socket_predec_53d_badSink(int <start> data <end> );
printIntLine <start> result <end> );"	3
d1e9da22-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_file_open_66 { void badSink(char * dataArray[]) { char * data = dataArray[2]; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"void badSink(char * <start> dataArray <end> []);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
void badSink(char * <start> dataArray <end> []);"	"void badSink(char * <start> dataArray <end> []);
char <start> * data = dataArray[2] <end> ;"	1
a36a7914-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticFive = 5; void CWE190_Integer_Overflow__int_listen_socket_multiply_07_bad() { int data; data = 0; if(staticFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticFive==5) { if(data > 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"data = <start> atoi(inputBuffer) <end> ;
printIntLine <start> result <end> );"	"int result = <start> data * 2 <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data = atoi(inputBuffer) <end> ;"	0
48d25d81-6c15-11ed-81d4-94e6f77dd552	"void CWE190_Integer_Overflow__int_fscanf_square_15_bad() { int data; data = 0; switch(6) { case 6: fscanf(stdin, ""%d"", &data); break; default: printLine(""Benign, fixed string""); break; } switch(7) { case 7: { int result = data * data; printIntLine(result); } break; default: printLine(""Benign, fixed string""); break; } }"	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  * data;
<start> printIntLine(result) <end> ;"	"fscanf(stdin, ""%d"", <start> &data <end> );
int result = <start> data <end>  * data;"	"<start> printIntLine(result) <end> ;
fscanf(stdin, ""%d"", <start> &data <end> );"	"int result = <start> data <end>  * data;
fscanf(stdin, ""%d"", <start> &data <end> );"	1
964cdbfb-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FULL_COMMAND ""dir "" #else #define FULL_COMMAND ""ls "" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define POPEN _popen #define PCLOSE _pclose #else #define POPEN popen #define PCLOSE pclose #endif void CWE78_OS_Command_Injection__char_file_popen_63b_badSink(char * * dataPtr) { char * data = *dataPtr; { FILE *pipe; pipe = POPEN(data, ""w""); if (pipe != NULL) { PCLOSE(pipe); } } }"	where is the vulnerable dataflow from data to POPEN ?	"pipe = <start> POPEN(data, ""w"") <end> ;
pipe = POPEN <start> data <end> , ""w"");"	"pipe = POPEN <start> data <end> , ""w"");
void CWE78_OS_Command_Injection__char_file_popen_63b_badSink(char * * <start> dataPtr <end> );"	"pipe = <start> POPEN(data, ""w"") <end> ;
void CWE78_OS_Command_Injection__char_file_popen_63b_badSink(char * * <start> dataPtr <end> );"	"void CWE78_OS_Command_Injection__char_file_popen_63b_badSink(char * * <start> dataPtr <end> );
pipe = POPEN <start> data <end> , ""w"");"	3
a6fd8242-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_preinc_12_bad() { int data; data = 0; if(globalReturnsTrueOrFalse()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } else { data = 2; } if(globalReturnsTrueOrFalse()) { { ++data; int result = data; printIntLine(result); } } else { if (data < INT_MAX) { ++data; int result = data; printIntLine(result); } else { printLine(""data value is too large to perform arithmetic safely.""); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"data = <start> atoi(inputBuffer) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"data = <start> atoi(inputBuffer) <end> ;
printIntLine <start> result <end> );"	"<start> data = atoi(inputBuffer) <end> ;
printIntLine <start> result <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	3
8f278a41-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define PATH_SZ 100 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define PATH_SZ PATH_MAX #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 void CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__listen_bind_accept_09_bad() { if(GLOBAL_CONST_TRUE) { { char data[100] = """"; #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[recvResult] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif printLine(data); } } }"	where is the vulnerable dataflow from data to printLine ?	"size_t <start> dataLen = strlen(data) <end> ;
recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);"	"recvResult = recv(acceptSocket, <start> (char *)data <end> +dataLen, (int)(100-dataLen-1), 0);
printLine <start> data <end> );"	"printLine <start> data <end> );
replace = <start> strchr(data, '\n') <end> ;"	"recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);
printLine <start> data <end> );"	3
525b6472-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_preinc_65b_badSink(int data) { { ++data; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"void CWE190_Integer_Overflow__int_listen_socket_preinc_65b_badSink(int <start> data <end> );
int <start> result = data <end> ;"	"void CWE190_Integer_Overflow__int_listen_socket_preinc_65b_badSink(int <start> data <end> );
<start> printIntLine(result) <end> ;"	"+ <start> data <end> ;
void CWE190_Integer_Overflow__int_listen_socket_preinc_65b_badSink(int <start> data <end> );"	"void CWE190_Integer_Overflow__int_listen_socket_preinc_65b_badSink(int <start> data <end> );
+ <start> data <end> ;"	3
728a5001-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 extern char * CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_68_badData; extern char * CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_68_goodG2BData; extern char * CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_68_goodB2GData; static void badVaSink(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_68b_badSink() { char * data = CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_68_badData; badVaSink(data, data); }"	where is the vulnerable dataflow from data to vfprintf ?	"char * data = <start> CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_68_badData <end> ;
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);"	"<start> va_start(args, data) <end> ;
vfprintf(stdout, <start> data <end> , args);
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);"	"static void badVaSink(char * <start> data <end> , ...);
char * data = <start> CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_68_badData <end> ;
vfprintf(stdout, <start> data <end> , args);
badVaSink <start> data <end> , data);"	"char * data = <start> CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_68_badData <end> ;
<start> vfprintf(stdout, data, args) <end> ;
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);"	0
69161b3e-6c15-11ed-81d4-94e6f77dd552	static int badSource(int data) { data = RAND32(); return data; } void CWE190_Integer_Overflow__int_rand_preinc_42_bad() { int data; data = 0; data = badSource(data); { ++data; int result = data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"data = <start> RAND32() <end> ;
static int <start> badSource <end> (int data);
data = <start> badSource <end> (data);
+ <start> data <end> ;"	"+ <start> data <end> ;
data = <start> badSource <end> (data);"	"static int <start> badSource <end> (int data);
data = <start> RAND32() <end> ;
<start> ++data <end> ;
+ <start> data <end> ;"	"<start> printIntLine(result) <end> ;
static int <start> badSource <end> (int data);
+ <start> data <end> ;
data = <start> badSource <end> (data);"	0
acf67e47-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_fgets_predec_14_bad() { int data; data = 0; if(globalFive==5) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(globalFive==5) { { --data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"int <start> result = data <end> ;
printIntLine <start> result <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
if  <start> fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) <end>  != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> printIntLine(result) <end> ;"	1
7c1275b8-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_14_bad() { int data; data = -1; if(globalFive==5) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"printLine <start> dest <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printLine <start> dest <end> );"	"<start> memmove(dest, source, data) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"<start> printLine(dest) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	1
c26a7e42-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_console_open_13 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(GLOBAL_CONST_FIVE==5) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"size_t dataLen = <start> strlen(data) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	1
5f76fc85-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_listen_socket_predec_15_bad() { int data; data = 0; switch(6) { case 6: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; default: printLine(""Benign, fixed string""); break; } switch(7) { case 7: { --data; int result = data; printIntLine(result); } break; default: printLine(""Benign, fixed string""); break; } }"	where is the vulnerable dataflow from data ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
- <start> data <end> ;"	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
- <start> data <end> ;"	"- <start> data <end> ;
<start> recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"- <start> data <end> ;
int <start> result = data <end> ;"	0
74ee2414-6c15-11ed-81d4-94e6f77dd552	namespace CWE194_Unexpected_Sign_Extension__fgets_malloc_62 { void badSource(short &data); void bad() { short data; data = 0; badSource(data); if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }	where is the vulnerable dataflow from data to malloc ?	"badSource <start> data <end> );
<start> printLine(dataBuffer) <end> ;"	"char * dataBuffer = (char *)malloc <start> data <end> );
badSource <start> data <end> );"	"badSource <start> data <end> );
char * dataBuffer = (char * <start> malloc(data) <end> ;"	"badSource <start> data <end> );
char * dataBuffer = (char *)malloc <start> data <end> );"	3
86cea150-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE369_Divide_by_Zero__int_listen_socket_divide_15_bad() { int data; data = -1; switch(6) { case 6: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; default: printLine(""Benign, fixed string""); break; } switch(7) { case 7: printIntLine(100 / data); break; default: printLine(""Benign, fixed string""); break; } }"	where is the vulnerable dataflow from data to printIntLine ?	"if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> 100 / data <end> );"	"printIntLine <start> 100 / data <end> );
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"printIntLine <start> 100 / data <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	1
48d25dc8-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_multiply_03_bad() { int data; data = 0; if(5==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(5==5) { if(data > 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printIntLine(result) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  * 2;"	"if <start> data > 0 <end> ) ;
int result = <start> data <end>  * 2;"	"int result = <start> data <end>  * 2;
<start> printIntLine(result) <end> ;"	1
cf8750a3-6c15-11ed-81d4-94e6f77dd552	#ifndef _WIN32 #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_environment_open_74 { void badSink(map<int, char *> dataMap) { char * data = dataMap[2]; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }	where is the vulnerable dataflow from data to OPEN ?	"char <start> * data = dataMap[2] <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);
void badSink(map<int, char *> <start> dataMap <end> );"	"char <start> * data = dataMap[2] <end> ;
void badSink(map<int, char *> <start> dataMap <end> );"	"void badSink(map<int, char *> <start> dataMap <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	3
5e44fc77-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_fgets_predec_15_bad() { int data; data = 0; switch(6) { case 6: { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } break; default: printLine(""Benign, fixed string""); break; } switch(7) { case 7: { --data; int result = data; printIntLine(result); } break; default: printLine(""Benign, fixed string""); break; } }"	where is the vulnerable dataflow from data ?	"- <start> data <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"<start> printIntLine(result) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
- <start> data <end> ;"	"- <start> data <end> ;
<start> --data <end> ;"	2
669edac0-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__char_rand_postinc_17_bad() { int i,j; char data; data = ' '; for(i = 0; i < 1; i++) { data = (char)RAND32(); } for(j = 0; j < 1; j++) { { data++; char result = data; printHexCharLine(result); } } }	where is the vulnerable dataflow from data ?	"<start> data <end> ++;
data = (char <start> RAND32() <end> ;"	"<start> printHexCharLine(result) <end> ;
<start> data <end> ++;"	"data = (char <start> RAND32() <end> ;
<start> data <end> ++;"	"data = (char <start> RAND32() <end> ;
<start> printHexCharLine(result) <end> ;"	2
a6fd8263-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_preinc_09_bad() { int data; data = 0; if(GLOBAL_CONST_TRUE) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(GLOBAL_CONST_TRUE) { { ++data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> ++data <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> data = 0 <end> ;"	"printIntLine <start> result <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	1
79b27519-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_01_bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }"	where is the vulnerable dataflow from data to malloc ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data = atoi(inputBuffer) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
char * dataBuffer = (char *)malloc <start> data <end> );"	"if  <start> dataBuffer == NULL <end> ) {exit(-1);};
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"<start> data = -1 <end> ;
char * dataBuffer = (char *)malloc <start> data <end> );"	1
6ef7684e-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif static const int STATIC_CONST_FIVE = 5; static void badVaSinkB(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_console_vprintf_06_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; if(STATIC_CONST_FIVE==5) { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } if(STATIC_CONST_FIVE==5) { badVaSinkB(data, data); } }"	where is the vulnerable dataflow from data to vprintf ?	"vprintf <start> data <end> , args);
static void badVaSinkB(char * <start> data <end> , ...);"	"<start> vprintf(data, args) <end> ;
badVaSinkB <start> data <end> , data);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
vprintf <start> data <end> , args);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);
vprintf <start> data <end> , args);"	"<start> data = dataBuffer <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
vprintf <start> data <end> , args);
badVaSinkB <start> data <end> , data);"	2
60db838f-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__char_rand_add_03_bad() { char data; data = ' '; if(5==5) { data = (char)RAND32(); } if(5==5) { { char result = data + 1; printHexCharLine(result); } } }	where is the vulnerable dataflow from data ?	"data = (char <start> RAND32() <end> ;
<start> data = (char)RAND32() <end> ;"	"data = (char <start> RAND32() <end> ;
char result = <start> data <end>  + 1;"	"<start> printHexCharLine(result) <end> ;
data = (char <start> RAND32() <end> ;"	"char <start> result = data + 1 <end> ;
data = (char <start> RAND32() <end> ;"	1
9059f3d0-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 256 void CWE681_Incorrect_Conversion_Between_Numeric_Types__double2int_16_bad() { while(1) { { char inputBuffer[CHAR_ARRAY_SIZE]; double doubleNumber = 0; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { doubleNumber = atof(inputBuffer); } else { printLine(""fgets() failed.""); } printIntLine((int)doubleNumber); } break; } }"	where is the vulnerable dataflow from (int)doubleNumber to printIntLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> (int)doubleNumber <end> );"	"<start> doubleNumber = atof(inputBuffer) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"doubleNumber = <start> atof(inputBuffer) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"printIntLine <start> (int)doubleNumber <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	0
c26a7e79-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_environment_fopen_43 { void badSource(char * &data) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } } void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; badSource(data); { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"strncat(data+dataLen, environment, <start> FILENAME_MAX-dataLen-1 <end> );
badSource <start> data <end> );
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
pFile = FOPEN <start> data <end> , ""wb+"");
<start> data = dataBuffer <end> ;"	"<start> data = dataBuffer <end> ;
badSource <start> data <end> );
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
badSource <start> data <end> );
pFile = FOPEN <start> data <end> , ""wb+"");"	3
715a3bb6-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif static void badVaSinkB(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_file_vprintf_09_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; if(GLOBAL_CONST_TRUE) { { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } if(GLOBAL_CONST_TRUE) { badVaSinkB(data, data); } }"	where is the vulnerable dataflow from data to vprintf ?	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);
vprintf <start> data <end> , args);"	"badVaSinkB <start> data <end> , data);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
static void badVaSinkB(char * <start> data <end> , ...);
<start> va_start(args, data) <end> ;"	"vprintf <start> data <end> , args);
static void badVaSinkB(char * <start> data <end> , ...);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	"<start> vprintf(data, args) <end> ;
vprintf <start> data <end> , args);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
static void badVaSinkB(char * <start> data <end> , ...);"	0
630ae81e-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__short_rand_square_66b_badSink(short dataArray[]) { short data = dataArray[2]; { short result = data * data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"short <start> result = data * data <end> ;
void CWE190_Integer_Overflow__short_rand_square_66b_badSink(short <start> dataArray <end> []);"	"<start> printIntLine(result) <end> ;
void CWE190_Integer_Overflow__short_rand_square_66b_badSink(short <start> dataArray <end> []);"	"void CWE190_Integer_Overflow__short_rand_square_66b_badSink(short <start> dataArray <end> []);
short result = <start> data <end>  * data;"	"short result = <start> data <end>  * data;
void CWE190_Integer_Overflow__short_rand_square_66b_badSink(short <start> dataArray <end> []);"	2
b7b09a2a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" namespace CWE427_Uncontrolled_Search_Path_Element__char_connect_socket_82 { void bad() { char * data; char dataBuffer[250] = ""PATH=""; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (250 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE427_Uncontrolled_Search_Path_Element__char_connect_socket_82_base* baseObject = new CWE427_Uncontrolled_Search_Path_Element__char_connect_socket_82_bad; baseObject->action(data); delete baseObject; }"	where is the vulnerable dataflow from data to action ?	"baseObject->action <start> data <end> );
replace = <start> strchr(data, '\r') <end> ;"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (250 - dataLen - 1), 0);
baseObject->action <start> data <end> );"	"replace = <start> strchr(data, '\n') <end> ;
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (250 - dataLen - 1), 0);"	"<start> data = dataBuffer <end> ;
baseObject->action <start> data <end> );"	1
bed4a8ec-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" namespace CWE23_Relative_Path_Traversal__char_connect_socket_ifstream_21 { static int badStatic = 0; static char * badSource(char * data) { if(badStatic) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } return data; } void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; badStatic = 1; data = badSource(data); { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } ; }"	where is the vulnerable dataflow from data to open ?	"recvResult = <start> recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0) <end> ;
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
data = <start> badSource <end> (data);
static char * <start> badSource <end> (char * data);"	"data = <start> badSource <end> (data);
recvResult = recv(connectSocket, (char *)(data + dataLen), <start> sizeof(char) * (FILENAME_MAX - dataLen - 1) <end> , 0);
static char * <start> badSource <end> (char * data);
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
inputFile.open((char * <start> data <end> );"	"replace = <start> strchr(data, '\n') <end> ;
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
inputFile.open((char * <start> data <end> );"	2
c39a65b1-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif namespace CWE23_Relative_Path_Traversal__char_environment_ofstream_14 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(globalFive==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"outputFile.open((char * <start> data <end> );
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"outputFile.open((char * <start> data <end> );
char <start> dataBuffer[FILENAME_MAX] = BASEPATH <end> ;"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
outputFile.open((char * <start> data <end> );"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
size_t dataLen = <start> strlen(data) <end> ;"	2
4b34afc0-6c15-11ed-81d4-94e6f77dd552	short CWE190_Integer_Overflow__short_fscanf_add_61b_badSource(short data); void CWE190_Integer_Overflow__short_fscanf_add_61_bad() { short data; data = 0; data = CWE190_Integer_Overflow__short_fscanf_add_61b_badSource(data); { short result = data + 1; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
data = <start> CWE190_Integer_Overflow__short_fscanf_add_61b_badSource <end> (data);"	"data = <start> CWE190_Integer_Overflow__short_fscanf_add_61b_badSource <end> (data);
short <start> result = data + 1 <end> ;"	"short result = <start> data <end>  + 1;
data = <start> CWE190_Integer_Overflow__short_fscanf_add_61b_badSource <end> (data);"	"data = <start> CWE190_Integer_Overflow__short_fscanf_add_61b_badSource <end> (data);
short result = <start> data <end>  + 1;"	3
85b15ef8-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink(int data) { printIntLine(100 / data); } void CWE369_Divide_by_Zero__int_fgets_divide_41_bad() { int data; data = -1; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } badSink(data); }"	where is the vulnerable dataflow from data to printIntLine ?	"printIntLine <start> 100 / data <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> badSink(data) <end> ;
static void badSink(int <start> data <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
badSink <start> data <end> );
static void badSink(int <start> data <end> );
printIntLine <start> 100 / data <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> 100 / data <end> );
static void badSink(int <start> data <end> );
badSink <start> data <end> );"	"badSink <start> data <end> );
printIntLine <start> 100 / data <end> );"	1
820a46d0-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_file_fopen_73 { void badSink(list<char *> dataList) { char * data = dataList.back(); { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
void badSink(list<char *> <start> dataList <end> );"	"pFile = FOPEN <start> data <end> , ""wb+"");
void badSink(list<char *> <start> dataList <end> );"	"void badSink(list<char *> <start> dataList <end> );
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	2
5be3a9d4-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_listen_socket_postdec_10_bad() { int data; data = 0; if(globalTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalTrue) { { data--; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> data <end> --;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printIntLine(result) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data <end> --;"	"data = <start> atoi(inputBuffer) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	2
87ff9859-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_connect_socket_fopen_64 { void badSink(void * dataVoidPtr) { char * * dataPtr = (char * *)dataVoidPtr; char * data = (*dataPtr); { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
void badSink(void * <start> dataVoidPtr <end> );"	"void badSink(void * <start> dataVoidPtr <end> );
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	"pFile = FOPEN <start> data <end> , ""wb+"");
void badSink(void * <start> dataVoidPtr <end> );"	1
ce547d42-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif namespace CWE36_Absolute_Path_Traversal__char_environment_ifstream_12 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(globalReturnsTrueOrFalse()) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } } else { #ifdef _WIN32 strcat(data, ""c:\\temp\\file.txt""); #else strcat(data, ""/tmp/file.txt""); #endif } { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"size_t dataLen = <start> strlen(data) <end> ;
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"inputFile.open((char * <start> data <end> );
size_t <start> dataLen = strlen(data) <end> ;"	"<start> data = dataBuffer <end> ;
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
inputFile.open((char * <start> data <end> );"	3
60db8395-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__char_rand_add_10_bad() { char data; data = ' '; if(globalTrue) { data = (char)RAND32(); } if(globalTrue) { { char result = data + 1; printHexCharLine(result); } } }	where is the vulnerable dataflow from data ?	"data = (char <start> RAND32() <end> ;
char result = <start> data <end>  + 1;"	"char result = <start> data <end>  + 1;
data = (char <start> RAND32() <end> ;"	"char <start> result = data + 1 <end> ;
data = (char <start> RAND32() <end> ;"	"<start> data = (char)RAND32() <end> ;
char result = <start> data <end>  + 1;"	0
4ec5d076-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_postinc_14_bad() { int data; data = 0; if(globalFive==5) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(globalFive==5) { { data++; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"<start> data = 0 <end> ;
<start> data <end> ++;"	"<start> data <end> ++;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> data <end> ++;"	3
b08640c7-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE197_Numeric_Truncation_Error__int_fgets_to_char_63b_badSink(int * dataPtr) { int data = *dataPtr; { char charData = (char)data; printHexCharLine(charData); } }	where is the vulnerable dataflow from charData to printHexCharLine ?	"printHexCharLine <start> charData <end> );
void CWE197_Numeric_Truncation_Error__int_fgets_to_char_63b_badSink(int * <start> dataPtr <end> );"	"void CWE197_Numeric_Truncation_Error__int_fgets_to_char_63b_badSink(int * <start> dataPtr <end> );
printHexCharLine <start> charData <end> );"	"printHexCharLine <start> charData <end> );
char <start> charData = (char)data <end> ;"	"printHexCharLine <start> charData <end> );
char charData = <start> (char)data <end> ;"	1
ba102ba8-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define EXECLP _execlp #else #define EXECLP execlp #endif static char * badSource(char * data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } return data; } void CWE78_OS_Command_Injection__char_connect_socket_execlp_42_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; data = badSource(data); EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECLP ?	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"static char * <start> badSource <end> (char * data);
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
data = <start> badSource <end> (data);
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (100 - dataLen - 1), 0);"	"EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
size_t dataLen = <start> strlen(data) <end> ;
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
static char * <start> badSource <end> (char * data);"	"EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
data = <start> badSource <end> (data);
size_t dataLen = <start> strlen(data) <end> ;"	0
b68484d3-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" namespace CWE36_Absolute_Path_Traversal__char_connect_socket_ofstream_82 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE36_Absolute_Path_Traversal__char_connect_socket_ofstream_82_base* baseObject = new CWE36_Absolute_Path_Traversal__char_connect_socket_ofstream_82_bad; baseObject->action(data); delete baseObject; }"	where is the vulnerable dataflow from data to action ?	"<start> data = dataBuffer <end> ;
baseObject->action <start> data <end> );"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
baseObject->action <start> data <end> );"	"recvResult = <start> recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0) <end> ;
baseObject->action <start> data <end> );"	"<start> data = dataBuffer <end> ;
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	1
bb49c5a9-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #define EXECLP _execlp #else #define EXECLP execlp #endif void CWE78_OS_Command_Injection__char_console_execlp_18_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; goto source; source: { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECLP ?	"EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
<start> data = dataBuffer <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"<start> EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	"size_t dataLen = <start> strlen(data) <end> ;
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	1
b2ea8ddc-6c15-11ed-81d4-94e6f77dd552	namespace CWE197_Numeric_Truncation_Error__short_fgets_74 { void badSink(map<int, short> dataMap) { short data = dataMap[2]; { char charData = (char)data; printHexCharLine(charData); } }	where is the vulnerable dataflow from charData to printHexCharLine ?	"printHexCharLine <start> charData <end> );
char charData = <start> (char)data <end> ;"	"short <start> data = dataMap[2] <end> ;
printHexCharLine <start> charData <end> );"	"void badSink(map<int, short> <start> dataMap <end> );
printHexCharLine <start> charData <end> );"	"<start> printHexCharLine(charData) <end> ;
void badSink(map<int, short> <start> dataMap <end> );"	2
c99197c5-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define STAT _stat #define OPEN _open #define WRITE _write #define O_RDWR _O_RDWR #define CLOSE _close #else #define STAT stat #define OPEN open #define WRITE write #define CLOSE close #endif #define BAD_SINK_STRING ""Bad Sink..."" #define GOOD_SINK_STRING ""Good Sink..."" void CWE367_TOC_TOU__stat_02_bad() { if(1) { { char filename[100] = """"; struct STAT statBuffer; int fileDesc = -1; if (fgets(filename, 100, stdin) == NULL) { printLine(""fgets() failed""); filename[0] = '\0'; } if (strlen(filename) > 0) { filename[strlen(filename)-1] = '\0'; } if (STAT(filename, &statBuffer) == -1) { exit(1); } fileDesc  = OPEN(filename, O_RDWR); if (fileDesc == -1) { exit(1); } if (WRITE(fileDesc, BAD_SINK_STRING, strlen(BAD_SINK_STRING)) == -1) { exit(1); } if (fileDesc != -1) { CLOSE(fileDesc); } } } }"	where is the vulnerable dataflow from filename to OPEN ?	"char <start> filename[100] = """" <end> ;
if (fgets <start> filename <end> , 100, stdin) == NULL);"	"fileDesc  = OPEN <start> filename <end> , O_RDWR);
char <start> filename[100] = """" <end> ;"	"if (fgets <start> filename <end> , 100, stdin) == NULL);
fileDesc  = OPEN <start> filename <end> , O_RDWR);"	"if  <start> strlen(filename) <end>  > 0);
fileDesc  = OPEN <start> filename <end> , O_RDWR);"	2
a830bf6c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_connect_socket_multiply_09_bad() { int data; data = 0; if(GLOBAL_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(GLOBAL_CONST_TRUE) { if(data < 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data * 2 <end> ;"	"<start> data = 0 <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;"	2
cbf237a3-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif static const int STATIC_CONST_FIVE = 5; namespace CWE36_Absolute_Path_Traversal__char_console_fopen_06 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(STATIC_CONST_FIVE==5) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
pFile = FOPEN <start> data <end> , ""wb+"");"	"if (dataLen > 0 && <start> data[dataLen-1] == '\n' <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
char <start> dataBuffer[FILENAME_MAX] = """" <end> ;"	"dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	0
846ad30d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define STAT _stat #define OPEN _open #define WRITE _write #define O_RDWR _O_RDWR #define CLOSE _close #else #define STAT stat #define OPEN open #define WRITE write #define CLOSE close #endif #define BAD_SINK_STRING ""Bad Sink..."" #define GOOD_SINK_STRING ""Good Sink..."" #ifdef _WIN32 #define ACCESS _access #define W_OK 02 #else #define ACCESS access #endif static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; void CWE367_TOC_TOU__access_04_bad() { if(STATIC_CONST_TRUE) { { char filename[100] = """"; int fileDesc = -1; if (fgets(filename, 100, stdin) == NULL) { printLine(""fgets() failed""); filename[0] = '\0'; } if (strlen(filename) > 0) { filename[strlen(filename)-1] = '\0'; } if (ACCESS(filename, W_OK) == -1) { exit(1); } fileDesc  = OPEN(filename, O_RDWR); if (fileDesc == -1) { exit(1); } if (WRITE(fileDesc, BAD_SINK_STRING, strlen(BAD_SINK_STRING)) == -1) { exit(1); } if (fileDesc != -1) { CLOSE(fileDesc); } } } }"	where is the vulnerable dataflow from filename to OPEN ?	"fileDesc  = OPEN <start> filename <end> , O_RDWR);
if  <start> ACCESS(filename, W_OK) <end>  == -1);"	"if (fgets <start> filename <end> , 100, stdin) == NULL);
fileDesc  = OPEN <start> filename <end> , O_RDWR);"	"fileDesc  = OPEN <start> filename <end> , O_RDWR);
if  <start> fgets(filename, 100, stdin) <end>  == NULL);"	"if (fgets <start> filename <end> , 100, stdin) == NULL);
if  <start> strlen(filename) <end>  > 0);"	1
c01af8ef-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_console_fopen_03 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(5==5) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
<start> data = dataBuffer <end> ;"	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
dataLen = <start> strlen(data) <end> ;"	2
bb49c5a4-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #define EXECLP _execlp #else #define EXECLP execlp #endif void CWE78_OS_Command_Injection__char_console_execlp_13_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(GLOBAL_CONST_FIVE==5) { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECLP ?	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
char <start> dataBuffer[100] = COMMAND_ARG2 <end> ;"	"size_t dataLen = <start> strlen(data) <end> ;
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	0
6c938c0c-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif void CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_54e_badSink(char * data) { { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"void CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_54e_badSink(char * <start> data <end> );
printLine <start> dest <end> );"	"void CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_54e_badSink(char * <start> data <end> );
<start> SNPRINTF(dest, 100-1, data) <end> ;"	"printLine <start> dest <end> );
<start> SNPRINTF(dest, 100-1, data) <end> ;"	"printLine <start> dest <end> );
<start> printLine(dest) <end> ;"	0
4b34afe8-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__short_fscanf_multiply_62 { void badSource(short &data); void bad() { short data; data = 0; badSource(data); if(data > 0) { short result = data * 2; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"short <start> result = data * 2 <end> ;
badSource <start> data <end> );"	"<start> printIntLine(result) <end> ;
badSource <start> data <end> );"	"short result = <start> data <end>  * 2;
badSource <start> data <end> );"	"badSource <start> data <end> );
short result = <start> data <end>  * 2;"	3
89321803-6c15-11ed-81d4-94e6f77dd552	#ifndef _WIN32 #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_console_open_74 { void badSink(map<int, char *> dataMap) { char * data = dataMap[2]; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }	where is the vulnerable dataflow from data to OPEN ?	"void badSink(map<int, char *> <start> dataMap <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"void badSink(map<int, char *> <start> dataMap <end> );
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
void badSink(map<int, char *> <start> dataMap <end> );"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	0
87ff9860-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" namespace CWE36_Absolute_Path_Traversal__char_connect_socket_ofstream_17 { void bad() { int i; char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; for(i = 0; i < 1; i++) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to sizeof ?	recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) *  <start> FILENAME_MAX - dataLen - 1 <end> ), 0);	<start> data = dataBuffer <end> ;	recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);	recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - <start> dataLen - 1 <end> ), 0);	2
c39a65be-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif namespace CWE23_Relative_Path_Traversal__char_environment_ofstream_51 { void badSink(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } badSink(data); }"	where is the vulnerable dataflow from data to badSink ?	"<start> badSink(data) <end> ;
badSink <start> data <end> );"	"badSink <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	"size_t dataLen = <start> strlen(data) <end> ;
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
badSink <start> data <end> );"	3
c01af8c7-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif static int staticFive = 5; namespace CWE23_Relative_Path_Traversal__char_connect_socket_open_07 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(staticFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN(data, O_RDWR|O_CREAT, <start> S_IREAD|S_IWRITE <end> );"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
recvResult = <start> recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0) <end> ;"	"replace = <start> strchr(data, '\n') <end> ;
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	1
54c581ed-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_connect_socket_multiply_17_bad() { int i,j; int data; data = 0; for(i = 0; i < 1; i++) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } for(j = 0; j < 1; j++) { if(data < 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  * 2;
<start> data = atoi(inputBuffer) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  * 2;"	"int result = <start> data <end>  * 2;
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"int result = <start> data <end>  * 2;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	1
54c58201-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_connect_socket_multiply_66b_badSink(int dataArray[]) { int data = dataArray[2]; if(data < 0) { int result = data * 2; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"void CWE191_Integer_Underflow__int_connect_socket_multiply_66b_badSink(int <start> dataArray <end> []);
int result = <start> data <end>  * 2;"	"int <start> result = data * 2 <end> ;
void CWE191_Integer_Underflow__int_connect_socket_multiply_66b_badSink(int <start> dataArray <end> []);"	"void CWE191_Integer_Underflow__int_connect_socket_multiply_66b_badSink(int <start> dataArray <end> []);
int result = <start> data * 2 <end> ;"	"int result = <start> data <end>  * 2;
void CWE191_Integer_Underflow__int_connect_socket_multiply_66b_badSink(int <start> dataArray <end> []);"	0
6b862423-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_connect_socket_10_bad() { int data; data = -1; if(globalTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalTrue) { { int i; int * buffer = (int *)malloc(10 * sizeof(int)); if (buffer == NULL) {exit(-1);} for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } free(buffer); } } }"	where is the vulnerable dataflow from buffer to free ?	"<start> free(buffer) <end> ;
free <start> buffer <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
free <start> buffer <end> );"	"if  <start> buffer == NULL <end> ) {exit(-1);};
free <start> buffer <end> );"	"<start> printIntLine(buffer[i]) <end> ;
free <start> buffer <end> );"	1
9fe7ad50-6c15-11ed-81d4-94e6f77dd552	extern int CWE190_Integer_Overflow__int_connect_socket_add_22_badGlobal; void CWE190_Integer_Overflow__int_connect_socket_add_22_badSink(int data) { if(CWE190_Integer_Overflow__int_connect_socket_add_22_badGlobal) { { int result = data + 1; printIntLine(result); } } }	where is the vulnerable dataflow from result to printIntLine ?	"void CWE190_Integer_Overflow__int_connect_socket_add_22_badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
void CWE190_Integer_Overflow__int_connect_socket_add_22_badSink(int <start> data <end> );"	"int <start> result = data + 1 <end> ;
void CWE190_Integer_Overflow__int_connect_socket_add_22_badSink(int <start> data <end> );"	"<start> printIntLine(result) <end> ;
void CWE190_Integer_Overflow__int_connect_socket_add_22_badSink(int <start> data <end> );"	0
60db8396-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__char_rand_add_11_bad() { char data; data = ' '; if(globalReturnsTrue()) { data = (char)RAND32(); } if(globalReturnsTrue()) { { char result = data + 1; printHexCharLine(result); } } }	where is the vulnerable dataflow from data ?	"char <start> result = data + 1 <end> ;
data = (char <start> RAND32() <end> ;"	"char result = <start> data <end>  + 1;
<start> printHexCharLine(result) <end> ;"	"char result = <start> data <end>  + 1;
data = (char <start> RAND32() <end> ;"	"data = (char <start> RAND32() <end> ;
char result = <start> data <end>  + 1;"	3
977ea79e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; void CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_04_bad() { int data; data = -1; if(STATIC_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(STATIC_CONST_TRUE) { { int i; int buffer[10] = { 0 }; if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } } } }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
data = <start> atoi(inputBuffer) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printIntLine(buffer[i]) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
if  <start> recvResult == SOCKET_ERROR <end>  || recvResult == 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[i] <end> );"	3
89321804-6c15-11ed-81d4-94e6f77dd552	#ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_console_open_81 { void CWE36_Absolute_Path_Traversal__char_console_open_81_bad::action(char * data) const { { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } } }	where is the vulnerable dataflow from data to OPEN ?	"void CWE36_Absolute_Path_Traversal__char_console_open_81_bad::action(char * <start> data <end> ) const;
fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);"	"void CWE36_Absolute_Path_Traversal__char_console_open_81_bad::action(char * <start> data <end> ) const;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN(data, O_RDWR|O_CREAT, <start> S_IREAD|S_IWRITE <end> );
void CWE36_Absolute_Path_Traversal__char_console_open_81_bad::action(char * <start> data <end> ) const;"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	1
87ff984a-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_connect_socket_fopen_16 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; while(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	"pFile = FOPEN <start> data <end> , ""wb+"");
size_t <start> dataLen = strlen(data) <end> ;"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
size_t dataLen = <start> strlen(data) <end> ;"	0
8b91e45f-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_listen_socket_fopen_66 { void badSink(char * dataArray[]) { char * data = dataArray[2]; { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"void badSink(char * <start> dataArray <end> []);
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	"pFile = FOPEN <start> data <end> , ""wb+"");
void badSink(char * <start> dataArray <end> []);"	"void badSink(char * <start> dataArray <end> []);
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	2
cac216ce-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; namespace CWE36_Absolute_Path_Traversal__char_connect_socket_open_04 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(STATIC_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"replace = <start> strchr(data, '\n') <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"char <start> dataBuffer[FILENAME_MAX] = """" <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - <start> dataLen - 1 <end> ), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	0
87ff9849-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_connect_socket_fopen_15 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; switch(6) { case 6: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; default: printLine(""Benign, fixed string""); break; } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	"replace = <start> strchr(data, '\r') <end> ;
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"size_t dataLen = <start> strlen(data) <end> ;
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"pFile = FOPEN <start> data <end> , ""wb+"");
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	0
d0b64ee8-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif namespace CWE36_Absolute_Path_Traversal__char_file_ofstream_13 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(GLOBAL_CONST_FIVE==5) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"<start> data = dataBuffer <end> ;
outputFile.open((char * <start> data <end> );"	"outputFile.open((char * <start> data <end> );
char <start> dataBuffer[FILENAME_MAX] = """" <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
outputFile.open((char * <start> data <end> );"	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	2
74ee23ba-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" void CWE194_Unexpected_Sign_Extension__connect_socket_memmove_54e_badSink(short data) { { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"void CWE194_Unexpected_Sign_Extension__connect_socket_memmove_54e_badSink(short <start> data <end> );
printLine <start> dest <end> );"	"char <start> dest[100] = """" <end> ;
void CWE194_Unexpected_Sign_Extension__connect_socket_memmove_54e_badSink(short <start> data <end> );"	"printLine <start> dest <end> );
<start> printLine(dest) <end> ;"	"void CWE194_Unexpected_Sign_Extension__connect_socket_memmove_54e_badSink(short <start> data <end> );
if  <start> data < 100 <end> );"	0
5133a76f-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_preinc_53d_badSink(int data) { { ++data; int result = data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
+ <start> data <end> ;"	"+ <start> data <end> ;
void CWE190_Integer_Overflow__int_fgets_preinc_53d_badSink(int <start> data <end> );"	"void CWE190_Integer_Overflow__int_fgets_preinc_53d_badSink(int <start> data <end> );
+ <start> data <end> ;"	"+ <start> data <end> ;
int <start> result = data <end> ;"	2
abc374f6-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } void CWE191_Integer_Underflow__int_connect_socket_postdec_08_bad() { int data; data = 0; if(staticReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticReturnsTrue()) { { data--; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int <start> result = data <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
data = <start> atoi(inputBuffer) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> result <end> );"	2
774f57f8-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 8 void CWE194_Unexpected_Sign_Extension__fgets_strncpy_54e_badSink(short data) { { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	"<start> strncpy(dest, source, data) <end> ;
printLine <start> dest <end> );"	"void CWE194_Unexpected_Sign_Extension__fgets_strncpy_54e_badSink(short <start> data <end> );
printLine <start> dest <end> );"	"<start> strncpy(dest, source, data) <end> ;
void CWE194_Unexpected_Sign_Extension__fgets_strncpy_54e_badSink(short <start> data <end> );"	2
c5fc234a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif namespace CWE23_Relative_Path_Traversal__char_file_ofstream_02 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(1) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
size_t dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
outputFile.open((char * <start> data <end> );"	"size_t dataLen = <start> strlen(data) <end> ;
outputFile.open((char * <start> data <end> );"	"outputFile.open((char * <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	1
c1366283-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif namespace CWE23_Relative_Path_Traversal__char_console_ofstream_10 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(globalTrue) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
size_t dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
dataLen = <start> strlen(data) <end> ;"	"outputFile.open((char * <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
outputFile.open((char * <start> data <end> );"	3
4b34b009-6c15-11ed-81d4-94e6f77dd552	"static short badSource(short data) { fscanf (stdin, ""%hd"", &data); return data; } void CWE190_Integer_Overflow__short_fscanf_square_42_bad() { short data; data = 0; data = badSource(data); { short result = data * data; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"fscanf (stdin, ""%hd"", <start> &data <end> );
static short <start> badSource <end> (short data);
data = <start> badSource <end> (data);
short result = <start> data <end>  * data;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
short result = <start> data * data <end> ;
data = <start> badSource <end> (data);
static short <start> badSource <end> (short data);"	"static short <start> badSource <end> (short data);
fscanf (stdin, ""%hd"", <start> &data <end> );
short result = <start> data <end>  * data;
data = <start> badSource(data) <end> ;"	"static short <start> badSource <end> (short data);
<start> printIntLine(result) <end> ;
short result = <start> data <end>  * data;
data = <start> badSource <end> (data);"	0
69161b2b-6c15-11ed-81d4-94e6f77dd552	static int staticTrue = 1; static int staticFalse = 0; void CWE190_Integer_Overflow__int_rand_preinc_05_bad() { int data; data = 0; if(staticTrue) { data = RAND32(); } if(staticTrue) { { ++data; int result = data; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"data = <start> RAND32() <end> ;
+ <start> data <end> ;"	"+ <start> data <end> ;
<start> ++data <end> ;"	"data = <start> RAND32() <end> ;
<start> ++data <end> ;"	"data = <start> RAND32() <end> ;
<start> printIntLine(result) <end> ;"	0
bb49c580-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #define EXECL _execl #else #define EXECL execl #endif static const int STATIC_CONST_FIVE = 5; void CWE78_OS_Command_Injection__char_console_execl_06_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(STATIC_CONST_FIVE==5) { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECL ?	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"dataLen = <start> strlen(data) <end> ;
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"if  <start> 100-dataLen <end>  > 1);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	"size_t dataLen = <start> strlen(data) <end> ;
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	0
833ac949-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_listen_socket_open_52 { void badSink_c(char * data) { { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"void badSink_c(char * <start> data <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN(data, O_RDWR|O_CREAT, <start> S_IREAD|S_IWRITE <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);"	0
9c4551a6-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE126_Buffer_Overread__CWE129_connect_socket_15_bad() { int data; data = -1; switch(6) { case 6: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; default: printLine(""Benign, fixed string""); break; } switch(7) { case 7: { int buffer[10] = { 0 }; if (data >= 0) { printIntLine(buffer[data]); } else { printLine(""ERROR: Array index is negative""); } } break; default: printLine(""Benign, fixed string""); break; } }"	where is the vulnerable dataflow from buffer[data] to printIntLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[data] <end> );"	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> buffer[data] <end> );"	"printIntLine <start> buffer[data] <end> );
<start> printIntLine(buffer[data]) <end> ;"	"recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);
printIntLine <start> buffer[data] <end> );"	0
54c581f1-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_connect_socket_multiply_31_bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { int dataCopy = data; int data = dataCopy; if(data < 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  * 2;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int <start> result = data * 2 <end> ;"	"int <start> dataCopy = data <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
if <start> data < 0 <end> ) ;"	0
93ece2df-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING ""hello"" void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_17_bad() { int i,j; size_t data; data = 0; for(i = 0; i < 1; i++) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = strtoul(inputBuffer, NULL, 0); } else { printLine(""fgets() failed.""); } } } for(j = 0; j < 1; j++) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); } else { printLine(""Input is less than the length of the source string""); } } } }"	where is the vulnerable dataflow from data to malloc ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
if  <start> data > strlen(HELLO_STRING) <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> printLine(myString) <end> ;"	"myString = (char *)malloc <start> data*sizeof(char) <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
myString = (char *)malloc <start> data*sizeof(char) <end> );"	3
5d16c9c9-6c15-11ed-81d4-94e6f77dd552	"static void badSink(short data) { { data--; short result = data; printIntLine(result); } } void CWE191_Integer_Underflow__short_fscanf_postdec_44_bad() { short data; void (*funcPtr) (short) = badSink; data = 0; fscanf (stdin, ""%hd"", &data); funcPtr(data); }"	where is the vulnerable dataflow from data ?	"fscanf (stdin, ""%hd"", <start> &data <end> );
funcPtr <start> data <end> );
static void badSink(short <start> data <end> );
<start> data <end> --;"	"static void badSink(short <start> data <end> );
<start> funcPtr(data) <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );
<start> data <end> --;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
static void badSink(short <start> data <end> );
<start> data <end> --;
funcPtr <start> data <end> );"	"<start> printIntLine(result) <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );
<start> data <end> --;
static void badSink(short <start> data <end> );"	0
c26a7e78-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_environment_fopen_42 { static char * badSource(char * data) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } return data; } void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; data = badSource(data); { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
static char * <start> badSource <end> (char * data);
char * environment = <start> GETENV <end> (ENV_VARIABLE);
pFile = FOPEN <start> data <end> , ""wb+"");"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
size_t dataLen = <start> strlen(data) <end> ;
static char * <start> badSource <end> (char * data);
pFile = FOPEN <start> data <end> , ""wb+"");"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
static char * <start> badSource <end> (char * data);
<start> data = badSource(data) <end> ;
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	2
b41b87aa-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 20 #define IP_ADDRESS ""127.0.0.1"" void CWE369_Divide_by_Zero__float_connect_socket_51b_badSink(float data) { { int result = (int)(100.0 / data); printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;"	"printIntLine <start> result <end> );
int <start> result = (int)(100.0 / data) <end> ;"	"int <start> result = (int)(100.0 / data) <end> ;
void CWE369_Divide_by_Zero__float_connect_socket_51b_badSink(float <start> data <end> );"	"void CWE369_Divide_by_Zero__float_connect_socket_51b_badSink(float <start> data <end> );
printIntLine <start> result <end> );"	3
584fa858-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink(int data) { if(data < 0) { int result = data * 2; printIntLine(result); } } void CWE191_Integer_Underflow__int_listen_socket_multiply_44_bad() { int data; void (*funcPtr) (int) = badSink; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } funcPtr(data); }"	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  * 2;
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
static void badSink(int <start> data <end> );
funcPtr <start> data <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printIntLine(result) <end> ;
static void badSink(int <start> data <end> );
int result = <start> data <end>  * 2;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
funcPtr <start> data <end> );
static void badSink(int <start> data <end> );
int result = <start> data <end>  * 2;"	"<start> funcPtr(data) <end> ;
static void badSink(int <start> data <end> );
funcPtr <start> data <end> );
int result = <start> data <end>  * 2;"	2
6c938c20-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" static int staticFive = 5; static void badVaSinkB(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_07_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; if(staticFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticFive==5) { badVaSinkB(data, data); } }"	where is the vulnerable dataflow from data to vfprintf ?	"<start> va_start(args, data) <end> ;
vfprintf(stdout, <start> data <end> , args);
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
badVaSinkB <start> data <end> , data);"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (100 - dataLen - 1), 0);
badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);"	"badVaSinkB <start> data <end> , data);
vfprintf(stdout, <start> data <end> , args);
<start> data = dataBuffer <end> ;
static void badVaSinkB(char * <start> data <end> , ...);"	2
977ea7ad-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int badStatic = 0; static void badSink(int data) { if(badStatic) { { int i; int buffer[10] = { 0 }; if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } } } } void CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_21_bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badStatic = 1; badSink(data); }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"static void badSink(int <start> data <end> );
printIntLine <start> buffer[i] <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
if  <start> recvResult == SOCKET_ERROR <end>  || recvResult == 0);"	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
static void badSink(int <start> data <end> );
badSink <start> data <end> );
printIntLine <start> buffer[i] <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSink <start> data <end> );
static void badSink(int <start> data <end> );
printIntLine <start> buffer[i] <end> );"	"if  <start> recvResult == SOCKET_ERROR <end>  || recvResult == 0);
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSink <start> data <end> );
static void badSink(int <start> data <end> );"	2
b41b8773-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" namespace CWE23_Relative_Path_Traversal__char_connect_socket_ifstream_81 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } const CWE23_Relative_Path_Traversal__char_connect_socket_ifstream_81_base& baseObject = CWE23_Relative_Path_Traversal__char_connect_socket_ifstream_81_bad(); baseObject.action(data); }"	where is the vulnerable dataflow from data to action ?	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
baseObject.action <start> data <end> );"	"baseObject.action <start> data <end> );
<start> data = dataBuffer <end> ;"	"size_t <start> dataLen = strlen(data) <end> ;
baseObject.action <start> data <end> );"	"baseObject.action <start> data <end> );
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	0
8cc3a67a-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(count) + 2) #ifdef _WIN32 #define SLEEP Sleep #else #define SLEEP usleep #endif static int badStatic = 0; static void badSink(int count) { if(badStatic) { SLEEP(count); printLine(""Sleep time possibly too long""); } } void CWE400_Resource_Exhaustion__fgets_sleep_21_bad() { int count; count = -1; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { count = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } badStatic = 1; badSink(count); }"	where is the vulnerable dataflow from count to SLEEP ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
badSink <start> count <end> );
static void badSink(int <start> count <end> );
SLEEP <start> count <end> );"	"SLEEP <start> count <end> );
static void badSink(int <start> count <end> );
count = <start> atoi(inputBuffer) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"<start> badSink(count) <end> ;
badSink <start> count <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
SLEEP <start> count <end> );"	"static void badSink(int <start> count <end> );
badSink <start> count <end> );
count = <start> atoi(inputBuffer) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	0
54c581f0-6c15-11ed-81d4-94e6f77dd552	extern int CWE191_Integer_Underflow__int_connect_socket_multiply_22_badGlobal; void CWE191_Integer_Underflow__int_connect_socket_multiply_22_badSink(int data) { if(CWE191_Integer_Underflow__int_connect_socket_multiply_22_badGlobal) { if(data < 0) { int result = data * 2; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  * 2;
void CWE191_Integer_Underflow__int_connect_socket_multiply_22_badSink(int <start> data <end> );"	"void CWE191_Integer_Underflow__int_connect_socket_multiply_22_badSink(int <start> data <end> );
int result = <start> data <end>  * 2;"	"int <start> result = data * 2 <end> ;
void CWE191_Integer_Underflow__int_connect_socket_multiply_22_badSink(int <start> data <end> );"	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  * 2;"	1
b1b80829-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_14_bad() { int data; data = -1; if(globalFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { short shortData = (short)data; printShortLine(shortData); } }"	where is the vulnerable dataflow from shortData to printShortLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printShortLine <start> shortData <end> );"	"<start> data = atoi(inputBuffer) <end> ;
printShortLine <start> shortData <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
data = <start> atoi(inputBuffer) <end> ;"	"short shortData = <start> (short)data <end> ;
printShortLine <start> shortData <end> );"	0
761e2944-6c15-11ed-81d4-94e6f77dd552	namespace CWE194_Unexpected_Sign_Extension__fgets_malloc_82 { void CWE194_Unexpected_Sign_Extension__fgets_malloc_82_bad::action(short data) { if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } } }	where is the vulnerable dataflow from data to malloc ?	"char * dataBuffer = (char *)malloc <start> data <end> );
<start> free(dataBuffer) <end> ;"	"void CWE194_Unexpected_Sign_Extension__fgets_malloc_82_bad::action(short <start> data <end> );
char * dataBuffer = (char *)malloc <start> data <end> );"	"void CWE194_Unexpected_Sign_Extension__fgets_malloc_82_bad::action(short <start> data <end> );
<start> free(dataBuffer) <end> ;"	"<start> memset(dataBuffer, 'A', data-1) <end> ;
void CWE194_Unexpected_Sign_Extension__fgets_malloc_82_bad::action(short <start> data <end> );"	1
c26a7e31-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif namespace CWE23_Relative_Path_Traversal__char_console_ofstream_51 { void badSink(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } badSink(data); }"	where is the vulnerable dataflow from data to badSink ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
if (dataLen > 0 && <start> data[dataLen-1] == '\n' <end> );"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
badSink <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
dataLen = <start> strlen(data) <end> ;"	"<start> data = dataBuffer <end> ;
badSink <start> data <end> );"	1
5e44fca1-6c15-11ed-81d4-94e6f77dd552	"typedef union { int unionFirst; int unionSecond; } CWE191_Integer_Underflow__int_fscanf_predec_34_unionType; void CWE191_Integer_Underflow__int_fscanf_predec_34_bad() { int data; CWE191_Integer_Underflow__int_fscanf_predec_34_unionType myUnion; data = 0; fscanf(stdin, ""%d"", &data); myUnion.unionFirst = data; { int data = myUnion.unionSecond; { --data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"fscanf(stdin, ""%d"", <start> &data <end> );
- <start> data <end> ;"	"fscanf(stdin, ""%d"", <start> &data <end> );
int <start> result = data <end> ;"	"<start> printIntLine(result) <end> ;
fscanf(stdin, ""%d"", <start> &data <end> );"	"- <start> data <end> ;
fscanf(stdin, ""%d"", <start> &data <end> );"	0
79b27522-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_10_bad() { int data; data = -1; if(globalTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }"	where is the vulnerable dataflow from data to malloc ?	"char <start> * dataBuffer = (char *)malloc(data) <end> ;
char * dataBuffer = (char *)malloc <start> data <end> );"	"data = <start> atoi(inputBuffer) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"char * dataBuffer = (char *)malloc <start> data <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
char * dataBuffer = (char *)malloc <start> data <end> );"	3
8df42220-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define PATH_SZ 100 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define PATH_SZ PATH_MAX #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 static int staticTrue = 1; static int staticFalse = 0; void CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__listen_accept_bind_05_bad() { if(staticTrue) { { char data[100] = """"; #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[recvResult] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif printLine(data); } } }"	where is the vulnerable dataflow from data to printLine ?	"if  <start> acceptSocket == SOCKET_ERROR <end> );
recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);"	"recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);
printLine <start> data <end> );"	"recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);
size_t <start> dataLen = strlen(data) <end> ;"	"<start> printLine(data) <end> ;
recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);"	1
9187cc05-6c15-11ed-81d4-94e6f77dd552	"#define SEARCH_CHAR 'S' static void badSink(char * data) { for (; *data != '\0'; data++) { if (*data == SEARCH_CHAR) { printLine(""We have a match!""); break; } } free(data); } void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_console_41_bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\0'; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } badSink(data); }"	where is the vulnerable dataflow from data to free ?	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
static void badSink(char * <start> data <end> );"	"dataLen = <start> strlen(data) <end> ;
static void badSink(char * <start> data <end> );
badSink <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
badSink <start> data <end> );
static void badSink(char * <start> data <end> );
free <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
static void badSink(char * <start> data <end> );
badSink <start> data <end> );"	2
abc37539-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; void CWE191_Integer_Underflow__int_listen_socket_postdec_04_bad() { int data; data = 0; if(STATIC_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(STATIC_CONST_TRUE) { { data--; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );"	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	"<start> printIntLine(result) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	0
c8600af0-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 namespace CWE23_Relative_Path_Traversal__char_listen_socket_ofstream_45 { static char * badData; static char * goodG2BData; static void badSink() { char * data = badData; { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } } void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badData = data; badSink(); }"	where is the vulnerable dataflow from data to open ?	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
<start> badData = data <end> ;
static char * <start> badData <end> ;
char * data = <start> badData <end> ;
outputFile.open((char * <start> data <end> );"	"outputFile.open((char * <start> data <end> );
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
char * data = <start> badData <end> ;
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
<start> badData = data <end> ;"	"if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );
outputFile.open((char * <start> data <end> );
<start> badData = data <end> ;
static char * <start> badData <end> ;
char * data = <start> badData <end> ;"	"if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );
char * data = <start> badData <end> ;
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
<start> badData = data <end> ;
static char * <start> badData <end> ;"	0
9b124d95-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) typedef struct _CWE124_Buffer_Underwrite__CWE839_fgets_67_structType { int structFirst; } CWE124_Buffer_Underwrite__CWE839_fgets_67_structType; void CWE124_Buffer_Underwrite__CWE839_fgets_67b_badSink(CWE124_Buffer_Underwrite__CWE839_fgets_67_structType myStruct) { int data = myStruct.structFirst; { int i; int buffer[10] = { 0 }; if (data < 10) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } } }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"printIntLine <start> buffer[i] <end> );
void CWE124_Buffer_Underwrite__CWE839_fgets_67b_badSink(CWE124_Buffer_Underwrite__CWE839_fgets_67_structType <start> myStruct <end> );"	"int <start> buffer[10] = { 0 } <end> ;
int data = <start> myStruct <end> .structFirst;
void CWE124_Buffer_Underwrite__CWE839_fgets_67b_badSink(CWE124_Buffer_Underwrite__CWE839_fgets_67_structType <start> myStruct <end> );"	"void CWE124_Buffer_Underwrite__CWE839_fgets_67b_badSink(CWE124_Buffer_Underwrite__CWE839_fgets_67_structType <start> myStruct <end> );
int data = <start> myStruct <end> .structFirst;
printIntLine <start> buffer[i] <end> );"	"printIntLine <start> buffer[i] <end> );
int data = <start> myStruct <end> .structFirst;
void CWE124_Buffer_Underwrite__CWE839_fgets_67b_badSink(CWE124_Buffer_Underwrite__CWE839_fgets_67_structType <start> myStruct <end> );"	2
af580933-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_54e_badSink(int data) { { char charData = (char)data; printHexCharLine(charData); } }"	where is the vulnerable dataflow from charData to printHexCharLine ?	"void CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_54e_badSink(int <start> data <end> );
printHexCharLine <start> charData <end> );"	"void CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_54e_badSink(int <start> data <end> );
char <start> charData = (char)data <end> ;"	"printHexCharLine <start> charData <end> );
char <start> charData = (char)data <end> ;"	"void CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_54e_badSink(int <start> data <end> );
<start> printHexCharLine(charData) <end> ;"	0
79b2756f-6c15-11ed-81d4-94e6f77dd552	"namespace CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_81 { void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_81_bad::action(int data) const { { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } } }"	where is the vulnerable dataflow from dest to printLine ?	"printLine <start> dest <end> );
<start> memcpy(dest, source, data) <end> ;"	"void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_81_bad::action(int <start> data <end> ) const;
printLine <start> dest <end> );"	"void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_81_bad::action(int <start> data <end> ) const;
<start> memcpy(dest, source, data) <end> ;"	"void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_81_bad::action(int <start> data <end> ) const;
if  <start> data < 100 <end> );"	1
80d98735-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_console_open_45 { static char * badData; static char * goodG2BData; static void badSink() { char * data = badData; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } } void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } badData = data; badSink(); }"	where is the vulnerable dataflow from data to OPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
<start> badData = data <end> ;
static char * <start> badData <end> ;
char * data = <start> badData <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"size_t dataLen = <start> strlen(data) <end> ;
static char * <start> badData <end> ;
<start> badData = data <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
char * data = <start> badData <end> ;"	"<start> badData = data <end> ;
static char * <start> badData <end> ;
char <start> dataBuffer[FILENAME_MAX] = BASEPATH <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
static char * <start> badData <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
char * data = <start> badData <end> ;
<start> badData = data <end> ;"	0
80d986e9-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_connect_socket_open_54 { void badSink_e(char * data) { { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"void badSink_e(char * <start> data <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
void badSink_e(char * <start> data <end> );"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);
void badSink_e(char * <start> data <end> );"	0
964cdc2b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_FIVE = 5; void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_06_bad() { int data; data = -1; if(STATIC_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(STATIC_CONST_FIVE==5) { { int i; int buffer[10] = { 0 }; if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } } } }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
data = <start> atoi(inputBuffer) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[i] <end> );"	"printIntLine <start> buffer[i] <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);
printIntLine <start> buffer[i] <end> );"	1
466e7ee2-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink(int data) { if(data > 0) { int result = data * 2; printIntLine(result); } } void CWE190_Integer_Overflow__int_fgets_multiply_41_bad() { int data; data = 0; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } badSink(data); }"	where is the vulnerable dataflow from data ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
badSink <start> data <end> );
static void badSink(int <start> data <end> );
int result = <start> data <end>  * 2;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
int result = <start> data <end>  * 2;
badSink <start> data <end> );
<start> printIntLine(result) <end> ;"	"if  <start> fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) <end>  != NULL);
static void badSink(int <start> data <end> );
badSink <start> data <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"int result = <start> data <end>  * 2;
static void badSink(int <start> data <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> data = 0 <end> ;"	0
c26a7e2b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif namespace CWE23_Relative_Path_Traversal__char_console_ofstream_34 { typedef union { char * unionFirst; char * unionSecond; } unionType; void bad() { char * data; unionType myUnion; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } } }"	where is the vulnerable dataflow from data to open ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
outputFile.open((char * <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
dataLen = <start> strlen(data) <end> ;"	"outputFile.open((char * <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
char <start> dataBuffer[FILENAME_MAX] = BASEPATH <end> ;"	0
846ad338-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE369_Divide_by_Zero__int_connect_socket_divide_09_bad() { int data; data = -1; if(GLOBAL_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(GLOBAL_CONST_TRUE) { printIntLine(100 / data); } }"	where is the vulnerable dataflow from data to printIntLine ?	"recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);
printIntLine <start> 100 / data <end> );"	"data = <start> atoi(inputBuffer) <end> ;
printIntLine <start> 100 / data <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> 100 / data <end> );"	"<start> data = -1 <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	2
5f76fc97-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_listen_socket_predec_64b_badSink(void * dataVoidPtr) { int * dataPtr = (int *)dataVoidPtr; int data = (*dataPtr); { --data; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"- <start> data <end> ;
<start> printIntLine(result) <end> ;"	"- <start> data <end> ;
int <start> result = data <end> ;"	"void CWE191_Integer_Underflow__int_listen_socket_predec_64b_badSink(void * <start> dataVoidPtr <end> );
- <start> data <end> ;"	"- <start> data <end> ;
void CWE191_Integer_Underflow__int_listen_socket_predec_64b_badSink(void * <start> dataVoidPtr <end> );"	2
b1b8082c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_17_bad() { int i; int data; data = -1; for(i = 0; i < 1; i++) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { short shortData = (short)data; printShortLine(shortData); } }"	where is the vulnerable dataflow from shortData to printShortLine ?	"printShortLine <start> shortData <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"printShortLine <start> shortData <end> );
if  <start> listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printShortLine <start> shortData <end> );"	"if  <start> listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	2
c8600ad9-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 namespace CWE23_Relative_Path_Traversal__char_listen_socket_ofstream_03 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(5==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"if  <start> recvResult == SOCKET_ERROR <end>  || recvResult == 0);
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
outputFile.open((char * <start> data <end> );"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
<start> data = dataBuffer <end> ;"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
size_t <start> dataLen = strlen(data) <end> ;"	1
761e297e-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 8 void CWE194_Unexpected_Sign_Extension__fgets_memmove_14_bad() { short data; data = 0; if(globalFive==5) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = (short)atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> memmove(dest, source, data) <end> ;"	"<start> printLine(dest) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"printLine <start> dest <end> );
<start> memmove(dest, source, data) <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printLine <start> dest <end> );"	3
525b6445-6c15-11ed-81d4-94e6f77dd552	"static int badStatic = 0; static void badSink(int data) { if(badStatic) { { ++data; int result = data; printIntLine(result); } } } void CWE190_Integer_Overflow__int_fscanf_preinc_21_bad() { int data; data = 0; fscanf(stdin, ""%d"", &data); badStatic = 1; badSink(data); }"	where is the vulnerable dataflow from data ?	"fscanf(stdin, ""%d"", <start> &data <end> );
badSink <start> data <end> );
static void badSink(int <start> data <end> );
+ <start> data <end> ;"	"+ <start> data <end> ;
static void badSink(int <start> data <end> );
badSink <start> data <end> );"	"+ <start> data <end> ;
int <start> result = data <end> ;
fscanf(stdin, ""%d"", <start> &data <end> );
static void badSink(int <start> data <end> );"	"<start> printIntLine(result) <end> ;
badSink <start> data <end> );
+ <start> data <end> ;
fscanf(stdin, ""%d"", <start> &data <end> );"	0
69161b51-6c15-11ed-81d4-94e6f77dd552	static int staticFive = 5; void CWE190_Integer_Overflow__short_rand_preinc_07_bad() { short data; data = 0; if(staticFive==5) { data = (short)RAND32(); } if(staticFive==5) { { ++data; short result = data; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
data = (short <start> RAND32() <end> ;"	"data = (short <start> RAND32() <end> ;
+ <start> data <end> ;"	"data = (short <start> RAND32() <end> ;
short <start> result = data <end> ;"	"+ <start> data <end> ;
data = (short <start> RAND32() <end> ;"	1
a49c4f60-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE190_Integer_Overflow__int_listen_socket_multiply_82 { void bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE190_Integer_Overflow__int_listen_socket_multiply_82_base* baseObject = new CWE190_Integer_Overflow__int_listen_socket_multiply_82_bad; baseObject->action(data); delete baseObject; }"	where is the vulnerable dataflow from data to action ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
baseObject->action <start> data <end> );"	"if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"baseObject->action <start> data <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"baseObject->action <start> data <end> );
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	0
466e7f05-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_square_15_bad() { int data; data = 0; switch(6) { case 6: { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } break; default: printLine(""Benign, fixed string""); break; } switch(7) { case 7: { int result = data * data; printIntLine(result); } break; default: printLine(""Benign, fixed string""); break; } }"	where is the vulnerable dataflow from data ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
int result = <start> data * data <end> ;"	"int result = <start> data <end>  * data;
if  <start> fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) <end>  != NULL);"	"int <start> result = data * data <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
int result = <start> data <end>  * data;"	3
6c938bf6-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif void CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_09_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; if(GLOBAL_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(GLOBAL_CONST_TRUE) { { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } } }"	where is the vulnerable dataflow from dest to printLine ?	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (100 - dataLen - 1), 0);"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
printLine <start> dest <end> );"	"printLine <start> dest <end> );
<start> printLine(dest) <end> ;"	"printLine <start> dest <end> );
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (100 - dataLen - 1), 0);"	1
7ae3a747-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink(int data) { { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } } void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_44_bad() { int data; void (*funcPtr) (int) = badSink; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } funcPtr(data); }"	where is the vulnerable dataflow from dest to printLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
funcPtr <start> data <end> );
static void badSink(int <start> data <end> );
printLine <start> dest <end> );"	"static void badSink(int <start> data <end> );
printLine <start> dest <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"static void badSink(int <start> data <end> );
data = <start> atoi(inputBuffer) <end> ;
funcPtr <start> data <end> );
printLine <start> dest <end> );"	"printLine <start> dest <end> );
recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);
funcPtr <start> data <end> );
static void badSink(int <start> data <end> );"	0
761e2988-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 8 static short badSource(short data) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = (short)atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } return data; } void CWE194_Unexpected_Sign_Extension__fgets_memmove_42_bad() { short data; data = 0; data = badSource(data); { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> memmove(dest, source, data) <end> ;
printLine <start> dest <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
static short <start> badSource <end> (short data);"	"printLine <start> dest <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
static short <start> badSource <end> (short data);
data = <start> badSource <end> (data);
printLine <start> dest <end> );"	"<start> memmove(dest, source, data) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
data = <start> badSource <end> (data);
printLine <start> dest <end> );"	2
92bb8a1e-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING ""hello"" void CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_09_bad() { size_t data; data = 0; if(GLOBAL_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = strtoul(inputBuffer, NULL, 0); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(GLOBAL_CONST_TRUE) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); } else { printLine(""Input is less than the length of the source string""); } } } }"	where is the vulnerable dataflow from data to malloc ?	"myString = (char *)malloc <start> data*sizeof(char) <end> );
myString = <start> (char *)malloc(data*sizeof(char)) <end> ;"	"myString = (char *)malloc <start> data*sizeof(char) <end> );
<start> data = strtoul(inputBuffer, NULL, 0) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
myString = (char *)malloc <start> data*sizeof(char) <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data = strtoul(inputBuffer, NULL, 0) <end> ;"	2
54c581f9-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_connect_socket_multiply_52c_badSink(int data) { if(data < 0) { int result = data * 2; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  * 2;
void CWE191_Integer_Underflow__int_connect_socket_multiply_52c_badSink(int <start> data <end> );"	"void CWE191_Integer_Underflow__int_connect_socket_multiply_52c_badSink(int <start> data <end> );
int result = <start> data <end>  * 2;"	"void CWE191_Integer_Underflow__int_connect_socket_multiply_52c_badSink(int <start> data <end> );
<start> printIntLine(result) <end> ;"	"int <start> result = data * 2 <end> ;
void CWE191_Integer_Underflow__int_connect_socket_multiply_52c_badSink(int <start> data <end> );"	1
8cc3a689-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(count) + 2) #ifdef _WIN32 #define SLEEP Sleep #else #define SLEEP usleep #endif static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; void CWE400_Resource_Exhaustion__listen_socket_sleep_04_bad() { int count; count = -1; if(STATIC_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; count = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(STATIC_CONST_TRUE) { SLEEP(count); printLine(""Sleep time possibly too long""); } }"	where is the vulnerable dataflow from count to SLEEP ?	"<start> count = atoi(inputBuffer) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
SLEEP <start> count <end> );"	"<start> SLEEP(count) <end> ;
SLEEP <start> count <end> );"	"if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	1
6c938c16-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif namespace CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_73 { void badSink(list<char *> dataList) { char * data = dataList.back(); { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"printLine <start> dest <end> );
<start> printLine(dest) <end> ;"	"printLine <start> dest <end> );
void badSink(list<char *> <start> dataList <end> );"	"void badSink(list<char *> <start> dataList <end> );
printLine <start> dest <end> );"	"<start> SNPRINTF(dest, 100-1, data) <end> ;
void badSink(list<char *> <start> dataList <end> );"	2
445c120f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_multiply_02_bad() { int data; data = 0; if(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(1) { if(data > 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  * 2;"	"int <start> result = data * 2 <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"int result = <start> data <end>  * 2;
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  * 2;"	3
a95fd81c-6c15-11ed-81d4-94e6f77dd552	namespace CWE191_Integer_Underflow__int_connect_socket_sub_82 { void CWE191_Integer_Underflow__int_connect_socket_sub_82_bad::action(int data) { { int result = data - 1; printIntLine(result); } } }	where is the vulnerable dataflow from result to printIntLine ?	"void CWE191_Integer_Underflow__int_connect_socket_sub_82_bad::action(int <start> data <end> );
printIntLine <start> result <end> );"	"void CWE191_Integer_Underflow__int_connect_socket_sub_82_bad::action(int <start> data <end> );
<start> printIntLine(result) <end> ;"	"int <start> result = data - 1 <end> ;
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
int result = <start> data - 1 <end> ;"	0
ae26ae70-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_14_bad() { int data; data = -1; if(globalFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { char charData = (char)data; printHexCharLine(charData); } }"	where is the vulnerable dataflow from charData to printHexCharLine ?	"printHexCharLine <start> charData <end> );
recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printHexCharLine <start> charData <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printHexCharLine(charData) <end> ;"	"<start> printHexCharLine(charData) <end> ;
printHexCharLine <start> charData <end> );"	1
9fe7ad47-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_add_11_bad() { int data; data = 0; if(globalReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalReturnsTrue()) { { int result = data + 1; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data = 0 <end> ;"	2
60db83b5-6c15-11ed-81d4-94e6f77dd552	static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; void CWE190_Integer_Overflow__char_rand_multiply_04_bad() { char data; data = ' '; if(STATIC_CONST_TRUE) { data = (char)RAND32(); } if(STATIC_CONST_TRUE) { if(data > 0) { char result = data * 2; printHexCharLine(result); } } }	where is the vulnerable dataflow from data ?	"data = (char <start> RAND32() <end> ;
<start> data = ' ' <end> ;"	"char result = <start> data <end>  * 2;
<start> printHexCharLine(result) <end> ;"	"data = (char <start> RAND32() <end> ;
char result = <start> data <end>  * 2;"	"<start> data = (char)RAND32() <end> ;
data = (char <start> RAND32() <end> ;"	2
78800fb9-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 8 typedef union { short unionFirst; short unionSecond; } CWE194_Unexpected_Sign_Extension__listen_socket_memmove_34_unionType; void CWE194_Unexpected_Sign_Extension__listen_socket_memmove_34_bad() { short data; CWE194_Unexpected_Sign_Extension__listen_socket_memmove_34_unionType myUnion; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } myUnion.unionFirst = data; { short data = myUnion.unionSecond; { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } } }"	where is the vulnerable dataflow from dest to printLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"<start> memmove(dest, source, data) <end> ;
printLine <start> dest <end> );"	"char <start> dest[100] = """" <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"printLine <start> dest <end> );
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	0
73bc8171-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" void CWE194_Unexpected_Sign_Extension__connect_socket_memmove_12_bad() { short data; data = 0; if(globalReturnsTrueOrFalse()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } else { data = 100-1; } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> tempInt = atoi(inputBuffer) <end> ;
printLine <start> dest <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data = 0 <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"<start> memmove(dest, source, data) <end> ;
printLine <start> dest <end> );"	2
893217b8-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_console_fopen_02 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(1) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"pFile = FOPEN <start> data <end> , ""wb+"");
char <start> dataBuffer[FILENAME_MAX] = """" <end> ;"	0
8b91e45b-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_listen_socket_fopen_45 { static char * badData; static char * goodG2BData; static void badSink() { char * data = badData; { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } } void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badData = data; badSink(); }"	where is the vulnerable dataflow from data to FOPEN ?	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
<start> badData = data <end> ;
static char * <start> badData <end> ;
char * data = <start> badData <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
<start> badData = data <end> ;
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
char * data = <start> badData <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"<start> badData = data <end> ;
static char * <start> badData <end> ;
char * data = <start> badData <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - <start> dataLen - 1 <end> ), 0);"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = FOPEN <start> data <end> , ""wb+"");
static char * <start> badData <end> ;
char * data = <start> badData <end> ;"	0
a95fd86f-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) extern int CWE191_Integer_Underflow__int_fgets_sub_68_badData; extern int CWE191_Integer_Underflow__int_fgets_sub_68_goodG2BData; extern int CWE191_Integer_Underflow__int_fgets_sub_68_goodB2GData; void CWE191_Integer_Underflow__int_fgets_sub_68b_badSink() { int data = CWE191_Integer_Underflow__int_fgets_sub_68_badData; { int result = data - 1; printIntLine(result); } }	where is the vulnerable dataflow from result to printIntLine ?	"<start> printIntLine(result) <end> ;
int data = <start> CWE191_Integer_Underflow__int_fgets_sub_68_badData <end> ;"	"printIntLine <start> result <end> );
int data = <start> CWE191_Integer_Underflow__int_fgets_sub_68_badData <end> ;"	"int data = <start> CWE191_Integer_Underflow__int_fgets_sub_68_badData <end> ;
printIntLine <start> result <end> );"	"int data = <start> CWE191_Integer_Underflow__int_fgets_sub_68_badData <end> ;
int <start> result = data - 1 <end> ;"	2
7c127575-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_64b_badSink(void * dataVoidPtr) { int * dataPtr = (int *)dataVoidPtr; int data = (*dataPtr); if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }	where is the vulnerable dataflow from data to malloc ?	"char * dataBuffer = (char *)malloc <start> data <end> );
void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_64b_badSink(void * <start> dataVoidPtr <end> );"	"void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_64b_badSink(void * <start> dataVoidPtr <end> );
char * dataBuffer = (char *)malloc <start> data <end> );"	"void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_64b_badSink(void * <start> dataVoidPtr <end> );
<start> memset(dataBuffer, 'A', data-1) <end> ;"	"char * dataBuffer = (char *)malloc <start> data <end> );
char * dataBuffer = <start> (char *)malloc(data) <end> ;"	1
453db03c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_square_11_bad() { int data; data = 0; if(globalReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalReturnsTrue()) { { int result = data * data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  * data;"	"int result = <start> data <end>  * data;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  * data;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data = atoi(inputBuffer) <end> ;"	0
6ef76814-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif void CWE134_Uncontrolled_Format_String__char_console_snprintf_63b_badSink(char * * dataPtr) { char * data = *dataPtr; { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> printLine(dest) <end> ;
void CWE134_Uncontrolled_Format_String__char_console_snprintf_63b_badSink(char * * <start> dataPtr <end> );"	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	"printLine <start> dest <end> );
char <start> dest[100] = """" <end> ;"	"void CWE134_Uncontrolled_Format_String__char_console_snprintf_63b_badSink(char * * <start> dataPtr <end> );
printLine <start> dest <end> );"	3
93ece30e-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING ""hello"" static void badSink(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); } else { printLine(""Input is less than the length of the source string""); } } } void CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_41_bad() { size_t data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = strtoul(inputBuffer, NULL, 0); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badSink(data); }"	where is the vulnerable dataflow from data to malloc ?	"static void badSink(size_t <start> data <end> );
myString = (char *)malloc <start> data*sizeof(char) <end> );
badSink <start> data <end> );
<start> data = strtoul(inputBuffer, NULL, 0) <end> ;"	"<start> strcpy(myString, HELLO_STRING) <end> ;
badSink <start> data <end> );
static void badSink(size_t <start> data <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"badSink <start> data <end> );
myString = (char *)malloc <start> data*sizeof(char) <end> );
if  <start> data > strlen(HELLO_STRING) <end> );
static void badSink(size_t <start> data <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSink <start> data <end> );
static void badSink(size_t <start> data <end> );
myString = (char *)malloc <start> data*sizeof(char) <end> );"	3
a5ce1c8a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_postinc_51b_badSink(int data) { { data++; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;"	"void CWE190_Integer_Overflow__int_listen_socket_postinc_51b_badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"void CWE190_Integer_Overflow__int_listen_socket_postinc_51b_badSink(int <start> data <end> );
int <start> result = data <end> ;"	"printIntLine <start> result <end> );
void CWE190_Integer_Overflow__int_listen_socket_postinc_51b_badSink(int <start> data <end> );"	1
a36a78e6-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticTrue = 1; static int staticFalse = 0; void CWE190_Integer_Overflow__int_listen_socket_add_05_bad() { int data; data = 0; if(staticTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticTrue) { { int result = data + 1; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data + 1 <end> ;"	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> result <end> );"	"int result = <start> data + 1 <end> ;
printIntLine <start> result <end> );"	0
846ad341-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int badStatic = 0; static void badSink(int data) { if(badStatic) { printIntLine(100 / data); } } void CWE369_Divide_by_Zero__int_connect_socket_divide_21_bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badStatic = 1; badSink(data); }"	where is the vulnerable dataflow from data to printIntLine ?	"badSink <start> data <end> );
static void badSink(int <start> data <end> );
printIntLine <start> 100 / data <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"<start> badSink(data) <end> ;
printIntLine <start> 100 / data <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSink <start> data <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSink <start> data <end> );
static void badSink(int <start> data <end> );
printIntLine <start> 100 / data <end> );"	"recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);
printIntLine <start> 100 / data <end> );
static void badSink(int <start> data <end> );
badSink <start> data <end> );"	2
a49c4f84-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_square_65b_badSink(int data) { { int result = data * data; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
int <start> result = data * data <end> ;"	"printIntLine <start> result <end> );
void CWE190_Integer_Overflow__int_listen_socket_square_65b_badSink(int <start> data <end> );"	"void CWE190_Integer_Overflow__int_listen_socket_square_65b_badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;"	2
5e44fc4c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticFive = 5; void CWE191_Integer_Underflow__int_connect_socket_predec_07_bad() { int data; data = 0; if(staticFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticFive==5) { { --data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"int <start> result = data <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
- <start> data <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> --data <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printIntLine(result) <end> ;"	1
80d9872b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_console_open_17 { void bad() { int i; char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; for(i = 0; i < 1; i++) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"size_t dataLen = <start> strlen(data) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"if (dataLen > 0 && <start> data[dataLen-1] == '\n' <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	1
833ac91c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_listen_socket_fopen_31 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { char * dataCopy = data; char * data = dataCopy; { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } } }"	where is the vulnerable dataflow from data to FOPEN ?	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
char <start> * dataCopy = data <end> ;"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
size_t dataLen = <start> strlen(data) <end> ;"	"pFile = FOPEN <start> data <end> , ""wb+"");
char <start> * data = dataCopy <end> ;"	1
9ebc76c2-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) typedef struct _CWE127_Buffer_Underread__CWE839_connect_socket_67_structType { int structFirst; } CWE127_Buffer_Underread__CWE839_connect_socket_67_structType; void CWE127_Buffer_Underread__CWE839_connect_socket_67b_badSink(CWE127_Buffer_Underread__CWE839_connect_socket_67_structType myStruct) { int data = myStruct.structFirst; { int buffer[10] = { 0 }; if (data < 10) { printIntLine(buffer[data]); } else { printLine(""ERROR: Array index is too big.""); } } }"	where is the vulnerable dataflow from buffer[data] to printIntLine ?	"void CWE127_Buffer_Underread__CWE839_connect_socket_67b_badSink(CWE127_Buffer_Underread__CWE839_connect_socket_67_structType <start> myStruct <end> );
int data = <start> myStruct <end> .structFirst;
printIntLine <start> buffer[data] <end> );"	"int data = <start> myStruct <end> .structFirst;
void CWE127_Buffer_Underread__CWE839_connect_socket_67b_badSink(CWE127_Buffer_Underread__CWE839_connect_socket_67_structType <start> myStruct <end> );
printIntLine <start> buffer[data] <end> );"	"void CWE127_Buffer_Underread__CWE839_connect_socket_67b_badSink(CWE127_Buffer_Underread__CWE839_connect_socket_67_structType <start> myStruct <end> );
int data = <start> myStruct <end> .structFirst;"	"void CWE127_Buffer_Underread__CWE839_connect_socket_67b_badSink(CWE127_Buffer_Underread__CWE839_connect_socket_67_structType <start> myStruct <end> );
printIntLine <start> buffer[data] <end> );
<start> printIntLine(buffer[data]) <end> ;"	0
7d44fcb9-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_14_bad() { int data; data = -1; if(globalFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }"	where is the vulnerable dataflow from data to malloc ?	"char * dataBuffer = (char *)malloc <start> data <end> );
<start> printLine(dataBuffer) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printLine(dataBuffer) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
char * dataBuffer = (char *)malloc <start> data <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
char * dataBuffer = (char * <start> malloc(data) <end> ;"	2
525b647c-6c15-11ed-81d4-94e6f77dd552	"static int staticFive = 5; void CWE190_Integer_Overflow__short_fscanf_preinc_07_bad() { short data; data = 0; if(staticFive==5) { fscanf (stdin, ""%hd"", &data); } if(staticFive==5) { { ++data; short result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"fscanf (stdin, ""%hd"", <start> &data <end> );
+ <start> data <end> ;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
<start> printIntLine(result) <end> ;"	"+ <start> data <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );"	"+ <start> data <end> ;
<start> ++data <end> ;"	0
964cdc28-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_02_bad() { int data; data = -1; if(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(1) { { int i; int buffer[10] = { 0 }; if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } } } }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"printIntLine <start> buffer[i] <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[i] <end> );"	"printIntLine <start> buffer[i] <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);
printIntLine <start> buffer[i] <end> );"	1
67d010b6-6c15-11ed-81d4-94e6f77dd552	static int badStatic = 0; static void badSink(short data) { if(badStatic) { { data++; short result = data; printIntLine(result); } } } void CWE190_Integer_Overflow__short_rand_postinc_21_bad() { short data; data = 0; data = (short)RAND32(); badStatic = 1; badSink(data); }	where is the vulnerable dataflow from data ?	"<start> data <end> ++;
static void badSink(short <start> data <end> );
badSink <start> data <end> );
<start> printIntLine(result) <end> ;"	"<start> printIntLine(result) <end> ;
badSink <start> data <end> );
data = (short <start> RAND32() <end> ;
static void badSink(short <start> data <end> );"	"static void badSink(short <start> data <end> );
data = (short <start> RAND32() <end> ;
<start> data <end> ++;
<start> badSink(data) <end> ;"	"data = (short <start> RAND32() <end> ;
badSink <start> data <end> );
static void badSink(short <start> data <end> );
<start> data <end> ++;"	3
c99197df-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_connect_socket_fopen_10 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(globalTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"size_t dataLen = <start> strlen(data) <end> ;
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"<start> data = dataBuffer <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
replace = <start> strchr(data, '\n') <end> ;"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	3
453db068-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_add_14_bad() { int data; data = 0; if(globalFive==5) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(globalFive==5) { { int result = data + 1; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> data = atoi(inputBuffer) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if  <start> fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) <end>  != NULL);
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
int result = <start> data <end>  + 1;"	"if  <start> fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) <end>  != NULL);
int result = <start> data <end>  + 1;"	2
61da66f3-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__char_rand_square_54e_badSink(char data) { { char result = data * data; printHexCharLine(result); } }	where is the vulnerable dataflow from data ?	"void CWE190_Integer_Overflow__char_rand_square_54e_badSink(char <start> data <end> );
char result = <start> data <end>  * data;"	"char result = <start> data <end>  * data;
void CWE190_Integer_Overflow__char_rand_square_54e_badSink(char <start> data <end> );"	"void CWE190_Integer_Overflow__char_rand_square_54e_badSink(char <start> data <end> );
char <start> result = data * data <end> ;"	"<start> printHexCharLine(result) <end> ;
void CWE190_Integer_Overflow__char_rand_square_54e_badSink(char <start> data <end> );"	0
cac216c9-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" namespace CWE36_Absolute_Path_Traversal__char_connect_socket_ofstream_54 { void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badSink_b(data); }"	where is the vulnerable dataflow from data to badSink_b ?	"badSink_b <start> data <end> );
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
badSink_b <start> data <end> );"	"recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - <start> dataLen - 1 <end> ), 0);
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
<start> data = dataBuffer <end> ;"	1
6ef7681c-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif namespace CWE134_Uncontrolled_Format_String__char_console_snprintf_74 { void badSink(map<int, char *> dataMap) { char * data = dataMap[2]; { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"printLine <start> dest <end> );
char <start> * data = dataMap[2] <end> ;"	"<start> SNPRINTF(dest, 100-1, data) <end> ;
void badSink(map<int, char *> <start> dataMap <end> );"	"void badSink(map<int, char *> <start> dataMap <end> );
printLine <start> dest <end> );"	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	2
951c5e76-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FULL_COMMAND ""dir "" #else #define FULL_COMMAND ""ls "" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define POPEN _popen #define PCLOSE _pclose #else #define POPEN popen #define PCLOSE pclose #endif void CWE78_OS_Command_Injection__char_connect_socket_popen_41_badSink(char * data) { { FILE *pipe; pipe = POPEN(data, ""w""); if (pipe != NULL) { PCLOSE(pipe); } } } void CWE78_OS_Command_Injection__char_connect_socket_popen_41_bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE78_OS_Command_Injection__char_connect_socket_popen_41_badSink(data); }"	where is the vulnerable dataflow from data to POPEN ?	"pipe = <start> POPEN(data, ""w"") <end> ;
pipe = POPEN <start> data <end> , ""w"");
CWE78_OS_Command_Injection__char_connect_socket_popen_41_badSink <start> data <end> );
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"CWE78_OS_Command_Injection__char_connect_socket_popen_41_badSink <start> data <end> );
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
replace = <start> strchr(data, '\r') <end> ;
void CWE78_OS_Command_Injection__char_connect_socket_popen_41_badSink(char * <start> data <end> );"	"void CWE78_OS_Command_Injection__char_connect_socket_popen_41_badSink(char * <start> data <end> );
pipe = POPEN <start> data <end> , ""w"");
CWE78_OS_Command_Injection__char_connect_socket_popen_41_badSink <start> data <end> );
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
CWE78_OS_Command_Injection__char_connect_socket_popen_41_badSink <start> data <end> );
void CWE78_OS_Command_Injection__char_connect_socket_popen_41_badSink(char * <start> data <end> );
pipe = POPEN <start> data <end> , ""w"");"	3
964cdc1f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FULL_COMMAND ""dir "" #else #define FULL_COMMAND ""ls "" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define POPEN _popen #define PCLOSE _pclose #else #define POPEN popen #define PCLOSE pclose #endif void CWE78_OS_Command_Injection__char_listen_socket_popen_64b_badSink(void * dataVoidPtr) { char * * dataPtr = (char * *)dataVoidPtr; char * data = (*dataPtr); { FILE *pipe; pipe = POPEN(data, ""w""); if (pipe != NULL) { PCLOSE(pipe); } } }"	where is the vulnerable dataflow from data to POPEN ?	"char <start> * data = (*dataPtr) <end> ;
pipe = POPEN <start> data <end> , ""w"");"	"pipe = <start> POPEN(data, ""w"") <end> ;
pipe = POPEN <start> data <end> , ""w"");"	"pipe = POPEN <start> data <end> , ""w"");
void CWE78_OS_Command_Injection__char_listen_socket_popen_64b_badSink(void * <start> dataVoidPtr <end> );"	"void CWE78_OS_Command_Injection__char_listen_socket_popen_64b_badSink(void * <start> dataVoidPtr <end> );
pipe = POPEN <start> data <end> , ""w"");"	3
d1e9da1c-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_file_open_54 { void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } badSink_b(data); }"	where is the vulnerable dataflow from data to badSink_b ?	"badSink_b <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
badSink_b <start> data <end> );"	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"badSink_b <start> data <end> );
<start> data = dataBuffer <end> ;"	1
9ebc76e1-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE127_Buffer_Underread__CWE839_listen_socket_43 { static void badSource(int &data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } void bad() { int data; data = -1; badSource(data); { int buffer[10] = { 0 }; if (data < 10) { printIntLine(buffer[data]); } else { printLine(""ERROR: Array index is too big.""); } } }"	where is the vulnerable dataflow from buffer[data] to printIntLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSource <start> data <end> );
printIntLine <start> buffer[data] <end> );"	"badSource <start> data <end> );
printIntLine <start> buffer[data] <end> );
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[data] <end> );
badSource <start> data <end> );"	"printIntLine <start> buffer[data] <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	0
98b01555-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_connect_socket_41 { static void badSink(int data) { { int i; int * buffer = new int[10]; for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } delete[] buffer; } } void bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badSink(data); }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"data = <start> atoi(inputBuffer) <end> ;
badSink <start> data <end> );
printIntLine <start> buffer[i] <end> );
static void badSink(int <start> data <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSink <start> data <end> );
static void badSink(int <start> data <end> );
printIntLine <start> buffer[i] <end> );"	"<start> badSink(data) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static void badSink(int <start> data <end> );
badSink <start> data <end> );"	"<start> badSink(data) <end> ;
printIntLine <start> buffer[i] <end> );
badSink <start> data <end> );
static void badSink(int <start> data <end> );"	1
977ea794-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int badStatic = 0; static void badSink(int data) { if(badStatic) { { int i; int buffer[10] = { 0 }; if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } } } } void CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_21_bad() { int data; data = -1; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } badStatic = 1; badSink(data); }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
badSink <start> data <end> );"	"data = <start> atoi(inputBuffer) <end> ;
static void badSink(int <start> data <end> );
printIntLine <start> buffer[i] <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"<start> badSink(data) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
badSink <start> data <end> );
static void badSink(int <start> data <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
badSink <start> data <end> );
static void badSink(int <start> data <end> );
printIntLine <start> buffer[i] <end> );"	3
cd228170-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_console_open_61 { char * badSource(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; data = badSource(data); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);
data = <start> badSource <end> (data);"	"data = <start> badSource <end> (data);
char <start> dataBuffer[FILENAME_MAX] = """" <end> ;"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"data = <start> badSource <end> (data);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	3
a95fd850-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } void CWE191_Integer_Underflow__int_fgets_sub_08_bad() { int data; data = 0; if(staticReturnsTrue()) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(staticReturnsTrue()) { { int result = data - 1; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> printIntLine(result) <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );"	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
data = <start> atoi(inputBuffer) <end> ;"	1
61da66f7-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__char_rand_square_65b_badSink(char data) { { char result = data * data; printHexCharLine(result); } }	where is the vulnerable dataflow from data ?	"<start> printHexCharLine(result) <end> ;
void CWE190_Integer_Overflow__char_rand_square_65b_badSink(char <start> data <end> );"	"char result = <start> data <end>  * data;
void CWE190_Integer_Overflow__char_rand_square_65b_badSink(char <start> data <end> );"	"char result = <start> data <end>  * data;
<start> printHexCharLine(result) <end> ;"	"void CWE190_Integer_Overflow__char_rand_square_65b_badSink(char <start> data <end> );
char result = <start> data <end>  * data;"	3
584fa850-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_listen_socket_multiply_18_bad() { int data; data = 0; goto source; source: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } goto sink; sink: if(data < 0) { int result = data * 2; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  * 2;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data = atoi(inputBuffer) <end> ;"	"int result = <start> data <end>  * 2;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  * 2;"	3
466e7f14-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_square_53d_badSink(int data) { { int result = data * data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
void CWE190_Integer_Overflow__int_fgets_square_53d_badSink(int <start> data <end> );"	"void CWE190_Integer_Overflow__int_fgets_square_53d_badSink(int <start> data <end> );
int result = <start> data <end>  * data;"	"int result = <start> data <end>  * data;
void CWE190_Integer_Overflow__int_fgets_square_53d_badSink(int <start> data <end> );"	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  * data;"	1
a49c4f52-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) int CWE190_Integer_Overflow__int_listen_socket_multiply_61b_badSource(int data); void CWE190_Integer_Overflow__int_listen_socket_multiply_61_bad() { int data; data = 0; data = CWE190_Integer_Overflow__int_listen_socket_multiply_61b_badSource(data); if(data > 0) { int result = data * 2; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"data = <start> CWE190_Integer_Overflow__int_listen_socket_multiply_61b_badSource <end> (data);
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;"	"printIntLine <start> result <end> );
data = <start> CWE190_Integer_Overflow__int_listen_socket_multiply_61b_badSource <end> (data);"	"<start> data = CWE190_Integer_Overflow__int_listen_socket_multiply_61b_badSource(data) <end> ;
printIntLine <start> result <end> );"	0
4ec5d08f-6c15-11ed-81d4-94e6f77dd552	"void CWE190_Integer_Overflow__int_fscanf_postinc_02_bad() { int data; data = 0; if(1) { fscanf(stdin, ""%d"", &data); } if(1) { { data++; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> data <end> ++;
<start> printIntLine(result) <end> ;"	"<start> printIntLine(result) <end> ;
fscanf(stdin, ""%d"", <start> &data <end> );"	"<start> data <end> ++;
fscanf(stdin, ""%d"", <start> &data <end> );"	"fscanf(stdin, ""%d"", <start> &data <end> );
<start> data <end> ++;"	3
761e29a3-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 8 static int staticFive = 5; void CWE194_Unexpected_Sign_Extension__fgets_strncpy_07_bad() { short data; data = 0; if(staticFive==5) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = (short)atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printLine <start> dest <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> strncpy(dest, source, data) <end> ;"	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	"if  <start> fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) <end>  != NULL);
printLine <start> dest <end> );"	0
453db045-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_square_31_bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { int dataCopy = data; int data = dataCopy; { int result = data * data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data * data <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  * data;"	"int <start> data = dataCopy <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
int result = <start> data <end>  * data;"	1
728a4fea-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 static void badVaSinkB(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_14_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; if(globalFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalFive==5) { badVaSinkB(data, data); } }"	where is the vulnerable dataflow from data to vfprintf ?	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);"	"static void badVaSinkB(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
size_t dataLen = <start> strlen(data) <end> ;"	"vfprintf(stdout, <start> data <end> , args);
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - <start> dataLen - 1 <end> ), 0);
badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);"	"vfprintf(stdout, <start> data <end> , args);
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (100 - dataLen - 1), 0);
static void badVaSinkB(char * <start> data <end> , ...);
badVaSinkB <start> data <end> , data);"	0
4b34aff3-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__short_fscanf_multiply_82 { void CWE190_Integer_Overflow__short_fscanf_multiply_82_bad::action(short data) { if(data > 0) { short result = data * 2; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
short result = <start> data <end>  * 2;"	"void CWE190_Integer_Overflow__short_fscanf_multiply_82_bad::action(short <start> data <end> );
short result = <start> data * 2 <end> ;"	"void CWE190_Integer_Overflow__short_fscanf_multiply_82_bad::action(short <start> data <end> );
short result = <start> data <end>  * 2;"	"short result = <start> data <end>  * 2;
void CWE190_Integer_Overflow__short_fscanf_multiply_82_bad::action(short <start> data <end> );"	2
9ebc76c8-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int CWE127_Buffer_Underread__CWE839_fgets_45_badData; static int CWE127_Buffer_Underread__CWE839_fgets_45_goodG2BData; static int CWE127_Buffer_Underread__CWE839_fgets_45_goodB2GData; static void badSink() { int data = CWE127_Buffer_Underread__CWE839_fgets_45_badData; { int buffer[10] = { 0 }; if (data < 10) { printIntLine(buffer[data]); } else { printLine(""ERROR: Array index is too big.""); } } } void CWE127_Buffer_Underread__CWE839_fgets_45_bad() { int data; data = -1; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } CWE127_Buffer_Underread__CWE839_fgets_45_badData = data; badSink(); }"	where is the vulnerable dataflow from buffer[data] to printIntLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
int data = <start> CWE127_Buffer_Underread__CWE839_fgets_45_badData <end> ;
<start> CWE127_Buffer_Underread__CWE839_fgets_45_badData = data <end> ;
static int <start> CWE127_Buffer_Underread__CWE839_fgets_45_badData <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> CWE127_Buffer_Underread__CWE839_fgets_45_badData = data <end> ;
static int <start> CWE127_Buffer_Underread__CWE839_fgets_45_badData <end> ;
int data = <start> CWE127_Buffer_Underread__CWE839_fgets_45_badData <end> ;
printIntLine <start> buffer[data] <end> );"	"int data = <start> CWE127_Buffer_Underread__CWE839_fgets_45_badData <end> ;
static int <start> CWE127_Buffer_Underread__CWE839_fgets_45_badData <end> ;"	"int data = <start> CWE127_Buffer_Underread__CWE839_fgets_45_badData <end> ;
static int <start> CWE127_Buffer_Underread__CWE839_fgets_45_badData <end> ;
<start> CWE127_Buffer_Underread__CWE839_fgets_45_badData = data <end> ;"	1
d1e9da35-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_listen_socket_fopen_12 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(globalReturnsTrueOrFalse()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } else { #ifdef _WIN32 strcat(data, ""c:\\temp\\file.txt""); #else strcat(data, ""/tmp/file.txt""); #endif } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = FOPEN <start> data <end> , ""wb+"");
replace = <start> strchr(data, '\n') <end> ;"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	"<start> strcat(data, ""c:\\temp\\file.txt"") <end> ;
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"replace = <start> strchr(data, '\n') <end> ;
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	1
bda4e41a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define EXECL _execl #else #define EXECL execl #endif void CWE78_OS_Command_Injection__char_listen_socket_execl_12_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(globalReturnsTrueOrFalse()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } else { strcat(data, ""*.*""); } EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECL ?	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (100 - dataLen - 1), 0);
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"size_t dataLen = <start> strlen(data) <end> ;
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"<start> data = dataBuffer <end> ;
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	3
a36a78cb-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_square_31_bad() { int data; data = 0; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } { int dataCopy = data; int data = dataCopy; { int result = data * data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"int <start> result = data * data <end> ;
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
data = <start> atoi(inputBuffer) <end> ;"	2
d1e9da25-6c15-11ed-81d4-94e6f77dd552	#ifndef _WIN32 #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_file_open_72 { void badSink(vector<char *> dataVector) { char * data = dataVector[2]; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }	where is the vulnerable dataflow from data to OPEN ?	"void badSink(vector<char *> <start> dataVector <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
void badSink(vector<char *> <start> dataVector <end> );"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
void badSink(vector<char *> <start> dataVector <end> );"	0
4a02113d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_square_64b_badSink(void * dataVoidPtr) { int * dataPtr = (int *)dataVoidPtr; int data = (*dataPtr); { int result = data * data; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  * data;
void CWE190_Integer_Overflow__int_listen_socket_square_64b_badSink(void * <start> dataVoidPtr <end> );"	"int result = <start> data <end>  * data;
<start> printIntLine(result) <end> ;"	"int <start> data = (*dataPtr) <end> ;
int result = <start> data <end>  * data;"	"void CWE190_Integer_Overflow__int_listen_socket_square_64b_badSink(void * <start> dataVoidPtr <end> );
int result = <start> data <end>  * data;"	3
79b27546-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_02_bad() { int data; data = -1; if(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);
printLine <start> dest <end> );"	"printLine <start> dest <end> );
data = <start> atoi(inputBuffer) <end> ;"	"data = <start> atoi(inputBuffer) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	3
7d44fcac-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_01_bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }"	where is the vulnerable dataflow from data to malloc ?	"if  <start> recvResult == SOCKET_ERROR <end>  || recvResult == 0);
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
char * dataBuffer = (char *)malloc <start> data <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
char <start> * dataBuffer = (char *)malloc(data) <end> ;"	"char * dataBuffer = (char *)malloc <start> data <end> );
if  <start> data < 100 <end> );"	1
630ae813-6c15-11ed-81d4-94e6f77dd552	static short badSource(short data) { data = (short)RAND32(); return data; } void CWE190_Integer_Overflow__short_rand_square_42_bad() { short data; data = 0; data = badSource(data); { short result = data * data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"data = (short <start> RAND32() <end> ;
data = <start> badSource <end> (data);
short result = <start> data * data <end> ;
static short <start> badSource <end> (short data);"	"data = (short <start> RAND32() <end> ;
static short <start> badSource <end> (short data);
data = <start> badSource <end> (data);
short result = <start> data <end>  * data;"	"data = <start> badSource <end> (data);
<start> printIntLine(result) <end> ;
static short <start> badSource <end> (short data);
short result = <start> data <end>  * data;"	"data = (short <start> RAND32() <end> ;
static short <start> badSource <end> (short data);"	1
a23a3e2b-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink(int data) { if(data > 0) { int result = data * 2; printIntLine(result); } } void CWE190_Integer_Overflow__int_fgets_multiply_41_bad() { int data; data = 0; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } badSink(data); }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
int result = <start> data * 2 <end> ;
badSink <start> data <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"printIntLine <start> result <end> );
badSink <start> data <end> );
<start> badSink(data) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
badSink <start> data <end> );
static void badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"badSink <start> data <end> );
<start> printIntLine(result) <end> ;
static void badSink(int <start> data <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	2
4ff78258-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_postinc_53d_badSink(int data) { { data++; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
void CWE190_Integer_Overflow__int_listen_socket_postinc_53d_badSink(int <start> data <end> );"	"void CWE190_Integer_Overflow__int_listen_socket_postinc_53d_badSink(int <start> data <end> );
<start> data <end> ++;"	"<start> data <end> ++;
int <start> result = data <end> ;"	"void CWE190_Integer_Overflow__int_listen_socket_postinc_53d_badSink(int <start> data <end> );
<start> data++ <end> ;"	1
85b15eff-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE369_Divide_by_Zero__int_fgets_modulo_01_bad() { int data; data = -1; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } printIntLine(100 % data); }"	where is the vulnerable dataflow from data to printIntLine ?	"printIntLine <start> 100 % data <end> );
<start> data = atoi(inputBuffer) <end> ;"	"if  <start> fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) <end>  != NULL);
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"printIntLine <start> 100 % data <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> 100 % data <end> );"	3
bda4e418-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define EXECL _execl #else #define EXECL execl #endif void CWE78_OS_Command_Injection__char_listen_socket_execl_10_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(globalTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECL ?	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (100 - dataLen - 1), 0);
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );"	"EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (100 - dataLen - 1), 0);"	1
4ff78279-6c15-11ed-81d4-94e6f77dd552	"static short CWE190_Integer_Overflow__short_fscanf_postinc_45_badData; static short CWE190_Integer_Overflow__short_fscanf_postinc_45_goodG2BData; static short CWE190_Integer_Overflow__short_fscanf_postinc_45_goodB2GData; static void badSink() { short data = CWE190_Integer_Overflow__short_fscanf_postinc_45_badData; { data++; short result = data; printIntLine(result); } } void CWE190_Integer_Overflow__short_fscanf_postinc_45_bad() { short data; data = 0; fscanf (stdin, ""%hd"", &data); CWE190_Integer_Overflow__short_fscanf_postinc_45_badData = data; badSink(); }"	where is the vulnerable dataflow from data ?	"fscanf (stdin, ""%hd"", <start> &data <end> );
<start> CWE190_Integer_Overflow__short_fscanf_postinc_45_badData = data <end> ;
static short <start> CWE190_Integer_Overflow__short_fscanf_postinc_45_badData <end> ;
short data = <start> CWE190_Integer_Overflow__short_fscanf_postinc_45_badData <end> ;
<start> data <end> ++;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
<start> printIntLine(result) <end> ;
<start> CWE190_Integer_Overflow__short_fscanf_postinc_45_badData = data <end> ;
short data = <start> CWE190_Integer_Overflow__short_fscanf_postinc_45_badData <end> ;
<start> data <end> ++;"	"short data = <start> CWE190_Integer_Overflow__short_fscanf_postinc_45_badData <end> ;
static short <start> CWE190_Integer_Overflow__short_fscanf_postinc_45_badData <end> ;
<start> CWE190_Integer_Overflow__short_fscanf_postinc_45_badData = data <end> ;"	"<start> data <end> ++;
short data = <start> CWE190_Integer_Overflow__short_fscanf_postinc_45_badData <end> ;
static short <start> CWE190_Integer_Overflow__short_fscanf_postinc_45_badData <end> ;
<start> CWE190_Integer_Overflow__short_fscanf_postinc_45_badData = data <end> ;"	0
5f76fc7d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_FIVE = 5; void CWE191_Integer_Underflow__int_listen_socket_predec_06_bad() { int data; data = 0; if(STATIC_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(STATIC_CONST_FIVE==5) { { --data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> --data <end> ;
- <start> data <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
- <start> data <end> ;"	"- <start> data <end> ;
if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printIntLine(result) <end> ;"	1
a23a3e11-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__int_fgets_add_73 { void badSink(list<int> dataList) { int data = dataList.back(); { int result = data + 1; printIntLine(result); } }	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;"	"int <start> result = data + 1 <end> ;
void badSink(list<int> <start> dataList <end> );"	"printIntLine <start> result <end> );
void badSink(list<int> <start> dataList <end> );"	"void badSink(list<int> <start> dataList <end> );
printIntLine <start> result <end> );"	3
774f57fe-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 8 void CWE194_Unexpected_Sign_Extension__fgets_strncpy_66b_badSink(short dataArray[]) { short data = dataArray[2]; { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"void CWE194_Unexpected_Sign_Extension__fgets_strncpy_66b_badSink(short <start> dataArray <end> []);
printLine <start> dest <end> );"	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	"printLine <start> dest <end> );
<start> strncpy(dest, source, data) <end> ;"	"printLine <start> dest <end> );
void CWE194_Unexpected_Sign_Extension__fgets_strncpy_66b_badSink(short <start> dataArray <end> []);"	0
833ac939-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_listen_socket_open_13 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(GLOBAL_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"replace = <start> strchr(data, '\n') <end> ;
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );"	0
8a6310eb-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_listen_socket_fopen_16 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; while(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"if  <start> acceptSocket == SOCKET_ERROR <end> );
pFile = FOPEN <start> data <end> , ""wb+"");"	"replace = <start> strchr(data, '\r') <end> ;
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"pFile = FOPEN <start> data <end> , ""wb+"");
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	3
d0b64ef2-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif namespace CWE36_Absolute_Path_Traversal__char_file_ofstream_42 { static char * badSource(char * data) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } return data; } void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; data = badSource(data); { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
outputFile.open((char * <start> data <end> );
data = <start> badSource <end> (data);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
size_t dataLen = <start> strlen(data) <end> ;
data = <start> badSource <end> (data);
outputFile.open((char * <start> data <end> );"	"data = <start> badSource <end> (data);
static char * <start> badSource <end> (char * data);
outputFile.open((char * <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
outputFile.open((char * <start> data <end> );"	3
d0b64ecb-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif namespace CWE36_Absolute_Path_Traversal__char_file_ifstream_12 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(globalReturnsTrueOrFalse()) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } else { #ifdef _WIN32 strcat(data, ""c:\\temp\\file.txt""); #else strcat(data, ""/tmp/file.txt""); #endif } { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
inputFile.open((char * <start> data <end> );"	"<start> data = dataBuffer <end> ;
inputFile.open((char * <start> data <end> );"	"inputFile.open((char * <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	"inputFile.open((char * <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	0
9fe7ad24-6c15-11ed-81d4-94e6f77dd552	"namespace CWE134_Uncontrolled_Format_String__char_console_snprintf_81 { void bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } const CWE134_Uncontrolled_Format_String__char_console_snprintf_81_base& baseObject = CWE134_Uncontrolled_Format_String__char_console_snprintf_81_bad(); baseObject.action(data); }"	where is the vulnerable dataflow from data to action ?	"char <start> dataBuffer[100] = """" <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
baseObject.action <start> data <end> );"	"baseObject.action <start> data <end> );
char <start> dataBuffer[100] = """" <end> ;"	"baseObject.action <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	1
893217d5-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_console_fopen_66 { void badSink(char * dataArray[]) { char * data = dataArray[2]; { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"void badSink(char * <start> dataArray <end> []);
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
void badSink(char * <start> dataArray <end> []);"	"void badSink(char * <start> dataArray <end> []);
pFile = FOPEN <start> data <end> , ""wb+"");"	3
78800f92-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 8 static short CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_45_badData; static short CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_45_goodG2BData; static void badSink() { short data = CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_45_badData; { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } } void CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_45_bad() { short data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_45_badData = data; badSink(); }"	where is the vulnerable dataflow from dest to printLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_45_badData = data <end> ;
static short <start> CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_45_badData <end> ;
short data = <start> CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_45_badData <end> ;
printLine <start> dest <end> );"	"printLine <start> dest <end> );
<start> CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_45_badData = data <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
short data = <start> CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_45_badData <end> ;
static short <start> CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_45_badData <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_45_badData = data <end> ;
static short <start> CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_45_badData <end> ;
short data = <start> CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_45_badData <end> ;
<start> memcpy(dest, source, data) <end> ;"	"short data = <start> CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_45_badData <end> ;
static short <start> CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_45_badData <end> ;
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
<start> CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_45_badData = data <end> ;
printLine <start> dest <end> );"	0
964cdc30-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_11_bad() { int data; data = -1; if(globalReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalReturnsTrue()) { { int i; int buffer[10] = { 0 }; if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } } } }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[i] <end> );"	"data = <start> atoi(inputBuffer) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"printIntLine <start> buffer[i] <end> );
data = <start> atoi(inputBuffer) <end> ;"	"int <start> buffer[10] = { 0 } <end> ;
printIntLine <start> buffer[i] <end> );"	0
61da6726-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__short_rand_add_74 { void badSink(map<int, short> dataMap) { short data = dataMap[2]; { short result = data + 1; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"void badSink(map<int, short> <start> dataMap <end> );
short result = <start> data <end>  + 1;"	"short <start> result = data + 1 <end> ;
void badSink(map<int, short> <start> dataMap <end> );"	"void badSink(map<int, short> <start> dataMap <end> );
short result = <start> data + 1 <end> ;"	"short result = <start> data <end>  + 1;
void badSink(map<int, short> <start> dataMap <end> );"	0
7e74f361-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) extern int CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_68_badData; extern int CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_68_goodG2BData; void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_68b_badSink() { int data = CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_68_badData; { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> memmove(dest, source, data) <end> ;
int data = <start> CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_68_badData <end> ;"	"printLine <start> dest <end> );
int data = <start> CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_68_badData <end> ;"	"int data = <start> CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_68_badData <end> ;
printLine <start> dest <end> );"	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	2
8b91e460-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_listen_socket_fopen_67 { typedef struct _structType { char * structFirst; } structType; void badSink(structType myStruct) { char * data = myStruct.structFirst; { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"char * data = <start> myStruct <end> .structFirst;
pFile = <start> FOPEN(data, ""wb+"") <end> ;
void badSink(structType <start> myStruct <end> );"	"void badSink(structType <start> myStruct <end> );
char * data = <start> myStruct <end> .structFirst;
pFile = FOPEN <start> data <end> , ""wb+"");"	"char * data = <start> myStruct <end> .structFirst;
pFile = FOPEN <start> data <end> , ""wb+"");
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	"char * data = <start> myStruct <end> .structFirst;
void badSink(structType <start> myStruct <end> );
pFile = FOPEN <start> data <end> , ""wb+"");"	1
8b91e49b-6c15-11ed-81d4-94e6f77dd552	"void CWE390_Error_Without_Action__fgets_char_13_bad() { if(GLOBAL_CONST_FIVE==5) { { char dataBuffer[100] = """"; char * data = dataBuffer; printLine(""Please enter a string: ""); if (fgets(data, 100, stdin) == NULL) { } printLine(data); } } }"	where is the vulnerable dataflow from data to printLine ?	"printLine <start> data <end> );
<start> printLine(data) <end> ;"	"<start> printLine(data) <end> ;
if (fgets <start> data <end> , 100, stdin) == NULL);"	"printLine <start> data <end> );
if (fgets <start> data <end> , 100, stdin) == NULL);"	"if (fgets <start> data <end> , 100, stdin) == NULL);
printLine <start> data <end> );"	3
7ae3a74f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_63b_badSink(int * dataPtr) { int data = *dataPtr; { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"int <start> data = *dataPtr <end> ;
printLine <start> dest <end> );"	"void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_63b_badSink(int * <start> dataPtr <end> );
printLine <start> dest <end> );"	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	"<start> strncpy(dest, source, data) <end> ;
printLine <start> dest <end> );"	1
8a6310b4-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; namespace CWE36_Absolute_Path_Traversal__char_file_open_04 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(STATIC_CONST_TRUE) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"size_t dataLen = <start> strlen(data) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
size_t dataLen = <start> strlen(data) <end> ;"	0
7ae3a741-6c15-11ed-81d4-94e6f77dd552	"int CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_22_badGlobal = 0; int CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_22_badSource(int data); void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_22_bad() { int data; data = -1; CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_22_badGlobal = 1; data = CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_22_badSource(data); { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> printLine(dest) <end> ;
data = <start> CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_22_badSource <end> (data);"	"printLine <start> dest <end> );
<start> printLine(dest) <end> ;"	"<start> strncpy(dest, source, data) <end> ;
data = <start> CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_22_badSource <end> (data);"	"data = <start> CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_22_badSource <end> (data);
printLine <start> dest <end> );"	3
c99197ca-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define STAT _stat #define OPEN _open #define WRITE _write #define O_RDWR _O_RDWR #define CLOSE _close #else #define STAT stat #define OPEN open #define WRITE write #define CLOSE close #endif #define BAD_SINK_STRING ""Bad Sink..."" #define GOOD_SINK_STRING ""Good Sink..."" static int staticFive = 5; void CWE367_TOC_TOU__stat_07_bad() { if(staticFive==5) { { char filename[100] = """"; struct STAT statBuffer; int fileDesc = -1; if (fgets(filename, 100, stdin) == NULL) { printLine(""fgets() failed""); filename[0] = '\0'; } if (strlen(filename) > 0) { filename[strlen(filename)-1] = '\0'; } if (STAT(filename, &statBuffer) == -1) { exit(1); } fileDesc  = OPEN(filename, O_RDWR); if (fileDesc == -1) { exit(1); } if (WRITE(fileDesc, BAD_SINK_STRING, strlen(BAD_SINK_STRING)) == -1) { exit(1); } if (fileDesc != -1) { CLOSE(fileDesc); } } } }"	where is the vulnerable dataflow from filename to OPEN ?	"fileDesc  = OPEN <start> filename <end> , O_RDWR);
filename <start> strlen(filename) <end> -1] = '\0'; ;"	"fileDesc  = <start> OPEN(filename, O_RDWR) <end> ;
fileDesc  = OPEN <start> filename <end> , O_RDWR);"	"fileDesc  = OPEN <start> filename <end> , O_RDWR);
if  <start> strlen(filename) <end>  > 0);"	"if (fgets <start> filename <end> , 100, stdin) == NULL);
fileDesc  = OPEN <start> filename <end> , O_RDWR);"	3
9c4551b0-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink(int data) { { int buffer[10] = { 0 }; if (data >= 0) { printIntLine(buffer[data]); } else { printLine(""ERROR: Array index is negative""); } } } void CWE126_Buffer_Overread__CWE129_connect_socket_44_bad() { int data; void (*funcPtr) (int) = badSink; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } funcPtr(data); }"	where is the vulnerable dataflow from buffer[data] to printIntLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
funcPtr <start> data <end> );
static void badSink(int <start> data <end> );
printIntLine <start> buffer[data] <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[data] <end> );
funcPtr <start> data <end> );
int <start> buffer[10] = { 0 } <end> ;"	"funcPtr <start> data <end> );
printIntLine <start> buffer[data] <end> );
static void badSink(int <start> data <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"printIntLine <start> buffer[data] <end> );
funcPtr <start> data <end> );
static void badSink(int <start> data <end> );"	0
67d010b1-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__short_rand_postinc_14_bad() { short data; data = 0; if(globalFive==5) { data = (short)RAND32(); } if(globalFive==5) { { data++; short result = data; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"<start> data <end> ++;
<start> printIntLine(result) <end> ;"	"<start> data = (short)RAND32() <end> ;
data = (short <start> RAND32() <end> ;"	"data = (short <start> RAND32() <end> ;
<start> data <end> ++;"	"<start> printIntLine(result) <end> ;
data = (short <start> RAND32() <end> ;"	2
bb49c59b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #define EXECLP _execlp #else #define EXECLP execlp #endif static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; void CWE78_OS_Command_Injection__char_console_execlp_04_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(STATIC_CONST_TRUE) { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECLP ?	"EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
if  <start> fgets(data+dataLen, (int)(100-dataLen), stdin) <end>  != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
dataLen = <start> strlen(data) <end> ;"	2
9187cc02-6c15-11ed-81d4-94e6f77dd552	"#define SEARCH_CHAR 'S' static int badStatic = 0; static void badSink(char * data) { if(badStatic) { for (; *data != '\0'; data++) { if (*data == SEARCH_CHAR) { printLine(""We have a match!""); break; } } free(data); } } void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_console_21_bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\0'; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } badStatic = 1; badSink(data); }"	where is the vulnerable dataflow from data to free ?	"dataLen = <start> strlen(data) <end> ;
badSink <start> data <end> );
static void badSink(char * <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	"size_t dataLen = <start> strlen(data) <end> ;
badSink <start> data <end> );
free <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	"if  <start> data == NULL <end> ) {exit(-1);};
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
badSink <start> data <end> );
free <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
badSink <start> data <end> );
static void badSink(char * <start> data <end> );
free <start> data <end> );"	3
48d25d94-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__int_fscanf_square_65b_badSink(int data) { { int result = data * data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  * data;"	"void CWE190_Integer_Overflow__int_fscanf_square_65b_badSink(int <start> data <end> );
int result = <start> data <end>  * data;"	"void CWE190_Integer_Overflow__int_fscanf_square_65b_badSink(int <start> data <end> );
<start> printIntLine(result) <end> ;"	"int result = <start> data * data <end> ;
void CWE190_Integer_Overflow__int_fscanf_square_65b_badSink(int <start> data <end> );"	1
a23a3e09-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__int_fgets_add_62 { void badSource(int &data); void bad() { int data; data = 0; badSource(data); { int result = data + 1; printIntLine(result); } }	where is the vulnerable dataflow from result to printIntLine ?	"<start> badSource(data) <end> ;
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
badSource <start> data <end> );"	"badSource <start> data <end> );
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
int result = <start> data + 1 <end> ;"	2
98b0153c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_45_badData; static int CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_45_goodG2BData; static int CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_45_goodB2GData; static void badSink() { int data = CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_45_badData; { int i; int buffer[10] = { 0 }; if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } } } void CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_45_bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_45_badData = data; badSink(); }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"<start> printIntLine(buffer[i]) <end> ;
printIntLine <start> buffer[i] <end> );
static int <start> CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_45_badData <end> ;
int data = <start> CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_45_badData <end> ;
<start> CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_45_badData = data <end> ;"	"<start> CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_45_badData = data <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"printIntLine <start> buffer[i] <end> );
int data = <start> CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_45_badData <end> ;
data = <start> atoi(inputBuffer) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_45_badData = data <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_45_badData = data <end> ;
static int <start> CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_45_badData <end> ;
int data = <start> CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_45_badData <end> ;
printIntLine <start> buffer[i] <end> );"	3
a5ce1c79-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_postinc_09_bad() { int data; data = 0; if(GLOBAL_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(GLOBAL_CONST_TRUE) { { data++; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"if  <start> recvResult == SOCKET_ERROR <end>  || recvResult == 0);
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
int <start> result = data <end> ;"	"printIntLine <start> result <end> );
<start> data++ <end> ;"	0
cd228176-6c15-11ed-81d4-94e6f77dd552	#ifndef _WIN32 #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_console_open_67 { typedef struct _structType { char * structFirst; } structType; void badSink(structType myStruct) { char * data = myStruct.structFirst; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }	where is the vulnerable dataflow from data to OPEN ?	"char * data = <start> myStruct <end> .structFirst;
void badSink(structType <start> myStruct <end> );"	"void badSink(structType <start> myStruct <end> );
char * data = <start> myStruct <end> .structFirst;
fileDesc = OPEN(data, O_RDWR|O_CREAT, <start> S_IREAD|S_IWRITE <end> );"	"void badSink(structType <start> myStruct <end> );
char * data = <start> myStruct <end> .structFirst;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"char * data = <start> myStruct <end> .structFirst;
void badSink(structType <start> myStruct <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	2
c4cd6f58-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_environment_open_74 { void badSink(map<int, char *> dataMap) { char * data = dataMap[2]; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"void badSink(map<int, char *> <start> dataMap <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"char <start> * data = dataMap[2] <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"void badSink(map<int, char *> <start> dataMap <end> );
fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);"	0
c72d5d30-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_file_open_22 { int badGlobal = 0; char * badSource(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; badGlobal = 1; data = badSource(data); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } ; }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
data = <start> badSource <end> (data);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
<start> data = badSource(data) <end> ;"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"data = <start> badSource <end> (data);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	3
715a3bbb-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif static void badVaSinkB(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_file_vprintf_14_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; if(globalFive==5) { { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } if(globalFive==5) { badVaSinkB(data, data); } }"	where is the vulnerable dataflow from data to vprintf ?	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
<start> data = dataBuffer <end> ;
static void badVaSinkB(char * <start> data <end> , ...);
badVaSinkB <start> data <end> , data);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);
vprintf <start> data <end> , args);"	"badVaSinkB <start> data <end> , data);
char <start> dataBuffer[100] = """" <end> ;
static void badVaSinkB(char * <start> data <end> , ...);
vprintf <start> data <end> , args);"	"vprintf <start> data <end> , args);
static void badVaSinkB(char * <start> data <end> , ...);
size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	1
c99197f7-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_connect_socket_fopen_63 { void badSink(char * * dataPtr) { char * data = *dataPtr; { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"void badSink(char * * <start> dataPtr <end> );
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	"pFile = FOPEN <start> data <end> , ""wb+"");
void badSink(char * * <start> dataPtr <end> );"	"pFile = FOPEN <start> data <end> , ""wb+"");
char <start> * data = *dataPtr <end> ;"	0
598370ca-6c15-11ed-81d4-94e6f77dd552	"typedef union { short unionFirst; short unionSecond; } CWE191_Integer_Underflow__short_fscanf_sub_34_unionType; void CWE191_Integer_Underflow__short_fscanf_sub_34_bad() { short data; CWE191_Integer_Underflow__short_fscanf_sub_34_unionType myUnion; data = 0; fscanf (stdin, ""%hd"", &data); myUnion.unionFirst = data; { short data = myUnion.unionSecond; { short result = data - 1; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"fscanf (stdin, ""%hd"", <start> &data <end> );
short result = <start> data - 1 <end> ;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
short result = <start> data <end>  - 1;"	"short result = <start> data <end>  - 1;
fscanf (stdin, ""%hd"", <start> &data <end> );"	"short result = <start> data <end>  - 1;
<start> printIntLine(result) <end> ;"	1
c26a7e69-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_environment_fopen_09 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(GLOBAL_CONST_TRUE) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"size_t <start> dataLen = strlen(data) <end> ;
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"<start> strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1) <end> ;
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	2
ce547d6c-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif namespace CWE36_Absolute_Path_Traversal__char_environment_ofstream_42 { static char * badSource(char * data) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } return data; } void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; data = badSource(data); { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"data = <start> badSource <end> (data);
outputFile.open((char * <start> data <end> );
size_t <start> dataLen = strlen(data) <end> ;
static char * <start> badSource <end> (char * data);"	"outputFile.open((char * <start> data <end> );
data = <start> badSource <end> (data);"	"outputFile.open((char * <start> data <end> );
data = <start> badSource <end> (data);
static char * <start> badSource <end> (char * data);"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
outputFile.open((char * <start> data <end> );"	3
4b34affe-6c15-11ed-81d4-94e6f77dd552	"void CWE190_Integer_Overflow__short_fscanf_square_12_bad() { short data; data = 0; if(globalReturnsTrueOrFalse()) { fscanf (stdin, ""%hd"", &data); } else { data = 2; } if(globalReturnsTrueOrFalse()) { { short result = data * data; printIntLine(result); } } else { if (abs((long)data) <= (long)sqrt((double)SHRT_MAX)) { short result = data * data; printIntLine(result); } else { printLine(""data value is too large to perform arithmetic safely.""); } } }"	where is the vulnerable dataflow from data ?	"fscanf (stdin, ""%hd"", <start> &data <end> );
<start> printIntLine(result) <end> ;"	"short result = <start> data <end>  * data;
<start> printIntLine(result) <end> ;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
short result = <start> data <end>  * data;"	"short result = <start> data <end>  * data;
<start> data = 0 <end> ;"	2
7c127584-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_FIVE = 5; void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_06_bad() { int data; data = -1; if(STATIC_CONST_FIVE==5) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> data = -1 <end> ;"	"data = <start> atoi(inputBuffer) <end> ;
printLine <start> dest <end> );"	"<start> data = -1 <end> ;
printLine <start> dest <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printLine <start> dest <end> );"	3
c01af8ae-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" namespace CWE23_Relative_Path_Traversal__char_connect_socket_ofstream_13 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(GLOBAL_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - <start> dataLen - 1 <end> ), 0);"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
outputFile.open((char * <start> data <end> );"	"size_t dataLen = <start> strlen(data) <end> ;
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	2
6dc614ef-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" namespace CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_43 { static void badVaSink(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); va_end(args); } } static void badSource(char * &data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } void bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; badSource(data); badVaSink(data, data); }"	where is the vulnerable dataflow from data to vprintf ?	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
static void badVaSink(char * <start> data <end> , ...);
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (100 - dataLen - 1), 0);
badSource <start> data <end> );
vprintf <start> data <end> , args);"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
badSource <start> data <end> );
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
vprintf <start> data <end> , args);"	"badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
badSource <start> data <end> );
vprintf <start> data <end> , args);"	"badVaSink <start> data <end> , data);
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
badSource <start> data <end> );"	1
c99197fa-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_connect_socket_fopen_67 { typedef struct _structType { char * structFirst; } structType; void badSink(structType myStruct) { char * data = myStruct.structFirst; { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
void badSink(structType <start> myStruct <end> );
char * data = <start> myStruct <end> .structFirst;"	"pFile = FOPEN <start> data <end> , ""wb+"");
char * data = <start> myStruct <end> .structFirst;
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	"void badSink(structType <start> myStruct <end> );
pFile = FOPEN <start> data <end> , ""wb+"");"	"void badSink(structType <start> myStruct <end> );
char * data = <start> myStruct <end> .structFirst;
pFile = FOPEN <start> data <end> , ""wb+"");"	3
bc721f7d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define EXECL _execl #else #define EXECL execl #endif static int badStatic = 0; static char * badSource(char * data) { if(badStatic) { { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } return data; } void CWE78_OS_Command_Injection__char_file_execl_21_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; badStatic = 1; data = badSource(data); EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECL ?	"size_t dataLen = <start> strlen(data) <end> ;
static char * <start> badSource <end> (char * data);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"data = <start> badSource <end> (data);
static char * <start> badSource <end> (char * data);
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
<start> EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL) <end> ;
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);"	1
c72d5d68-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_listen_socket_fopen_62 { void badSource(char * &data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; badSource(data); { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = FOPEN <start> data <end> , ""wb+"");
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	"<start> data = dataBuffer <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
badSource <start> data <end> );"	"badSource <start> data <end> );
pFile = FOPEN <start> data <end> , ""wb+"");"	3
c72d5d72-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 namespace CWE23_Relative_Path_Traversal__char_listen_socket_ifstream_03 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(5==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
size_t <start> dataLen = strlen(data) <end> ;"	"size_t dataLen = <start> strlen(data) <end> ;
inputFile.open((char * <start> data <end> );"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
inputFile.open((char * <start> data <end> );"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	2
b54bcf42-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 20 void CWE369_Divide_by_Zero__float_listenSocket_65b_badSink(float data) { { int result = (int)(100.0 / data); printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
void CWE369_Divide_by_Zero__float_listenSocket_65b_badSink(float <start> data <end> );"	"<start> printIntLine(result) <end> ;
void CWE369_Divide_by_Zero__float_listenSocket_65b_badSink(float <start> data <end> );"	"void CWE369_Divide_by_Zero__float_listenSocket_65b_badSink(float <start> data <end> );
printIntLine <start> result <end> );"	3
79b27554-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_16_bad() { int data; data = -1; while(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"printLine <start> dest <end> );
recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);"	"<start> memcpy(dest, source, data) <end> ;
printLine <start> dest <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"data = <start> atoi(inputBuffer) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	2
820a46c5-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_file_fopen_43 { void badSource(char * &data) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; badSource(data); { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"char <start> dataBuffer[FILENAME_MAX] = BASEPATH <end> ;
badSource <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"badSource <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
pFile = FOPEN <start> data <end> , ""wb+"");"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
badSource <start> data <end> );
pFile = FOPEN <start> data <end> , ""wb+"");"	"size_t dataLen = <start> strlen(data) <end> ;
badSource <start> data <end> );
pFile = FOPEN <start> data <end> , ""wb+"");"	2
5f76fcab-6c15-11ed-81d4-94e6f77dd552	"void CWE191_Integer_Underflow__short_fscanf_predec_17_bad() { int i,j; short data; data = 0; for(i = 0; i < 1; i++) { fscanf (stdin, ""%hd"", &data); } for(j = 0; j < 1; j++) { { --data; short result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"fscanf (stdin, ""%hd"", <start> &data <end> );
- <start> data <end> ;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
<start> printIntLine(result) <end> ;"	"- <start> data <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );"	"<start> printIntLine(result) <end> ;
- <start> data <end> ;"	0
c72d5d4b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; namespace CWE23_Relative_Path_Traversal__char_listen_socket_fopen_04 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(STATIC_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"size_t <start> dataLen = strlen(data) <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
replace = <start> strchr(data, '\n') <end> ;"	"pFile = FOPEN <start> data <end> , ""wb+"");
recvResult = recv(acceptSocket, (char *)(data + dataLen), <start> sizeof(char) * (FILENAME_MAX - dataLen - 1) <end> , 0);"	1
bed4a8d8-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif extern char * CWE23_Relative_Path_Traversal__char_connect_socket_fopen_68_badData; extern char * CWE23_Relative_Path_Traversal__char_connect_socket_fopen_68_goodG2BData; namespace CWE23_Relative_Path_Traversal__char_connect_socket_fopen_68 { void badSink() { char * data = CWE23_Relative_Path_Traversal__char_connect_socket_fopen_68_badData; { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = FOPEN <start> data <end> , ""wb+"");
char <start> * data = CWE23_Relative_Path_Traversal__char_connect_socket_fopen_68_badData <end> ;"	"char * data = <start> CWE23_Relative_Path_Traversal__char_connect_socket_fopen_68_badData <end> ;
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	"pFile = FOPEN <start> data <end> , ""wb+"");
char * data = <start> CWE23_Relative_Path_Traversal__char_connect_socket_fopen_68_badData <end> ;"	"char * data = <start> CWE23_Relative_Path_Traversal__char_connect_socket_fopen_68_badData <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	3
598370bf-6c15-11ed-81d4-94e6f77dd552	"void CWE191_Integer_Underflow__short_fscanf_sub_10_bad() { short data; data = 0; if(globalTrue) { fscanf (stdin, ""%hd"", &data); } if(globalTrue) { { short result = data - 1; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"fscanf (stdin, ""%hd"", <start> &data <end> );
short result = <start> data <end>  - 1;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
<start> printIntLine(result) <end> ;"	"<start> printIntLine(result) <end> ;
short result = <start> data <end>  - 1;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
<start> data = 0 <end> ;"	0
833ac927-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_listen_socket_fopen_66 { void badSink(char * dataArray[]) { char * data = dataArray[2]; { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"void badSink(char * <start> dataArray <end> []);
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
void badSink(char * <start> dataArray <end> []);"	"pFile = FOPEN <start> data <end> , ""wb+"");
char <start> * data = dataArray[2] <end> ;"	"pFile = FOPEN <start> data <end> , ""wb+"");
void badSink(char * <start> dataArray <end> []);"	0
445c11fc-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink(int data) { { int result = data + 1; printIntLine(result); } } void CWE190_Integer_Overflow__int_connect_socket_add_41_bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badSink(data); }"	where is the vulnerable dataflow from data ?	"static void badSink(int <start> data <end> );
int result = <start> data <end>  + 1;
<start> badSink(data) <end> ;
badSink <start> data <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSink <start> data <end> );
static void badSink(int <start> data <end> );
int result = <start> data <end>  + 1;"	"int result = <start> data <end>  + 1;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static void badSink(int <start> data <end> );
badSink <start> data <end> );"	"int result = <start> data <end>  + 1;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	1
b2ea8db3-6c15-11ed-81d4-94e6f77dd552	namespace CWE197_Numeric_Truncation_Error__short_connect_socket_82 { void CWE197_Numeric_Truncation_Error__short_connect_socket_82_bad::action(short data) { { char charData = (char)data; printHexCharLine(charData); } } }	where is the vulnerable dataflow from charData to printHexCharLine ?	"printHexCharLine <start> charData <end> );
char <start> charData = (char)data <end> ;"	"printHexCharLine <start> charData <end> );
void CWE197_Numeric_Truncation_Error__short_connect_socket_82_bad::action(short <start> data <end> );"	"printHexCharLine <start> charData <end> );
<start> printHexCharLine(charData) <end> ;"	"void CWE197_Numeric_Truncation_Error__short_connect_socket_82_bad::action(short <start> data <end> );
printHexCharLine <start> charData <end> );"	3
bc721f82-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define EXECL _execl #else #define EXECL execl #endif namespace CWE78_OS_Command_Injection__char_file_execl_43 { static void badSource(char * &data) { { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } void bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; badSource(data); EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECL ?	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
badSource <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
badSource <start> data <end> );
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
badSource <start> data <end> );"	"<start> EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
badSource <start> data <end> );"	1
7ae3a743-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) typedef union { int unionFirst; int unionSecond; } CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_34_unionType; void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_34_bad() { int data; CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_34_unionType myUnion; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } myUnion.unionFirst = data; { int data = myUnion.unionSecond; { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } } }"	where is the vulnerable dataflow from dest to printLine ?	"printLine <start> dest <end> );
if  <start> data < 100 <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"data = <start> atoi(inputBuffer) <end> ;
printLine <start> dest <end> );"	"printLine <start> dest <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	1
78800fd9-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 8 void CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_10_bad() { short data; data = 0; if(globalTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
tempInt = <start> atoi(inputBuffer) <end> ;"	"printLine <start> dest <end> );
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"<start> strncpy(dest, source, data) <end> ;
printLine <start> dest <end> );"	0
bed4a8b4-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_connect_socket_fopen_02 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	"replace = <start> strchr(data, '\n') <end> ;
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"<start> data = dataBuffer <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	1
820a46a1-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_console_open_62 { void badSource(char * &data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; badSource(data); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"<start> badSource(data) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"badSource <start> data <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	3
b684850b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define NEW_PATH ""%SystemRoot%\\system32"" #define PUTENV _putenv #else #define NEW_PATH ""/bin"" #define PUTENV putenv #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" void CWE427_Uncontrolled_Search_Path_Element__char_connect_socket_31_bad() { char * data; char dataBuffer[250] = ""PATH=""; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (250 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { char * dataCopy = data; char * data = dataCopy; PUTENV(data); } }"	where is the vulnerable dataflow from data to PUTENV ?	"PUTENV <start> data <end> );
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (250 - dataLen - 1), 0);"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (250 - dataLen - 1), 0);
char <start> * dataCopy = data <end> ;"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (250 - dataLen - 1), 0);
char <start> dataBuffer[250] = ""PATH="" <end> ;"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (250 - dataLen - 1), 0);
PUTENV <start> data <end> );"	3
92bb8a2f-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING ""hello"" static void badSink(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); } else { printLine(""Input is less than the length of the source string""); } } } void CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_44_bad() { size_t data; void (*funcPtr) (size_t) = badSink; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = strtoul(inputBuffer, NULL, 0); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } funcPtr(data); }"	where is the vulnerable dataflow from data to malloc ?	"<start> printLine(myString) <end> ;
myString = (char *)malloc <start> data*sizeof(char) <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
funcPtr <start> data <end> );"	"myString = (char *)malloc <start> data*sizeof(char) <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
funcPtr <start> data <end> );
data = <start> strtoul(inputBuffer, NULL, 0) <end> ;"	"funcPtr <start> data <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
if  <start> data > strlen(HELLO_STRING) <end> );
myString = (char *)malloc <start> data*sizeof(char) <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
funcPtr <start> data <end> );
static void badSink(size_t <start> data <end> );
myString = (char *)malloc <start> data*sizeof(char) <end> );"	3
c72d5d5e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_listen_socket_fopen_41 { void badSink(char * data) { { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } } void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badSink(data); }"	where is the vulnerable dataflow from data to badSink ?	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
badSink <start> data <end> );"	"char <start> dataBuffer[FILENAME_MAX] = BASEPATH <end> ;
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
badSink <start> data <end> );"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
badSink <start> data <end> );"	3
6c938c02-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif void CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_31_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { char * dataCopy = data; char * data = dataCopy; { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } } }"	where is the vulnerable dataflow from dest to printLine ?	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
printLine <start> dest <end> );"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
<start> data = dataBuffer <end> ;"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (100 - dataLen - 1), 0);
printLine <start> dest <end> );"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
char <start> * dataCopy = data <end> ;"	0
55ef4c91-6c15-11ed-81d4-94e6f77dd552	namespace CWE191_Integer_Underflow__int_connect_socket_sub_73 { void badSink(list<int> dataList) { int data = dataList.back(); { int result = data - 1; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  - 1;
void badSink(list<int> <start> dataList <end> );"	"void badSink(list<int> <start> dataList <end> );
int result = <start> data <end>  - 1;"	"void badSink(list<int> <start> dataList <end> );
<start> printIntLine(result) <end> ;"	"void badSink(list<int> <start> dataList <end> );
int <start> data = dataList.back() <end> ;"	1
cac216b4-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" namespace CWE36_Absolute_Path_Traversal__char_connect_socket_ofstream_09 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(GLOBAL_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
outputFile.open((char * <start> data <end> );"	"recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - <start> dataLen - 1 <end> ), 0);
outputFile.open((char * <start> data <end> );"	"replace = <start> strchr(data, '\n') <end> ;
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"char <start> dataBuffer[FILENAME_MAX] = """" <end> ;
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	0
964cdc0e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FULL_COMMAND ""dir "" #else #define FULL_COMMAND ""ls "" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define POPEN _popen #define PCLOSE _pclose #else #define POPEN popen #define PCLOSE pclose #endif void CWE78_OS_Command_Injection__char_listen_socket_popen_13_bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; if(GLOBAL_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { FILE *pipe; pipe = POPEN(data, ""w""); if (pipe != NULL) { PCLOSE(pipe); } } }"	where is the vulnerable dataflow from data to POPEN ?	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
pipe = POPEN <start> data <end> , ""w"");"	"size_t <start> dataLen = strlen(data) <end> ;
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"pipe = POPEN <start> data <end> , ""w"");
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (100 - dataLen - 1), 0);
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	0
774f5808-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 8 void CWE194_Unexpected_Sign_Extension__listen_socket_malloc_03_bad() { short data; data = 0; if(5==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }"	where is the vulnerable dataflow from data to malloc ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
char * dataBuffer = (char *)malloc <start> data <end> );"	"<start> free(dataBuffer) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> memset(dataBuffer, 'A', data-1) <end> ;"	"char * dataBuffer = (char *)malloc <start> data <end> );
char * dataBuffer = (char * <start> malloc(data) <end> ;"	0
70279c1d-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif static void badVaSinkB(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_file_vfprintf_02_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; if(1) { { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } if(1) { badVaSinkB(data, data); } }"	where is the vulnerable dataflow from data to vfprintf ?	"size_t dataLen = <start> strlen(data) <end> ;
vfprintf(stdout, <start> data <end> , args);
static void badVaSinkB(char * <start> data <end> , ...);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);"	"size_t dataLen = <start> strlen(data) <end> ;
badVaSinkB <start> data <end> , data);
vfprintf(stdout, <start> data <end> , args);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	"vfprintf(stdout, <start> data <end> , args);
static void badVaSinkB(char * <start> data <end> , ...);
char <start> dataBuffer[100] = """" <end> ;
badVaSinkB <start> data <end> , data);"	1
af580932-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_53d_badSink(int data) { { char charData = (char)data; printHexCharLine(charData); } }"	where is the vulnerable dataflow from charData to printHexCharLine ?	"void CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_53d_badSink(int <start> data <end> );
char <start> charData = (char)data <end> ;"	"printHexCharLine <start> charData <end> );
<start> printHexCharLine(charData) <end> ;"	"void CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_53d_badSink(int <start> data <end> );
printHexCharLine <start> charData <end> );"	"printHexCharLine <start> charData <end> );
char charData = <start> (char)data <end> ;"	2
466e7ef1-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) typedef struct _CWE190_Integer_Overflow__int_fgets_multiply_67_structType { int structFirst; } CWE190_Integer_Overflow__int_fgets_multiply_67_structType; void CWE190_Integer_Overflow__int_fgets_multiply_67b_badSink(CWE190_Integer_Overflow__int_fgets_multiply_67_structType myStruct) { int data = myStruct.structFirst; if(data > 0) { int result = data * 2; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"int <start> data = myStruct.structFirst <end> ;
void CWE190_Integer_Overflow__int_fgets_multiply_67b_badSink(CWE190_Integer_Overflow__int_fgets_multiply_67_structType <start> myStruct <end> );
int result = <start> data <end>  * 2;"	"int data = <start> myStruct <end> .structFirst;
int result = <start> data * 2 <end> ;
void CWE190_Integer_Overflow__int_fgets_multiply_67b_badSink(CWE190_Integer_Overflow__int_fgets_multiply_67_structType <start> myStruct <end> );"	"void CWE190_Integer_Overflow__int_fgets_multiply_67b_badSink(CWE190_Integer_Overflow__int_fgets_multiply_67_structType <start> myStruct <end> );
int data = <start> myStruct <end> .structFirst;
int result = <start> data <end>  * 2;"	"<start> printIntLine(result) <end> ;
int data = <start> myStruct <end> .structFirst;
int result = <start> data <end>  * 2;"	2
69161b39-6c15-11ed-81d4-94e6f77dd552	static int badStatic = 0; static void badSink(int data) { if(badStatic) { { ++data; int result = data; printIntLine(result); } } } void CWE190_Integer_Overflow__int_rand_preinc_21_bad() { int data; data = 0; data = RAND32(); badStatic = 1; badSink(data); }	where is the vulnerable dataflow from data ?	"static void badSink(int <start> data <end> );
+ <start> data <end> ;
data = <start> RAND32() <end> ;
<start> printIntLine(result) <end> ;"	"<start> badSink(data) <end> ;
static void badSink(int <start> data <end> );
+ <start> data <end> ;
data = <start> RAND32() <end> ;"	"data = <start> RAND32() <end> ;
badSink <start> data <end> );
static void badSink(int <start> data <end> );
+ <start> data <end> ;"	"+ <start> data <end> ;
static void badSink(int <start> data <end> );
data = <start> RAND32() <end> ;
badSink <start> data <end> );"	2
c01af8a8-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" static int staticFive = 5; namespace CWE23_Relative_Path_Traversal__char_connect_socket_ofstream_07 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(staticFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"recvResult = recv(connectSocket, (char *)(data + dataLen), <start> sizeof(char) * (FILENAME_MAX - dataLen - 1) <end> , 0);
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"<start> data = dataBuffer <end> ;
outputFile.open((char * <start> data <end> );"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
size_t dataLen = <start> strlen(data) <end> ;"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
outputFile.open((char * <start> data <end> );"	3
cbf237ca-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif static int staticTrue = 1; static int staticFalse = 0; namespace CWE36_Absolute_Path_Traversal__char_console_ifstream_05 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(staticTrue) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"inputFile.open((char * <start> data <end> );
dataLen = <start> strlen(data) <end> ;"	"size_t dataLen = <start> strlen(data) <end> ;
inputFile.open((char * <start> data <end> );"	"<start> data = dataBuffer <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
inputFile.open((char * <start> data <end> );"	3
7fa68e55-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_connect_socket_open_17 { void bad() { int i; char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; for(i = 0; i < 1; i++) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to sizeof ?	size_t dataLen = <start> strlen(data) <end> ;	recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - <start> dataLen - 1 <end> ), 0);	recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);	fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;	2
a49c4f79-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE190_Integer_Overflow__int_listen_socket_square_43 { static void badSource(int &data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } void bad() { int data; data = 0; badSource(data); { int result = data * data; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
badSource <start> data <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;
badSource <start> data <end> );"	"printIntLine <start> result <end> );
badSource <start> data <end> );
<start> badSource(data) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSource <start> data <end> );
printIntLine <start> result <end> );"	3
61da66f5-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__char_rand_square_62 { void badSource(char &data); void bad() { char data; data = ' '; badSource(data); { char result = data * data; printHexCharLine(result); } }	where is the vulnerable dataflow from data ?	"<start> printHexCharLine(result) <end> ;
char result = <start> data <end>  * data;"	"<start> badSource(data) <end> ;
char result = <start> data <end>  * data;"	"badSource <start> data <end> );
char result = <start> data <end>  * data;"	"badSource <start> data <end> );
<start> printHexCharLine(result) <end> ;"	2
93ece318-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING ""hello"" void CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_63b_badSink(size_t * dataPtr) { size_t data = *dataPtr; { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); } else { printLine(""Input is less than the length of the source string""); } } }"	where is the vulnerable dataflow from data to malloc ?	"<start> strcpy(myString, HELLO_STRING) <end> ;
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_63b_badSink(size_t * <start> dataPtr <end> );"	"void CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_63b_badSink(size_t * <start> dataPtr <end> );
myString = (char *)malloc <start> data*sizeof(char) <end> );"	"myString = (char *)malloc <start> data*sizeof(char) <end> );
<start> free(myString) <end> ;"	"if  <start> myString == NULL <end> ) {exit(-1);};
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_63b_badSink(size_t * <start> dataPtr <end> );"	1
466e7ebb-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE190_Integer_Overflow__int_fgets_add_43 { static void badSource(int &data) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } void bad() { int data; data = 0; badSource(data); { int result = data + 1; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"badSource <start> data <end> );
int <start> result = data + 1 <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"badSource <start> data <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
badSource <start> data <end> );
int result = <start> data <end>  + 1;"	"<start> printIntLine(result) <end> ;
badSource <start> data <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	2
61da66ef-6c15-11ed-81d4-94e6f77dd552	static void badSink(char data) { { char result = data * data; printHexCharLine(result); } } void CWE190_Integer_Overflow__char_rand_square_44_bad() { char data; void (*funcPtr) (char) = badSink; data = ' '; data = (char)RAND32(); funcPtr(data); }	where is the vulnerable dataflow from data ?	"data = (char <start> RAND32() <end> ;
funcPtr <start> data <end> );
static void badSink(char <start> data <end> );
char result = <start> data <end>  * data;"	"char result = <start> data <end>  * data;
<start> printHexCharLine(result) <end> ;
funcPtr <start> data <end> );
data = (char <start> RAND32() <end> ;"	"char result = <start> data <end>  * data;
funcPtr <start> data <end> );
data = (char <start> RAND32() <end> ;"	"data = (char <start> RAND32() <end> ;
char result = <start> data <end>  * data;
funcPtr <start> data <end> );
static void badSink(char <start> data <end> );"	0
c99197c0-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define STAT _stat #define OPEN _open #define WRITE _write #define O_RDWR _O_RDWR #define CLOSE _close #else #define STAT stat #define OPEN open #define WRITE write #define CLOSE close #endif #define BAD_SINK_STRING ""Bad Sink..."" #define GOOD_SINK_STRING ""Good Sink..."" #ifdef _WIN32 #define ACCESS _access #define W_OK 02 #else #define ACCESS access #endif void CWE367_TOC_TOU__access_15_bad() { switch(6) { case 6: { char filename[100] = """"; int fileDesc = -1; if (fgets(filename, 100, stdin) == NULL) { printLine(""fgets() failed""); filename[0] = '\0'; } if (strlen(filename) > 0) { filename[strlen(filename)-1] = '\0'; } if (ACCESS(filename, W_OK) == -1) { exit(1); } fileDesc  = OPEN(filename, O_RDWR); if (fileDesc == -1) { exit(1); } if (WRITE(fileDesc, BAD_SINK_STRING, strlen(BAD_SINK_STRING)) == -1) { exit(1); } if (fileDesc != -1) { CLOSE(fileDesc); } } break; default: printLine(""Benign, fixed string""); break; } }"	where is the vulnerable dataflow from filename to OPEN ?	"if (fgets <start> filename <end> , 100, stdin) == NULL);
fileDesc  = OPEN <start> filename <end> , O_RDWR);"	"if (fgets <start> filename <end> , 100, stdin) == NULL);
if  <start> ACCESS(filename, W_OK) <end>  == -1);"	"filename <start> strlen(filename) <end> -1] = '\0'; ;
if (fgets <start> filename <end> , 100, stdin) == NULL);"	"fileDesc  = OPEN <start> filename <end> , O_RDWR);
if  <start> ACCESS(filename, W_OK) <end>  == -1);"	0
bc721f88-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define EXECLP _execlp #else #define EXECLP execlp #endif void CWE78_OS_Command_Injection__char_file_execlp_01_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECLP ?	"if  <start> 100-dataLen <end>  > 1);
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"if  <start> 100-dataLen <end>  > 1);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
<start> data = dataBuffer <end> ;"	2
c5fc234f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif static int staticFive = 5; namespace CWE23_Relative_Path_Traversal__char_file_ofstream_07 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(staticFive==5) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
outputFile.open((char * <start> data <end> );"	"outputFile.open((char * <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	"outputFile.open((char * <start> data <end> );
char <start> dataBuffer[FILENAME_MAX] = BASEPATH <end> ;"	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	0
ae26ae48-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) typedef struct _CWE191_Integer_Underflow__int_listen_socket_predec_67_structType { int structFirst; } CWE191_Integer_Underflow__int_listen_socket_predec_67_structType; void CWE191_Integer_Underflow__int_listen_socket_predec_67b_badSink(CWE191_Integer_Underflow__int_listen_socket_predec_67_structType myStruct) { int data = myStruct.structFirst; { --data; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
void CWE191_Integer_Underflow__int_listen_socket_predec_67b_badSink(CWE191_Integer_Underflow__int_listen_socket_predec_67_structType <start> myStruct <end> );
int <start> result = data <end> ;"	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );
void CWE191_Integer_Underflow__int_listen_socket_predec_67b_badSink(CWE191_Integer_Underflow__int_listen_socket_predec_67_structType <start> myStruct <end> );"	"void CWE191_Integer_Underflow__int_listen_socket_predec_67b_badSink(CWE191_Integer_Underflow__int_listen_socket_predec_67_structType <start> myStruct <end> );
printIntLine <start> result <end> );
int data = <start> myStruct <end> .structFirst;"	"void CWE191_Integer_Underflow__int_listen_socket_predec_67b_badSink(CWE191_Integer_Underflow__int_listen_socket_predec_67_structType <start> myStruct <end> );
int data = <start> myStruct <end> .structFirst;
printIntLine <start> result <end> );"	3
b1b80815-6c15-11ed-81d4-94e6f77dd552	namespace CWE197_Numeric_Truncation_Error__int_listen_socket_to_char_72 { void badSink(vector<int> dataVector) { int data = dataVector[2]; { char charData = (char)data; printHexCharLine(charData); } }	where is the vulnerable dataflow from charData to printHexCharLine ?	"void badSink(vector<int> <start> dataVector <end> );
printHexCharLine <start> charData <end> );"	"printHexCharLine <start> charData <end> );
<start> printHexCharLine(charData) <end> ;"	"void badSink(vector<int> <start> dataVector <end> );
char <start> charData = (char)data <end> ;"	"char <start> charData = (char)data <end> ;
printHexCharLine <start> charData <end> );"	0
7fa68e38-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_connect_socket_fopen_41 { void badSink(char * data) { { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } } void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badSink(data); }"	where is the vulnerable dataflow from data to FOPEN ?	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
void badSink(char * <start> data <end> );
pFile = FOPEN <start> data <end> , ""wb+"");
badSink <start> data <end> );"	"void badSink(char * <start> data <end> );
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
size_t dataLen = <start> strlen(data) <end> ;
badSink <start> data <end> );"	"void badSink(char * <start> data <end> );
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
replace = <start> strchr(data, '\r') <end> ;
badSink <start> data <end> );"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
badSink <start> data <end> );
void badSink(char * <start> data <end> );
pFile = FOPEN <start> data <end> , ""wb+"");"	3
74ee2403-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 8 void CWE194_Unexpected_Sign_Extension__fgets_malloc_16_bad() { short data; data = 0; while(1) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = (short)atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } break; } if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }"	where is the vulnerable dataflow from data to malloc ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
char * dataBuffer = (char * <start> malloc(data) <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
char * dataBuffer = (char *)malloc <start> data <end> );"	"char * dataBuffer = (char *)malloc <start> data <end> );
<start> free(dataBuffer) <end> ;"	"char * dataBuffer = (char *)malloc <start> data <end> );
char * dataBuffer = (char * <start> malloc(data) <end> ;"	1
833ac93d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_listen_socket_open_17 { void bad() { int i; char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; for(i = 0; i < 1; i++) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to sizeof ?	recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);	fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;	replace = <start> strchr(data, '\r') <end> ;	if  <start> recvResult == SOCKET_ERROR <end>  || recvResult == 0);	0
6b862459-6c15-11ed-81d4-94e6f77dd552	"extern int CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_22_badGlobal; void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_22_badSink(int data) { if(CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_22_badGlobal) { { int i; int * buffer = (int *)malloc(10 * sizeof(int)); if (buffer == NULL) {exit(-1);} for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } free(buffer); } } }"	where is the vulnerable dataflow from buffer to free ?	"<start> printIntLine(buffer[i]) <end> ;
free <start> buffer <end> );"	"free <start> buffer <end> );
void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_22_badSink(int <start> data <end> );"	"free <start> buffer <end> );
<start> free(buffer) <end> ;"	"void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_22_badSink(int <start> data <end> );
free <start> buffer <end> );"	3
5be3a9b5-6c15-11ed-81d4-94e6f77dd552	"void CWE191_Integer_Underflow__int_fscanf_postdec_15_bad() { int data; data = 0; switch(6) { case 6: fscanf(stdin, ""%d"", &data); break; default: printLine(""Benign, fixed string""); break; } switch(7) { case 7: { data--; int result = data; printIntLine(result); } break; default: printLine(""Benign, fixed string""); break; } }"	where is the vulnerable dataflow from data ?	"<start> data <end> --;
fscanf(stdin, ""%d"", <start> &data <end> );"	"fscanf(stdin, ""%d"", <start> &data <end> );
<start> data <end> --;"	"<start> data <end> --;
<start> printIntLine(result) <end> ;"	"<start> data-- <end> ;
fscanf(stdin, ""%d"", <start> &data <end> );"	1
d31a24fb-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 namespace CWE36_Absolute_Path_Traversal__char_listen_socket_ofstream_12 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(globalReturnsTrueOrFalse()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } else { #ifdef _WIN32 strcat(data, ""c:\\temp\\file.txt""); #else strcat(data, ""/tmp/file.txt""); #endif } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
outputFile.open((char * <start> data <end> );"	"outputFile.open((char * <start> data <end> );
<start> data = dataBuffer <end> ;"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
outputFile.open((char * <start> data <end> );"	"if  <start> recvResult == SOCKET_ERROR <end>  || recvResult == 0);
outputFile.open((char * <start> data <end> );"	0
a6fd8290-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_preinc_18_bad() { int data; data = 0; goto source; source: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } goto sink; sink: { ++data; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> result <end> );"	"<start> ++data <end> ;
printIntLine <start> result <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;"	2
a10948e1-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_multiply_14_bad() { int data; data = 0; if(globalFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalFive==5) { if(data > 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"int <start> result = data * 2 <end> ;
printIntLine <start> result <end> );"	1
5af03de9-6c15-11ed-81d4-94e6f77dd552	"static void badSink(int64_t data) { { data--; int64_t result = data; printLongLongLine(result); } } void CWE191_Integer_Underflow__int64_t_fscanf_postdec_41_bad() { int64_t data; data = 0LL; fscanf (stdin, ""%"" SCNd64, &data); badSink(data); }"	where is the vulnerable dataflow from data ?	"fscanf (stdin, ""%"" SCNd64, <start> &data <end> );
badSink <start> data <end> );
static void badSink(int64_t <start> data <end> );
<start> data <end> --;"	"fscanf (stdin, ""%"" SCNd64, <start> &data <end> );
<start> data <end> --;
badSink <start> data <end> );"	"fscanf (stdin, ""%"" SCNd64, <start> &data <end> );
<start> data <end> --;
<start> badSink(data) <end> ;
badSink <start> data <end> );"	"fscanf (stdin, ""%"" SCNd64, <start> &data <end> );
badSink <start> data <end> );
<start> data <end> --;
static void badSink(int64_t <start> data <end> );"	0
5f76fcbb-6c15-11ed-81d4-94e6f77dd552	void CWE191_Integer_Underflow__short_fscanf_predec_64b_badSink(void * dataVoidPtr) { short * dataPtr = (short *)dataVoidPtr; short data = (*dataPtr); { --data; short result = data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"void CWE191_Integer_Underflow__short_fscanf_predec_64b_badSink(void * <start> dataVoidPtr <end> );
<start> printIntLine(result) <end> ;"	"- <start> data <end> ;
void CWE191_Integer_Underflow__short_fscanf_predec_64b_badSink(void * <start> dataVoidPtr <end> );"	"void CWE191_Integer_Underflow__short_fscanf_predec_64b_badSink(void * <start> dataVoidPtr <end> );
short <start> result = data <end> ;"	"void CWE191_Integer_Underflow__short_fscanf_predec_64b_badSink(void * <start> dataVoidPtr <end> );
- <start> data <end> ;"	3
c01af8d4-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_connect_socket_open_22 { int badGlobal = 0; char * badSource(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; badGlobal = 1; data = badSource(data); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } ; }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"<start> data = dataBuffer <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"<start> data = badSource(data) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"data = <start> badSource <end> (data);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	3
c39a6598-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif namespace CWE23_Relative_Path_Traversal__char_environment_ifstream_31 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } { char * dataCopy = data; char * data = dataCopy; { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } } }"	where is the vulnerable dataflow from data to open ?	"inputFile.open((char * <start> data <end> );
char <start> dataBuffer[FILENAME_MAX] = BASEPATH <end> ;"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
size_t <start> dataLen = strlen(data) <end> ;"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
inputFile.open((char * <start> data <end> );"	"size_t dataLen = <start> strlen(data) <end> ;
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	2
7fa68e2c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_connect_socket_fopen_11 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(globalReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
<start> data = dataBuffer <end> ;"	"recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) *  <start> FILENAME_MAX - dataLen - 1 <end> ), 0);
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"pFile = FOPEN <start> data <end> , ""wb+"");
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) *  <start> FILENAME_MAX - dataLen - 1 <end> ), 0);"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	3
669edaae-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__int_rand_square_74 { void badSink(map<int, int> dataMap) { int data = dataMap[2]; { int result = data * data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"void badSink(map<int, int> <start> dataMap <end> );
int result = <start> data <end>  * data;"	"int result = <start> data <end>  * data;
void badSink(map<int, int> <start> dataMap <end> );"	"int <start> result = data * data <end> ;
void badSink(map<int, int> <start> dataMap <end> );"	"void badSink(map<int, int> <start> dataMap <end> );
int result = <start> data * data <end> ;"	0
7fa68e01-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_12_bad() { int data; data = -1; if(globalReturnsTrueOrFalse()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } else { data = 100-1; } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> data = atoi(inputBuffer) <end> ;
printLine <start> dest <end> );"	"<start> strncpy(dest, source, data) <end> ;
printLine <start> dest <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"printLine <start> dest <end> );
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	2
964cdc17-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FULL_COMMAND ""dir "" #else #define FULL_COMMAND ""ls "" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define POPEN _popen #define PCLOSE _pclose #else #define POPEN popen #define PCLOSE pclose #endif typedef union { char * unionFirst; char * unionSecond; } CWE78_OS_Command_Injection__char_listen_socket_popen_34_unionType; void CWE78_OS_Command_Injection__char_listen_socket_popen_34_bad() { char * data; CWE78_OS_Command_Injection__char_listen_socket_popen_34_unionType myUnion; char data_buf[100] = FULL_COMMAND; data = data_buf; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { FILE *pipe; pipe = POPEN(data, ""w""); if (pipe != NULL) { PCLOSE(pipe); } } } }"	where is the vulnerable dataflow from data to POPEN ?	"<start> data = data_buf <end> ;
pipe = POPEN <start> data <end> , ""w"");"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (100 - dataLen - 1), 0);"	"pipe = <start> POPEN(data, ""w"") <end> ;
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
pipe = POPEN <start> data <end> , ""w"");"	3
774f5815-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 8 void CWE194_Unexpected_Sign_Extension__listen_socket_malloc_16_bad() { short data; data = 0; while(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; } if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }"	where is the vulnerable dataflow from data to malloc ?	"if  <start> dataBuffer == NULL <end> ) {exit(-1);};
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
char * dataBuffer = (char *)malloc <start> data <end> );"	"<start> printLine(dataBuffer) <end> ;
char * dataBuffer = (char *)malloc <start> data <end> );"	"char * dataBuffer = (char * <start> malloc(data) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	1
47a2a7fd-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) extern int CWE190_Integer_Overflow__int_fgets_square_68_badData; extern int CWE190_Integer_Overflow__int_fgets_square_68_goodG2BData; extern int CWE190_Integer_Overflow__int_fgets_square_68_goodB2GData; void CWE190_Integer_Overflow__int_fgets_square_68b_badSink() { int data = CWE190_Integer_Overflow__int_fgets_square_68_badData; { int result = data * data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"int <start> result = data * data <end> ;
int data = <start> CWE190_Integer_Overflow__int_fgets_square_68_badData <end> ;"	"int data = <start> CWE190_Integer_Overflow__int_fgets_square_68_badData <end> ;
<start> printIntLine(result) <end> ;"	"int data = <start> CWE190_Integer_Overflow__int_fgets_square_68_badData <end> ;
int result = <start> data <end>  * data;"	"int result = <start> data <end>  * data;
int data = <start> CWE190_Integer_Overflow__int_fgets_square_68_badData <end> ;"	2
5be3a9bf-6c15-11ed-81d4-94e6f77dd552	"static void badSink(int data) { { data--; int result = data; printIntLine(result); } } void CWE191_Integer_Underflow__int_fscanf_postdec_44_bad() { int data; void (*funcPtr) (int) = badSink; data = 0; fscanf(stdin, ""%d"", &data); funcPtr(data); }"	where is the vulnerable dataflow from data ?	"<start> funcPtr(data) <end> ;
funcPtr <start> data <end> );
fscanf(stdin, ""%d"", <start> &data <end> );
<start> data <end> --;"	"<start> funcPtr(data) <end> ;
funcPtr <start> data <end> );
<start> data <end> --;
static void badSink(int <start> data <end> );"	"fscanf(stdin, ""%d"", <start> &data <end> );
funcPtr <start> data <end> );
static void badSink(int <start> data <end> );
<start> data <end> --;"	"fscanf(stdin, ""%d"", <start> &data <end> );
static void badSink(int <start> data <end> );
<start> data <end> --;
funcPtr <start> data <end> );"	2
48d25d87-6c15-11ed-81d4-94e6f77dd552	"typedef union { int unionFirst; int unionSecond; } CWE190_Integer_Overflow__int_fscanf_square_34_unionType; void CWE190_Integer_Overflow__int_fscanf_square_34_bad() { int data; CWE190_Integer_Overflow__int_fscanf_square_34_unionType myUnion; data = 0; fscanf(stdin, ""%d"", &data); myUnion.unionFirst = data; { int data = myUnion.unionSecond; { int result = data * data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  * data;
fscanf(stdin, ""%d"", <start> &data <end> );"	"fscanf(stdin, ""%d"", <start> &data <end> );
int <start> result = data * data <end> ;"	"<start> printIntLine(result) <end> ;
fscanf(stdin, ""%d"", <start> &data <end> );"	"fscanf(stdin, ""%d"", <start> &data <end> );
int result = <start> data <end>  * data;"	3
630ae820-6c15-11ed-81d4-94e6f77dd552	extern short CWE190_Integer_Overflow__short_rand_square_68_badData; extern short CWE190_Integer_Overflow__short_rand_square_68_goodG2BData; extern short CWE190_Integer_Overflow__short_rand_square_68_goodB2GData; void CWE190_Integer_Overflow__short_rand_square_68b_badSink() { short data = CWE190_Integer_Overflow__short_rand_square_68_badData; { short result = data * data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"short result = <start> data <end>  * data;
short data = <start> CWE190_Integer_Overflow__short_rand_square_68_badData <end> ;"	"short data = <start> CWE190_Integer_Overflow__short_rand_square_68_badData <end> ;
short result = <start> data <end>  * data;"	"short data = <start> CWE190_Integer_Overflow__short_rand_square_68_badData <end> ;
<start> printIntLine(result) <end> ;"	"<start> printIntLine(result) <end> ;
short result = <start> data <end>  * data;"	1
951c5e85-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FULL_COMMAND ""dir "" #else #define FULL_COMMAND ""ls "" #endif #ifdef _WIN32 #define POPEN _popen #define PCLOSE _pclose #else #define POPEN popen #define PCLOSE pclose #endif void CWE78_OS_Command_Injection__char_console_popen_03_bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; if(5==5) { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } { FILE *pipe; pipe = POPEN(data, ""w""); if (pipe != NULL) { PCLOSE(pipe); } } }"	where is the vulnerable dataflow from data to POPEN ?	"if (dataLen > 0 && <start> data[dataLen-1] == '\n' <end> );
pipe = POPEN <start> data <end> , ""w"");"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
pipe = POPEN <start> data <end> , ""w"");"	"pipe = <start> POPEN(data, ""w"") <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
size_t dataLen = <start> strlen(data) <end> ;"	1
ce547d51-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif namespace CWE36_Absolute_Path_Traversal__char_environment_ifstream_51 { void badSink(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } badSink(data); }"	where is the vulnerable dataflow from data to badSink ?	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
strncat(data+dataLen, environment, FILENAME_MAX <start> dataLen-1 <end> );"	"<start> badSink(data) <end> ;
badSink <start> data <end> );"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
badSink <start> data <end> );"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
size_t dataLen = <start> strlen(data) <end> ;"	2
5f76fca5-6c15-11ed-81d4-94e6f77dd552	"void CWE191_Integer_Underflow__short_fscanf_predec_10_bad() { short data; data = 0; if(globalTrue) { fscanf (stdin, ""%hd"", &data); } if(globalTrue) { { --data; short result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> --data <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );"	"fscanf (stdin, ""%hd"", <start> &data <end> );
- <start> data <end> ;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
short <start> result = data <end> ;"	"- <start> data <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );"	1
9187cc1a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #define SEARCH_CHAR 'S' static int staticFive = 5; void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_file_07_bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\0'; { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } if(staticFive==5) { for (; *data != '\0'; data++) { if (*data == SEARCH_CHAR) { printLine(""We have a match!""); break; } } free(data); } }"	where is the vulnerable dataflow from data to free ?	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
if  <start> data == NULL <end> ) {exit(-1);};"	"size_t dataLen = <start> strlen(data) <end> ;
free <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
free <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
size_t dataLen = <start> strlen(data) <end> ;"	2
61da671a-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__short_rand_add_51b_badSink(short data) { { short result = data + 1; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"void CWE190_Integer_Overflow__short_rand_add_51b_badSink(short <start> data <end> );
short <start> result = data + 1 <end> ;"	"<start> printIntLine(result) <end> ;
short result = <start> data <end>  + 1;"	"short result = <start> data <end>  + 1;
void CWE190_Integer_Overflow__short_rand_add_51b_badSink(short <start> data <end> );"	"void CWE190_Integer_Overflow__short_rand_add_51b_badSink(short <start> data <end> );
short result = <start> data <end>  + 1;"	3
7ae3a757-6c15-11ed-81d4-94e6f77dd552	"namespace CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_74 { void badSink(map<int, int> dataMap) { int data = dataMap[2]; { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"int <start> data = dataMap[2] <end> ;
void badSink(map<int, int> <start> dataMap <end> );"	"void badSink(map<int, int> <start> dataMap <end> );
if  <start> data < 100 <end> );"	"void badSink(map<int, int> <start> dataMap <end> );
char <start> dest[100] = """" <end> ;"	"void badSink(map<int, int> <start> dataMap <end> );
printLine <start> dest <end> );"	3
6b862466-6c15-11ed-81d4-94e6f77dd552	"namespace CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_62 { void badSource(int &data); void bad() { int data; data = -1; badSource(data); { int i; int * buffer = (int *)malloc(10 * sizeof(int)); if (buffer == NULL) {exit(-1);} for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } free(buffer); } }"	where is the vulnerable dataflow from buffer to free ?	"<start> printIntLine(buffer[i]) <end> ;
free <start> buffer <end> );"	"if  <start> buffer == NULL <end> ) {exit(-1);};
badSource <start> data <end> );"	"badSource <start> data <end> );
free <start> buffer <end> );"	"badSource <start> data <end> );
<start> free(buffer) <end> ;"	2
6b86243a-6c15-11ed-81d4-94e6f77dd552	"namespace CWE122_Heap_Based_Buffer_Overflow__c_CWE129_connect_socket_62 { void badSource(int &data); void bad() { int data; data = -1; badSource(data); { int i; int * buffer = (int *)malloc(10 * sizeof(int)); if (buffer == NULL) {exit(-1);} for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } free(buffer); } }"	where is the vulnerable dataflow from buffer to free ?	"free <start> buffer <end> );
badSource <start> data <end> );"	"<start> free(buffer) <end> ;
badSource <start> data <end> );"	"badSource <start> data <end> );
free <start> buffer <end> );"	"if  <start> buffer == NULL <end> ) {exit(-1);};
badSource <start> data <end> );"	2
8cc3a686-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(count) + 2) #ifdef _WIN32 #define SLEEP Sleep #else #define SLEEP usleep #endif void CWE400_Resource_Exhaustion__listen_socket_sleep_01_bad() { int count; count = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; count = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } SLEEP(count); printLine(""Sleep time possibly too long""); }"	where is the vulnerable dataflow from count to SLEEP ?	"count = <start> atoi(inputBuffer) <end> ;
SLEEP <start> count <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
SLEEP <start> count <end> );"	"SLEEP <start> count <end> );
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"<start> count = atoi(inputBuffer) <end> ;
SLEEP <start> count <end> );"	1
761e296e-6c15-11ed-81d4-94e6f77dd552	"namespace CWE194_Unexpected_Sign_Extension__fgets_memcpy_74 { void badSink(map<int, short> dataMap) { short data = dataMap[2]; { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"void badSink(map<int, short> <start> dataMap <end> );
printLine <start> dest <end> );"	"if  <start> data < 100 <end> );
void badSink(map<int, short> <start> dataMap <end> );"	"printLine <start> dest <end> );
if  <start> data < 100 <end> );"	"<start> memcpy(dest, source, data) <end> ;
printLine <start> dest <end> );"	0
d31a251d-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_listen_socket_open_15 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; switch(6) { case 6: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; default: printLine(""Benign, fixed string""); break; } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
size_t dataLen = <start> strlen(data) <end> ;"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
if  <start> listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR <end> );"	1
60db83b0-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__char_rand_add_81 { void CWE190_Integer_Overflow__char_rand_add_81_bad::action(char data) const { { char result = data + 1; printHexCharLine(result); } } }	where is the vulnerable dataflow from data ?	"void CWE190_Integer_Overflow__char_rand_add_81_bad::action(char <start> data <end> ) const;
char result = <start> data <end>  + 1;"	"char result = <start> data <end>  + 1;
void CWE190_Integer_Overflow__char_rand_add_81_bad::action(char <start> data <end> ) const;"	"char result = <start> data <end>  + 1;
<start> printHexCharLine(result) <end> ;"	"void CWE190_Integer_Overflow__char_rand_add_81_bad::action(char <start> data <end> ) const;
char <start> result = data + 1 <end> ;"	0
4a021101-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_multiply_17_bad() { int i,j; int data; data = 0; for(i = 0; i < 1; i++) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } for(j = 0; j < 1; j++) { if(data > 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"int result = <start> data <end>  * 2;
<start> printIntLine(result) <end> ;"	"int result = <start> data * 2 <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  * 2;"	3
b8e2bdb8-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" namespace CWE606_Unchecked_Loop_Condition__char_connect_socket_82 { void bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE606_Unchecked_Loop_Condition__char_connect_socket_82_base* baseObject = new CWE606_Unchecked_Loop_Condition__char_connect_socket_82_bad; baseObject->action(data); delete baseObject; }"	where is the vulnerable dataflow from data to action ?	"replace = <start> strchr(data, '\r') <end> ;
baseObject->action <start> data <end> );"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
baseObject->action <start> data <end> );"	"recvResult = recv(connectSocket, (char *)(data + dataLen), <start> sizeof(char) * (100 - dataLen - 1) <end> , 0);
baseObject->action <start> data <end> );"	"baseObject->action <start> data <end> );
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	1
774f57ec-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 8 static int badStatic = 0; static short badSource(short data) { if(badStatic) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = (short)atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } return data; } void CWE194_Unexpected_Sign_Extension__fgets_strncpy_21_bad() { short data; data = 0; badStatic = 1; data = badSource(data); { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> strncpy(dest, source, data) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
static short <start> badSource <end> (short data);
data = <start> badSource <end> (data);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
static short <start> badSource <end> (short data);
data = <start> badSource <end> (data);
printLine <start> dest <end> );"	"data = <start> badSource <end> (data);
static short <start> badSource <end> (short data);
<start> data = 0 <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"static short <start> badSource <end> (short data);
char <start> dest[100] = """" <end> ;
printLine <start> dest <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	1
bda4e448-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 namespace CWE78_OS_Command_Injection__char_listen_socket_popen_82 { void bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE78_OS_Command_Injection__char_listen_socket_popen_82_base* baseObject = new CWE78_OS_Command_Injection__char_listen_socket_popen_82_bad; baseObject->action(data); delete baseObject; }"	where is the vulnerable dataflow from data to action ?	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
if  <start> listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR <end> );"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
baseObject->action <start> data <end> );"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (100 - dataLen - 1), 0);
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"replace = <start> strchr(data, '\n') <end> ;
baseObject->action <start> data <end> );"	1
c01af8c6-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif static const int STATIC_CONST_FIVE = 5; namespace CWE23_Relative_Path_Traversal__char_connect_socket_open_06 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(STATIC_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"replace = <start> strchr(data, '\r') <end> ;
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"replace = <start> strchr(data, '\r') <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	0
a1094910-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_square_17_bad() { int i,j; int data; data = 0; for(i = 0; i < 1; i++) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } for(j = 0; j < 1; j++) { { int result = data * data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"<start> printIntLine(result) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"int result = <start> data * data <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"<start> data = 0 <end> ;
printIntLine <start> result <end> );"	2
598370cf-6c15-11ed-81d4-94e6f77dd552	"static short CWE191_Integer_Underflow__short_fscanf_sub_45_badData; static short CWE191_Integer_Underflow__short_fscanf_sub_45_goodG2BData; static short CWE191_Integer_Underflow__short_fscanf_sub_45_goodB2GData; static void badSink() { short data = CWE191_Integer_Underflow__short_fscanf_sub_45_badData; { short result = data - 1; printIntLine(result); } } void CWE191_Integer_Underflow__short_fscanf_sub_45_bad() { short data; data = 0; fscanf (stdin, ""%hd"", &data); CWE191_Integer_Underflow__short_fscanf_sub_45_badData = data; badSink(); }"	where is the vulnerable dataflow from data ?	"fscanf (stdin, ""%hd"", <start> &data <end> );
static short <start> CWE191_Integer_Underflow__short_fscanf_sub_45_badData <end> ;
<start> printIntLine(result) <end> ;
<start> CWE191_Integer_Underflow__short_fscanf_sub_45_badData = data <end> ;
short result = <start> data <end>  - 1;"	"<start> CWE191_Integer_Underflow__short_fscanf_sub_45_badData = data <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );
short result = <start> data <end>  - 1;
static short <start> CWE191_Integer_Underflow__short_fscanf_sub_45_badData <end> ;
short data = <start> CWE191_Integer_Underflow__short_fscanf_sub_45_badData <end> ;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
<start> CWE191_Integer_Underflow__short_fscanf_sub_45_badData = data <end> ;
static short <start> CWE191_Integer_Underflow__short_fscanf_sub_45_badData <end> ;
short data = <start> CWE191_Integer_Underflow__short_fscanf_sub_45_badData <end> ;
short result = <start> data <end>  - 1;"	"short <start> data = CWE191_Integer_Underflow__short_fscanf_sub_45_badData <end> ;
<start> CWE191_Integer_Underflow__short_fscanf_sub_45_badData = data <end> ;
short result = <start> data <end>  - 1;
static short <start> CWE191_Integer_Underflow__short_fscanf_sub_45_badData <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );"	2
525b6453-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_preinc_02_bad() { int data; data = 0; if(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(1) { { ++data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
+ <start> data <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
+ <start> data <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> ++data <end> ;"	"if  <start> listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR <end> );
+ <start> data <end> ;"	1
c39a65ba-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif namespace CWE23_Relative_Path_Traversal__char_environment_ofstream_42 { static char * badSource(char * data) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } return data; } void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; data = badSource(data); { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"data = <start> badSource <end> (data);
char * environment = <start> GETENV <end> (ENV_VARIABLE);
static char * <start> badSource <end> (char * data);
size_t dataLen = <start> strlen(data) <end> ;"	"strncat(data+dataLen, environment, <start> FILENAME_MAX-dataLen-1 <end> );
data = <start> badSource <end> (data);
static char * <start> badSource <end> (char * data);
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
outputFile.open((char * <start> data <end> );"	"outputFile.open((char * <start> data <end> );
data = <start> badSource <end> (data);
char * environment = <start> GETENV <end> (ENV_VARIABLE);
static char * <start> badSource <end> (char * data);"	2
7c127563-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_17_bad() { int i; int data; data = -1; for(i = 0; i < 1; i++) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }"	where is the vulnerable dataflow from data to malloc ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
if  <start> data < 100 <end> );"	"char * dataBuffer = (char *)malloc <start> data <end> );
<start> data = -1 <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
char * dataBuffer = (char *)malloc <start> data <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
char <start> inputBuffer[CHAR_ARRAY_SIZE] = """" <end> ;"	2
833ac928-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_listen_socket_fopen_67 { typedef struct _structType { char * structFirst; } structType; void badSink(structType myStruct) { char * data = myStruct.structFirst; { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"char <start> * data = myStruct.structFirst <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");
void badSink(structType <start> myStruct <end> );"	"char * data = <start> myStruct <end> .structFirst;
pFile = FOPEN <start> data <end> , ""wb+"");
void badSink(structType <start> myStruct <end> );"	"void badSink(structType <start> myStruct <end> );
char * data = <start> myStruct <end> .structFirst;
pFile = FOPEN <start> data <end> , ""wb+"");"	"char * data = <start> myStruct <end> .structFirst;
pFile = FOPEN <start> data <end> , ""wb+"");"	2
cf8750af-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_file_fopen_10 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(globalTrue) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = FOPEN <start> data <end> , ""wb+"");
size_t dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
pFile = FOPEN <start> data <end> , ""wb+"");"	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	1
93ece2d5-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING ""hello"" static int staticFive = 5; void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_07_bad() { size_t data; data = 0; if(staticFive==5) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = strtoul(inputBuffer, NULL, 0); } else { printLine(""fgets() failed.""); } } } if(staticFive==5) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); } else { printLine(""Input is less than the length of the source string""); } } } }"	where is the vulnerable dataflow from data to malloc ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
myString = (char *)malloc <start> data*sizeof(char) <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
if  <start> data > strlen(HELLO_STRING) <end> );"	"myString = <start> (char *)malloc(data*sizeof(char)) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"myString = (char *)malloc <start> data*sizeof(char) <end> );
myString = <start> (char *)malloc(data*sizeof(char)) <end> ;"	0
c01af8ea-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_connect_socket_open_74 { void badSink(map<int, char *> dataMap) { char * data = dataMap[2]; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"void badSink(map<int, char *> <start> dataMap <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"char <start> * data = dataMap[2] <end> ;
void badSink(map<int, char *> <start> dataMap <end> );"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
void badSink(map<int, char *> <start> dataMap <end> );"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = OPEN(data, O_RDWR|O_CREAT, <start> S_IREAD|S_IWRITE <end> );"	0
93ece2de-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING ""hello"" void CWE789_Uncontrolled_Mem_Alloc__malloc_char_fgets_16_bad() { size_t data; data = 0; while(1) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = strtoul(inputBuffer, NULL, 0); } else { printLine(""fgets() failed.""); } } break; } while(1) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); } else { printLine(""Input is less than the length of the source string""); } } break; } }"	where is the vulnerable dataflow from data to malloc ?	"myString = (char *)malloc <start> data*sizeof(char) <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"data = <start> strtoul(inputBuffer, NULL, 0) <end> ;
myString = (char *)malloc <start> data*sizeof(char) <end> );"	"<start> data = strtoul(inputBuffer, NULL, 0) <end> ;
myString = (char *)malloc <start> data*sizeof(char) <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
myString = (char *)malloc <start> data*sizeof(char) <end> );"	3
aa91a193-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_listen_socket_sub_17_bad() { int i,j; int data; data = 0; for(i = 0; i < 1; i++) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } for(j = 0; j < 1; j++) { { int result = data - 1; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> result <end> );"	"int <start> result = data - 1 <end> ;
printIntLine <start> result <end> );"	"<start> data = atoi(inputBuffer) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	3
d0b64ec1-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif namespace CWE36_Absolute_Path_Traversal__char_file_ifstream_02 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(1) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
<start> data = dataBuffer <end> ;"	"inputFile.open((char * <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
size_t dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
inputFile.open((char * <start> data <end> );"	3
c99197e1-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_connect_socket_fopen_12 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(globalReturnsTrueOrFalse()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } else { #ifdef _WIN32 strcat(data, ""c:\\temp\\file.txt""); #else strcat(data, ""/tmp/file.txt""); #endif } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
<start> data = dataBuffer <end> ;"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
char <start> dataBuffer[FILENAME_MAX] = """" <end> ;"	"<start> strcat(data, ""c:\\temp\\file.txt"") <end> ;
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	3
acf67e46-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_fgets_predec_13_bad() { int data; data = 0; if(GLOBAL_CONST_FIVE==5) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(GLOBAL_CONST_FIVE==5) { { --data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
int <start> result = data <end> ;"	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
<start> --data <end> ;"	2
b54bcf34-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 20 typedef union { float unionFirst; float unionSecond; } CWE369_Divide_by_Zero__float_listenSocket_34_unionType; void CWE369_Divide_by_Zero__float_listenSocket_34_bad() { float data; CWE369_Divide_by_Zero__float_listenSocket_34_unionType myUnion; data = 0.0F; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = (float)atof(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } myUnion.unionFirst = data; { float data = myUnion.unionSecond; { int result = (int)(100.0 / data); printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"data = (float <start> atof(inputBuffer) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"<start> printIntLine(result) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"int result = (int) <start> 100.0 / data <end> );
printIntLine <start> result <end> );"	1
a830bf79-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) typedef union { int unionFirst; int unionSecond; } CWE191_Integer_Underflow__int_connect_socket_multiply_34_unionType; void CWE191_Integer_Underflow__int_connect_socket_multiply_34_bad() { int data; CWE191_Integer_Underflow__int_connect_socket_multiply_34_unionType myUnion; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } myUnion.unionFirst = data; { int data = myUnion.unionSecond; if(data < 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"if <start> data < 0 <end> ) ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"data = <start> atoi(inputBuffer) <end> ;
printIntLine <start> result <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	3
656cd3cb-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__int_rand_add_43 { static void badSource(int &data) { data = RAND32(); } void bad() { int data; data = 0; badSource(data); { int result = data + 1; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"data = <start> RAND32() <end> ;
<start> printIntLine(result) <end> ;
int result = <start> data <end>  + 1;"	"data = <start> RAND32() <end> ;
badSource <start> data <end> );
int result = <start> data <end>  + 1;"	"data = <start> RAND32() <end> ;
<start> badSource(data) <end> ;
badSource <start> data <end> );"	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  + 1;
badSource <start> data <end> );"	1
9c4551b6-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int badSource(int data) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } return data; } void CWE126_Buffer_Overread__CWE129_fgets_42_bad() { int data; data = -1; data = badSource(data); { int buffer[10] = { 0 }; if (data >= 0) { printIntLine(buffer[data]); } else { printLine(""ERROR: Array index is negative""); } } }"	where is the vulnerable dataflow from buffer[data] to printIntLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
data = <start> badSource <end> (data);
static int <start> badSource <end> (int data);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
static int <start> badSource <end> (int data);
data = <start> badSource <end> (data);
printIntLine <start> buffer[data] <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
data = <start> badSource <end> (data);"	"static int <start> badSource <end> (int data);
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
data = <start> badSource <end> (data);
printIntLine <start> buffer[data] <end> );"	1
6ef76822-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; static void badVaSinkB(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_console_vfprintf_04_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; if(STATIC_CONST_TRUE) { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } if(STATIC_CONST_TRUE) { badVaSinkB(data, data); } }"	where is the vulnerable dataflow from data to vfprintf ?	"badVaSinkB <start> data <end> , data);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
dataLen = <start> strlen(data) <end> ;
vfprintf(stdout, <start> data <end> , args);"	"vfprintf(stdout, <start> data <end> , args);
badVaSinkB <start> data <end> , data);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);"	"vfprintf(stdout, <start> data <end> , args);
size_t dataLen = <start> strlen(data) <end> ;
badVaSinkB <start> data <end> , data);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	2
d1e9da49-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_listen_socket_fopen_61 { char * badSource(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; data = badSource(data); { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"data = <start> badSource <end> (data);
pFile = FOPEN <start> data <end> , ""wb+"");"	"char <start> dataBuffer[FILENAME_MAX] = """" <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
data = <start> badSource <end> (data);"	"data = <start> badSource <end> (data);
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	0
c136626b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif namespace CWE23_Relative_Path_Traversal__char_console_ifstream_17 { void bad() { int i; char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; for(i = 0; i < 1; i++) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
inputFile.open((char * <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
if (dataLen > 0 && <start> data[dataLen-1] == '\n' <end> );"	"dataLen = <start> strlen(data) <end> ;
inputFile.open((char * <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
<start> data = dataBuffer <end> ;"	0
a23a3e17-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_multiply_03_bad() { int data; data = 0; if(5==5) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(5==5) { if(data > 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );"	"int result = <start> data * 2 <end> ;
printIntLine <start> result <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> printIntLine(result) <end> ;"	"printIntLine <start> result <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	0
d0b64ef5-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif namespace CWE36_Absolute_Path_Traversal__char_file_ofstream_45 { static char * badData; static char * goodG2BData; static void badSink() { char * data = badData; { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } } void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } badData = data; badSink(); }"	where is the vulnerable dataflow from data to open ?	"<start> badData = data <end> ;
static char * <start> badData <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
<start> badData = data <end> ;
static char * <start> badData <end> ;
char * data = <start> badData <end> ;
outputFile.open((char * <start> data <end> );"	"<start> badData = data <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"char * data = <start> badData <end> ;
size_t dataLen = <start> strlen(data) <end> ;
outputFile.open((char * <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
<start> badData = data <end> ;"	1
584fa882-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int CWE191_Integer_Underflow__int_listen_socket_sub_45_badData; static int CWE191_Integer_Underflow__int_listen_socket_sub_45_goodG2BData; static int CWE191_Integer_Underflow__int_listen_socket_sub_45_goodB2GData; static void badSink() { int data = CWE191_Integer_Underflow__int_listen_socket_sub_45_badData; { int result = data - 1; printIntLine(result); } } void CWE191_Integer_Underflow__int_listen_socket_sub_45_bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE191_Integer_Underflow__int_listen_socket_sub_45_badData = data; badSink(); }"	where is the vulnerable dataflow from data ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> CWE191_Integer_Underflow__int_listen_socket_sub_45_badData = data <end> ;
static int <start> CWE191_Integer_Underflow__int_listen_socket_sub_45_badData <end> ;
int data = <start> CWE191_Integer_Underflow__int_listen_socket_sub_45_badData <end> ;
int result = <start> data <end>  - 1;"	"static int <start> CWE191_Integer_Underflow__int_listen_socket_sub_45_badData <end> ;
int result = <start> data <end>  - 1;
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
<start> CWE191_Integer_Underflow__int_listen_socket_sub_45_badData = data <end> ;
int data = <start> CWE191_Integer_Underflow__int_listen_socket_sub_45_badData <end> ;"	"int result = <start> data <end>  - 1;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int data = <start> CWE191_Integer_Underflow__int_listen_socket_sub_45_badData <end> ;
<start> CWE191_Integer_Underflow__int_listen_socket_sub_45_badData = data <end> ;
static int <start> CWE191_Integer_Underflow__int_listen_socket_sub_45_badData <end> ;"	"<start> CWE191_Integer_Underflow__int_listen_socket_sub_45_badData = data <end> ;
int result = <start> data <end>  - 1;
static int <start> CWE191_Integer_Underflow__int_listen_socket_sub_45_badData <end> ;
if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );
int data = <start> CWE191_Integer_Underflow__int_listen_socket_sub_45_badData <end> ;"	0
c8600afb-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif static const int STATIC_CONST_FIVE = 5; namespace CWE23_Relative_Path_Traversal__char_listen_socket_open_06 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(STATIC_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"<start> data = dataBuffer <end> ;
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN(data, O_RDWR|O_CREAT, <start> S_IREAD|S_IWRITE <end> );
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	1
774f5805-6c15-11ed-81d4-94e6f77dd552	"namespace CWE194_Unexpected_Sign_Extension__fgets_strncpy_82 { void CWE194_Unexpected_Sign_Extension__fgets_strncpy_82_bad::action(short data) { { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> printLine(dest) <end> ;
void CWE194_Unexpected_Sign_Extension__fgets_strncpy_82_bad::action(short <start> data <end> );"	"void CWE194_Unexpected_Sign_Extension__fgets_strncpy_82_bad::action(short <start> data <end> );
printLine <start> dest <end> );"	"<start> strncpy(dest, source, data) <end> ;
void CWE194_Unexpected_Sign_Extension__fgets_strncpy_82_bad::action(short <start> data <end> );"	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	1
ae26ae4b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" namespace CWE194_Unexpected_Sign_Extension__connect_socket_malloc_82 { void bad() { short data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE194_Unexpected_Sign_Extension__connect_socket_malloc_82_base* baseObject = new CWE194_Unexpected_Sign_Extension__connect_socket_malloc_82_bad; baseObject->action(data); delete baseObject; }"	where is the vulnerable dataflow from data to action ?	"baseObject->action <start> data <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"baseObject->action <start> data <end> );
tempInt = <start> atoi(inputBuffer) <end> ;"	"baseObject->action <start> data <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
baseObject->action <start> data <end> );"	3
b08640bb-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE197_Numeric_Truncation_Error__int_fgets_to_char_31_bad() { int data; data = -1; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } { int dataCopy = data; int data = dataCopy; { char charData = (char)data; printHexCharLine(charData); } } }"	where is the vulnerable dataflow from charData to printHexCharLine ?	"<start> printHexCharLine(charData) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
char charData = <start> (char)data <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printHexCharLine <start> charData <end> );"	"char charData = <start> (char)data <end> ;
printHexCharLine <start> charData <end> );"	2
ba102b81-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define EXECL _execl #else #define EXECL execl #endif void CWE78_OS_Command_Injection__char_connect_socket_execl_11_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(globalReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECL ?	"<start> EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL) <end> ;
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
size_t dataLen = <start> strlen(data) <end> ;"	"EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	1
c26a7e56-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_console_open_62 { void badSource(char * &data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; badSource(data); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"badSource <start> data <end> );
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"<start> badSource(data) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"badSource <start> data <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	3
8df421f7-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define PATH_SZ 100 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define PATH_SZ PATH_MAX #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 void CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__accept_bind_listen_18_bad() { goto sink; sink: { char data[100] = """"; #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[recvResult] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif printLine(data); } }"	where is the vulnerable dataflow from data to printLine ?	"recvResult = recv(acceptSocket, (char *)data+dataLen, <start> (int)(100-dataLen-1) <end> , 0);
printLine <start> data <end> );"	"recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);
printLine <start> data <end> );"	"printLine <start> data <end> );
recvResult = recv(acceptSocket, <start> (char *)data <end> +dataLen, (int)(100-dataLen-1), 0);"	"printLine <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	1
ae26ae6f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_13_bad() { int data; data = -1; if(GLOBAL_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { char charData = (char)data; printHexCharLine(charData); } }"	where is the vulnerable dataflow from charData to printHexCharLine ?	"printHexCharLine <start> charData <end> );
data = <start> atoi(inputBuffer) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
data = <start> atoi(inputBuffer) <end> ;"	"printHexCharLine <start> charData <end> );
char <start> charData = (char)data <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printHexCharLine <start> charData <end> );"	3
69161b5b-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__short_rand_preinc_17_bad() { int i,j; short data; data = 0; for(i = 0; i < 1; i++) { data = (short)RAND32(); } for(j = 0; j < 1; j++) { { ++data; short result = data; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"data = (short <start> RAND32() <end> ;
+ <start> data <end> ;"	"<start> printIntLine(result) <end> ;
data = (short <start> RAND32() <end> ;"	"<start> printIntLine(result) <end> ;
+ <start> data <end> ;"	"<start> ++data <end> ;
+ <start> data <end> ;"	0
a49c4f9a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_postinc_12_bad() { int data; data = 0; if(globalReturnsTrueOrFalse()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } else { data = 2; } if(globalReturnsTrueOrFalse()) { { data++; int result = data; printIntLine(result); } } else { if (data < INT_MAX) { data++; int result = data; printIntLine(result); } else { printLine(""data value is too large to perform arithmetic safely.""); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"<start> data = atoi(inputBuffer) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> result <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int <start> result = data <end> ;"	1
7e74f367-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_01_bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );
printLine <start> dest <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );"	"printLine <start> dest <end> );
data = <start> atoi(inputBuffer) <end> ;"	0
abc37507-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink(int data) { { data--; int result = data; printIntLine(result); } } void CWE191_Integer_Underflow__int_connect_socket_postdec_44_bad() { int data; void (*funcPtr) (int) = badSink; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } funcPtr(data); }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
funcPtr <start> data <end> );
static void badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
funcPtr <start> data <end> );"	"<start> data = atoi(inputBuffer) <end> ;
static void badSink(int <start> data <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"funcPtr <start> data <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
data = <start> atoi(inputBuffer) <end> ;
static void badSink(int <start> data <end> );"	0
977ea78a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int badStatic = 0; static void badSink(int data) { if(badStatic) { { int i; int buffer[10] = { 0 }; if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } } } } void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_21_bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badStatic = 1; badSink(data); }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"printIntLine <start> buffer[i] <end> );
static void badSink(int <start> data <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSink <start> data <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSink <start> data <end> );
printIntLine <start> buffer[i] <end> );
<start> badSink(data) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSink <start> data <end> );
static void badSink(int <start> data <end> );
printIntLine <start> buffer[i] <end> );"	"printIntLine <start> buffer[i] <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static void badSink(int <start> data <end> );"	2
525b6440-6c15-11ed-81d4-94e6f77dd552	"void CWE190_Integer_Overflow__int_fscanf_preinc_13_bad() { int data; data = 0; if(GLOBAL_CONST_FIVE==5) { fscanf(stdin, ""%d"", &data); } if(GLOBAL_CONST_FIVE==5) { { ++data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"fscanf(stdin, ""%d"", <start> &data <end> );
<start> printIntLine(result) <end> ;"	"fscanf(stdin, ""%d"", <start> &data <end> );
+ <start> data <end> ;"	"<start> ++data <end> ;
fscanf(stdin, ""%d"", <start> &data <end> );"	"<start> printIntLine(result) <end> ;
+ <start> data <end> ;"	1
48d25da6-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_add_10_bad() { int data; data = 0; if(globalTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalTrue) { { int result = data + 1; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"int <start> result = data + 1 <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"data = <start> atoi(inputBuffer) <end> ;
int result = <start> data <end>  + 1;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  + 1;"	"<start> recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
int result = <start> data <end>  + 1;"	2
b8e2bdbe-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE617_Reachable_Assertion__connect_socket_82 { void bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE617_Reachable_Assertion__connect_socket_82_base* baseObject = new CWE617_Reachable_Assertion__connect_socket_82_bad; baseObject->action(data); delete baseObject; }"	where is the vulnerable dataflow from data to action ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
data = <start> atoi(inputBuffer) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
baseObject->action <start> data <end> );"	"baseObject->action <start> data <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"baseObject->action <start> data <end> );
data = <start> atoi(inputBuffer) <end> ;"	1
6c938c25-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" static void badVaSinkB(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); va_end(args); } } static void badVaSinkG(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, ""%s"", args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_12_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; if(globalReturnsTrueOrFalse()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } else { strcpy(data, ""fixedstringtest""); } if(globalReturnsTrueOrFalse()) { badVaSinkB(data, data); } else { badVaSinkG(data, data); } }"	where is the vulnerable dataflow from data to vfprintf ?	"size_t dataLen = <start> strlen(data) <end> ;
badVaSinkB <start> data <end> , data);
vfprintf(stdout, <start> data <end> , args);
static void badVaSinkB(char * <start> data <end> , ...);"	"vfprintf(stdout, <start> data <end> , args);
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (100 - dataLen - 1), 0);
static void badVaSinkB(char * <start> data <end> , ...);"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (100 - dataLen - 1), 0);
static void badVaSinkB(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);
badVaSinkB <start> data <end> , data);"	2
8cc3a65a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(count) + 2) #ifdef _WIN32 #define SLEEP Sleep #else #define SLEEP usleep #endif static void badSink(int count) { SLEEP(count); printLine(""Sleep time possibly too long""); } void CWE400_Resource_Exhaustion__connect_socket_sleep_41_bad() { int count; count = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; count = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badSink(count); }"	where is the vulnerable dataflow from count to SLEEP ?	"static void badSink(int <start> count <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
SLEEP <start> count <end> );
badSink <start> count <end> );"	"count = <start> atoi(inputBuffer) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
SLEEP <start> count <end> );
static void badSink(int <start> count <end> );"	"<start> count = -1 <end> ;
badSink <start> count <end> );
SLEEP <start> count <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSink <start> count <end> );
static void badSink(int <start> count <end> );
SLEEP <start> count <end> );"	3
c26a7e4d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_console_open_42 { static char * badSource(char * data) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } return data; } void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; data = badSource(data); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
static char * <start> badSource <end> (char * data);
data = <start> badSource(data) <end> ;"	"<start> data = badSource(data) <end> ;
static char * <start> badSource <end> (char * data);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	0
54c581fc-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) int CWE191_Integer_Underflow__int_connect_socket_multiply_61b_badSource(int data); void CWE191_Integer_Underflow__int_connect_socket_multiply_61_bad() { int data; data = 0; data = CWE191_Integer_Underflow__int_connect_socket_multiply_61b_badSource(data); if(data < 0) { int result = data * 2; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"data = <start> CWE191_Integer_Underflow__int_connect_socket_multiply_61b_badSource <end> (data);
int <start> result = data * 2 <end> ;"	"int result = <start> data <end>  * 2;
data = <start> CWE191_Integer_Underflow__int_connect_socket_multiply_61b_badSource <end> (data);"	"data = <start> CWE191_Integer_Underflow__int_connect_socket_multiply_61b_badSource <end> (data);
int result = <start> data <end>  * 2;"	"int result = <start> data <end>  * 2;
<start> printIntLine(result) <end> ;"	2
6a52bee7-6c15-11ed-81d4-94e6f77dd552	static void badSink(unsigned int data) { { unsigned int result = data - 1; printUnsignedLine(result); } } void CWE191_Integer_Underflow__unsigned_int_rand_sub_41_bad() { unsigned int data; data = 0; data = (unsigned int)RAND32(); badSink(data); }	where is the vulnerable dataflow from data ?	"static void badSink(unsigned int <start> data <end> );
badSink <start> data <end> );
unsigned int result = <start> data <end>  - 1;"	"data = (unsigned int <start> RAND32() <end> ;
badSink <start> data <end> );
static void badSink(unsigned int <start> data <end> );
unsigned int result = <start> data <end>  - 1;"	"badSink <start> data <end> );
<start> data = (unsigned int)RAND32() <end> ;
static void badSink(unsigned int <start> data <end> );
unsigned int result = <start> data <end>  - 1;"	"data = (unsigned int <start> RAND32() <end> ;
badSink <start> data <end> );
unsigned int result = <start> data <end>  - 1;
static void badSink(unsigned int <start> data <end> );"	1
cf8750b3-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_file_fopen_14 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(globalFive==5) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
pFile = FOPEN <start> data <end> , ""wb+"");"	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"char <start> dataBuffer[FILENAME_MAX] = """" <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	1
79b27544-6c15-11ed-81d4-94e6f77dd552	namespace CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_82 { void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_82_bad::action(int data) { if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } } }	where is the vulnerable dataflow from data to malloc ?	"<start> free(dataBuffer) <end> ;
char * dataBuffer = (char *)malloc <start> data <end> );"	"void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_82_bad::action(int <start> data <end> );
<start> memset(dataBuffer, 'A', data-1) <end> ;"	"<start> memset(dataBuffer, 'A', data-1) <end> ;
char * dataBuffer = (char *)malloc <start> data <end> );"	"void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_82_bad::action(int <start> data <end> );
char * dataBuffer = (char *)malloc <start> data <end> );"	3
4ec5d08d-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) extern int CWE190_Integer_Overflow__int_fgets_postinc_68_badData; extern int CWE190_Integer_Overflow__int_fgets_postinc_68_goodG2BData; extern int CWE190_Integer_Overflow__int_fgets_postinc_68_goodB2GData; void CWE190_Integer_Overflow__int_fgets_postinc_68b_badSink() { int data = CWE190_Integer_Overflow__int_fgets_postinc_68_badData; { data++; int result = data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
<start> data <end> ++;"	"int data = <start> CWE190_Integer_Overflow__int_fgets_postinc_68_badData <end> ;
<start> printIntLine(result) <end> ;"	"int data = <start> CWE190_Integer_Overflow__int_fgets_postinc_68_badData <end> ;
<start> data <end> ++;"	"int <start> result = data <end> ;
int data = <start> CWE190_Integer_Overflow__int_fgets_postinc_68_badData <end> ;"	2
7e74f337-6c15-11ed-81d4-94e6f77dd552	"namespace CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_73 { void badSink(list<int> dataList) { int data = dataList.back(); { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	"void badSink(list<int> <start> dataList <end> );
printLine <start> dest <end> );"	"<start> memcpy(dest, source, data) <end> ;
printLine <start> dest <end> );"	"printLine <start> dest <end> );
void badSink(list<int> <start> dataList <end> );"	1
4a021123-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticFive = 5; void CWE190_Integer_Overflow__int_listen_socket_square_07_bad() { int data; data = 0; if(staticFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticFive==5) { { int result = data * data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  * data;
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"if  <start> recvResult == SOCKET_ERROR <end>  || recvResult == 0);
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"int result = <start> data <end>  * data;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  * data;"	3
93ece2cb-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #define HELLO_STRING ""hello"" namespace CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_72 { void badSink(vector<size_t> dataVector) { size_t data = dataVector[2]; { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); } else { printLine(""Input is less than the length of the source string""); } } }"	where is the vulnerable dataflow from data to malloc ?	"<start> strcpy(myString, HELLO_STRING) <end> ;
void badSink(vector<size_t> <start> dataVector <end> );"	"if  <start> data > strlen(HELLO_STRING) <end> );
myString = (char *)malloc <start> data*sizeof(char) <end> );"	"void badSink(vector<size_t> <start> dataVector <end> );
myString = (char *)malloc <start> data*sizeof(char) <end> );"	"<start> free(myString) <end> ;
void badSink(vector<size_t> <start> dataVector <end> );"	2
4c66614f-6c15-11ed-81d4-94e6f77dd552	"static void badSink(unsigned int data) { if(data > 0) { unsigned int result = data * 2; printUnsignedLine(result); } } void CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_41_bad() { unsigned int data; data = 0; fscanf (stdin, ""%u"", &data); badSink(data); }"	where is the vulnerable dataflow from data ?	"badSink <start> data <end> );
static void badSink(unsigned int <start> data <end> );
fscanf (stdin, ""%u"", <start> &data <end> );
unsigned int result = <start> data <end>  * 2;"	"unsigned int result = <start> data <end>  * 2;
fscanf (stdin, ""%u"", <start> &data <end> );
<start> badSink(data) <end> ;
static void badSink(unsigned int <start> data <end> );"	"fscanf (stdin, ""%u"", <start> &data <end> );
badSink <start> data <end> );
static void badSink(unsigned int <start> data <end> );
unsigned int result = <start> data <end>  * 2;"	"unsigned int result = <start> data <end>  * 2;
badSink <start> data <end> );
static void badSink(unsigned int <start> data <end> );"	2
55ef4cc7-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } void CWE191_Integer_Underflow__int_fgets_sub_08_bad() { int data; data = 0; if(staticReturnsTrue()) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(staticReturnsTrue()) { { int result = data - 1; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
int result = <start> data <end>  - 1;"	"int <start> result = data - 1 <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"<start> printIntLine(result) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"data = <start> atoi(inputBuffer) <end> ;
int result = <start> data <end>  - 1;"	0
cf8750a4-6c15-11ed-81d4-94e6f77dd552	#ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_environment_open_81 { void CWE36_Absolute_Path_Traversal__char_environment_open_81_bad::action(char * data) const { { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } } }	where is the vulnerable dataflow from data to OPEN ?	"void CWE36_Absolute_Path_Traversal__char_environment_open_81_bad::action(char * <start> data <end> ) const;
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"void CWE36_Absolute_Path_Traversal__char_environment_open_81_bad::action(char * <start> data <end> ) const;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
void CWE36_Absolute_Path_Traversal__char_environment_open_81_bad::action(char * <start> data <end> ) const;"	1
73bc8154-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" static short CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_45_badData; static short CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_45_goodG2BData; static void badSink() { short data = CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_45_badData; { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } } void CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_45_bad() { short data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_45_badData = data; badSink(); }"	where is the vulnerable dataflow from dest to printLine ?	"<start> printLine(dest) <end> ;
static short <start> CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_45_badData <end> ;
printLine <start> dest <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
short data = <start> CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_45_badData <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printLine(dest) <end> ;
<start> CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_45_badData = data <end> ;
static short <start> CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_45_badData <end> ;
printLine <start> dest <end> );"	"<start> memcpy(dest, source, data) <end> ;
short data = <start> CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_45_badData <end> ;
static short <start> CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_45_badData <end> ;
<start> CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_45_badData = data <end> ;
printLine <start> dest <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_45_badData = data <end> ;
static short <start> CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_45_badData <end> ;
short data = <start> CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_45_badData <end> ;
printLine <start> dest <end> );"	3
4b34afe0-6c15-11ed-81d4-94e6f77dd552	"static short badSource(short data) { fscanf (stdin, ""%hd"", &data); return data; } void CWE190_Integer_Overflow__short_fscanf_multiply_42_bad() { short data; data = 0; data = badSource(data); if(data > 0) { short result = data * 2; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"fscanf (stdin, ""%hd"", <start> &data <end> );
data = <start> badSource <end> (data);
short result = <start> data <end>  * 2;
<start> data = 0 <end> ;"	"data = <start> badSource <end> (data);
short result = <start> data <end>  * 2;
static short <start> badSource <end> (short data);"	"fscanf (stdin, ""%hd"", <start> &data <end> );
static short <start> badSource <end> (short data);
data = <start> badSource <end> (data);
short result = <start> data <end>  * 2;"	"short result = <start> data * 2 <end> ;
static short <start> badSource <end> (short data);
fscanf (stdin, ""%hd"", <start> &data <end> );
data = <start> badSource <end> (data);"	2
4a021106-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) typedef union { int unionFirst; int unionSecond; } CWE190_Integer_Overflow__int_listen_socket_multiply_34_unionType; void CWE190_Integer_Overflow__int_listen_socket_multiply_34_bad() { int data; CWE190_Integer_Overflow__int_listen_socket_multiply_34_unionType myUnion; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } myUnion.unionFirst = data; { int data = myUnion.unionSecond; if(data > 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  * 2;"	"int result = <start> data <end>  * 2;
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"if <start> data > 0 <end> ) ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"int result = <start> data <end>  * 2;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	0
92bb8a25-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING ""hello"" void CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_16_bad() { size_t data; data = 0; while(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = strtoul(inputBuffer, NULL, 0); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; } while(1) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); } else { printLine(""Input is less than the length of the source string""); } } break; } }"	where is the vulnerable dataflow from data to malloc ?	"<start> myString = (char *)malloc(data*sizeof(char)) <end> ;
myString = (char *)malloc <start> data*sizeof(char) <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
myString = (char *)malloc <start> data*sizeof(char) <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
if  <start> data > strlen(HELLO_STRING) <end> );"	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
myString = (char *)malloc <start> data*sizeof(char) <end> );"	1
47a2a81a-6c15-11ed-81d4-94e6f77dd552	"static void badSink(int data) { { int result = data + 1; printIntLine(result); } } void CWE190_Integer_Overflow__int_fscanf_add_44_bad() { int data; void (*funcPtr) (int) = badSink; data = 0; fscanf(stdin, ""%d"", &data); funcPtr(data); }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
fscanf(stdin, ""%d"", <start> &data <end> );
funcPtr <start> data <end> );
static void badSink(int <start> data <end> );"	"<start> funcPtr(data) <end> ;
fscanf(stdin, ""%d"", <start> &data <end> );
int result = <start> data <end>  + 1;
static void badSink(int <start> data <end> );"	"fscanf(stdin, ""%d"", <start> &data <end> );
funcPtr <start> data <end> );
static void badSink(int <start> data <end> );
int result = <start> data <end>  + 1;"	"fscanf(stdin, ""%d"", <start> &data <end> );
static void badSink(int <start> data <end> );
funcPtr <start> data <end> );"	2
656cd3c7-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__int_rand_add_31_bad() { int data; data = 0; data = RAND32(); { int dataCopy = data; int data = dataCopy; { int result = data + 1; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
data = <start> RAND32() <end> ;"	"int <start> dataCopy = data <end> ;
int result = <start> data <end>  + 1;"	"int <start> result = data + 1 <end> ;
data = <start> RAND32() <end> ;"	"data = <start> RAND32() <end> ;
int result = <start> data <end>  + 1;"	3
7d44fc7a-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) extern int CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_68_badData; extern int CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_68_goodG2BData; void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_68b_badSink() { int data = CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_68_badData; { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"printLine <start> dest <end> );
<start> printLine(dest) <end> ;"	"int data = <start> CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_68_badData <end> ;
printLine <start> dest <end> );"	"<start> memmove(dest, source, data) <end> ;
int data = <start> CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_68_badData <end> ;"	"int <start> data = CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_68_badData <end> ;
printLine <start> dest <end> );"	1
4ec5d0ae-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__int_fscanf_postinc_66b_badSink(int dataArray[]) { int data = dataArray[2]; { data++; int result = data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"void CWE190_Integer_Overflow__int_fscanf_postinc_66b_badSink(int <start> dataArray <end> []);
<start> data <end> ++;"	"int <start> data = dataArray[2] <end> ;
void CWE190_Integer_Overflow__int_fscanf_postinc_66b_badSink(int <start> dataArray <end> []);"	"<start> data <end> ++;
void CWE190_Integer_Overflow__int_fscanf_postinc_66b_badSink(int <start> dataArray <end> []);"	"<start> printIntLine(result) <end> ;
void CWE190_Integer_Overflow__int_fscanf_postinc_66b_badSink(int <start> dataArray <end> []);"	0
656cd3ef-6c15-11ed-81d4-94e6f77dd552	typedef union { int unionFirst; int unionSecond; } CWE190_Integer_Overflow__int_rand_multiply_34_unionType; void CWE190_Integer_Overflow__int_rand_multiply_34_bad() { int data; CWE190_Integer_Overflow__int_rand_multiply_34_unionType myUnion; data = 0; data = RAND32(); myUnion.unionFirst = data; { int data = myUnion.unionSecond; if(data > 0) { int result = data * 2; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"data = <start> RAND32() <end> ;
int result = <start> data * 2 <end> ;"	"int result = <start> data <end>  * 2;
int <start> data = myUnion.unionSecond <end> ;"	"int <start> result = data * 2 <end> ;
data = <start> RAND32() <end> ;"	"data = <start> RAND32() <end> ;
int result = <start> data <end>  * 2;"	3
a5ce1c48-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_postinc_65b_badSink(int data) { { data++; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"void CWE190_Integer_Overflow__int_connect_socket_postinc_65b_badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
void CWE190_Integer_Overflow__int_connect_socket_postinc_65b_badSink(int <start> data <end> );"	"int <start> result = data <end> ;
void CWE190_Integer_Overflow__int_connect_socket_postinc_65b_badSink(int <start> data <end> );"	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;"	0
cd228171-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_console_open_62 { void badSource(char * &data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; badSource(data); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"badSource <start> data <end> );
<start> badSource(data) <end> ;"	"badSource <start> data <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
<start> badSource(data) <end> ;"	"badSource <start> data <end> );
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	1
7fa68e12-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_52c_badSink(int data) { { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> strncpy(dest, source, data) <end> ;
printLine <start> dest <end> );"	"void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_52c_badSink(int <start> data <end> );
printLine <start> dest <end> );"	"<start> strncpy(dest, source, data) <end> ;
void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_52c_badSink(int <start> data <end> );"	"printLine <start> dest <end> );
<start> printLine(dest) <end> ;"	1
6b862429-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_connect_socket_16_bad() { int data; data = -1; while(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; } while(1) { { int i; int * buffer = (int *)malloc(10 * sizeof(int)); if (buffer == NULL) {exit(-1);} for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } free(buffer); } break; } }"	where is the vulnerable dataflow from buffer to free ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
free <start> buffer <end> );"	"free <start> buffer <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
free <start> buffer <end> );"	"free <start> buffer <end> );
<start> free(buffer) <end> ;"	0
cbf237ad-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_console_fopen_16 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; while(1) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } break; } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
pFile = FOPEN <start> data <end> , ""wb+"");"	"dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"char <start> dataBuffer[FILENAME_MAX] = """" <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"pFile = FOPEN <start> data <end> , ""wb+"");
<start> data = dataBuffer <end> ;"	0
87ff9867-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif static int staticFive = 5; namespace CWE36_Absolute_Path_Traversal__char_connect_socket_open_07 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(staticFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
replace = <start> strchr(data, '\r') <end> ;"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
replace = <start> strchr(data, '\n') <end> ;"	"recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) *  <start> FILENAME_MAX - dataLen - 1 <end> ), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	1
79b2756d-6c15-11ed-81d4-94e6f77dd552	"namespace CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_73 { void badSink(list<int> dataList) { int data = dataList.back(); { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"void badSink(list<int> <start> dataList <end> );
if  <start> data < 100 <end> );"	"void badSink(list<int> <start> dataList <end> );
<start> printLine(dest) <end> ;"	"void badSink(list<int> <start> dataList <end> );
printLine <start> dest <end> );"	"char <start> dest[100] = """" <end> ;
void badSink(list<int> <start> dataList <end> );"	2
74ee2410-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE 8 void CWE194_Unexpected_Sign_Extension__fgets_malloc_52c_badSink(short data) { if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }	where is the vulnerable dataflow from data to malloc ?	"<start> memset(dataBuffer, 'A', data-1) <end> ;
void CWE194_Unexpected_Sign_Extension__fgets_malloc_52c_badSink(short <start> data <end> );"	"void CWE194_Unexpected_Sign_Extension__fgets_malloc_52c_badSink(short <start> data <end> );
<start> printLine(dataBuffer) <end> ;"	"char * dataBuffer = (char *)malloc <start> data <end> );
<start> printLine(dataBuffer) <end> ;"	"void CWE194_Unexpected_Sign_Extension__fgets_malloc_52c_badSink(short <start> data <end> );
char * dataBuffer = (char *)malloc <start> data <end> );"	3
4c66614c-6c15-11ed-81d4-94e6f77dd552	"static void badSink(unsigned int data) { { unsigned int result = data + 1; printUnsignedLine(result); } } void CWE190_Integer_Overflow__unsigned_int_fscanf_add_44_bad() { unsigned int data; void (*funcPtr) (unsigned int) = badSink; data = 0; fscanf (stdin, ""%u"", &data); funcPtr(data); }"	where is the vulnerable dataflow from data ?	"funcPtr <start> data <end> );
<start> funcPtr(data) <end> ;
fscanf (stdin, ""%u"", <start> &data <end> );
unsigned int result = <start> data <end>  + 1;"	"fscanf (stdin, ""%u"", <start> &data <end> );
funcPtr <start> data <end> );
static void badSink(unsigned int <start> data <end> );
unsigned int result = <start> data <end>  + 1;"	"unsigned int result = <start> data <end>  + 1;
funcPtr <start> data <end> );
fscanf (stdin, ""%u"", <start> &data <end> );"	"static void badSink(unsigned int <start> data <end> );
<start> funcPtr(data) <end> ;
funcPtr <start> data <end> );
unsigned int result = <start> data <end>  + 1;"	1
47a2a810-6c15-11ed-81d4-94e6f77dd552	"void CWE190_Integer_Overflow__int_fscanf_add_15_bad() { int data; data = 0; switch(6) { case 6: fscanf(stdin, ""%d"", &data); break; default: printLine(""Benign, fixed string""); break; } switch(7) { case 7: { int result = data + 1; printIntLine(result); } break; default: printLine(""Benign, fixed string""); break; } }"	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  + 1;
<start> printIntLine(result) <end> ;"	"int <start> result = data + 1 <end> ;
fscanf(stdin, ""%d"", <start> &data <end> );"	"int result = <start> data <end>  + 1;
fscanf(stdin, ""%d"", <start> &data <end> );"	"fscanf(stdin, ""%d"", <start> &data <end> );
int result = <start> data <end>  + 1;"	3
79b2750f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 8 void CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_64b_badSink(void * dataVoidPtr) { short * dataPtr = (short *)dataVoidPtr; short data = (*dataPtr); { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"void CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_64b_badSink(void * <start> dataVoidPtr <end> );
printLine <start> dest <end> );"	"printLine <start> dest <end> );
<start> printLine(dest) <end> ;"	"void CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_64b_badSink(void * <start> dataVoidPtr <end> );
char <start> dest[100] = """" <end> ;"	"void CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_64b_badSink(void * <start> dataVoidPtr <end> );
short <start> data = (*dataPtr) <end> ;"	0
c136624c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_console_fopen_42 { static char * badSource(char * data) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } return data; } void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; data = badSource(data); { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
static char * <start> badSource <end> (char * data);
pFile = FOPEN <start> data <end> , ""wb+"");
dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
pFile = FOPEN <start> data <end> , ""wb+"");"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
data = <start> badSource <end> (data);
char <start> dataBuffer[FILENAME_MAX] = BASEPATH <end> ;
static char * <start> badSource <end> (char * data);"	"size_t dataLen = <start> strlen(data) <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
data = <start> badSource <end> (data);"	1
ce547d1d-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_environment_fopen_14 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(globalFive==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"char <start> dataBuffer[FILENAME_MAX] = """" <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"size_t dataLen = <start> strlen(data) <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
strncat(data+dataLen, environment, FILENAME_MAX <start> dataLen-1 <end> );"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
pFile = FOPEN <start> data <end> , ""wb+"");"	3
47a2a826-6c15-11ed-81d4-94e6f77dd552	typedef struct _CWE190_Integer_Overflow__int_fscanf_add_67_structType { int structFirst; } CWE190_Integer_Overflow__int_fscanf_add_67_structType; void CWE190_Integer_Overflow__int_fscanf_add_67b_badSink(CWE190_Integer_Overflow__int_fscanf_add_67_structType myStruct) { int data = myStruct.structFirst; { int result = data + 1; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  + 1;
int data = <start> myStruct <end> .structFirst;
void CWE190_Integer_Overflow__int_fscanf_add_67b_badSink(CWE190_Integer_Overflow__int_fscanf_add_67_structType <start> myStruct <end> );"	"void CWE190_Integer_Overflow__int_fscanf_add_67b_badSink(CWE190_Integer_Overflow__int_fscanf_add_67_structType <start> myStruct <end> );
int data = <start> myStruct <end> .structFirst;
int result = <start> data <end>  + 1;"	"int result = <start> data <end>  + 1;
void CWE190_Integer_Overflow__int_fscanf_add_67b_badSink(CWE190_Integer_Overflow__int_fscanf_add_67_structType <start> myStruct <end> );
<start> printIntLine(result) <end> ;"	"void CWE190_Integer_Overflow__int_fscanf_add_67b_badSink(CWE190_Integer_Overflow__int_fscanf_add_67_structType <start> myStruct <end> );
int <start> result = data + 1 <end> ;
int data = <start> myStruct <end> .structFirst;"	1
d31a24e8-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 namespace CWE36_Absolute_Path_Traversal__char_listen_socket_ifstream_43 { void badSource(char * &data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; badSource(data); { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"replace = <start> strchr(data, '\n') <end> ;
inputFile.open((char * <start> data <end> );
badSource <start> data <end> );"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
badSource <start> data <end> );
inputFile.open((char * <start> data <end> );"	"badSource <start> data <end> );
replace = <start> strchr(data, '\n') <end> ;
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"inputFile.open((char * <start> data <end> );
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
if  <start> acceptSocket == SOCKET_ERROR <end> );"	1
b68484cd-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE369_Divide_by_Zero__int_listen_socket_modulo_82 { void bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE369_Divide_by_Zero__int_listen_socket_modulo_82_base* baseObject = new CWE369_Divide_by_Zero__int_listen_socket_modulo_82_bad; baseObject->action(data); delete baseObject; }"	where is the vulnerable dataflow from data to action ?	"baseObject->action <start> data <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
data = <start> atoi(inputBuffer) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
baseObject->action <start> data <end> );"	"baseObject->action <start> data <end> );
if  <start> recvResult == SOCKET_ERROR <end>  || recvResult == 0);"	2
669edad0-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__char_rand_postinc_66b_badSink(char dataArray[]) { char data = dataArray[2]; { data++; char result = data; printHexCharLine(result); } }	where is the vulnerable dataflow from data ?	"<start> data <end> ++;
<start> printHexCharLine(result) <end> ;"	"<start> data <end> ++;
void CWE190_Integer_Overflow__char_rand_postinc_66b_badSink(char <start> dataArray <end> []);"	"<start> data++ <end> ;
void CWE190_Integer_Overflow__char_rand_postinc_66b_badSink(char <start> dataArray <end> []);"	"void CWE190_Integer_Overflow__char_rand_postinc_66b_badSink(char <start> dataArray <end> []);
<start> data <end> ++;"	3
61da672c-6c15-11ed-81d4-94e6f77dd552	static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; void CWE190_Integer_Overflow__short_rand_multiply_04_bad() { short data; data = 0; if(STATIC_CONST_TRUE) { data = (short)RAND32(); } if(STATIC_CONST_TRUE) { if(data > 0) { short result = data * 2; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"short result = <start> data <end>  * 2;
<start> printIntLine(result) <end> ;"	"data = (short <start> RAND32() <end> ;
short <start> result = data * 2 <end> ;"	"short result = <start> data <end>  * 2;
data = (short <start> RAND32() <end> ;"	"data = (short <start> RAND32() <end> ;
short result = <start> data <end>  * 2;"	3
98b0155f-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fgets_41 { static void badSink(int data) { { int i; int * buffer = new int[10]; for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } delete[] buffer; } } void bad() { int data; data = -1; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } badSink(data); }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"<start> badSink(data) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
badSink <start> data <end> );
static void badSink(int <start> data <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
badSink <start> data <end> );
static void badSink(int <start> data <end> );
printIntLine <start> buffer[i] <end> );"	"printIntLine <start> buffer[i] <end> );
badSink <start> data <end> );
<start> data = atoi(inputBuffer) <end> ;
static void badSink(int <start> data <end> );"	"printIntLine <start> buffer[i] <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
static void badSink(int <start> data <end> );"	1
466e7eca-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__int_fgets_add_73 { void badSink(list<int> dataList) { int data = dataList.back(); { int result = data + 1; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  + 1;
void badSink(list<int> <start> dataList <end> );"	"int result = <start> data <end>  + 1;
<start> printIntLine(result) <end> ;"	"void badSink(list<int> <start> dataList <end> );
int <start> result = data + 1 <end> ;"	"void badSink(list<int> <start> dataList <end> );
int result = <start> data <end>  + 1;"	3
73bc8135-6c15-11ed-81d4-94e6f77dd552	namespace CWE194_Unexpected_Sign_Extension__connect_socket_malloc_72 { void badSink(vector<short> dataVector) { short data = dataVector[2]; if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }	where is the vulnerable dataflow from data to malloc ?	"void badSink(vector<short> <start> dataVector <end> );
char * dataBuffer = (char *)malloc <start> data <end> );"	"if  <start> data < 100 <end> );
void badSink(vector<short> <start> dataVector <end> );"	"char * dataBuffer = (char *)malloc <start> data <end> );
memset(dataBuffer, 'A', <start> data-1 <end> );"	"if  <start> dataBuffer == NULL <end> ) {exit(-1);};
char * dataBuffer = (char *)malloc <start> data <end> );"	0
5e44fc51-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_connect_socket_predec_13_bad() { int data; data = 0; if(GLOBAL_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(GLOBAL_CONST_FIVE==5) { { --data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"int <start> result = data <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"- <start> data <end> ;
<start> printIntLine(result) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
- <start> data <end> ;"	"- <start> data <end> ;
int <start> result = data <end> ;"	2
c39a6577-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_environment_fopen_52 { void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } badSink_b(data); }"	where is the vulnerable dataflow from data to badSink_b ?	"badSink_b <start> data <end> );
<start> badSink_b(data) <end> ;"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
size_t <start> dataLen = strlen(data) <end> ;"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
badSink_b <start> data <end> );"	"strncat(data+dataLen, environment, <start> FILENAME_MAX-dataLen-1 <end> );
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	2
4db33f79-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int badStatic = 0; static void badSink(int data) { if(badStatic) { { data++; int result = data; printIntLine(result); } } } void CWE190_Integer_Overflow__int_connect_socket_postinc_21_bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badStatic = 1; badSink(data); }"	where is the vulnerable dataflow from data ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int <start> result = data <end> ;
badSink <start> data <end> );
static void badSink(int <start> data <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSink <start> data <end> );
static void badSink(int <start> data <end> );
<start> data <end> ++;"	"<start> data = 0 <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data <end> ++;
badSink <start> data <end> );"	"badSink <start> data <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static void badSink(int <start> data <end> );
<start> data = atoi(inputBuffer) <end> ;"	1
4a02110c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_multiply_51b_badSink(int data) { if(data > 0) { int result = data * 2; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"void CWE190_Integer_Overflow__int_listen_socket_multiply_51b_badSink(int <start> data <end> );
int result = <start> data <end>  * 2;"	"<start> printIntLine(result) <end> ;
void CWE190_Integer_Overflow__int_listen_socket_multiply_51b_badSink(int <start> data <end> );"	"void CWE190_Integer_Overflow__int_listen_socket_multiply_51b_badSink(int <start> data <end> );
if <start> data > 0 <end> ) ;"	"int result = <start> data <end>  * 2;
void CWE190_Integer_Overflow__int_listen_socket_multiply_51b_badSink(int <start> data <end> );"	0
73bc813f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" static const int STATIC_CONST_FIVE = 5; void CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_06_bad() { short data; data = 0; if(STATIC_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
if  <start> data < 100 <end> );"	"printLine <start> dest <end> );
if  <start> data < 100 <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> memcpy(dest, source, data) <end> ;"	0
7e74f318-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_10_bad() { int data; data = -1; if(globalTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> memcpy(dest, source, data) <end> ;
printLine <start> dest <end> );"	"data = <start> atoi(inputBuffer) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> memcpy(dest, source, data) <end> ;"	2
67d010ca-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__char_rand_preinc_03_bad() { char data; data = ' '; if(5==5) { data = (char)RAND32(); } if(5==5) { { ++data; char result = data; printHexCharLine(result); } } }	where is the vulnerable dataflow from data ?	"data = (char <start> RAND32() <end> ;
char <start> result = data <end> ;"	"data = (char <start> RAND32() <end> ;
+ <start> data <end> ;"	"char <start> result = data <end> ;
+ <start> data <end> ;"	"+ <start> data <end> ;
<start> printHexCharLine(result) <end> ;"	1
93ece2c2-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING ""hello"" void CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_53d_badSink(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); } else { printLine(""Input is less than the length of the source string""); } } }"	where is the vulnerable dataflow from data to malloc ?	"void CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_53d_badSink(size_t <start> data <end> );
myString = (char *)malloc <start> data*sizeof(char) <end> );"	"if  <start> myString == NULL <end> ) {exit(-1);};
myString = (char *)malloc <start> data*sizeof(char) <end> );"	"void CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_53d_badSink(size_t <start> data <end> );
if  <start> myString == NULL <end> ) {exit(-1);};"	"myString = (char *)malloc <start> data*sizeof(char) <end> );
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_53d_badSink(size_t <start> data <end> );"	0
584fa856-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int badSource(int data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } return data; } void CWE191_Integer_Underflow__int_listen_socket_multiply_42_bad() { int data; data = 0; data = badSource(data); if(data < 0) { int result = data * 2; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static int <start> badSource <end> (int data);
data = <start> badSource <end> (data);
int result = <start> data <end>  * 2;"	"data = <start> badSource <end> (data);
int <start> result = data * 2 <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static int <start> badSource <end> (int data);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static int <start> badSource <end> (int data);"	"data = <start> badSource <end> (data);
static int <start> badSource <end> (int data);
int result = <start> data <end>  * 2;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	0
85b15ee3-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE369_Divide_by_Zero__int_connect_socket_modulo_43 { static void badSource(int &data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } void bad() { int data; data = -1; badSource(data); printIntLine(100 % data); }"	where is the vulnerable dataflow from data to printIntLine ?	"printIntLine <start> 100 % data <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
data = <start> atoi(inputBuffer) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSource <start> data <end> );
printIntLine <start> 100 % data <end> );"	"printIntLine <start> 100 % data <end> );
badSource <start> data <end> );"	"badSource <start> data <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> 100 % data <end> );"	1
9c455191-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int badSource(int data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } return data; } void CWE124_Buffer_Underwrite__CWE839_listen_socket_42_bad() { int data; data = -1; data = badSource(data); { int i; int buffer[10] = { 0 }; if (data < 10) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } } }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"printIntLine <start> buffer[i] <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int <start> buffer[10] = { 0 } <end> ;
data = <start> badSource <end> (data);"	"data = <start> badSource <end> (data);
static int <start> badSource <end> (int data);
printIntLine <start> buffer[i] <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static int <start> badSource <end> (int data);
data = <start> badSource <end> (data);
printIntLine <start> buffer[i] <end> );"	"static int <start> badSource <end> (int data);
printIntLine <start> buffer[i] <end> );
data = <start> badSource <end> (data);
<start> recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	2
d31a251b-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_listen_socket_open_13 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(GLOBAL_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"size_t <start> dataLen = strlen(data) <end> ;
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"size_t dataLen = <start> strlen(data) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	3
b68484f3-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(count) + 2) namespace CWE400_Resource_Exhaustion__listen_socket_for_loop_81 { void bad() { int count; count = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; count = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } const CWE400_Resource_Exhaustion__listen_socket_for_loop_81_base& baseObject = CWE400_Resource_Exhaustion__listen_socket_for_loop_81_bad(); baseObject.action(count); }"	where is the vulnerable dataflow from count to action ?	"baseObject.action <start> count <end> );
if  <start> listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
baseObject.action <start> count <end> );"	"if  <start> listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
baseObject.action <start> count <end> );"	1
bc721f64-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #define EXECLP _execlp #else #define EXECLP execlp #endif typedef struct _CWE78_OS_Command_Injection__char_console_execlp_67_structType { char * structFirst; } CWE78_OS_Command_Injection__char_console_execlp_67_structType; void CWE78_OS_Command_Injection__char_console_execlp_67b_badSink(CWE78_OS_Command_Injection__char_console_execlp_67_structType myStruct) { char * data = myStruct.structFirst; EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECLP ?	"void CWE78_OS_Command_Injection__char_console_execlp_67b_badSink(CWE78_OS_Command_Injection__char_console_execlp_67_structType <start> myStruct <end> );
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
char * data = <start> myStruct <end> .structFirst;"	"void CWE78_OS_Command_Injection__char_console_execlp_67b_badSink(CWE78_OS_Command_Injection__char_console_execlp_67_structType <start> myStruct <end> );
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"void CWE78_OS_Command_Injection__char_console_execlp_67b_badSink(CWE78_OS_Command_Injection__char_console_execlp_67_structType <start> myStruct <end> );
char * data = <start> myStruct <end> .structFirst;
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"char * data = <start> myStruct <end> .structFirst;
<start> EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL) <end> ;
void CWE78_OS_Command_Injection__char_console_execlp_67b_badSink(CWE78_OS_Command_Injection__char_console_execlp_67_structType <start> myStruct <end> );"	2
964cdbff-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FULL_COMMAND ""dir "" #else #define FULL_COMMAND ""ls "" #endif #ifdef _WIN32 #define POPEN _popen #define PCLOSE _pclose #else #define POPEN popen #define PCLOSE pclose #endif namespace CWE78_OS_Command_Injection__char_file_popen_73 { void badSink(list<char *> dataList) { char * data = dataList.back(); { FILE *pipe; pipe = POPEN(data, ""w""); if (pipe != NULL) { PCLOSE(pipe); } } }"	where is the vulnerable dataflow from data to POPEN ?	"void badSink(list<char *> <start> dataList <end> );
char <start> * data = dataList.back() <end> ;"	"pipe = POPEN <start> data <end> , ""w"");
void badSink(list<char *> <start> dataList <end> );"	"void badSink(list<char *> <start> dataList <end> );
pipe = POPEN <start> data <end> , ""w"");"	"pipe = <start> POPEN(data, ""w"") <end> ;
void badSink(list<char *> <start> dataList <end> );"	2
bda4e42b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define EXECLP _execlp #else #define EXECLP execlp #endif void CWE78_OS_Command_Injection__char_listen_socket_execlp_01_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECLP ?	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"replace = <start> strchr(data, '\r') <end> ;
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
char <start> dataBuffer[100] = COMMAND_ARG2 <end> ;"	"EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
recvResult = <start> recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0) <end> ;"	0
bc721f69-6c15-11ed-81d4-94e6f77dd552	"namespace CWE78_OS_Command_Injection__char_console_system_81 { void bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } const CWE78_OS_Command_Injection__char_console_system_81_base& baseObject = CWE78_OS_Command_Injection__char_console_system_81_bad(); baseObject.action(data); }"	where is the vulnerable dataflow from data to action ?	"dataLen = <start> strlen(data) <end> ;
baseObject.action <start> data <end> );"	"baseObject.action <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	"<start> data = data_buf <end> ;
baseObject.action <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
baseObject.action <start> data <end> );"	3
6dc61506-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; void CWE134_Uncontrolled_Format_String__char_console_snprintf_04_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; if(STATIC_CONST_TRUE) { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } if(STATIC_CONST_TRUE) { { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } } }"	where is the vulnerable dataflow from dest to printLine ?	"printLine <start> dest <end> );
SNPRINTF(dest, <start> 100-1 <end> , data);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
char <start> dataBuffer[100] = """" <end> ;"	"<start> SNPRINTF(dest, 100-1, data) <end> ;
printLine <start> dest <end> );"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
printLine <start> dest <end> );"	3
b54bcf4d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE369_Divide_by_Zero__int_connect_socket_divide_82 { void bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE369_Divide_by_Zero__int_connect_socket_divide_82_base* baseObject = new CWE369_Divide_by_Zero__int_connect_socket_divide_82_bad; baseObject->action(data); delete baseObject; }"	where is the vulnerable dataflow from data to action ?	"baseObject->action <start> data <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"data = <start> atoi(inputBuffer) <end> ;
baseObject->action <start> data <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
baseObject->action <start> data <end> );"	"baseObject->action <start> data <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	2
a95fd840-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_fgets_multiply_65b_badSink(int data) { if(data < 0) { int result = data * 2; printIntLine(result); } }	where is the vulnerable dataflow from result to printIntLine ?	"void CWE191_Integer_Underflow__int_fgets_multiply_65b_badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"void CWE191_Integer_Underflow__int_fgets_multiply_65b_badSink(int <start> data <end> );
if <start> data < 0 <end> ) ;"	"int <start> result = data * 2 <end> ;
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
void CWE191_Integer_Underflow__int_fgets_multiply_65b_badSink(int <start> data <end> );"	0
9fe7ad39-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 namespace CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_81 { void bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } const CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_81_base& baseObject = CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_81_bad(); baseObject.action(data); }"	where is the vulnerable dataflow from data to action ?	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (100 - dataLen - 1), 0);"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
baseObject.action <start> data <end> );"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
size_t dataLen = <start> strlen(data) <end> ;"	"baseObject.action <start> data <end> );
replace = <start> strchr(data, '\n') <end> ;"	1
b1b80825-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_10_bad() { int data; data = -1; if(globalTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { short shortData = (short)data; printShortLine(shortData); } }"	where is the vulnerable dataflow from shortData to printShortLine ?	"printShortLine <start> shortData <end> );
if  <start> listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR <end> );"	"printShortLine <start> shortData <end> );
short <start> shortData = (short)data <end> ;"	"<start> printShortLine(shortData) <end> ;
printShortLine <start> shortData <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printShortLine <start> shortData <end> );"	3
5d16c9d8-6c15-11ed-81d4-94e6f77dd552	"static unsigned int badSource(unsigned int data) { fscanf (stdin, ""%u"", &data); return data; } void CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_42_bad() { unsigned int data; data = 0; data = badSource(data); { data--; unsigned int result = data; printUnsignedLine(result); } }"	where is the vulnerable dataflow from data ?	"fscanf (stdin, ""%u"", <start> &data <end> );
static unsigned int <start> badSource <end> (unsigned int data);"	"fscanf (stdin, ""%u"", <start> &data <end> );
data = <start> badSource <end> (data);
static unsigned int <start> badSource <end> (unsigned int data);"	"static unsigned int <start> badSource <end> (unsigned int data);
<start> data <end> --;
fscanf (stdin, ""%u"", <start> &data <end> );
data = <start> badSource <end> (data);"	"fscanf (stdin, ""%u"", <start> &data <end> );
static unsigned int <start> badSource <end> (unsigned int data);
data = <start> badSource <end> (data);
<start> data <end> --;"	3
8cc3a673-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(count) + 2) #ifdef _WIN32 #define SLEEP Sleep #else #define SLEEP usleep #endif void CWE400_Resource_Exhaustion__fgets_sleep_12_bad() { int count; count = -1; if(globalReturnsTrueOrFalse()) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { count = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } else { count = 20; } if(globalReturnsTrueOrFalse()) { SLEEP(count); printLine(""Sleep time possibly too long""); } else { if (count > 0 && count <= 2000) { SLEEP(count); printLine(""Sleep time OK""); } else { printLine(""Sleep time too long""); } } }"	where is the vulnerable dataflow from count to SLEEP ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
if  <start> count > 0 <end>  && count <= 2000);"	"count = <start> atoi(inputBuffer) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
SLEEP <start> count <end> );"	"SLEEP <start> count <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	2
aa91a197-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_listen_socket_sub_31_bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { int dataCopy = data; int data = dataCopy; { int result = data - 1; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	"<start> printIntLine(result) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"printIntLine <start> result <end> );
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	3
92bb8a0f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define SEARCH_CHAR 'S' char * CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_61b_badSource(char * data); void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_61_bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\0'; data = CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_61b_badSource(data); for (; *data != '\0'; data++) { if (*data == SEARCH_CHAR) { printLine(""We have a match!""); break; } } free(data); }"	where is the vulnerable dataflow from data to free ?	"for (; *data != '\0'; <start> data++ <end> );
data = <start> CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_61b_badSource <end> (data);"	"free <start> data <end> );
for (; *data != '\0'; <start> data++ <end> );"	"data = <start> CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_61b_badSource <end> (data);
free <start> data <end> );"	"free <start> data <end> );
<start> free(data) <end> ;"	2
a36a78e8-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticFive = 5; void CWE190_Integer_Overflow__int_listen_socket_add_07_bad() { int data; data = 0; if(staticFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticFive==5) { { int result = data + 1; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int <start> result = data + 1 <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printIntLine(result) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	2
b6848514-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define NEW_PATH ""%SystemRoot%\\system32"" #define PUTENV _putenv #else #define NEW_PATH ""/bin"" #define PUTENV putenv #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" void CWE427_Uncontrolled_Search_Path_Element__char_connect_socket_64b_badSink(void * dataVoidPtr) { char * * dataPtr = (char * *)dataVoidPtr; char * data = (*dataPtr); PUTENV(data); }"	where is the vulnerable dataflow from data to PUTENV ?	"void CWE427_Uncontrolled_Search_Path_Element__char_connect_socket_64b_badSink(void * <start> dataVoidPtr <end> );
<start> PUTENV(data) <end> ;"	"void CWE427_Uncontrolled_Search_Path_Element__char_connect_socket_64b_badSink(void * <start> dataVoidPtr <end> );
PUTENV <start> data <end> );"	"PUTENV <start> data <end> );
void CWE427_Uncontrolled_Search_Path_Element__char_connect_socket_64b_badSink(void * <start> dataVoidPtr <end> );"	"<start> PUTENV(data) <end> ;
PUTENV <start> data <end> );"	1
b54bcf37-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 20 namespace CWE369_Divide_by_Zero__float_listenSocket_43 { static void badSource(float &data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = (float)atof(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } void bad() { float data; data = 0.0F; badSource(data); { int result = (int)(100.0 / data); printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
if  <start> recvResult == SOCKET_ERROR <end>  || recvResult == 0);
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSource <start> data <end> );
printIntLine <start> result <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSource <start> data <end> );
<start> printIntLine(result) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	1
435200f2-6c15-11ed-81d4-94e6f77dd552	"static void badSink(int64_t data) { if(data > 0) { int64_t result = data * 2; printLongLongLine(result); } } void CWE190_Integer_Overflow__int64_t_fscanf_multiply_44_bad() { int64_t data; void (*funcPtr) (int64_t) = badSink; data = 0LL; fscanf (stdin, ""%"" SCNd64, &data); funcPtr(data); }"	where is the vulnerable dataflow from data ?	"fscanf (stdin, ""%"" SCNd64, <start> &data <end> );
funcPtr <start> data <end> );
static void badSink(int64_t <start> data <end> );
int64_t result = <start> data <end>  * 2;"	"int64_t result = <start> data <end>  * 2;
funcPtr <start> data <end> );
static void badSink(int64_t <start> data <end> );
fscanf (stdin, ""%"" SCNd64, <start> &data <end> );"	"static void badSink(int64_t <start> data <end> );
fscanf (stdin, ""%"" SCNd64, <start> &data <end> );
int64_t result = <start> data <end>  * 2;"	"<start> funcPtr(data) <end> ;
fscanf (stdin, ""%"" SCNd64, <start> &data <end> );
int64_t result = <start> data <end>  * 2;
static void badSink(int64_t <start> data <end> );"	0
6a52beeb-6c15-11ed-81d4-94e6f77dd552	static int badStatic = 0; static void badSink(unsigned int data) { if(badStatic) { { data--; unsigned int result = data; printUnsignedLine(result); } } } void CWE191_Integer_Underflow__unsigned_int_rand_postdec_21_bad() { unsigned int data; data = 0; data = (unsigned int)RAND32(); badStatic = 1; badSink(data); }	where is the vulnerable dataflow from data ?	"<start> badSink(data) <end> ;
static void badSink(unsigned int <start> data <end> );
data = (unsigned int <start> RAND32() <end> ;
<start> data <end> --;"	"data = (unsigned int <start> RAND32() <end> ;
badSink <start> data <end> );
static void badSink(unsigned int <start> data <end> );
<start> data <end> --;"	"badSink <start> data <end> );
data = (unsigned int <start> RAND32() <end> ;
static void badSink(unsigned int <start> data <end> );"	"data = (unsigned int <start> RAND32() <end> ;
<start> data <end> --;
badSink <start> data <end> );
static void badSink(unsigned int <start> data <end> );"	1
c01af8ac-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" namespace CWE23_Relative_Path_Traversal__char_connect_socket_ofstream_11 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(globalReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
outputFile.open((char * <start> data <end> );"	"<start> data = dataBuffer <end> ;
outputFile.open((char * <start> data <end> );"	"recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - <start> dataLen - 1 <end> ), 0);
outputFile.open((char * <start> data <end> );"	"size_t dataLen = <start> strlen(data) <end> ;
outputFile.open((char * <start> data <end> );"	0
4a021103-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int badStatic = 0; static void badSink(int data) { if(badStatic) { if(data > 0) { int result = data * 2; printIntLine(result); } } } void CWE190_Integer_Overflow__int_listen_socket_multiply_21_bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badStatic = 1; badSink(data); }"	where is the vulnerable dataflow from data ?	"recvResult = recv(acceptSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);
int result = <start> data <end>  * 2;
badSink <start> data <end> );
static void badSink(int <start> data <end> );"	"<start> data = atoi(inputBuffer) <end> ;
static void badSink(int <start> data <end> );
badSink <start> data <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSink <start> data <end> );
static void badSink(int <start> data <end> );
int result = <start> data <end>  * 2;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static void badSink(int <start> data <end> );
int result = <start> data <end>  * 2;
<start> data = 0 <end> ;"	2
c72d5d36-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_file_open_44 { static void badSink(char * data) { { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } } void bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } funcPtr(data); }"	where is the vulnerable dataflow from data to funcPtr ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
<start> data = dataBuffer <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
<start> funcPtr(data) <end> ;"	"fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);
funcPtr <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
funcPtr <start> data <end> );"	3
a830bf8f-6c15-11ed-81d4-94e6f77dd552	namespace CWE191_Integer_Underflow__int_connect_socket_multiply_82 { void CWE191_Integer_Underflow__int_connect_socket_multiply_82_bad::action(int data) { if(data < 0) { int result = data * 2; printIntLine(result); } } }	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
void CWE191_Integer_Underflow__int_connect_socket_multiply_82_bad::action(int <start> data <end> );"	"void CWE191_Integer_Underflow__int_connect_socket_multiply_82_bad::action(int <start> data <end> );
printIntLine <start> result <end> );"	"int result = <start> data * 2 <end> ;
void CWE191_Integer_Underflow__int_connect_socket_multiply_82_bad::action(int <start> data <end> );"	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	1
a830bf69-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_FIVE = 5; void CWE191_Integer_Underflow__int_connect_socket_multiply_06_bad() { int data; data = 0; if(STATIC_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(STATIC_CONST_FIVE==5) { if(data < 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"printIntLine <start> result <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	1
b2ea8dbf-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 8 void CWE197_Numeric_Truncation_Error__short_fgets_11_bad() { short data; data = -1; if(globalReturnsTrue()) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = (short)atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } { char charData = (char)data; printHexCharLine(charData); } }"	where is the vulnerable dataflow from charData to printHexCharLine ?	"printHexCharLine <start> charData <end> );
<start> printHexCharLine(charData) <end> ;"	"printHexCharLine <start> charData <end> );
char <start> charData = (char)data <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printHexCharLine <start> charData <end> );"	"<start> printHexCharLine(charData) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	2
584fa89c-6c15-11ed-81d4-94e6f77dd552	"void CWE191_Integer_Underflow__short_fscanf_multiply_11_bad() { short data; data = 0; if(globalReturnsTrue()) { fscanf (stdin, ""%hd"", &data); } if(globalReturnsTrue()) { if(data < 0) { short result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"short result = <start> data <end>  * 2;
<start> printIntLine(result) <end> ;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
short result = <start> data * 2 <end> ;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
short result = <start> data <end>  * 2;"	"short result = <start> data <end>  * 2;
fscanf (stdin, ""%hd"", <start> &data <end> );"	2
b08640cd-6c15-11ed-81d4-94e6f77dd552	namespace CWE197_Numeric_Truncation_Error__int_fgets_to_char_72 { void badSink(vector<int> dataVector) { int data = dataVector[2]; { char charData = (char)data; printHexCharLine(charData); } }	where is the vulnerable dataflow from charData to printHexCharLine ?	"printHexCharLine <start> charData <end> );
<start> printHexCharLine(charData) <end> ;"	"printHexCharLine <start> charData <end> );
char <start> charData = (char)data <end> ;"	"void badSink(vector<int> <start> dataVector <end> );
printHexCharLine <start> charData <end> );"	"char <start> charData = (char)data <end> ;
void badSink(vector<int> <start> dataVector <end> );"	2
7ae3a744-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_41_badSink(int data) { { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } } void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_41_bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_41_badSink(data); }"	where is the vulnerable dataflow from dest to printLine ?	"char <start> dest[100] = """" <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_41_badSink <start> data <end> );
void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_41_badSink(int <start> data <end> );"	"if  <start> data < 100 <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_41_badSink <start> data <end> );
printLine <start> dest <end> );"	"CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_41_badSink <start> data <end> );
recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);
printLine <start> dest <end> );
void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_41_badSink(int <start> data <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_41_badSink <start> data <end> );
void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_41_badSink(int <start> data <end> );
printLine <start> dest <end> );"	3
c26a7e73-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_environment_fopen_21 { static int badStatic = 0; static char * badSource(char * data) { if(badStatic) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } } return data; } void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; badStatic = 1; data = badSource(data); { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } ; }"	where is the vulnerable dataflow from data to FOPEN ?	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
size_t dataLen = <start> strlen(data) <end> ;
static char * <start> badSource <end> (char * data);
pFile = FOPEN <start> data <end> , ""wb+"");"	"strncat(data+dataLen, environment, <start> FILENAME_MAX-dataLen-1 <end> );
static char * <start> badSource <end> (char * data);
char * environment = <start> GETENV <end> (ENV_VARIABLE);
data = <start> badSource <end> (data);"	"pFile = FOPEN <start> data <end> , ""wb+"");
data = <start> badSource <end> (data);
static char * <start> badSource <end> (char * data);"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
pFile = FOPEN <start> data <end> , ""wb+"");"	3
b41b876c-6c15-11ed-81d4-94e6f77dd552	namespace CWE197_Numeric_Truncation_Error__short_listen_socket_74 { void badSink(map<int, short> dataMap) { short data = dataMap[2]; { char charData = (char)data; printHexCharLine(charData); } }	where is the vulnerable dataflow from charData to printHexCharLine ?	"void badSink(map<int, short> <start> dataMap <end> );
printHexCharLine <start> charData <end> );"	"printHexCharLine <start> charData <end> );
char <start> charData = (char)data <end> ;"	"printHexCharLine <start> charData <end> );
void badSink(map<int, short> <start> dataMap <end> );"	"char <start> charData = (char)data <end> ;
void badSink(map<int, short> <start> dataMap <end> );"	0
bb49c588-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #define EXECL _execl #else #define EXECL execl #endif void CWE78_OS_Command_Injection__char_console_execl_14_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(globalFive==5) { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECL ?	"if  <start> 100-dataLen <end>  > 1);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	"dataLen = <start> strlen(data) <end> ;
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"if  <start> 100-dataLen <end>  > 1);
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	3
571e97fa-6c15-11ed-81d4-94e6f77dd552	"static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; void CWE191_Integer_Underflow__int_fscanf_multiply_04_bad() { int data; data = 0; if(STATIC_CONST_TRUE) { fscanf(stdin, ""%d"", &data); } if(STATIC_CONST_TRUE) { if(data < 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"fscanf(stdin, ""%d"", <start> &data <end> );
<start> data = 0 <end> ;"	"fscanf(stdin, ""%d"", <start> &data <end> );
int result = <start> data <end>  * 2;"	"int result = <start> data <end>  * 2;
fscanf(stdin, ""%d"", <start> &data <end> );"	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  * 2;"	1
c26a7e6e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_environment_fopen_14 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(globalFive==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"size_t dataLen = <start> strlen(data) <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
pFile = FOPEN <start> data <end> , ""wb+"");"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	"strncat(data+dataLen, environment, <start> FILENAME_MAX-dataLen-1 <end> );
pFile = FOPEN <start> data <end> , ""wb+"");"	1
a830bf59-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int CWE190_Integer_Overflow__int_listen_socket_preinc_45_badData; static int CWE190_Integer_Overflow__int_listen_socket_preinc_45_goodG2BData; static int CWE190_Integer_Overflow__int_listen_socket_preinc_45_goodB2GData; static void badSink() { int data = CWE190_Integer_Overflow__int_listen_socket_preinc_45_badData; { ++data; int result = data; printIntLine(result); } } void CWE190_Integer_Overflow__int_listen_socket_preinc_45_bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE190_Integer_Overflow__int_listen_socket_preinc_45_badData = data; badSink(); }"	where is the vulnerable dataflow from result to printIntLine ?	"if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );
int data = <start> CWE190_Integer_Overflow__int_listen_socket_preinc_45_badData <end> ;
printIntLine <start> result <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> CWE190_Integer_Overflow__int_listen_socket_preinc_45_badData = data <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> CWE190_Integer_Overflow__int_listen_socket_preinc_45_badData = data <end> ;
int data = <start> CWE190_Integer_Overflow__int_listen_socket_preinc_45_badData <end> ;
static int <start> CWE190_Integer_Overflow__int_listen_socket_preinc_45_badData <end> ;
int <start> result = data <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> CWE190_Integer_Overflow__int_listen_socket_preinc_45_badData = data <end> ;
static int <start> CWE190_Integer_Overflow__int_listen_socket_preinc_45_badData <end> ;
int data = <start> CWE190_Integer_Overflow__int_listen_socket_preinc_45_badData <end> ;
printIntLine <start> result <end> );"	"<start> CWE190_Integer_Overflow__int_listen_socket_preinc_45_badData = data <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int data = <start> CWE190_Integer_Overflow__int_listen_socket_preinc_45_badData <end> ;
static int <start> CWE190_Integer_Overflow__int_listen_socket_preinc_45_badData <end> ;
data = <start> atoi(inputBuffer) <end> ;"	2
92bb89f5-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define SEARCH_CHAR 'S' void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_01_bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\0'; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } for (; *data != '\0'; data++) { if (*data == SEARCH_CHAR) { printLine(""We have a match!""); break; } } free(data); }"	where is the vulnerable dataflow from data to free ?	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
free <start> data <end> );"	"<start> free(data) <end> ;
free <start> data <end> );"	"free <start> data <end> );
<start> data = (char *)malloc(100*sizeof(char)) <end> ;"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
for (; *data != '\0'; <start> data++ <end> );"	0
79b27538-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) int CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_61b_badSource(int data); void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_61_bad() { int data; data = -1; data = CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_61b_badSource(data); if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }"	where is the vulnerable dataflow from data to malloc ?	"if  <start> dataBuffer == NULL <end> ) {exit(-1);};
char * dataBuffer = (char *)malloc <start> data <end> );"	"data = <start> CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_61b_badSource <end> (data);
char * dataBuffer = (char *)malloc <start> data <end> );"	"if  <start> data < 100 <end> );
data = <start> CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_61b_badSource <end> (data);"	"char <start> * dataBuffer = (char *)malloc(data) <end> ;
char * dataBuffer = (char *)malloc <start> data <end> );"	1
951c5ea6-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FULL_COMMAND ""dir "" #else #define FULL_COMMAND ""ls "" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define POPEN _popen #define PCLOSE _pclose #else #define POPEN popen #define PCLOSE pclose #endif static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; void CWE78_OS_Command_Injection__char_file_popen_04_bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; if(STATIC_CONST_TRUE) { { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } { FILE *pipe; pipe = POPEN(data, ""w""); if (pipe != NULL) { PCLOSE(pipe); } } }"	where is the vulnerable dataflow from data to POPEN ?	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	"size_t dataLen = <start> strlen(data) <end> ;
pipe = POPEN <start> data <end> , ""w"");"	"pipe = <start> POPEN(data, ""w"") <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
pipe = POPEN <start> data <end> , ""w"");"	3
a6fd8257-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_preinc_65b_badSink(int data) { { ++data; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
void CWE190_Integer_Overflow__int_connect_socket_preinc_65b_badSink(int <start> data <end> );"	"void CWE190_Integer_Overflow__int_connect_socket_preinc_65b_badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"int <start> result = data <end> ;
printIntLine <start> result <end> );"	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	1
b08640ee-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE197_Numeric_Truncation_Error__int_fgets_to_short_52c_badSink(int data) { { short shortData = (short)data; printShortLine(shortData); } }	where is the vulnerable dataflow from shortData to printShortLine ?	"short <start> shortData = (short)data <end> ;
printShortLine <start> shortData <end> );"	"void CWE197_Numeric_Truncation_Error__int_fgets_to_short_52c_badSink(int <start> data <end> );
<start> printShortLine(shortData) <end> ;"	"void CWE197_Numeric_Truncation_Error__int_fgets_to_short_52c_badSink(int <start> data <end> );
short <start> shortData = (short)data <end> ;"	"void CWE197_Numeric_Truncation_Error__int_fgets_to_short_52c_badSink(int <start> data <end> );
printShortLine <start> shortData <end> );"	3
54c581f2-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) typedef union { int unionFirst; int unionSecond; } CWE191_Integer_Underflow__int_connect_socket_multiply_34_unionType; void CWE191_Integer_Underflow__int_connect_socket_multiply_34_bad() { int data; CWE191_Integer_Underflow__int_connect_socket_multiply_34_unionType myUnion; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } myUnion.unionFirst = data; { int data = myUnion.unionSecond; if(data < 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
int result = <start> data <end>  * 2;"	"if <start> data < 0 <end> ) ;
int result = <start> data <end>  * 2;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  * 2;"	3
b7b09a44-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define NEW_PATH ""%SystemRoot%\\system32"" #define PUTENV _putenv #else #define NEW_PATH ""/bin"" #define PUTENV putenv #endif static void badSink(char * data) { PUTENV(data); } void CWE427_Uncontrolled_Search_Path_Element__char_console_44_bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[250] = ""PATH=""; data = dataBuffer; { size_t dataLen = strlen(data); if (250-dataLen > 1) { if (fgets(data+dataLen, (int)(250-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } funcPtr(data); }"	where is the vulnerable dataflow from data to PUTENV ?	"if (fgets <start> data+dataLen <end> , (int)(250-dataLen), stdin) != NULL);
funcPtr <start> data <end> );
static void badSink(char * <start> data <end> );
PUTENV <start> data <end> );"	"<start> funcPtr(data) <end> ;
static void badSink(char * <start> data <end> );
funcPtr <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(250-dataLen), stdin) != NULL);"	"char <start> dataBuffer[250] = ""PATH="" <end> ;
PUTENV <start> data <end> );
funcPtr <start> data <end> );
static void badSink(char * <start> data <end> );"	"PUTENV <start> data <end> );
funcPtr <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(250-dataLen), stdin) != NULL);
dataLen = <start> strlen(data) <end> ;"	0
92bb8a0d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define SEARCH_CHAR 'S' static void badSink(char * data) { for (; *data != '\0'; data++) { if (*data == SEARCH_CHAR) { printLine(""We have a match!""); break; } } free(data); } void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_44_bad() { char * data; void (*funcPtr) (char *) = badSink; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\0'; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } funcPtr(data); }"	where is the vulnerable dataflow from data to free ?	"static void badSink(char * <start> data <end> );
<start> free(data) <end> ;
funcPtr <start> data <end> );
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"funcPtr <start> data <end> );
if  <start> data == NULL <end> ) {exit(-1);};
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
free <start> data <end> );"	"size_t dataLen = <start> strlen(data) <end> ;
free <start> data <end> );
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
funcPtr <start> data <end> );"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
funcPtr <start> data <end> );
static void badSink(char * <start> data <end> );
free <start> data <end> );"	3
571e97fd-6c15-11ed-81d4-94e6f77dd552	"static int staticFive = 5; void CWE191_Integer_Underflow__int_fscanf_multiply_07_bad() { int data; data = 0; if(staticFive==5) { fscanf(stdin, ""%d"", &data); } if(staticFive==5) { if(data < 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> data = 0 <end> ;
fscanf(stdin, ""%d"", <start> &data <end> );"	"fscanf(stdin, ""%d"", <start> &data <end> );
int result = <start> data <end>  * 2;"	"int result = <start> data <end>  * 2;
<start> printIntLine(result) <end> ;"	"fscanf(stdin, ""%d"", <start> &data <end> );
int <start> result = data * 2 <end> ;"	1
bda4e43a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define EXECLP _execlp #else #define EXECLP execlp #endif void CWE78_OS_Command_Injection__char_listen_socket_execlp_16_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; while(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; } EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECLP ?	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"<start> data = dataBuffer <end> ;
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
size_t dataLen = <start> strlen(data) <end> ;"	"size_t dataLen = <start> strlen(data) <end> ;
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	0
cbf237d9-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif namespace CWE36_Absolute_Path_Traversal__char_console_ifstream_31 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } { char * dataCopy = data; char * data = dataCopy; { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } } }"	where is the vulnerable dataflow from data to open ?	"inputFile.open((char * <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	"char <start> dataBuffer[FILENAME_MAX] = """" <end> ;
inputFile.open((char * <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
inputFile.open((char * <start> data <end> );"	"dataLen = <start> strlen(data) <end> ;
inputFile.open((char * <start> data <end> );"	2
5af03df2-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_FIVE = 5; void CWE191_Integer_Underflow__int_connect_socket_postdec_06_bad() { int data; data = 0; if(STATIC_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(STATIC_CONST_FIVE==5) { { data--; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"<start> data <end> --;
data = <start> atoi(inputBuffer) <end> ;"	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
<start> data <end> --;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data <end> --;"	3
5be3a99d-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_fgets_postdec_51b_badSink(int data) { { data--; int result = data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
<start> data <end> --;"	"<start> printIntLine(result) <end> ;
void CWE191_Integer_Underflow__int_fgets_postdec_51b_badSink(int <start> data <end> );"	"<start> data <end> --;
void CWE191_Integer_Underflow__int_fgets_postdec_51b_badSink(int <start> data <end> );"	"void CWE191_Integer_Underflow__int_fgets_postdec_51b_badSink(int <start> data <end> );
<start> data <end> --;"	3
92bb8a12-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define SEARCH_CHAR 'S' void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_64b_badSink(void * dataVoidPtr) { char * * dataPtr = (char * *)dataVoidPtr; char * data = (*dataPtr); for (; *data != '\0'; data++) { if (*data == SEARCH_CHAR) { printLine(""We have a match!""); break; } } free(data); }"	where is the vulnerable dataflow from data to free ?	"void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_64b_badSink(void * <start> dataVoidPtr <end> );
<start> free(data) <end> ;"	"free <start> data <end> );
void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_64b_badSink(void * <start> dataVoidPtr <end> );"	"for (; *data != '\0'; <start> data++ <end> );
void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_64b_badSink(void * <start> dataVoidPtr <end> );"	"void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_listen_socket_64b_badSink(void * <start> dataVoidPtr <end> );
free <start> data <end> );"	3
74ee2415-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE 8 void CWE194_Unexpected_Sign_Extension__fgets_malloc_63b_badSink(short * dataPtr) { short data = *dataPtr; if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }	where is the vulnerable dataflow from data to malloc ?	"void CWE194_Unexpected_Sign_Extension__fgets_malloc_63b_badSink(short * <start> dataPtr <end> );
char * dataBuffer = (char *)malloc <start> data <end> );"	"if  <start> dataBuffer == NULL <end> ) {exit(-1);};
void CWE194_Unexpected_Sign_Extension__fgets_malloc_63b_badSink(short * <start> dataPtr <end> );"	"memset(dataBuffer, 'A', <start> data-1 <end> );
void CWE194_Unexpected_Sign_Extension__fgets_malloc_63b_badSink(short * <start> dataPtr <end> );"	"char * dataBuffer = (char *)malloc <start> data <end> );
<start> free(dataBuffer) <end> ;"	0
67d010a8-6c15-11ed-81d4-94e6f77dd552	static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; void CWE190_Integer_Overflow__short_rand_postinc_04_bad() { short data; data = 0; if(STATIC_CONST_TRUE) { data = (short)RAND32(); } if(STATIC_CONST_TRUE) { { data++; short result = data; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"data = (short <start> RAND32() <end> ;
<start> data <end> ++;"	"short <start> result = data <end> ;
<start> data <end> ++;"	"<start> data <end> ++;
data = (short <start> RAND32() <end> ;"	"data = (short <start> RAND32() <end> ;
<start> printIntLine(result) <end> ;"	0
9c455192-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE124_Buffer_Underwrite__CWE839_listen_socket_43 { static void badSource(int &data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } void bad() { int data; data = -1; badSource(data); { int i; int buffer[10] = { 0 }; if (data < 10) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } } }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"printIntLine <start> buffer[i] <end> );
badSource <start> data <end> );"	"if  <start> listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR <end> );
printIntLine <start> buffer[i] <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
badSource <start> data <end> );
printIntLine <start> buffer[i] <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSource <start> data <end> );
printIntLine <start> buffer[i] <end> );"	3
715a3c05-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif namespace CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_82 { void CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_82_bad::action(char * data) { { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } } }"	where is the vulnerable dataflow from dest to printLine ?	"printLine <start> dest <end> );
<start> SNPRINTF(dest, 100-1, data) <end> ;"	"void CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_82_bad::action(char * <start> data <end> );
<start> printLine(dest) <end> ;"	"<start> SNPRINTF(dest, 100-1, data) <end> ;
void CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_82_bad::action(char * <start> data <end> );"	"void CWE134_Uncontrolled_Format_String__char_listen_socket_snprintf_82_bad::action(char * <start> data <end> );
printLine <start> dest <end> );"	3
9059f3d3-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define SEARCH_CHAR 'S' void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_02_bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\0'; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } if(1) { for (; *data != '\0'; data++) { if (*data == SEARCH_CHAR) { printLine(""We have a match!""); break; } } free(data); } }"	where is the vulnerable dataflow from data to free ?	"for (; *data != '\0'; <start> data++ <end> );
free <start> data <end> );"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (100 - dataLen - 1), 0);
free <start> data <end> );"	"<start> free(data) <end> ;
free <start> data <end> );"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
free <start> data <end> );"	3
6dc6150a-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } void CWE134_Uncontrolled_Format_String__char_console_snprintf_08_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; if(staticReturnsTrue()) { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } if(staticReturnsTrue()) { { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } } }"	where is the vulnerable dataflow from dest to printLine ?	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
size_t dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
<start> printLine(dest) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
printLine <start> dest <end> );"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
dataLen = <start> strlen(data) <end> ;"	2
5133a745-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink(int data) { { ++data; int result = data; printIntLine(result); } } void CWE190_Integer_Overflow__int_connect_socket_preinc_41_bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badSink(data); }"	where is the vulnerable dataflow from data ?	"+ <start> data <end> ;
static void badSink(int <start> data <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> badSink(data) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSink <start> data <end> );
static void badSink(int <start> data <end> );
+ <start> data <end> ;"	"+ <start> data <end> ;
static void badSink(int <start> data <end> );
badSink <start> data <end> );
int <start> result = data <end> ;"	"+ <start> data <end> ;
static void badSink(int <start> data <end> );
recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);
badSink <start> data <end> );"	1
8df421e4-6c15-11ed-81d4-94e6f77dd552	"#define MAX_LOOP 10000 #ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" void CWE606_Unchecked_Loop_Condition__char_connect_socket_17_bad() { int i,j; char * data; char dataBuffer[100] = """"; data = dataBuffer; for(i = 0; i < 1; i++) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } for(j = 0; j < 1; j++) { { int i, n, intVariable; if (sscanf(data, ""%d"", &n) == 1) { intVariable = 0; for (i = 0; i < n; i++) { intVariable++; } printIntLine(intVariable); } } } }"	where is the vulnerable dataflow from data to sizeof ?	replace = <start> strchr(data, '\r') <end> ;	size_t dataLen = <start> strlen(data) <end> ;	size_t <start> dataLen = strlen(data) <end> ;	recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);	3
977ea7ac-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_18_bad() { int data; data = -1; goto source; source: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } goto sink; sink: { int i; int buffer[10] = { 0 }; if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } } }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"if  <start> acceptSocket == SOCKET_ERROR <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[i] <end> );"	"data = <start> atoi(inputBuffer) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"<start> printIntLine(buffer[i]) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	1
4ff78271-6c15-11ed-81d4-94e6f77dd552	"void CWE190_Integer_Overflow__short_fscanf_postinc_18_bad() { short data; data = 0; goto source; source: fscanf (stdin, ""%hd"", &data); goto sink; sink: { data++; short result = data; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"short <start> result = data <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );"	"<start> printIntLine(result) <end> ;
<start> data <end> ++;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
<start> data <end> ++;"	"<start> data <end> ++;
short <start> result = data <end> ;"	2
c5fc2343-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif namespace CWE23_Relative_Path_Traversal__char_file_ifstream_45 { static char * badData; static char * goodG2BData; static void badSink() { char * data = badData; { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } } void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } badData = data; badSink(); }"	where is the vulnerable dataflow from data to open ?	"<start> badData = data <end> ;
inputFile.open((char * <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
<start> badData = data <end> ;
static char * <start> badData <end> ;
char * data = <start> badData <end> ;
inputFile.open((char * <start> data <end> );"	"<start> badData = data <end> ;
inputFile.open((char * <start> data <end> );
char * data = <start> badData <end> ;"	"<start> badData = data <end> ;
inputFile.open((char * <start> data <end> );
static char * <start> badData <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
size_t dataLen = <start> strlen(data) <end> ;"	1
5e44fc75-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_fgets_predec_13_bad() { int data; data = 0; if(GLOBAL_CONST_FIVE==5) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(GLOBAL_CONST_FIVE==5) { { --data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> data = 0 <end> ;
- <start> data <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
- <start> data <end> ;"	"- <start> data <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"char <start> inputBuffer[CHAR_ARRAY_SIZE] = """" <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	1
af58093d-6c15-11ed-81d4-94e6f77dd552	namespace CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_73 { void badSink(list<int> dataList) { int data = dataList.back(); { char charData = (char)data; printHexCharLine(charData); } }	where is the vulnerable dataflow from charData to printHexCharLine ?	"<start> printHexCharLine(charData) <end> ;
void badSink(list<int> <start> dataList <end> );"	"int <start> data = dataList.back() <end> ;
printHexCharLine <start> charData <end> );"	"void badSink(list<int> <start> dataList <end> );
printHexCharLine <start> charData <end> );"	"<start> printHexCharLine(charData) <end> ;
printHexCharLine <start> charData <end> );"	2
a49c4f8e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE190_Integer_Overflow__int_listen_socket_square_82 { void bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE190_Integer_Overflow__int_listen_socket_square_82_base* baseObject = new CWE190_Integer_Overflow__int_listen_socket_square_82_bad; baseObject->action(data); delete baseObject; }"	where is the vulnerable dataflow from data to action ?	"baseObject->action <start> data <end> );
data = <start> atoi(inputBuffer) <end> ;"	"baseObject->action <start> data <end> );
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"baseObject->action <start> data <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
baseObject->action <start> data <end> );"	3
5be3a9c4-6c15-11ed-81d4-94e6f77dd552	int CWE191_Integer_Underflow__int_fscanf_postdec_61b_badSource(int data); void CWE191_Integer_Underflow__int_fscanf_postdec_61_bad() { int data; data = 0; data = CWE191_Integer_Underflow__int_fscanf_postdec_61b_badSource(data); { data--; int result = data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"data = <start> CWE191_Integer_Underflow__int_fscanf_postdec_61b_badSource <end> (data);
<start> data <end> --;"	"data = <start> CWE191_Integer_Underflow__int_fscanf_postdec_61b_badSource <end> (data);
<start> data-- <end> ;"	"data = <start> CWE191_Integer_Underflow__int_fscanf_postdec_61b_badSource <end> (data);
<start> data = 0 <end> ;"	"<start> printIntLine(result) <end> ;
data = <start> CWE191_Integer_Underflow__int_fscanf_postdec_61b_badSource <end> (data);"	0
6ef76839-6c15-11ed-81d4-94e6f77dd552	#ifndef _WIN32 #endif static void badVaSink(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_console_vfprintf_51b_badSink(char * data) { badVaSink(data, data); }	where is the vulnerable dataflow from data to vfprintf ?	"vfprintf(stdout, <start> data <end> , args);
static void badVaSink(char * <start> data <end> , ...);
void CWE134_Uncontrolled_Format_String__char_console_vfprintf_51b_badSink(char * <start> data <end> );
badVaSink <start> data <end> , data);"	"static void badVaSink(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);
badVaSink <start> data <end> , data);"	"void CWE134_Uncontrolled_Format_String__char_console_vfprintf_51b_badSink(char * <start> data <end> );
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);"	"badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
void CWE134_Uncontrolled_Format_String__char_console_vfprintf_51b_badSink(char * <start> data <end> );
<start> vfprintf(stdout, data, args) <end> ;"	2
7d44fc6e-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_45_badData; static int CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_45_goodG2BData; static void badSink() { int data = CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_45_badData; { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } } void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_45_bad() { int data; data = -1; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_45_badData = data; badSink(); }"	where is the vulnerable dataflow from dest to printLine ?	"<start> CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_45_badData = data <end> ;
printLine <start> dest <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
int data = <start> CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_45_badData <end> ;
static int <start> CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_45_badData <end> ;"	"int data = <start> CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_45_badData <end> ;
<start> CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_45_badData = data <end> ;
<start> memmove(dest, source, data) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printLine <start> dest <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_45_badData = data <end> ;
static int <start> CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_45_badData <end> ;
int data = <start> CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_45_badData <end> ;
printLine <start> dest <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printLine <start> dest <end> );
<start> CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_45_badData = data <end> ;"	2
acf67e25-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_connect_socket_predec_17_bad() { int i,j; int data; data = 0; for(i = 0; i < 1; i++) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } for(j = 0; j < 1; j++) { { --data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"<start> data = atoi(inputBuffer) <end> ;
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	1
8cc3a67d-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(count) + 2) #ifdef _WIN32 #define SLEEP Sleep #else #define SLEEP usleep #endif static void badSink(int count) { SLEEP(count); printLine(""Sleep time possibly too long""); } void CWE400_Resource_Exhaustion__fgets_sleep_41_bad() { int count; count = -1; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { count = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } badSink(count); }"	where is the vulnerable dataflow from count to SLEEP ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
static void badSink(int <start> count <end> );
badSink <start> count <end> );
<start> SLEEP(count) <end> ;"	"badSink <start> count <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
badSink <start> count <end> );
static void badSink(int <start> count <end> );
SLEEP <start> count <end> );"	"badSink <start> count <end> );
static void badSink(int <start> count <end> );
SLEEP <start> count <end> );
<start> count = atoi(inputBuffer) <end> ;"	2
445c11f1-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_add_11_bad() { int data; data = 0; if(globalReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalReturnsTrue()) { { int result = data + 1; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  + 1;
<start> data = 0 <end> ;"	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
int result = <start> data <end>  + 1;"	"int result = <start> data <end>  + 1;
recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  + 1;"	3
55ef4ce0-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_fgets_sub_63b_badSink(int * dataPtr) { int data = *dataPtr; { int result = data - 1; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
void CWE191_Integer_Underflow__int_fgets_sub_63b_badSink(int * <start> dataPtr <end> );"	"int result = <start> data - 1 <end> ;
void CWE191_Integer_Underflow__int_fgets_sub_63b_badSink(int * <start> dataPtr <end> );"	"int result = <start> data <end>  - 1;
void CWE191_Integer_Underflow__int_fgets_sub_63b_badSink(int * <start> dataPtr <end> );"	"void CWE191_Integer_Underflow__int_fgets_sub_63b_badSink(int * <start> dataPtr <end> );
int result = <start> data <end>  - 1;"	3
85b15eeb-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_FIVE = 5; void CWE369_Divide_by_Zero__int_fgets_divide_06_bad() { int data; data = -1; if(STATIC_CONST_FIVE==5) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(STATIC_CONST_FIVE==5) { printIntLine(100 / data); } }"	where is the vulnerable dataflow from data to printIntLine ?	"printIntLine <start> 100 / data <end> );
<start> data = atoi(inputBuffer) <end> ;"	"<start> data = atoi(inputBuffer) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"<start> data = -1 <end> ;
printIntLine <start> 100 / data <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> 100 / data <end> );"	3
54c581de-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_connect_socket_multiply_01_bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } if(data < 0) { int result = data * 2; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data * 2 <end> ;"	"<start> printIntLine(result) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  * 2;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
data = <start> atoi(inputBuffer) <end> ;"	2
67d010bd-6c15-11ed-81d4-94e6f77dd552	static short CWE190_Integer_Overflow__short_rand_postinc_45_badData; static short CWE190_Integer_Overflow__short_rand_postinc_45_goodG2BData; static short CWE190_Integer_Overflow__short_rand_postinc_45_goodB2GData; static void badSink() { short data = CWE190_Integer_Overflow__short_rand_postinc_45_badData; { data++; short result = data; printIntLine(result); } } void CWE190_Integer_Overflow__short_rand_postinc_45_bad() { short data; data = 0; data = (short)RAND32(); CWE190_Integer_Overflow__short_rand_postinc_45_badData = data; badSink(); }	where is the vulnerable dataflow from data ?	"data = (short <start> RAND32() <end> ;
<start> CWE190_Integer_Overflow__short_rand_postinc_45_badData = data <end> ;
static short <start> CWE190_Integer_Overflow__short_rand_postinc_45_badData <end> ;
short data = <start> CWE190_Integer_Overflow__short_rand_postinc_45_badData <end> ;
<start> data <end> ++;"	"<start> data <end> ++;
data = (short <start> RAND32() <end> ;
<start> CWE190_Integer_Overflow__short_rand_postinc_45_badData = data <end> ;
static short <start> CWE190_Integer_Overflow__short_rand_postinc_45_badData <end> ;
<start> printIntLine(result) <end> ;"	"short data = <start> CWE190_Integer_Overflow__short_rand_postinc_45_badData <end> ;
<start> data <end> ++;
<start> printIntLine(result) <end> ;
data = (short <start> RAND32() <end> ;
static short <start> CWE190_Integer_Overflow__short_rand_postinc_45_badData <end> ;"	"short data = <start> CWE190_Integer_Overflow__short_rand_postinc_45_badData <end> ;
<start> data <end> ++;
static short <start> CWE190_Integer_Overflow__short_rand_postinc_45_badData <end> ;
data = (short <start> RAND32() <end> ;
<start> CWE190_Integer_Overflow__short_rand_postinc_45_badData = data <end> ;"	0
c01af8d1-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_connect_socket_open_17 { void bad() { int i; char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; for(i = 0; i < 1; i++) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - <start> dataLen - 1 <end> ), 0);"	"recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - <start> dataLen - 1 <end> ), 0);
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	1
69161b63-6c15-11ed-81d4-94e6f77dd552	static void badSink(short data) { { ++data; short result = data; printIntLine(result); } } void CWE190_Integer_Overflow__short_rand_preinc_44_bad() { short data; void (*funcPtr) (short) = badSink; data = 0; data = (short)RAND32(); funcPtr(data); }	where is the vulnerable dataflow from data ?	"funcPtr <start> data <end> );
<start> printIntLine(result) <end> ;
static void badSink(short <start> data <end> );
+ <start> data <end> ;"	"funcPtr <start> data <end> );
static void badSink(short <start> data <end> );"	"data = (short <start> RAND32() <end> ;
funcPtr <start> data <end> );
<start> data = (short)RAND32() <end> ;
static void badSink(short <start> data <end> );"	"data = (short <start> RAND32() <end> ;
funcPtr <start> data <end> );
static void badSink(short <start> data <end> );
+ <start> data <end> ;"	3
b7b09a32-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define NEW_PATH ""%SystemRoot%\\system32"" #define PUTENV _putenv #else #define NEW_PATH ""/bin"" #define PUTENV putenv #endif static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } void CWE427_Uncontrolled_Search_Path_Element__char_console_08_bad() { char * data; char dataBuffer[250] = ""PATH=""; data = dataBuffer; if(staticReturnsTrue()) { { size_t dataLen = strlen(data); if (250-dataLen > 1) { if (fgets(data+dataLen, (int)(250-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } PUTENV(data); }"	where is the vulnerable dataflow from data to PUTENV ?	"if (fgets <start> data+dataLen <end> , (int)(250-dataLen), stdin) != NULL);
size_t dataLen = <start> strlen(data) <end> ;"	"PUTENV <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(250-dataLen), stdin) != NULL);
PUTENV <start> data <end> );"	"PUTENV <start> data <end> );
dataLen = <start> strlen(data) <end> ;"	2
571e9835-6c15-11ed-81d4-94e6f77dd552	"static void badSink(int data) { { int result = data - 1; printIntLine(result); } } void CWE191_Integer_Underflow__int_fscanf_sub_41_bad() { int data; data = 0; fscanf(stdin, ""%d"", &data); badSink(data); }"	where is the vulnerable dataflow from data ?	"<start> badSink(data) <end> ;
int result = <start> data <end>  - 1;
badSink <start> data <end> );
static void badSink(int <start> data <end> );"	"static void badSink(int <start> data <end> );
badSink <start> data <end> );
fscanf(stdin, ""%d"", <start> &data <end> );
int result = <start> data <end>  - 1;"	"static void badSink(int <start> data <end> );
int result = <start> data - 1 <end> ;
fscanf(stdin, ""%d"", <start> &data <end> );
badSink <start> data <end> );"	"fscanf(stdin, ""%d"", <start> &data <end> );
badSink <start> data <end> );
static void badSink(int <start> data <end> );
int result = <start> data <end>  - 1;"	3
9d745391-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE127_Buffer_Underread__CWE839_connect_socket_12_bad() { int data; data = -1; if(globalReturnsTrueOrFalse()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } else { data = 7; } if(globalReturnsTrueOrFalse()) { { int buffer[10] = { 0 }; if (data < 10) { printIntLine(buffer[data]); } else { printLine(""ERROR: Array index is too big.""); } } } else { { int buffer[10] = { 0 }; if (data >= 0 && data < (10)) { printIntLine(buffer[data]); } else { printLine(""ERROR: Array index is out-of-bounds""); } } } }"	where is the vulnerable dataflow from buffer[data] to printIntLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printIntLine(buffer[data]) <end> ;"	"printIntLine <start> buffer[data] <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[data] <end> );"	"printIntLine <start> buffer[data] <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	2
b68484d2-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" namespace CWE36_Absolute_Path_Traversal__char_connect_socket_ofstream_81 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } const CWE36_Absolute_Path_Traversal__char_connect_socket_ofstream_81_base& baseObject = CWE36_Absolute_Path_Traversal__char_connect_socket_ofstream_81_bad(); baseObject.action(data); }"	where is the vulnerable dataflow from data to action ?	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
baseObject.action <start> data <end> );"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
size_t dataLen = <start> strlen(data) <end> ;"	"recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - <start> dataLen - 1 <end> ), 0);
baseObject.action <start> data <end> );"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
baseObject.action <start> data <end> );"	0
6b862462-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_52c_badSink(int data) { { int i; int * buffer = (int *)malloc(10 * sizeof(int)); if (buffer == NULL) {exit(-1);} for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } free(buffer); } }"	where is the vulnerable dataflow from buffer to free ?	"void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_52c_badSink(int <start> data <end> );
<start> free(buffer) <end> ;"	"free <start> buffer <end> );
if  <start> buffer == NULL <end> ) {exit(-1);};"	"void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_52c_badSink(int <start> data <end> );
free <start> buffer <end> );"	"int <start> * buffer = (int *)malloc(10 * sizeof(int)) <end> ;
free <start> buffer <end> );"	2
8cc3a66c-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(count) + 2) #ifdef _WIN32 #define SLEEP Sleep #else #define SLEEP usleep #endif static int staticTrue = 1; static int staticFalse = 0; void CWE400_Resource_Exhaustion__fgets_sleep_05_bad() { int count; count = -1; if(staticTrue) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { count = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(staticTrue) { SLEEP(count); printLine(""Sleep time possibly too long""); } }"	where is the vulnerable dataflow from count to SLEEP ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
SLEEP <start> count <end> );"	"SLEEP <start> count <end> );
count = <start> atoi(inputBuffer) <end> ;"	"<start> SLEEP(count) <end> ;
SLEEP <start> count <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> count = -1 <end> ;"	0
4a02111b-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__int_listen_socket_multiply_81 { void CWE190_Integer_Overflow__int_listen_socket_multiply_81_bad::action(int data) const { if(data > 0) { int result = data * 2; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"void CWE190_Integer_Overflow__int_listen_socket_multiply_81_bad::action(int <start> data <end> ) const;
int result = <start> data <end>  * 2;"	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  * 2;"	"void CWE190_Integer_Overflow__int_listen_socket_multiply_81_bad::action(int <start> data <end> ) const;
int result = <start> data * 2 <end> ;"	"int <start> result = data * 2 <end> ;
void CWE190_Integer_Overflow__int_listen_socket_multiply_81_bad::action(int <start> data <end> ) const;"	0
a830bf73-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_connect_socket_multiply_16_bad() { int data; data = 0; while(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; } while(1) { if(data < 0) { int result = data * 2; printIntLine(result); } break; } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> result <end> );"	"int result = <start> data * 2 <end> ;
printIntLine <start> result <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);"	2
7ae3a736-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_09_bad() { int data; data = -1; if(GLOBAL_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> strncpy(dest, source, data) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);
printLine <start> dest <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printLine <start> dest <end> );"	2
bda4e444-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define EXECLP _execlp #else #define EXECLP execlp #endif typedef struct _CWE78_OS_Command_Injection__char_listen_socket_execlp_67_structType { char * structFirst; } CWE78_OS_Command_Injection__char_listen_socket_execlp_67_structType; void CWE78_OS_Command_Injection__char_listen_socket_execlp_67b_badSink(CWE78_OS_Command_Injection__char_listen_socket_execlp_67_structType myStruct) { char * data = myStruct.structFirst; EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECLP ?	"void CWE78_OS_Command_Injection__char_listen_socket_execlp_67b_badSink(CWE78_OS_Command_Injection__char_listen_socket_execlp_67_structType <start> myStruct <end> );
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
char * data = <start> myStruct <end> .structFirst;"	"void CWE78_OS_Command_Injection__char_listen_socket_execlp_67b_badSink(CWE78_OS_Command_Injection__char_listen_socket_execlp_67_structType <start> myStruct <end> );
char * data = <start> myStruct <end> .structFirst;
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"char * data = <start> myStruct <end> .structFirst;
<start> EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL) <end> ;
void CWE78_OS_Command_Injection__char_listen_socket_execlp_67b_badSink(CWE78_OS_Command_Injection__char_listen_socket_execlp_67_structType <start> myStruct <end> );"	"EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
void CWE78_OS_Command_Injection__char_listen_socket_execlp_67b_badSink(CWE78_OS_Command_Injection__char_listen_socket_execlp_67_structType <start> myStruct <end> );"	1
6dc614bc-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" static void badVaSinkB(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_16_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; while(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; } while(1) { badVaSinkB(data, data); break; } }"	where is the vulnerable dataflow from data to vfprintf ?	"static void badVaSinkB(char * <start> data <end> , ...);
badVaSinkB <start> data <end> , data);
recvResult = <start> recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0) <end> ;
vfprintf(stdout, <start> data <end> , args);"	"<start> vfprintf(stdout, data, args) <end> ;
badVaSinkB <start> data <end> , data);
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
static void badVaSinkB(char * <start> data <end> , ...);"	"vfprintf(stdout, <start> data <end> , args);
badVaSinkB <start> data <end> , data);
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (100 - dataLen - 1), 0);"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);"	3
6ef76827-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif static void badVaSinkB(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_console_vfprintf_09_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; if(GLOBAL_CONST_TRUE) { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } if(GLOBAL_CONST_TRUE) { badVaSinkB(data, data); } }"	where is the vulnerable dataflow from data to vfprintf ?	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);"	"badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);
<start> vfprintf(stdout, data, args) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
static void badVaSinkB(char * <start> data <end> , ...);
<start> data = dataBuffer <end> ;
vfprintf(stdout, <start> data <end> , args);"	"vfprintf(stdout, <start> data <end> , args);
size_t dataLen = <start> strlen(data) <end> ;
badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);"	0
bed4a8dd-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; namespace CWE23_Relative_Path_Traversal__char_connect_socket_ifstream_04 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(STATIC_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"replace = <start> strchr(data, '\r') <end> ;
inputFile.open((char * <start> data <end> );"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
inputFile.open((char * <start> data <end> );"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) *  <start> FILENAME_MAX - dataLen - 1 <end> ), 0);"	"inputFile.open((char * <start> data <end> );
<start> data = dataBuffer <end> ;"	1
87ff987a-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_connect_socket_open_45 { static char * badData; static char * goodG2BData; static void badSink() { char * data = badData; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } } void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badData = data; badSink(); }"	where is the vulnerable dataflow from data to OPEN ?	"char * data = <start> badData <end> ;
char <start> dataBuffer[FILENAME_MAX] = """" <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
<start> badData = data <end> ;
static char * <start> badData <end> ;"	"static char * <start> badData <end> ;
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
char * data = <start> badData <end> ;
<start> badData = data <end> ;
char <start> dataBuffer[FILENAME_MAX] = """" <end> ;"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
<start> badData = data <end> ;
static char * <start> badData <end> ;
char * data = <start> badData <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"static char * <start> badData <end> ;
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
char * data = <start> badData <end> ;
<start> badData = data <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	2
b08640bf-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE197_Numeric_Truncation_Error__int_fgets_to_char_43 { static void badSource(int &data) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } void bad() { int data; data = -1; badSource(data); { char charData = (char)data; printHexCharLine(charData); } }"	where is the vulnerable dataflow from charData to printHexCharLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
badSource <start> data <end> );
printHexCharLine <start> charData <end> );"	"char charData = <start> (char)data <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printHexCharLine <start> charData <end> );"	"printHexCharLine <start> charData <end> );
badSource <start> data <end> );
<start> printHexCharLine(charData) <end> ;"	"printHexCharLine <start> charData <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
badSource <start> data <end> );"	0
5af03e0d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_connect_socket_postdec_66b_badSink(int dataArray[]) { int data = dataArray[2]; { data--; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"void CWE191_Integer_Underflow__int_connect_socket_postdec_66b_badSink(int <start> dataArray <end> []);
<start> printIntLine(result) <end> ;"	"<start> data <end> --;
<start> printIntLine(result) <end> ;"	"<start> data <end> --;
void CWE191_Integer_Underflow__int_connect_socket_postdec_66b_badSink(int <start> dataArray <end> []);"	"void CWE191_Integer_Underflow__int_connect_socket_postdec_66b_badSink(int <start> dataArray <end> []);
<start> data <end> --;"	3
8cc3a697-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(count) + 2) #ifdef _WIN32 #define SLEEP Sleep #else #define SLEEP usleep #endif void CWE400_Resource_Exhaustion__listen_socket_sleep_18_bad() { int count; count = -1; goto source; source: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; count = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } goto sink; sink: SLEEP(count); printLine(""Sleep time possibly too long""); }"	where is the vulnerable dataflow from count to SLEEP ?	"SLEEP <start> count <end> );
<start> SLEEP(count) <end> ;"	"SLEEP <start> count <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"if  <start> recvResult == SOCKET_ERROR <end>  || recvResult == 0);
SLEEP <start> count <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
SLEEP <start> count <end> );"	3
7e74f34b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memmove_17_bad() { int i; int data; data = -1; for(i = 0; i < 1; i++) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"<start> data = atoi(inputBuffer) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"<start> memmove(dest, source, data) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"printLine <start> dest <end> );
<start> recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	0
8f278a72-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_04_bad() { int data; data = -1; if(STATIC_CONST_TRUE) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } { size_t i; int *intPointer; intPointer = (int*)malloc(data * sizeof(int)); if (intPointer == NULL) {exit(-1);} for (i = 0; i < (size_t)data; i++) { intPointer[i] = 0; } printIntLine(intPointer[0]); free(intPointer); } }"	where is the vulnerable dataflow from data to malloc ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	"<start> data = atoi(inputBuffer) <end> ;
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	"intPointer = (int*)malloc <start> data * sizeof(int) <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> data = -1 <end> ;"	0
a36a7908-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__int_listen_socket_add_72 { void badSink(vector<int> dataVector) { int data = dataVector[2]; { int result = data + 1; printIntLine(result); } }	where is the vulnerable dataflow from result to printIntLine ?	"<start> printIntLine(result) <end> ;
void badSink(vector<int> <start> dataVector <end> );"	"int <start> data = dataVector[2] <end> ;
void badSink(vector<int> <start> dataVector <end> );"	"printIntLine <start> result <end> );
void badSink(vector<int> <start> dataVector <end> );"	"void badSink(vector<int> <start> dataVector <end> );
printIntLine <start> result <end> );"	3
8b91e491-6c15-11ed-81d4-94e6f77dd552	"void CWE390_Error_Without_Action__fgets_char_02_bad() { if(1) { { char dataBuffer[100] = """"; char * data = dataBuffer; printLine(""Please enter a string: ""); if (fgets(data, 100, stdin) == NULL) { } printLine(data); } } }"	where is the vulnerable dataflow from data to printLine ?	"if (fgets <start> data <end> , 100, stdin) == NULL);
printLine <start> data <end> );"	"if (fgets <start> data <end> , 100, stdin) == NULL);
char <start> * data = dataBuffer <end> ;"	"printLine <start> data <end> );
<start> printLine(data) <end> ;"	"printLine <start> data <end> );
if (fgets <start> data <end> , 100, stdin) == NULL);"	0
9d745367-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink(int data) { { int buffer[10] = { 0 }; if (data >= 0) { printIntLine(buffer[data]); } else { printLine(""ERROR: Array index is negative""); } } } void CWE126_Buffer_Overread__CWE129_fgets_44_bad() { int data; void (*funcPtr) (int) = badSink; data = -1; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } funcPtr(data); }"	where is the vulnerable dataflow from buffer[data] to printIntLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> buffer[data] <end> );
int <start> buffer[10] = { 0 } <end> ;
static void badSink(int <start> data <end> );"	"static void badSink(int <start> data <end> );
printIntLine <start> buffer[data] <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> funcPtr(data) <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
funcPtr <start> data <end> );
static void badSink(int <start> data <end> );
printIntLine <start> buffer[data] <end> );"	"<start> data = atoi(inputBuffer) <end> ;
static void badSink(int <start> data <end> );
printIntLine <start> buffer[data] <end> );
funcPtr <start> data <end> );"	2
c39a65a0-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif namespace CWE23_Relative_Path_Traversal__char_environment_ifstream_52 { void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } badSink_b(data); }"	where is the vulnerable dataflow from data to badSink_b ?	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
<start> badSink_b(data) <end> ;"	"char <start> dataBuffer[FILENAME_MAX] = BASEPATH <end> ;
badSink_b <start> data <end> );"	"badSink_b <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
badSink_b <start> data <end> );"	3
b41b877f-6c15-11ed-81d4-94e6f77dd552	"namespace CWE23_Relative_Path_Traversal__char_console_open_81 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } const CWE23_Relative_Path_Traversal__char_console_open_81_base& baseObject = CWE23_Relative_Path_Traversal__char_console_open_81_bad(); baseObject.action(data); }"	where is the vulnerable dataflow from data to action ?	"baseObject.action <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
baseObject.action <start> data <end> );"	"<start> data = dataBuffer <end> ;
baseObject.action <start> data <end> );"	"baseObject.action <start> data <end> );
dataLen = <start> strlen(data) <end> ;"	1
a10948ea-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink(int data) { if(data > 0) { int result = data * 2; printIntLine(result); } } void CWE190_Integer_Overflow__int_connect_socket_multiply_41_bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badSink(data); }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSink <start> data <end> );
static void badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"badSink <start> data <end> );
printIntLine <start> result <end> );
static void badSink(int <start> data <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"static void badSink(int <start> data <end> );
<start> printIntLine(result) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSink <start> data <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static void badSink(int <start> data <end> );"	0
820a46c2-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_file_fopen_34 { typedef union { char * unionFirst; char * unionSecond; } unionType; void bad() { char * data; unionType myUnion; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } } }"	where is the vulnerable dataflow from data to FOPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
char <start> dataBuffer[FILENAME_MAX] = BASEPATH <end> ;"	"pFile = FOPEN <start> data <end> , ""wb+"");
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
pFile = FOPEN <start> data <end> , ""wb+"");"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
size_t dataLen = <start> strlen(data) <end> ;"	2
abc3751a-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticFive = 5; void CWE191_Integer_Underflow__int_fgets_postdec_07_bad() { int data; data = 0; if(staticFive==5) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(staticFive==5) { { data--; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"<start> data = atoi(inputBuffer) <end> ;
printIntLine <start> result <end> );"	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
if  <start> fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) <end>  != NULL);"	2
acf67e17-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_connect_socket_predec_03_bad() { int data; data = 0; if(5==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(5==5) { { --data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> result <end> );"	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	3
d1e9da30-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif static int staticFive = 5; namespace CWE36_Absolute_Path_Traversal__char_listen_socket_fopen_07 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(staticFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
<start> data = dataBuffer <end> ;"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
size_t <start> dataLen = strlen(data) <end> ;"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
size_t dataLen = <start> strlen(data) <end> ;"	0
9d745399-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE127_Buffer_Underread__CWE839_connect_socket_31_bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { int dataCopy = data; int data = dataCopy; { int buffer[10] = { 0 }; if (data < 10) { printIntLine(buffer[data]); } else { printLine(""ERROR: Array index is too big.""); } } } }"	where is the vulnerable dataflow from buffer[data] to printIntLine ?	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> buffer[data] <end> );"	"data = <start> atoi(inputBuffer) <end> ;
printIntLine <start> buffer[data] <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[data] <end> );"	"int <start> buffer[10] = { 0 } <end> ;
printIntLine <start> buffer[data] <end> );"	2
a23a3dfb-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int badStatic = 0; static void badSink(int data) { if(badStatic) { { int result = data + 1; printIntLine(result); } } } void CWE190_Integer_Overflow__int_fgets_add_21_bad() { int data; data = 0; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } badStatic = 1; badSink(data); }"	where is the vulnerable dataflow from result to printIntLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );
<start> badSink(data) <end> ;
badSink <start> data <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
badSink <start> data <end> );
static void badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"<start> data = 0 <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
static void badSink(int <start> data <end> );
badSink <start> data <end> );"	"badSink <start> data <end> );
static void badSink(int <start> data <end> );
<start> badSink(data) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	1
79b27536-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_53d_badSink(int data) { if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }"	where is the vulnerable dataflow from data to malloc ?	"<start> free(dataBuffer) <end> ;
char * dataBuffer = (char *)malloc <start> data <end> );"	"void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_53d_badSink(int <start> data <end> );
char * dataBuffer = (char *)malloc <start> data <end> );"	"char * dataBuffer = (char *)malloc <start> data <end> );
char <start> * dataBuffer = (char *)malloc(data) <end> ;"	"void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_malloc_53d_badSink(int <start> data <end> );
memset(dataBuffer, 'A', <start> data-1 <end> );"	1
833ac938-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_listen_socket_open_12 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(globalReturnsTrueOrFalse()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } else { strcat(data, ""file.txt""); } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);"	"size_t dataLen = <start> strlen(data) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	3
92bb8a31-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING ""hello"" void CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_51b_badSink(size_t data) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); } else { printLine(""Input is less than the length of the source string""); } } }"	where is the vulnerable dataflow from data to malloc ?	"<start> myString = (char *)malloc(data*sizeof(char)) <end> ;
myString = (char *)malloc <start> data*sizeof(char) <end> );"	"myString = (char *)malloc <start> data*sizeof(char) <end> );
void CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_51b_badSink(size_t <start> data <end> );"	"void CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_51b_badSink(size_t <start> data <end> );
myString = (char *)malloc <start> data*sizeof(char) <end> );"	"void CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_51b_badSink(size_t <start> data <end> );
<start> myString = (char *)malloc(data*sizeof(char)) <end> ;"	2
c26a7e48-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_console_open_21 { static int badStatic = 0; static char * badSource(char * data) { if(badStatic) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } return data; } void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; badStatic = 1; data = badSource(data); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } ; }"	where is the vulnerable dataflow from data to OPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"size_t dataLen = <start> strlen(data) <end> ;
data = <start> badSource <end> (data);
static char * <start> badSource <end> (char * data);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
data = <start> badSource <end> (data);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
static char * <start> badSource <end> (char * data);"	0
893217c4-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_console_fopen_14 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(globalFive==5) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"char <start> dataBuffer[FILENAME_MAX] = """" <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
pFile = FOPEN <start> data <end> , ""wb+"");"	"<start> data = dataBuffer <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
size_t dataLen = <start> strlen(data) <end> ;"	1
cd22815b-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_console_open_11 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(globalReturnsTrue()) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
size_t dataLen = <start> strlen(data) <end> ;"	"char <start> dataBuffer[FILENAME_MAX] = """" <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
<start> data = dataBuffer <end> ;"	2
55ef4cbd-6c15-11ed-81d4-94e6f77dd552	namespace CWE191_Integer_Underflow__int_fgets_multiply_74 { void badSink(map<int, int> dataMap) { int data = dataMap[2]; if(data < 0) { int result = data * 2; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"void badSink(map<int, int> <start> dataMap <end> );
<start> printIntLine(result) <end> ;"	"void badSink(map<int, int> <start> dataMap <end> );
int result = <start> data <end>  * 2;"	"if <start> data < 0 <end> ) ;
int result = <start> data <end>  * 2;"	"int result = <start> data <end>  * 2;
void badSink(map<int, int> <start> dataMap <end> );"	1
b7b09a48-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define NEW_PATH ""%SystemRoot%\\system32"" #define PUTENV _putenv #else #define NEW_PATH ""/bin"" #define PUTENV putenv #endif void CWE427_Uncontrolled_Search_Path_Element__char_console_64b_badSink(void * dataVoidPtr) { char * * dataPtr = (char * *)dataVoidPtr; char * data = (*dataPtr); PUTENV(data); }"	where is the vulnerable dataflow from data to PUTENV ?	"PUTENV <start> data <end> );
<start> PUTENV(data) <end> ;"	"char <start> * data = (*dataPtr) <end> ;
PUTENV <start> data <end> );"	"void CWE427_Uncontrolled_Search_Path_Element__char_console_64b_badSink(void * <start> dataVoidPtr <end> );
PUTENV <start> data <end> );"	"PUTENV <start> data <end> );
void CWE427_Uncontrolled_Search_Path_Element__char_console_64b_badSink(void * <start> dataVoidPtr <end> );"	2
8a631098-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_file_fopen_12 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(globalReturnsTrueOrFalse()) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } else { #ifdef _WIN32 strcat(data, ""c:\\temp\\file.txt""); #else strcat(data, ""/tmp/file.txt""); #endif } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = FOPEN <start> data <end> , ""wb+"");
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
pFile = FOPEN <start> data <end> , ""wb+"");"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
<start> data = dataBuffer <end> ;"	2
d44c3fc8-6c15-11ed-81d4-94e6f77dd552	#ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_listen_socket_open_82 { void CWE36_Absolute_Path_Traversal__char_listen_socket_open_82_bad::action(char * data) { { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } } }	where is the vulnerable dataflow from data to OPEN ?	"void CWE36_Absolute_Path_Traversal__char_listen_socket_open_82_bad::action(char * <start> data <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN(data, O_RDWR|O_CREAT, <start> S_IREAD|S_IWRITE <end> );
void CWE36_Absolute_Path_Traversal__char_listen_socket_open_82_bad::action(char * <start> data <end> );"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
void CWE36_Absolute_Path_Traversal__char_listen_socket_open_82_bad::action(char * <start> data <end> );"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	0
846ad33c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE369_Divide_by_Zero__int_connect_socket_divide_14_bad() { int data; data = -1; if(globalFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalFive==5) { printIntLine(100 / data); } }"	where is the vulnerable dataflow from data to printIntLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
data = <start> atoi(inputBuffer) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> 100 / data <end> );"	"recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);
printIntLine <start> 100 / data <end> );"	"<start> data = atoi(inputBuffer) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	1
7ae3a751-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_65b_badSink(int data) { { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> printLine(dest) <end> ;
void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_65b_badSink(int <start> data <end> );"	"printLine <start> dest <end> );
<start> strncpy(dest, source, data) <end> ;"	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	"void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_65b_badSink(int <start> data <end> );
printLine <start> dest <end> );"	3
525b6460-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_preinc_16_bad() { int data; data = 0; while(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; } while(1) { { ++data; int result = data; printIntLine(result); } break; } }"	where is the vulnerable dataflow from data ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
+ <start> data <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
data = <start> atoi(inputBuffer) <end> ;"	"if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );
+ <start> data <end> ;"	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
+ <start> data <end> ;"	0
74ee23e8-6c15-11ed-81d4-94e6f77dd552	"namespace CWE194_Unexpected_Sign_Extension__connect_socket_strncpy_62 { void badSource(short &data); void bad() { short data; data = 0; badSource(data); { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> strncpy(dest, source, data) <end> ;
printLine <start> dest <end> );"	"printLine <start> dest <end> );
badSource <start> data <end> );"	"printLine <start> dest <end> );
<start> printLine(dest) <end> ;"	"badSource <start> data <end> );
printLine <start> dest <end> );"	3
54c5820c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; void CWE191_Integer_Underflow__int_connect_socket_sub_04_bad() { int data; data = 0; if(STATIC_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(STATIC_CONST_TRUE) { { int result = data - 1; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  - 1;
<start> printIntLine(result) <end> ;"	"int result = <start> data <end>  - 1;
recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  - 1;"	"int result = <start> data - 1 <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	2
6b862436-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_connect_socket_52c_badSink(int data) { { int i; int * buffer = (int *)malloc(10 * sizeof(int)); if (buffer == NULL) {exit(-1);} for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } free(buffer); } }"	where is the vulnerable dataflow from buffer to free ?	"void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_connect_socket_52c_badSink(int <start> data <end> );
<start> printIntLine(buffer[i]) <end> ;"	"void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_connect_socket_52c_badSink(int <start> data <end> );
free <start> buffer <end> );"	"free <start> buffer <end> );
void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_connect_socket_52c_badSink(int <start> data <end> );"	"<start> free(buffer) <end> ;
void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_connect_socket_52c_badSink(int <start> data <end> );"	1
d1e9da51-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_listen_socket_fopen_74 { void badSink(map<int, char *> dataMap) { char * data = dataMap[2]; { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = FOPEN <start> data <end> , ""wb+"");
void badSink(map<int, char *> <start> dataMap <end> );"	"void badSink(map<int, char *> <start> dataMap <end> );
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
void badSink(map<int, char *> <start> dataMap <end> );"	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	1
c8600af8-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_listen_socket_open_03 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(5==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"recvResult = <start> recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0) <end> ;
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
recvResult = <start> recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0) <end> ;"	"replace = <start> strchr(data, '\r') <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	1
c72d5d4f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } namespace CWE23_Relative_Path_Traversal__char_listen_socket_fopen_08 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(staticReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = FOPEN <start> data <end> , ""wb+"");
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
size_t dataLen = <start> strlen(data) <end> ;"	1
70279c23-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } static void badVaSinkB(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_file_vfprintf_08_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; if(staticReturnsTrue()) { { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } if(staticReturnsTrue()) { badVaSinkB(data, data); } }"	where is the vulnerable dataflow from data to vfprintf ?	"static void badVaSinkB(char * <start> data <end> , ...);
badVaSinkB <start> data <end> , data);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
static void badVaSinkB(char * <start> data <end> , ...);
badVaSinkB <start> data <end> , data);
vfprintf(stdout, <start> data <end> , args);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);"	"static void badVaSinkB(char * <start> data <end> , ...);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	2
cbf237de-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif namespace CWE36_Absolute_Path_Traversal__char_console_ifstream_44 { static void badSink(char * data) { { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } } void bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } funcPtr(data); }"	where is the vulnerable dataflow from data to funcPtr ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
funcPtr <start> data <end> );"	"funcPtr <start> data <end> );
dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
<start> funcPtr(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
size_t dataLen = <start> strlen(data) <end> ;"	0
774f5844-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 8 static int badStatic = 0; static short badSource(short data) { if(badStatic) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } return data; } void CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_21_bad() { short data; data = 0; badStatic = 1; data = badSource(data); { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"static short <start> badSource <end> (short data);
data = <start> badSource <end> (data);
printLine <start> dest <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static short <start> badSource <end> (short data);
data = <start> badSource <end> (data);
printLine <start> dest <end> );"	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );
static short <start> badSource <end> (short data);
data = <start> badSource <end> (data);"	"if  <start> acceptSocket == SOCKET_ERROR <end> );
printLine <start> dest <end> );
static short <start> badSource <end> (short data);
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	1
70279bf5-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif static int staticTrue = 1; static int staticFalse = 0; void CWE134_Uncontrolled_Format_String__char_file_snprintf_05_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; if(staticTrue) { { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } if(staticTrue) { { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } } }"	where is the vulnerable dataflow from dest to printLine ?	"printLine <start> dest <end> );
char <start> dataBuffer[100] = """" <end> ;"	"<start> printLine(dest) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
printLine <start> dest <end> );"	"printLine <start> dest <end> );
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	2
9c4551b3-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE126_Buffer_Overread__CWE129_fgets_12_bad() { int data; data = -1; if(globalReturnsTrueOrFalse()) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } else { data = 7; } if(globalReturnsTrueOrFalse()) { { int buffer[10] = { 0 }; if (data >= 0) { printIntLine(buffer[data]); } else { printLine(""ERROR: Array index is negative""); } } } else { { int buffer[10] = { 0 }; if (data >= 0 && data < (10)) { printIntLine(buffer[data]); } else { printLine(""ERROR: Array index is out-of-bounds""); } } } }"	where is the vulnerable dataflow from buffer[data] to printIntLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> buffer[data] <end> );"	"printIntLine <start> buffer[data] <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"int <start> buffer[10] = { 0 } <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> printIntLine(buffer[data]) <end> ;"	0
b54bcf2b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 20 void CWE369_Divide_by_Zero__float_listenSocket_13_bad() { float data; data = 0.0F; if(GLOBAL_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = (float)atof(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(GLOBAL_CONST_FIVE==5) { { int result = (int)(100.0 / data); printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = (int) <start> 100.0 / data <end> );"	"printIntLine <start> result <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"if  <start> listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	2
4db33f60-6c15-11ed-81d4-94e6f77dd552	"static unsigned int badSource(unsigned int data) { fscanf (stdin, ""%u"", &data); return data; } void CWE190_Integer_Overflow__unsigned_int_fscanf_square_42_bad() { unsigned int data; data = 0; data = badSource(data); { unsigned int result = data * data; printUnsignedLine(result); } }"	where is the vulnerable dataflow from data ?	"fscanf (stdin, ""%u"", <start> &data <end> );
static unsigned int <start> badSource <end> (unsigned int data);
data = <start> badSource <end> (data);
unsigned int result = <start> data <end>  * data;"	"static unsigned int <start> badSource <end> (unsigned int data);
data = <start> badSource <end> (data);
fscanf (stdin, ""%u"", <start> &data <end> );"	"data = <start> badSource <end> (data);
unsigned int result = <start> data <end>  * data;
static unsigned int <start> badSource <end> (unsigned int data);
fscanf (stdin, ""%u"", <start> &data <end> );"	"fscanf (stdin, ""%u"", <start> &data <end> );
static unsigned int <start> badSource <end> (unsigned int data);"	0
cd228146-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif namespace CWE36_Absolute_Path_Traversal__char_console_ofstream_34 { typedef union { char * unionFirst; char * unionSecond; } unionType; void bad() { char * data; unionType myUnion; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } } }"	where is the vulnerable dataflow from data to open ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
char <start> dataBuffer[FILENAME_MAX] = """" <end> ;"	"<start> data = dataBuffer <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
outputFile.open((char * <start> data <end> );"	"outputFile.open((char * <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	2
466e7ecb-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__int_fgets_add_74 { void badSink(map<int, int> dataMap) { int data = dataMap[2]; { int result = data + 1; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"int <start> data = dataMap[2] <end> ;
void badSink(map<int, int> <start> dataMap <end> );"	"void badSink(map<int, int> <start> dataMap <end> );
int result = <start> data <end>  + 1;"	"int <start> result = data + 1 <end> ;
void badSink(map<int, int> <start> dataMap <end> );"	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  + 1;"	1
b41b8776-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" namespace CWE23_Relative_Path_Traversal__char_connect_socket_ofstream_82 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE23_Relative_Path_Traversal__char_connect_socket_ofstream_82_base* baseObject = new CWE23_Relative_Path_Traversal__char_connect_socket_ofstream_82_bad; baseObject->action(data); delete baseObject; }"	where is the vulnerable dataflow from data to action ?	"baseObject->action <start> data <end> );
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"baseObject->action <start> data <end> );
recvResult = <start> recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0) <end> ;"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
baseObject->action <start> data <end> );"	"baseObject->action <start> data <end> );
recvResult = recv(connectSocket, (char *)(data + dataLen), <start> sizeof(char) * (FILENAME_MAX - dataLen - 1) <end> , 0);"	2
7d44fccd-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_63b_badSink(int * dataPtr) { int data = *dataPtr; if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }"	where is the vulnerable dataflow from data to malloc ?	"char * dataBuffer = <start> (char *)malloc(data) <end> ;
void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_63b_badSink(int * <start> dataPtr <end> );"	"void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_63b_badSink(int * <start> dataPtr <end> );
char * dataBuffer = (char *)malloc <start> data <end> );"	"void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_63b_badSink(int * <start> dataPtr <end> );
memset(dataBuffer, 'A', <start> data-1 <end> );"	"if  <start> dataBuffer == NULL <end> ) {exit(-1);};
char * dataBuffer = (char *)malloc <start> data <end> );"	1
b8e2bdc9-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 256 void CWE681_Incorrect_Conversion_Between_Numeric_Types__doubleNaN2int_03_bad() { if(5==5) { { char inputBuffer[CHAR_ARRAY_SIZE]; double doubleNumber = 0; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { doubleNumber = atof(inputBuffer); } else { printLine(""fgets() failed.""); } printIntLine((int)(sqrt(doubleNumber))); } } }"	where is the vulnerable dataflow from doubleNumber to printIntLine ?	"doubleNumber = <start> atof(inputBuffer) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine((int)(sqrt <start> doubleNumber <end> )));"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> (int)(sqrt(doubleNumber)) <end> );"	"printIntLine((int)(sqrt <start> doubleNumber <end> )));
printIntLine((int) <start> sqrt(doubleNumber) <end> ));"	1
571e980c-6c15-11ed-81d4-94e6f77dd552	"static void badSink(int data) { if(data < 0) { int result = data * 2; printIntLine(result); } } void CWE191_Integer_Underflow__int_fscanf_multiply_41_bad() { int data; data = 0; fscanf(stdin, ""%d"", &data); badSink(data); }"	where is the vulnerable dataflow from data ?	"fscanf(stdin, ""%d"", <start> &data <end> );
badSink <start> data <end> );
static void badSink(int <start> data <end> );
int result = <start> data <end>  * 2;"	"<start> badSink(data) <end> ;
badSink <start> data <end> );
fscanf(stdin, ""%d"", <start> &data <end> );
static void badSink(int <start> data <end> );"	"fscanf(stdin, ""%d"", <start> &data <end> );
int result = <start> data <end>  * 2;
badSink <start> data <end> );
<start> badSink(data) <end> ;"	"fscanf(stdin, ""%d"", <start> &data <end> );
int result = <start> data <end>  * 2;
badSink <start> data <end> );
static void badSink(int <start> data <end> );"	0
9c455195-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) typedef struct _CWE124_Buffer_Underwrite__CWE839_listen_socket_67_structType { int structFirst; } CWE124_Buffer_Underwrite__CWE839_listen_socket_67_structType; void CWE124_Buffer_Underwrite__CWE839_listen_socket_67b_badSink(CWE124_Buffer_Underwrite__CWE839_listen_socket_67_structType myStruct) { int data = myStruct.structFirst; { int i; int buffer[10] = { 0 }; if (data < 10) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } } }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"printIntLine <start> buffer[i] <end> );
void CWE124_Buffer_Underwrite__CWE839_listen_socket_67b_badSink(CWE124_Buffer_Underwrite__CWE839_listen_socket_67_structType <start> myStruct <end> );
int data = <start> myStruct <end> .structFirst;"	"void CWE124_Buffer_Underwrite__CWE839_listen_socket_67b_badSink(CWE124_Buffer_Underwrite__CWE839_listen_socket_67_structType <start> myStruct <end> );
int data = <start> myStruct <end> .structFirst;
printIntLine <start> buffer[i] <end> );"	"int data = <start> myStruct <end> .structFirst;
void CWE124_Buffer_Underwrite__CWE839_listen_socket_67b_badSink(CWE124_Buffer_Underwrite__CWE839_listen_socket_67_structType <start> myStruct <end> );"	"void CWE124_Buffer_Underwrite__CWE839_listen_socket_67b_badSink(CWE124_Buffer_Underwrite__CWE839_listen_socket_67_structType <start> myStruct <end> );
int data = <start> myStruct <end> .structFirst;
<start> printIntLine(buffer[i]) <end> ;"	1
453db02d-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__int_connect_socket_multiply_72 { void badSink(vector<int> dataVector) { int data = dataVector[2]; if(data > 0) { int result = data * 2; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"void badSink(vector<int> <start> dataVector <end> );
int result = <start> data <end>  * 2;"	"void badSink(vector<int> <start> dataVector <end> );
<start> printIntLine(result) <end> ;"	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  * 2;"	"int result = <start> data <end>  * 2;
void badSink(vector<int> <start> dataVector <end> );"	0
b54bcf22-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 20 void CWE369_Divide_by_Zero__float_listenSocket_03_bad() { float data; data = 0.0F; if(5==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = (float)atof(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(5==5) { { int result = (int)(100.0 / data); printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
if  <start> listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR <end> );"	"printIntLine <start> result <end> );
int <start> result = (int)(100.0 / data) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
data = (float <start> atof(inputBuffer) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	3
8a6310de-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_listen_socket_fopen_03 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(5==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
<start> data = dataBuffer <end> ;"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
<start> data = dataBuffer <end> ;"	1
4a02110b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int CWE190_Integer_Overflow__int_listen_socket_multiply_45_badData; static int CWE190_Integer_Overflow__int_listen_socket_multiply_45_goodG2BData; static int CWE190_Integer_Overflow__int_listen_socket_multiply_45_goodB2GData; static void badSink() { int data = CWE190_Integer_Overflow__int_listen_socket_multiply_45_badData; if(data > 0) { int result = data * 2; printIntLine(result); } } void CWE190_Integer_Overflow__int_listen_socket_multiply_45_bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE190_Integer_Overflow__int_listen_socket_multiply_45_badData = data; badSink(); }"	where is the vulnerable dataflow from data ?	"int data = <start> CWE190_Integer_Overflow__int_listen_socket_multiply_45_badData <end> ;
<start> CWE190_Integer_Overflow__int_listen_socket_multiply_45_badData = data <end> ;
static int <start> CWE190_Integer_Overflow__int_listen_socket_multiply_45_badData <end> ;
int result = <start> data <end>  * 2;
data = <start> atoi(inputBuffer) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> CWE190_Integer_Overflow__int_listen_socket_multiply_45_badData = data <end> ;
static int <start> CWE190_Integer_Overflow__int_listen_socket_multiply_45_badData <end> ;
int data = <start> CWE190_Integer_Overflow__int_listen_socket_multiply_45_badData <end> ;
int result = <start> data <end>  * 2;"	"int data = <start> CWE190_Integer_Overflow__int_listen_socket_multiply_45_badData <end> ;
int result = <start> data <end>  * 2;
<start> CWE190_Integer_Overflow__int_listen_socket_multiply_45_badData = data <end> ;"	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  * 2;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int data = <start> CWE190_Integer_Overflow__int_listen_socket_multiply_45_badData <end> ;
<start> CWE190_Integer_Overflow__int_listen_socket_multiply_45_badData = data <end> ;"	1
820a46e3-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_file_open_18 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; goto source; source: { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
<start> data = dataBuffer <end> ;"	"size_t dataLen = <start> strlen(data) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN(data, O_RDWR|O_CREAT, <start> S_IREAD|S_IWRITE <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	3
48d25d8e-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__int_fscanf_square_52c_badSink(int data) { { int result = data * data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  * data;"	"void CWE190_Integer_Overflow__int_fscanf_square_52c_badSink(int <start> data <end> );
int result = <start> data <end>  * data;"	"void CWE190_Integer_Overflow__int_fscanf_square_52c_badSink(int <start> data <end> );
int <start> result = data * data <end> ;"	"int result = <start> data <end>  * data;
void CWE190_Integer_Overflow__int_fscanf_square_52c_badSink(int <start> data <end> );"	1
86cea13c-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int badStatic = 0; static void badSink(int data) { if(badStatic) { printIntLine(100 % data); } } void CWE369_Divide_by_Zero__int_fgets_modulo_21_bad() { int data; data = -1; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } badStatic = 1; badSink(data); }"	where is the vulnerable dataflow from data to printIntLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
badSink <start> data <end> );
static void badSink(int <start> data <end> );
printIntLine <start> 100 % data <end> );"	"printIntLine <start> 100 % data <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
badSink <start> data <end> );
<start> data = -1 <end> ;"	"if  <start> fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) <end>  != NULL);
static void badSink(int <start> data <end> );
badSink <start> data <end> );
printIntLine <start> 100 % data <end> );"	"printIntLine <start> 100 % data <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
static void badSink(int <start> data <end> );"	0
85b15efa-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE369_Divide_by_Zero__int_fgets_divide_43 { static void badSource(int &data) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } void bad() { int data; data = -1; badSource(data); printIntLine(100 / data); }"	where is the vulnerable dataflow from data to printIntLine ?	"printIntLine <start> 100 / data <end> );
badSource <start> data <end> );"	"badSource <start> data <end> );
<start> data = -1 <end> ;
printIntLine <start> 100 / data <end> );"	"printIntLine <start> 100 / data <end> );
badSource <start> data <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
badSource <start> data <end> );
printIntLine <start> 100 / data <end> );"	3
728a5006-6c15-11ed-81d4-94e6f77dd552	namespace CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_82 { static void badVaSink(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_82_bad::action(char * data) { badVaSink(data, data); } }	where is the vulnerable dataflow from data to vfprintf ?	"void CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_82_bad::action(char * <start> data <end> );
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);"	"vfprintf(stdout, <start> data <end> , args);
void CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_82_bad::action(char * <start> data <end> );
badVaSink <start> data <end> , data);"	"void CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_82_bad::action(char * <start> data <end> );
vfprintf(stdout, <start> data <end> , args);"	"void CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_82_bad::action(char * <start> data <end> );
static void badVaSink(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);
badVaSink <start> data <end> , data);"	0
a10948db-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } void CWE190_Integer_Overflow__int_connect_socket_multiply_08_bad() { int data; data = 0; if(staticReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticReturnsTrue()) { if(data > 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;"	"<start> printIntLine(result) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"printIntLine <start> result <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	3
78800f91-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 8 static void badSink(short data) { { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } } void CWE194_Unexpected_Sign_Extension__listen_socket_memcpy_44_bad() { short data; void (*funcPtr) (short) = badSink; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } funcPtr(data); }"	where is the vulnerable dataflow from dest to printLine ?	"static void badSink(short <start> data <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> funcPtr(data) <end> ;
funcPtr <start> data <end> );"	"<start> memcpy(dest, source, data) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
funcPtr <start> data <end> );
static void badSink(short <start> data <end> );"	"if  <start> data < 100 <end> );
printLine <start> dest <end> );
funcPtr <start> data <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
funcPtr <start> data <end> );
static void badSink(short <start> data <end> );
printLine <start> dest <end> );"	3
c26a7e6d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_environment_fopen_13 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(GLOBAL_CONST_FIVE==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = FOPEN <start> data <end> , ""wb+"");
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	"pFile = FOPEN <start> data <end> , ""wb+"");
strncat(data+dataLen, environment, FILENAME_MAX <start> dataLen-1 <end> );"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	2
a49c4f5f-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__int_listen_socket_multiply_82 { void CWE190_Integer_Overflow__int_listen_socket_multiply_82_bad::action(int data) { if(data > 0) { int result = data * 2; printIntLine(result); } } }	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
if <start> data > 0 <end> ) ;"	"printIntLine <start> result <end> );
void CWE190_Integer_Overflow__int_listen_socket_multiply_82_bad::action(int <start> data <end> );"	"void CWE190_Integer_Overflow__int_listen_socket_multiply_82_bad::action(int <start> data <end> );
printIntLine <start> result <end> );"	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	2
acf67e59-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_fgets_predec_63b_badSink(int * dataPtr) { int data = *dataPtr; { --data; int result = data; printIntLine(result); } }	where is the vulnerable dataflow from result to printIntLine ?	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	"void CWE191_Integer_Underflow__int_fgets_predec_63b_badSink(int * <start> dataPtr <end> );
<start> printIntLine(result) <end> ;"	"void CWE191_Integer_Underflow__int_fgets_predec_63b_badSink(int * <start> dataPtr <end> );
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
void CWE191_Integer_Underflow__int_fgets_predec_63b_badSink(int * <start> dataPtr <end> );"	2
b8e2bdba-6c15-11ed-81d4-94e6f77dd552	"namespace CWE606_Unchecked_Loop_Condition__char_console_82 { void bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } CWE606_Unchecked_Loop_Condition__char_console_82_base* baseObject = new CWE606_Unchecked_Loop_Condition__char_console_82_bad; baseObject->action(data); delete baseObject; }"	where is the vulnerable dataflow from data to action ?	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
baseObject->action <start> data <end> );"	"<start> data = dataBuffer <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	"baseObject->action <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	"baseObject->action <start> data <end> );
<start> data = dataBuffer <end> ;"	0
bed4a8f5-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" namespace CWE23_Relative_Path_Traversal__char_connect_socket_ifstream_52 { void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badSink_b(data); }"	where is the vulnerable dataflow from data to badSink_b ?	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
<start> data = dataBuffer <end> ;"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
badSink_b <start> data <end> );"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
<start> badSink_b(data) <end> ;"	2
964cdc21-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FULL_COMMAND ""dir "" #else #define FULL_COMMAND ""ls "" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define POPEN _popen #define PCLOSE _pclose #else #define POPEN popen #define PCLOSE pclose #endif typedef struct _CWE78_OS_Command_Injection__char_listen_socket_popen_67_structType { char * structFirst; } CWE78_OS_Command_Injection__char_listen_socket_popen_67_structType; void CWE78_OS_Command_Injection__char_listen_socket_popen_67b_badSink(CWE78_OS_Command_Injection__char_listen_socket_popen_67_structType myStruct) { char * data = myStruct.structFirst; { FILE *pipe; pipe = POPEN(data, ""w""); if (pipe != NULL) { PCLOSE(pipe); } } }"	where is the vulnerable dataflow from data to POPEN ?	"pipe = <start> POPEN(data, ""w"") <end> ;
pipe = POPEN <start> data <end> , ""w"");
void CWE78_OS_Command_Injection__char_listen_socket_popen_67b_badSink(CWE78_OS_Command_Injection__char_listen_socket_popen_67_structType <start> myStruct <end> );"	"void CWE78_OS_Command_Injection__char_listen_socket_popen_67b_badSink(CWE78_OS_Command_Injection__char_listen_socket_popen_67_structType <start> myStruct <end> );
char * data = <start> myStruct <end> .structFirst;
pipe = POPEN <start> data <end> , ""w"");"	"char * data = <start> myStruct <end> .structFirst;
void CWE78_OS_Command_Injection__char_listen_socket_popen_67b_badSink(CWE78_OS_Command_Injection__char_listen_socket_popen_67_structType <start> myStruct <end> );
pipe = <start> POPEN(data, ""w"") <end> ;"	"void CWE78_OS_Command_Injection__char_listen_socket_popen_67b_badSink(CWE78_OS_Command_Injection__char_listen_socket_popen_67_structType <start> myStruct <end> );
char * data = <start> myStruct <end> .structFirst;"	1
951c5e6d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FULL_COMMAND ""dir "" #else #define FULL_COMMAND ""ls "" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define POPEN _popen #define PCLOSE _pclose #else #define POPEN popen #define PCLOSE pclose #endif void CWE78_OS_Command_Injection__char_connect_socket_popen_13_bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; if(GLOBAL_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { FILE *pipe; pipe = POPEN(data, ""w""); if (pipe != NULL) { PCLOSE(pipe); } } }"	where is the vulnerable dataflow from data to POPEN ?	"pipe = <start> POPEN(data, ""w"") <end> ;
pipe = POPEN <start> data <end> , ""w"");"	"pipe = POPEN <start> data <end> , ""w"");
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (100 - dataLen - 1), 0);"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
pipe = POPEN <start> data <end> , ""w"");"	"pipe = <start> POPEN(data, ""w"") <end> ;
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	2
60db83c6-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__char_rand_multiply_31_bad() { char data; data = ' '; data = (char)RAND32(); { char dataCopy = data; char data = dataCopy; if(data > 0) { char result = data * 2; printHexCharLine(result); } } }	where is the vulnerable dataflow from data ?	"data = (char <start> RAND32() <end> ;
char result = <start> data * 2 <end> ;"	"data = (char <start> RAND32() <end> ;
char result = <start> data <end>  * 2;"	"if <start> data > 0 <end> ) ;
char result = <start> data <end>  * 2;"	"<start> printHexCharLine(result) <end> ;
data = (char <start> RAND32() <end> ;"	1
67d010e9-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__char_rand_preinc_66b_badSink(char dataArray[]) { char data = dataArray[2]; { ++data; char result = data; printHexCharLine(result); } }	where is the vulnerable dataflow from data ?	"void CWE190_Integer_Overflow__char_rand_preinc_66b_badSink(char <start> dataArray <end> []);
+ <start> data <end> ;"	"+ <start> data <end> ;
<start> printHexCharLine(result) <end> ;"	"char <start> data = dataArray[2] <end> ;
void CWE190_Integer_Overflow__char_rand_preinc_66b_badSink(char <start> dataArray <end> []);"	"char <start> result = data <end> ;
void CWE190_Integer_Overflow__char_rand_preinc_66b_badSink(char <start> dataArray <end> []);"	0
9b124d91-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int badSource(int data) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } return data; } void CWE124_Buffer_Underwrite__CWE839_fgets_42_bad() { int data; data = -1; data = badSource(data); { int i; int buffer[10] = { 0 }; if (data < 10) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } } }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> buffer[i] <end> );"	"data = <start> badSource <end> (data);
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> buffer[i] <end> );"	"data = <start> badSource <end> (data);
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> buffer[i] <end> );
static int <start> badSource <end> (int data);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
static int <start> badSource <end> (int data);
data = <start> badSource <end> (data);
printIntLine <start> buffer[i] <end> );"	3
b1b80809-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int CWE197_Numeric_Truncation_Error__int_listen_socket_to_char_45_badData; static int CWE197_Numeric_Truncation_Error__int_listen_socket_to_char_45_goodG2BData; static void badSink() { int data = CWE197_Numeric_Truncation_Error__int_listen_socket_to_char_45_badData; { char charData = (char)data; printHexCharLine(charData); } } void CWE197_Numeric_Truncation_Error__int_listen_socket_to_char_45_bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE197_Numeric_Truncation_Error__int_listen_socket_to_char_45_badData = data; badSink(); }"	where is the vulnerable dataflow from charData to printHexCharLine ?	"printHexCharLine <start> charData <end> );
int data = <start> CWE197_Numeric_Truncation_Error__int_listen_socket_to_char_45_badData <end> ;
static int <start> CWE197_Numeric_Truncation_Error__int_listen_socket_to_char_45_badData <end> ;
<start> recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
<start> CWE197_Numeric_Truncation_Error__int_listen_socket_to_char_45_badData = data <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> CWE197_Numeric_Truncation_Error__int_listen_socket_to_char_45_badData = data <end> ;
static int <start> CWE197_Numeric_Truncation_Error__int_listen_socket_to_char_45_badData <end> ;
int data = <start> CWE197_Numeric_Truncation_Error__int_listen_socket_to_char_45_badData <end> ;
printHexCharLine <start> charData <end> );"	"int data = <start> CWE197_Numeric_Truncation_Error__int_listen_socket_to_char_45_badData <end> ;
printHexCharLine <start> charData <end> );
<start> CWE197_Numeric_Truncation_Error__int_listen_socket_to_char_45_badData = data <end> ;
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
static int <start> CWE197_Numeric_Truncation_Error__int_listen_socket_to_char_45_badData <end> ;"	"char charData = <start> (char)data <end> ;
printHexCharLine <start> charData <end> );
int data = <start> CWE197_Numeric_Truncation_Error__int_listen_socket_to_char_45_badData <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static int <start> CWE197_Numeric_Truncation_Error__int_listen_socket_to_char_45_badData <end> ;"	1
48d25dd0-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_multiply_11_bad() { int data; data = 0; if(globalReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalReturnsTrue()) { if(data > 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printIntLine(result) <end> ;"	"data = <start> atoi(inputBuffer) <end> ;
int result = <start> data <end>  * 2;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int <start> result = data * 2 <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  * 2;"	3
6a52beee-6c15-11ed-81d4-94e6f77dd552	static void badSink(unsigned int data) { { data--; unsigned int result = data; printUnsignedLine(result); } } void CWE191_Integer_Underflow__unsigned_int_rand_postdec_44_bad() { unsigned int data; void (*funcPtr) (unsigned int) = badSink; data = 0; data = (unsigned int)RAND32(); funcPtr(data); }	where is the vulnerable dataflow from data ?	"<start> data <end> --;
funcPtr <start> data <end> );
data = (unsigned int <start> RAND32() <end> ;
static void badSink(unsigned int <start> data <end> );"	"data = (unsigned int <start> RAND32() <end> ;
funcPtr <start> data <end> );
static void badSink(unsigned int <start> data <end> );
<start> data <end> --;"	"<start> funcPtr(data) <end> ;
<start> data <end> --;
funcPtr <start> data <end> );
data = (unsigned int <start> RAND32() <end> ;"	"static void badSink(unsigned int <start> data <end> );
<start> data <end> --;
funcPtr <start> data <end> );
<start> funcPtr(data) <end> ;"	1
86cea165-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE369_Divide_by_Zero__int_listen_socket_modulo_09_bad() { int data; data = -1; if(GLOBAL_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(GLOBAL_CONST_TRUE) { printIntLine(100 % data); } }"	where is the vulnerable dataflow from data to printIntLine ?	"if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data = atoi(inputBuffer) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> 100 % data <end> );"	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> 100 % data <end> );"	2
c8600adf-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 namespace CWE23_Relative_Path_Traversal__char_listen_socket_ofstream_09 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(GLOBAL_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
outputFile.open((char * <start> data <end> );"	"outputFile.open((char * <start> data <end> );
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"replace = <start> strchr(data, '\r') <end> ;
outputFile.open((char * <start> data <end> );"	0
99e16a93-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_listen_socket_82 { void bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_listen_socket_82_base* baseObject = new CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_listen_socket_82_bad; baseObject->action(data); delete baseObject; }"	where is the vulnerable dataflow from data to action ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
baseObject->action <start> data <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
data = <start> atoi(inputBuffer) <end> ;"	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
baseObject->action <start> data <end> );"	"if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );
baseObject->action <start> data <end> );"	0
584fa868-6c15-11ed-81d4-94e6f77dd552	namespace CWE191_Integer_Underflow__int_listen_socket_multiply_81 { void CWE191_Integer_Underflow__int_listen_socket_multiply_81_bad::action(int data) const { if(data < 0) { int result = data * 2; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
void CWE191_Integer_Underflow__int_listen_socket_multiply_81_bad::action(int <start> data <end> ) const;"	"void CWE191_Integer_Underflow__int_listen_socket_multiply_81_bad::action(int <start> data <end> ) const;
int result = <start> data <end>  * 2;"	"void CWE191_Integer_Underflow__int_listen_socket_multiply_81_bad::action(int <start> data <end> ) const;
int result = <start> data * 2 <end> ;"	"if <start> data < 0 <end> ) ;
void CWE191_Integer_Underflow__int_listen_socket_multiply_81_bad::action(int <start> data <end> ) const;"	1
8b91e48d-6c15-11ed-81d4-94e6f77dd552	#ifndef _WIN32 #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_listen_socket_open_74 { void badSink(map<int, char *> dataMap) { char * data = dataMap[2]; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"void badSink(map<int, char *> <start> dataMap <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
void badSink(map<int, char *> <start> dataMap <end> );"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
void badSink(map<int, char *> <start> dataMap <end> );"	1
4c66614e-6c15-11ed-81d4-94e6f77dd552	"static int badStatic = 0; static void badSink(unsigned int data) { if(badStatic) { if(data > 0) { unsigned int result = data * 2; printUnsignedLine(result); } } } void CWE190_Integer_Overflow__unsigned_int_fscanf_multiply_21_bad() { unsigned int data; data = 0; fscanf (stdin, ""%u"", &data); badStatic = 1; badSink(data); }"	where is the vulnerable dataflow from data ?	"fscanf (stdin, ""%u"", <start> &data <end> );
unsigned int result = <start> data <end>  * 2;
static void badSink(unsigned int <start> data <end> );
<start> badSink(data) <end> ;"	"fscanf (stdin, ""%u"", <start> &data <end> );
badSink <start> data <end> );
static void badSink(unsigned int <start> data <end> );
unsigned int result = <start> data <end>  * 2;"	"badSink <start> data <end> );
fscanf (stdin, ""%u"", <start> &data <end> );
<start> badSink(data) <end> ;
static void badSink(unsigned int <start> data <end> );"	"static void badSink(unsigned int <start> data <end> );
fscanf (stdin, ""%u"", <start> &data <end> );
unsigned int result = <start> data <end>  * 2;
badSink <start> data <end> );"	1
c01af8ee-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_console_fopen_02 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(1) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = FOPEN <start> data <end> , ""wb+"");
<start> data = dataBuffer <end> ;"	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
pFile = FOPEN <start> data <end> , ""wb+"");"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
dataLen = <start> strlen(data) <end> ;"	2
5be3a9ba-6c15-11ed-81d4-94e6f77dd552	extern int CWE191_Integer_Underflow__int_fscanf_postdec_22_badGlobal; void CWE191_Integer_Underflow__int_fscanf_postdec_22_badSink(int data) { if(CWE191_Integer_Underflow__int_fscanf_postdec_22_badGlobal) { { data--; int result = data; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"void CWE191_Integer_Underflow__int_fscanf_postdec_22_badSink(int <start> data <end> );
<start> printIntLine(result) <end> ;"	"void CWE191_Integer_Underflow__int_fscanf_postdec_22_badSink(int <start> data <end> );
<start> data-- <end> ;"	"<start> data <end> --;
void CWE191_Integer_Underflow__int_fscanf_postdec_22_badSink(int <start> data <end> );"	"void CWE191_Integer_Underflow__int_fscanf_postdec_22_badSink(int <start> data <end> );
<start> data <end> --;"	3
4a02115b-6c15-11ed-81d4-94e6f77dd552	"static short badSource(short data) { fscanf (stdin, ""%hd"", &data); return data; } void CWE190_Integer_Overflow__short_fscanf_add_42_bad() { short data; data = 0; data = badSource(data); { short result = data + 1; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"data = <start> badSource <end> (data);
fscanf (stdin, ""%hd"", <start> &data <end> );
static short <start> badSource <end> (short data);
<start> printIntLine(result) <end> ;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
static short <start> badSource <end> (short data);
data = <start> badSource <end> (data);
short result = <start> data <end>  + 1;"	"data = <start> badSource <end> (data);
static short <start> badSource <end> (short data);
fscanf (stdin, ""%hd"", <start> &data <end> );
short <start> result = data + 1 <end> ;"	"data = <start> badSource <end> (data);
static short <start> badSource <end> (short data);"	1
acf67e34-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_connect_socket_predec_63b_badSink(int * dataPtr) { int data = *dataPtr; { --data; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
int <start> data = *dataPtr <end> ;"	"void CWE191_Integer_Underflow__int_connect_socket_predec_63b_badSink(int * <start> dataPtr <end> );
printIntLine <start> result <end> );"	"void CWE191_Integer_Underflow__int_connect_socket_predec_63b_badSink(int * <start> dataPtr <end> );
<start> printIntLine(result) <end> ;"	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	1
6dc61518-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif typedef union { char * unionFirst; char * unionSecond; } CWE134_Uncontrolled_Format_String__char_console_snprintf_34_unionType; void CWE134_Uncontrolled_Format_String__char_console_snprintf_34_bad() { char * data; CWE134_Uncontrolled_Format_String__char_console_snprintf_34_unionType myUnion; char dataBuffer[100] = """"; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } myUnion.unionFirst = data; { char * data = myUnion.unionSecond; { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } } }"	where is the vulnerable dataflow from dest to printLine ?	"printLine <start> dest <end> );
char <start> dataBuffer[100] = """" <end> ;"	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
printLine <start> dest <end> );"	"printLine <start> dest <end> );
if (dataLen > 0 && <start> data[dataLen-1] == '\n' <end> );"	2
b68484df-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif namespace CWE36_Absolute_Path_Traversal__char_file_fopen_82 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } CWE36_Absolute_Path_Traversal__char_file_fopen_82_base* baseObject = new CWE36_Absolute_Path_Traversal__char_file_fopen_82_bad; baseObject->action(data); delete baseObject; }"	where is the vulnerable dataflow from data to action ?	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"baseObject->action <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
<start> data = dataBuffer <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
baseObject->action <start> data <end> );"	3
b8e2bda6-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define NEW_PATH ""%SystemRoot%\\system32"" #define PUTENV _putenv #else #define NEW_PATH ""/bin"" #define PUTENV putenv #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 typedef union { char * unionFirst; char * unionSecond; } CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_34_unionType; void CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_34_bad() { char * data; CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_34_unionType myUnion; char dataBuffer[250] = ""PATH=""; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (250 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } myUnion.unionFirst = data; { char * data = myUnion.unionSecond; PUTENV(data); } }"	where is the vulnerable dataflow from data to PUTENV ?	"<start> PUTENV(data) <end> ;
PUTENV <start> data <end> );"	"size_t dataLen = <start> strlen(data) <end> ;
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (250 - dataLen - 1), 0);"	"recvResult = <start> recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (250 - dataLen - 1), 0) <end> ;
PUTENV <start> data <end> );"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (250 - dataLen - 1), 0);
PUTENV <start> data <end> );"	3
4ec5d067-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_postinc_66b_badSink(int dataArray[]) { int data = dataArray[2]; { data++; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"void CWE190_Integer_Overflow__int_connect_socket_postinc_66b_badSink(int <start> dataArray <end> []);
<start> data <end> ++;"	"<start> data <end> ++;
void CWE190_Integer_Overflow__int_connect_socket_postinc_66b_badSink(int <start> dataArray <end> []);"	"<start> printIntLine(result) <end> ;
void CWE190_Integer_Overflow__int_connect_socket_postinc_66b_badSink(int <start> dataArray <end> []);"	"<start> data++ <end> ;
void CWE190_Integer_Overflow__int_connect_socket_postinc_66b_badSink(int <start> dataArray <end> []);"	0
bed4a8b2-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 namespace CWE78_OS_Command_Injection__char_listen_socket_system_82 { void bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE78_OS_Command_Injection__char_listen_socket_system_82_base* baseObject = new CWE78_OS_Command_Injection__char_listen_socket_system_82_bad; baseObject->action(data); delete baseObject; }"	where is the vulnerable dataflow from data to action ?	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
baseObject->action <start> data <end> );"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
size_t dataLen = <start> strlen(data) <end> ;"	"replace = <start> strchr(data, '\r') <end> ;
baseObject->action <start> data <end> );"	"baseObject->action <start> data <end> );
replace = <start> strchr(data, '\n') <end> ;"	0
c26a7e52-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_console_open_52 { void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } badSink_b(data); }"	where is the vulnerable dataflow from data to badSink_b ?	"badSink_b <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"<start> data = dataBuffer <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"badSink_b <start> data <end> );
dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
badSink_b <start> data <end> );"	3
bb49c59a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #define EXECLP _execlp #else #define EXECLP execlp #endif void CWE78_OS_Command_Injection__char_console_execlp_03_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(5==5) { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECLP ?	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
dataLen = <start> strlen(data) <end> ;"	"char <start> dataBuffer[100] = COMMAND_ARG2 <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	2
af580947-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticTrue = 1; static int staticFalse = 0; void CWE197_Numeric_Truncation_Error__int_connect_socket_to_short_05_bad() { int data; data = -1; if(staticTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { short shortData = (short)data; printShortLine(shortData); } }"	where is the vulnerable dataflow from shortData to printShortLine ?	"<start> printShortLine(shortData) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printShortLine <start> shortData <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printShortLine <start> shortData <end> );"	"short <start> shortData = (short)data <end> ;
printShortLine <start> shortData <end> );"	2
aa91a1ac-6c15-11ed-81d4-94e6f77dd552	namespace CWE191_Integer_Underflow__int_listen_socket_sub_81 { void CWE191_Integer_Underflow__int_listen_socket_sub_81_bad::action(int data) const { { int result = data - 1; printIntLine(result); } } }	where is the vulnerable dataflow from result to printIntLine ?	"int <start> result = data - 1 <end> ;
void CWE191_Integer_Underflow__int_listen_socket_sub_81_bad::action(int <start> data <end> ) const;"	"printIntLine <start> result <end> );
void CWE191_Integer_Underflow__int_listen_socket_sub_81_bad::action(int <start> data <end> ) const;"	"printIntLine <start> result <end> );
int <start> result = data - 1 <end> ;"	"void CWE191_Integer_Underflow__int_listen_socket_sub_81_bad::action(int <start> data <end> ) const;
printIntLine <start> result <end> );"	3
7d44fcb3-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_malloc_08_bad() { int data; data = -1; if(staticReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }"	where is the vulnerable dataflow from data to malloc ?	"<start> free(dataBuffer) <end> ;
char * dataBuffer = (char *)malloc <start> data <end> );"	"char * dataBuffer = (char *)malloc <start> data <end> );
<start> data = -1 <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
char * dataBuffer = (char *)malloc <start> data <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printLine(dataBuffer) <end> ;"	2
bc721f73-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define EXECL _execl #else #define EXECL execl #endif void CWE78_OS_Command_Injection__char_file_execl_09_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(GLOBAL_CONST_TRUE) { { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECL ?	"<start> EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	"if  <start> fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL <end> );
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	3
73bc817b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" typedef union { short unionFirst; short unionSecond; } CWE194_Unexpected_Sign_Extension__connect_socket_memmove_34_unionType; void CWE194_Unexpected_Sign_Extension__connect_socket_memmove_34_bad() { short data; CWE194_Unexpected_Sign_Extension__connect_socket_memmove_34_unionType myUnion; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } myUnion.unionFirst = data; { short data = myUnion.unionSecond; { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } } }"	where is the vulnerable dataflow from dest to printLine ?	"char <start> dest[100] = """" <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> memmove(dest, source, data) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"<start> memmove(dest, source, data) <end> ;
printLine <start> dest <end> );"	2
67d010c9-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__char_rand_preinc_02_bad() { char data; data = ' '; if(1) { data = (char)RAND32(); } if(1) { { ++data; char result = data; printHexCharLine(result); } } }	where is the vulnerable dataflow from data ?	"+ <start> data <end> ;
data = (char <start> RAND32() <end> ;"	"data = (char <start> RAND32() <end> ;
<start> printHexCharLine(result) <end> ;"	"data = (char <start> RAND32() <end> ;
+ <start> data <end> ;"	"<start> ++data <end> ;
data = (char <start> RAND32() <end> ;"	2
6b862433-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink(int data) { { int i; int * buffer = (int *)malloc(10 * sizeof(int)); if (buffer == NULL) {exit(-1);} for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } free(buffer); } } void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_connect_socket_44_bad() { int data; void (*funcPtr) (int) = badSink; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } funcPtr(data); }"	where is the vulnerable dataflow from buffer to free ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
free <start> buffer <end> );
data = <start> atoi(inputBuffer) <end> ;
funcPtr <start> data <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
funcPtr <start> data <end> );
static void badSink(int <start> data <end> );
free <start> buffer <end> );"	"funcPtr <start> data <end> );
static void badSink(int <start> data <end> );
free <start> buffer <end> );
<start> funcPtr(data) <end> ;"	"free <start> buffer <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> funcPtr(data) <end> ;
funcPtr <start> data <end> );"	1
630ae7f0-6c15-11ed-81d4-94e6f77dd552	short CWE190_Integer_Overflow__short_rand_multiply_61b_badSource(short data); void CWE190_Integer_Overflow__short_rand_multiply_61_bad() { short data; data = 0; data = CWE190_Integer_Overflow__short_rand_multiply_61b_badSource(data); if(data > 0) { short result = data * 2; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"short result = <start> data <end>  * 2;
data = <start> CWE190_Integer_Overflow__short_rand_multiply_61b_badSource(data) <end> ;"	"data = <start> CWE190_Integer_Overflow__short_rand_multiply_61b_badSource <end> (data);
short result = <start> data * 2 <end> ;"	"short result = <start> data <end>  * 2;
<start> printIntLine(result) <end> ;"	"data = <start> CWE190_Integer_Overflow__short_rand_multiply_61b_badSource <end> (data);
short result = <start> data <end>  * 2;"	3
5133a74b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_preinc_53d_badSink(int data) { { ++data; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"void CWE190_Integer_Overflow__int_connect_socket_preinc_53d_badSink(int <start> data <end> );
+ <start> data <end> ;"	"void CWE190_Integer_Overflow__int_connect_socket_preinc_53d_badSink(int <start> data <end> );
<start> printIntLine(result) <end> ;"	"+ <start> data <end> ;
void CWE190_Integer_Overflow__int_connect_socket_preinc_53d_badSink(int <start> data <end> );"	"<start> printIntLine(result) <end> ;
+ <start> data <end> ;"	0
7ae3a73c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_15_bad() { int data; data = -1; switch(6) { case 6: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; default: printLine(""Benign, fixed string""); break; } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);
printLine <start> dest <end> );"	"if  <start> data < 100 <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"data = <start> atoi(inputBuffer) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	2
aa91a1a4-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_listen_socket_sub_64b_badSink(void * dataVoidPtr) { int * dataPtr = (int *)dataVoidPtr; int data = (*dataPtr); { int result = data - 1; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;"	"void CWE191_Integer_Underflow__int_listen_socket_sub_64b_badSink(void * <start> dataVoidPtr <end> );
printIntLine <start> result <end> );"	"int <start> result = data - 1 <end> ;
void CWE191_Integer_Underflow__int_listen_socket_sub_64b_badSink(void * <start> dataVoidPtr <end> );"	"int <start> result = data - 1 <end> ;
printIntLine <start> result <end> );"	1
d0b64ee0-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif namespace CWE36_Absolute_Path_Traversal__char_file_ofstream_03 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(5==5) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"outputFile.open((char * <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
outputFile.open((char * <start> data <end> );"	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"<start> data = dataBuffer <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	1
5133a746-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int badSource(int data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } return data; } void CWE190_Integer_Overflow__int_connect_socket_preinc_42_bad() { int data; data = 0; data = badSource(data); { ++data; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"int <start> result = data <end> ;
+ <start> data <end> ;
static int <start> badSource <end> (int data);
data = <start> badSource <end> (data);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static int <start> badSource <end> (int data);
data = <start> badSource <end> (data);
+ <start> data <end> ;"	"static int <start> badSource <end> (int data);
data = <start> badSource <end> (data);
+ <start> data <end> ;"	"<start> data = badSource(data) <end> ;
static int <start> badSource <end> (int data);
+ <start> data <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	1
55ef4cdd-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_fgets_sub_54e_badSink(int data) { { int result = data - 1; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"int <start> result = data - 1 <end> ;
void CWE191_Integer_Underflow__int_fgets_sub_54e_badSink(int <start> data <end> );"	"void CWE191_Integer_Underflow__int_fgets_sub_54e_badSink(int <start> data <end> );
int result = <start> data <end>  - 1;"	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  - 1;"	"int result = <start> data <end>  - 1;
void CWE191_Integer_Underflow__int_fgets_sub_54e_badSink(int <start> data <end> );"	1
ce547d2e-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_environment_fopen_54 { void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } badSink_b(data); }"	where is the vulnerable dataflow from data to badSink_b ?	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
<start> badSink_b(data) <end> ;"	"<start> strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1) <end> ;
badSink_b <start> data <end> );"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
<start> strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1) <end> ;"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
badSink_b <start> data <end> );"	3
4ff78256-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_postinc_51b_badSink(int data) { { data++; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"int <start> result = data <end> ;
<start> data <end> ++;"	"void CWE190_Integer_Overflow__int_listen_socket_postinc_51b_badSink(int <start> data <end> );
<start> data <end> ++;"	"void CWE190_Integer_Overflow__int_listen_socket_postinc_51b_badSink(int <start> data <end> );
int <start> result = data <end> ;"	"<start> data <end> ++;
void CWE190_Integer_Overflow__int_listen_socket_postinc_51b_badSink(int <start> data <end> );"	1
8932180c-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif static int staticFive = 5; namespace CWE36_Absolute_Path_Traversal__char_file_fopen_07 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(staticFive==5) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
pFile = FOPEN <start> data <end> , ""wb+"");"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
<start> data = dataBuffer <end> ;"	"pFile = FOPEN <start> data <end> , ""wb+"");
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	1
774f5823-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 8 void CWE194_Unexpected_Sign_Extension__listen_socket_malloc_53d_badSink(short data) { if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }"	where is the vulnerable dataflow from data to malloc ?	"<start> printLine(dataBuffer) <end> ;
char * dataBuffer = (char *)malloc <start> data <end> );"	"char * dataBuffer = (char *)malloc <start> data <end> );
if  <start> data < 100 <end> );"	"void CWE194_Unexpected_Sign_Extension__listen_socket_malloc_53d_badSink(short <start> data <end> );
char * dataBuffer = (char *)malloc <start> data <end> );"	"char * dataBuffer = (char *)malloc <start> data <end> );
memset(dataBuffer, 'A', <start> data-1 <end> );"	2
55ef4caf-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_fgets_multiply_51b_badSink(int data) { if(data < 0) { int result = data * 2; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"if <start> data < 0 <end> ) ;
int result = <start> data <end>  * 2;"	"void CWE191_Integer_Underflow__int_fgets_multiply_51b_badSink(int <start> data <end> );
<start> printIntLine(result) <end> ;"	"int result = <start> data <end>  * 2;
void CWE191_Integer_Underflow__int_fgets_multiply_51b_badSink(int <start> data <end> );"	"void CWE191_Integer_Underflow__int_fgets_multiply_51b_badSink(int <start> data <end> );
int result = <start> data <end>  * 2;"	3
b08640d6-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticTrue = 1; static int staticFalse = 0; void CWE197_Numeric_Truncation_Error__int_fgets_to_short_05_bad() { int data; data = -1; if(staticTrue) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } { short shortData = (short)data; printShortLine(shortData); } }"	where is the vulnerable dataflow from shortData to printShortLine ?	"<start> printShortLine(shortData) <end> ;
printShortLine <start> shortData <end> );"	"printShortLine <start> shortData <end> );
short shortData = <start> (short)data <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printShortLine <start> shortData <end> );"	"<start> data = -1 <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	2
c99197b0-6c15-11ed-81d4-94e6f77dd552	#ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_listen_socket_open_81 { void CWE23_Relative_Path_Traversal__char_listen_socket_open_81_bad::action(char * data) const { { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } } }	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"void CWE23_Relative_Path_Traversal__char_listen_socket_open_81_bad::action(char * <start> data <end> ) const;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
void CWE23_Relative_Path_Traversal__char_listen_socket_open_81_bad::action(char * <start> data <end> ) const;"	2
ae26ae2a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_FIVE = 5; void CWE191_Integer_Underflow__int_listen_socket_predec_06_bad() { int data; data = 0; if(STATIC_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(STATIC_CONST_FIVE==5) { { --data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> --data <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"<start> printIntLine(result) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"printIntLine <start> result <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	1
c5fc2360-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif namespace CWE23_Relative_Path_Traversal__char_file_ofstream_43 { void badSource(char * &data) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; badSource(data); { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
badSource <start> data <end> );"	"badSource <start> data <end> );
outputFile.open((char * <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"outputFile.open((char * <start> data <end> );
badSource <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
badSource <start> data <end> );
outputFile.open((char * <start> data <end> );"	3
a49c4f91-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_postinc_03_bad() { int data; data = 0; if(5==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(5==5) { { data++; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"<start> data++ <end> ;
printIntLine <start> result <end> );"	"int <start> result = data <end> ;
printIntLine <start> result <end> );"	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> result <end> );"	0
8a63109b-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_file_fopen_15 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; switch(6) { case 6: { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } break; default: printLine(""Benign, fixed string""); break; } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"<start> data = dataBuffer <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"size_t dataLen = <start> strlen(data) <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	0
cf875089-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_environment_open_16 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; while(1) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } break; } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"char <start> dataBuffer[FILENAME_MAX] = """" <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"strncat(data+dataLen, environment, FILENAME_MAX <start> dataLen-1 <end> );
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"strncat(data+dataLen, environment, FILENAME_MAX <start> dataLen-1 <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	3
964cdc23-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FULL_COMMAND ""dir "" #else #define FULL_COMMAND ""ls "" #endif #ifdef _WIN32 #define POPEN _popen #define PCLOSE _pclose #else #define POPEN popen #define PCLOSE pclose #endif namespace CWE78_OS_Command_Injection__char_listen_socket_popen_72 { void badSink(vector<char *> dataVector) { char * data = dataVector[2]; { FILE *pipe; pipe = POPEN(data, ""w""); if (pipe != NULL) { PCLOSE(pipe); } } }"	where is the vulnerable dataflow from data to POPEN ?	"char <start> * data = dataVector[2] <end> ;
void badSink(vector<char *> <start> dataVector <end> );"	"void badSink(vector<char *> <start> dataVector <end> );
pipe = POPEN <start> data <end> , ""w"");"	"pipe = <start> POPEN(data, ""w"") <end> ;
void badSink(vector<char *> <start> dataVector <end> );"	"pipe = POPEN <start> data <end> , ""w"");
void badSink(vector<char *> <start> dataVector <end> );"	1
5e44fc8d-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) extern int CWE191_Integer_Underflow__int_fgets_predec_68_badData; extern int CWE191_Integer_Underflow__int_fgets_predec_68_goodG2BData; extern int CWE191_Integer_Underflow__int_fgets_predec_68_goodB2GData; void CWE191_Integer_Underflow__int_fgets_predec_68b_badSink() { int data = CWE191_Integer_Underflow__int_fgets_predec_68_badData; { --data; int result = data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"int data = <start> CWE191_Integer_Underflow__int_fgets_predec_68_badData <end> ;
- <start> data <end> ;"	"int data = <start> CWE191_Integer_Underflow__int_fgets_predec_68_badData <end> ;
<start> --data <end> ;"	"<start> printIntLine(result) <end> ;
- <start> data <end> ;"	"- <start> data <end> ;
int data = <start> CWE191_Integer_Underflow__int_fgets_predec_68_badData <end> ;"	0
86cea151-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE369_Divide_by_Zero__int_listen_socket_divide_16_bad() { int data; data = -1; while(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; } while(1) { printIntLine(100 / data); break; } }"	where is the vulnerable dataflow from data to printIntLine ?	"printIntLine <start> 100 / data <end> );
if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );"	"printIntLine <start> 100 / data <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"printIntLine <start> 100 / data <end> );
<start> data = atoi(inputBuffer) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> 100 / data <end> );"	3
964cdc01-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define EXECLP _execlp #else #define EXECLP execlp #endif void CWE78_OS_Command_Injection__char_listen_socket_execlp_17_bad() { int i; char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; for(i = 0; i < 1; i++) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from data to sizeof ?	<start> EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL) <end> ;	size_t dataLen = <start> strlen(data) <end> ;	replace = <start> strchr(data, '\r') <end> ;	recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);	3
571e9848-6c15-11ed-81d4-94e6f77dd552	namespace CWE191_Integer_Underflow__int_fscanf_sub_74 { void badSink(map<int, int> dataMap) { int data = dataMap[2]; { int result = data - 1; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"void badSink(map<int, int> <start> dataMap <end> );
int result = <start> data <end>  - 1;"	"int <start> data = dataMap[2] <end> ;
int result = <start> data <end>  - 1;"	"int result = <start> data <end>  - 1;
<start> printIntLine(result) <end> ;"	"void badSink(map<int, int> <start> dataMap <end> );
int <start> result = data - 1 <end> ;"	0
846ad322-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define STAT _stat #define OPEN _open #define WRITE _write #define O_RDWR _O_RDWR #define CLOSE _close #else #define STAT stat #define OPEN open #define WRITE write #define CLOSE close #endif #define BAD_SINK_STRING ""Bad Sink..."" #define GOOD_SINK_STRING ""Good Sink..."" static int staticFive = 5; void CWE367_TOC_TOU__stat_07_bad() { if(staticFive==5) { { char filename[100] = """"; struct STAT statBuffer; int fileDesc = -1; if (fgets(filename, 100, stdin) == NULL) { printLine(""fgets() failed""); filename[0] = '\0'; } if (strlen(filename) > 0) { filename[strlen(filename)-1] = '\0'; } if (STAT(filename, &statBuffer) == -1) { exit(1); } fileDesc  = OPEN(filename, O_RDWR); if (fileDesc == -1) { exit(1); } if (WRITE(fileDesc, BAD_SINK_STRING, strlen(BAD_SINK_STRING)) == -1) { exit(1); } if (fileDesc != -1) { CLOSE(fileDesc); } } } }"	where is the vulnerable dataflow from filename to OPEN ?	"fileDesc  = OPEN <start> filename <end> , O_RDWR);
if  <start> fgets(filename, 100, stdin) <end>  == NULL);"	"if (fgets <start> filename <end> , 100, stdin) == NULL);
fileDesc  = OPEN <start> filename <end> , O_RDWR);"	"fileDesc  = OPEN <start> filename <end> , O_RDWR);
filename <start> strlen(filename) <end> -1] = '\0'; ;"	"if  <start> strlen(filename) <end>  > 0);
fileDesc  = OPEN <start> filename <end> , O_RDWR);"	1
630ae806-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__short_rand_square_11_bad() { short data; data = 0; if(globalReturnsTrue()) { data = (short)RAND32(); } if(globalReturnsTrue()) { { short result = data * data; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"data = (short <start> RAND32() <end> ;
short <start> result = data * data <end> ;"	"<start> data = 0 <end> ;
data = (short <start> RAND32() <end> ;"	"short result = <start> data <end>  * data;
data = (short <start> RAND32() <end> ;"	"data = (short <start> RAND32() <end> ;
short result = <start> data <end>  * data;"	3
cd228162-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_console_open_18 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; goto source; source: { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
size_t dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
if (dataLen > 0 && <start> data[dataLen-1] == '\n' <end> );"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
if (dataLen > 0 && <start> data[dataLen-1] == '\n' <end> );"	1
ce547d48-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif namespace CWE36_Absolute_Path_Traversal__char_environment_ifstream_18 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; goto source; source: { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"size_t <start> dataLen = strlen(data) <end> ;
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"inputFile.open((char * <start> data <end> );
size_t <start> dataLen = strlen(data) <end> ;"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
inputFile.open((char * <start> data <end> );"	"<start> data = dataBuffer <end> ;
inputFile.open((char * <start> data <end> );"	2
af580937-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_64b_badSink(void * dataVoidPtr) { int * dataPtr = (int *)dataVoidPtr; int data = (*dataPtr); { char charData = (char)data; printHexCharLine(charData); } }"	where is the vulnerable dataflow from charData to printHexCharLine ?	"printHexCharLine <start> charData <end> );
char <start> charData = (char)data <end> ;"	"<start> printHexCharLine(charData) <end> ;
void CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_64b_badSink(void * <start> dataVoidPtr <end> );"	"void CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_64b_badSink(void * <start> dataVoidPtr <end> );
printHexCharLine <start> charData <end> );"	"char <start> charData = (char)data <end> ;
void CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_64b_badSink(void * <start> dataVoidPtr <end> );"	2
4b34b000-6c15-11ed-81d4-94e6f77dd552	"void CWE190_Integer_Overflow__short_fscanf_square_14_bad() { short data; data = 0; if(globalFive==5) { fscanf (stdin, ""%hd"", &data); } if(globalFive==5) { { short result = data * data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );"	"fscanf (stdin, ""%hd"", <start> &data <end> );
short result = <start> data <end>  * data;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
<start> data = 0 <end> ;"	"<start> printIntLine(result) <end> ;
short result = <start> data <end>  * data;"	1
55ef4c98-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; void CWE191_Integer_Underflow__int_fgets_multiply_04_bad() { int data; data = 0; if(STATIC_CONST_TRUE) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(STATIC_CONST_TRUE) { if(data < 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"int result = <start> data * 2 <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if  <start> fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) <end>  != NULL);
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"int <start> result = data * 2 <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
int result = <start> data <end>  * 2;"	3
61da66da-6c15-11ed-81d4-94e6f77dd552	static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; void CWE190_Integer_Overflow__char_rand_square_04_bad() { char data; data = ' '; if(STATIC_CONST_TRUE) { data = (char)RAND32(); } if(STATIC_CONST_TRUE) { { char result = data * data; printHexCharLine(result); } } }	where is the vulnerable dataflow from data ?	"data = (char <start> RAND32() <end> ;
<start> printHexCharLine(result) <end> ;"	"char result = <start> data <end>  * data;
<start> printHexCharLine(result) <end> ;"	"data = (char <start> RAND32() <end> ;
char result = <start> data <end>  * data;"	"char result = <start> data <end>  * data;
<start> data = (char)RAND32() <end> ;"	2
c72d5d5c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_listen_socket_fopen_31 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { char * dataCopy = data; char * data = dataCopy; { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } } }"	where is the vulnerable dataflow from data to FOPEN ?	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
replace = <start> strchr(data, '\r') <end> ;"	"size_t dataLen = <start> strlen(data) <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	0
761e29a1-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 8 static int staticTrue = 1; static int staticFalse = 0; void CWE194_Unexpected_Sign_Extension__fgets_strncpy_05_bad() { short data; data = 0; if(staticTrue) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = (short)atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printLine <start> dest <end> );"	"printLine <start> dest <end> );
if  <start> data < 100 <end> );"	"char <start> dest[100] = """" <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"printLine <start> dest <end> );
<start> printLine(dest) <end> ;"	0
453db02a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_multiply_66b_badSink(int dataArray[]) { int data = dataArray[2]; if(data > 0) { int result = data * 2; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
void CWE190_Integer_Overflow__int_connect_socket_multiply_66b_badSink(int <start> dataArray <end> []);"	"void CWE190_Integer_Overflow__int_connect_socket_multiply_66b_badSink(int <start> dataArray <end> []);
int result = <start> data <end>  * 2;"	"int result = <start> data <end>  * 2;
void CWE190_Integer_Overflow__int_connect_socket_multiply_66b_badSink(int <start> dataArray <end> []);"	"void CWE190_Integer_Overflow__int_connect_socket_multiply_66b_badSink(int <start> dataArray <end> []);
int <start> result = data * 2 <end> ;"	1
6c938bc6-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticFive = 5; void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_07_bad() { int data; data = -1; if(staticFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticFive==5) { { int i; int * buffer = (int *)malloc(10 * sizeof(int)); if (buffer == NULL) {exit(-1);} for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } free(buffer); } } }"	where is the vulnerable dataflow from buffer to free ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
free <start> buffer <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
data = <start> atoi(inputBuffer) <end> ;"	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
free <start> buffer <end> );"	"free <start> buffer <end> );
<start> printIntLine(buffer[i]) <end> ;"	0
93ece2cd-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #define HELLO_STRING ""hello"" namespace CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_74 { void badSink(map<int, size_t> dataMap) { size_t data = dataMap[2]; { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); } else { printLine(""Input is less than the length of the source string""); } } }"	where is the vulnerable dataflow from data to malloc ?	"void badSink(map<int, size_t> <start> dataMap <end> );
myString = <start> (char *)malloc(data*sizeof(char)) <end> ;"	"void badSink(map<int, size_t> <start> dataMap <end> );
myString = (char *)malloc <start> data*sizeof(char) <end> );"	"myString = (char *)malloc <start> data*sizeof(char) <end> );
if  <start> data > strlen(HELLO_STRING) <end> );"	"myString = (char *)malloc <start> data*sizeof(char) <end> );
myString = <start> (char *)malloc(data*sizeof(char)) <end> ;"	1
5be3a9a2-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_fgets_postdec_63b_badSink(int * dataPtr) { int data = *dataPtr; { data--; int result = data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
void CWE191_Integer_Underflow__int_fgets_postdec_63b_badSink(int * <start> dataPtr <end> );"	"<start> data <end> --;
void CWE191_Integer_Underflow__int_fgets_postdec_63b_badSink(int * <start> dataPtr <end> );"	"void CWE191_Integer_Underflow__int_fgets_postdec_63b_badSink(int * <start> dataPtr <end> );
<start> data <end> --;"	"int <start> result = data <end> ;
<start> data <end> --;"	2
5e44fc50-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_connect_socket_predec_11_bad() { int data; data = 0; if(globalReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalReturnsTrue()) { { --data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int <start> result = data <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
- <start> data <end> ;"	"- <start> data <end> ;
int <start> result = data <end> ;"	"<start> printIntLine(result) <end> ;
- <start> data <end> ;"	1
571e984c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_listen_socket_multiply_03_bad() { int data; data = 0; if(5==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(5==5) { if(data < 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printIntLine(result) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  * 2;"	"int <start> result = data * 2 <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  * 2;"	1
a23a3e4a-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_square_10_bad() { int data; data = 0; if(globalTrue) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(globalTrue) { { int result = data * data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> printIntLine(result) <end> ;"	"printIntLine <start> result <end> );
data = <start> atoi(inputBuffer) <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	2
60db83b3-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__char_rand_multiply_02_bad() { char data; data = ' '; if(1) { data = (char)RAND32(); } if(1) { if(data > 0) { char result = data * 2; printHexCharLine(result); } } }	where is the vulnerable dataflow from data ?	"data = (char <start> RAND32() <end> ;
char result = <start> data <end>  * 2;"	"<start> data = ' ' <end> ;
data = (char <start> RAND32() <end> ;"	"<start> printHexCharLine(result) <end> ;
char result = <start> data <end>  * 2;"	"char result = <start> data <end>  * 2;
data = (char <start> RAND32() <end> ;"	0
67d010d0-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__char_rand_preinc_09_bad() { char data; data = ' '; if(GLOBAL_CONST_TRUE) { data = (char)RAND32(); } if(GLOBAL_CONST_TRUE) { { ++data; char result = data; printHexCharLine(result); } } }	where is the vulnerable dataflow from data ?	"char <start> result = data <end> ;
data = (char <start> RAND32() <end> ;"	"data = (char <start> RAND32() <end> ;
+ <start> data <end> ;"	"<start> printHexCharLine(result) <end> ;
data = (char <start> RAND32() <end> ;"	"<start> data = ' ' <end> ;
+ <start> data <end> ;"	1
a95fd84d-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticTrue = 1; static int staticFalse = 0; void CWE191_Integer_Underflow__int_fgets_sub_05_bad() { int data; data = 0; if(staticTrue) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(staticTrue) { { int result = data - 1; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"int result = <start> data - 1 <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"int result = <start> data - 1 <end> ;
printIntLine <start> result <end> );"	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );"	3
7fa68e04-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_15_bad() { int data; data = -1; switch(6) { case 6: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; default: printLine(""Benign, fixed string""); break; } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
if  <start> data < 100 <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> strncpy(dest, source, data) <end> ;"	1
69161b2c-6c15-11ed-81d4-94e6f77dd552	static const int STATIC_CONST_FIVE = 5; void CWE190_Integer_Overflow__int_rand_preinc_06_bad() { int data; data = 0; if(STATIC_CONST_FIVE==5) { data = RAND32(); } if(STATIC_CONST_FIVE==5) { { ++data; int result = data; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"+ <start> data <end> ;
data = <start> RAND32() <end> ;"	"data = <start> RAND32() <end> ;
<start> ++data <end> ;"	"+ <start> data <end> ;
<start> data = RAND32() <end> ;"	"data = <start> RAND32() <end> ;
+ <start> data <end> ;"	3
bda4e43f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define EXECLP _execlp #else #define EXECLP execlp #endif void CWE78_OS_Command_Injection__char_listen_socket_execlp_41_badSink(char * data) { EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL); } void CWE78_OS_Command_Injection__char_listen_socket_execlp_41_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE78_OS_Command_Injection__char_listen_socket_execlp_41_badSink(data); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECLP ?	"CWE78_OS_Command_Injection__char_listen_socket_execlp_41_badSink <start> data <end> );
void CWE78_OS_Command_Injection__char_listen_socket_execlp_41_badSink(char * <start> data <end> );
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
<start> recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0) <end> ;"	"if  <start> recvResult == SOCKET_ERROR <end>  || recvResult == 0);
void CWE78_OS_Command_Injection__char_listen_socket_execlp_41_badSink(char * <start> data <end> );
CWE78_OS_Command_Injection__char_listen_socket_execlp_41_badSink <start> data <end> );
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
CWE78_OS_Command_Injection__char_listen_socket_execlp_41_badSink <start> data <end> );
void CWE78_OS_Command_Injection__char_listen_socket_execlp_41_badSink(char * <start> data <end> );
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	3
6c938c1b-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" static void badVaSinkB(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_02_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; if(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(1) { badVaSinkB(data, data); } }"	where is the vulnerable dataflow from data to vfprintf ?	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);"	"size_t <start> dataLen = strlen(data) <end> ;
static void badVaSinkB(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"vfprintf(stdout, <start> data <end> , args);
static void badVaSinkB(char * <start> data <end> , ...);
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (100 - dataLen - 1), 0);"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
size_t dataLen = <start> strlen(data) <end> ;
static void badVaSinkB(char * <start> data <end> , ...);
badVaSinkB <start> data <end> , data);"	0
d1e9da3b-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_listen_socket_fopen_18 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; goto source; source: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"pFile = FOPEN <start> data <end> , ""wb+"");
char <start> dataBuffer[FILENAME_MAX] = """" <end> ;"	1
9fe7ad64-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__int_connect_socket_add_73 { void badSink(list<int> dataList) { int data = dataList.back(); { int result = data + 1; printIntLine(result); } }	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;"	"printIntLine <start> result <end> );
void badSink(list<int> <start> dataList <end> );"	"void badSink(list<int> <start> dataList <end> );
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
int <start> data = dataList.back() <end> ;"	2
c4cd6f3b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_environment_open_13 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(GLOBAL_CONST_FIVE==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"<start> data = dataBuffer <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);"	2
c26a7e43-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_console_open_14 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(globalFive==5) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
<start> data = dataBuffer <end> ;"	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	1
a95fd857-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_fgets_sub_15_bad() { int data; data = 0; switch(6) { case 6: { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } break; default: printLine(""Benign, fixed string""); break; } switch(7) { case 7: { int result = data - 1; printIntLine(result); } break; default: printLine(""Benign, fixed string""); break; } }"	where is the vulnerable dataflow from result to printIntLine ?	"int result = <start> data - 1 <end> ;
printIntLine <start> result <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> printIntLine(result) <end> ;"	"<start> data = atoi(inputBuffer) <end> ;
printIntLine <start> result <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );"	3
79b27570-6c15-11ed-81d4-94e6f77dd552	"namespace CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_82 { void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_82_bad::action(int data) { { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> memcpy(dest, source, data) <end> ;
void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_82_bad::action(int <start> data <end> );"	"printLine <start> dest <end> );
void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_82_bad::action(int <start> data <end> );"	"void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_82_bad::action(int <start> data <end> );
char <start> dest[100] = """" <end> ;"	"void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_82_bad::action(int <start> data <end> );
printLine <start> dest <end> );"	3
630ae826-6c15-11ed-81d4-94e6f77dd552	static int badStatic = 0; static void badSink(int64_t data) { if(badStatic) { { int64_t result = data + 1; printLongLongLine(result); } } } void CWE190_Integer_Overflow__int64_t_rand_add_21_bad() { int64_t data; data = 0LL; data = (int64_t)RAND64(); badStatic = 1; badSink(data); }	where is the vulnerable dataflow from data ?	"data = (int64_t <start> RAND64() <end> ;
badSink <start> data <end> );
static void badSink(int64_t <start> data <end> );
int64_t result = <start> data <end>  + 1;"	"<start> badSink(data) <end> ;
badSink <start> data <end> );
data = (int64_t <start> RAND64() <end> ;
int64_t result = <start> data <end>  + 1;"	"static void badSink(int64_t <start> data <end> );
badSink <start> data <end> );
int64_t result = <start> data <end>  + 1;
data = (int64_t <start> RAND64() <end> ;"	"int64_t result = <start> data <end>  + 1;
data = (int64_t <start> RAND64() <end> ;"	0
d0b64ef7-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif namespace CWE36_Absolute_Path_Traversal__char_file_ofstream_52 { void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } badSink_b(data); }"	where is the vulnerable dataflow from data to badSink_b ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
<start> badSink_b(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
<start> data = dataBuffer <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
badSink_b <start> data <end> );"	"badSink_b <start> data <end> );
<start> data = dataBuffer <end> ;"	2
54c581ec-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_connect_socket_multiply_16_bad() { int data; data = 0; while(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; } while(1) { if(data < 0) { int result = data * 2; printIntLine(result); } break; } }"	where is the vulnerable dataflow from data ?	"data = <start> atoi(inputBuffer) <end> ;
int result = <start> data <end>  * 2;"	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
int result = <start> data <end>  * 2;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printIntLine(result) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  * 2;"	3
715a3bd5-6c15-11ed-81d4-94e6f77dd552	#ifndef _WIN32 #endif namespace CWE134_Uncontrolled_Format_String__char_file_vprintf_73 { static void badVaSink(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); va_end(args); } } void badSink(list<char *> dataList) { char * data = dataList.back(); badVaSink(data, data); }	where is the vulnerable dataflow from data to vprintf ?	"void badSink(list<char *> <start> dataList <end> );
badVaSink <start> data <end> , data);
vprintf <start> data <end> , args);
static void badVaSink(char * <start> data <end> , ...);"	"badVaSink <start> data <end> , data);
vprintf <start> data <end> , args);
static void badVaSink(char * <start> data <end> , ...);"	"void badSink(list<char *> <start> dataList <end> );
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
vprintf <start> data <end> , args);"	"badVaSink <start> data <end> , data);
vprintf <start> data <end> , args);
void badSink(list<char *> <start> dataList <end> );
<start> va_start(args, data) <end> ;"	2
7d44fc7d-6c15-11ed-81d4-94e6f77dd552	"namespace CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_74 { void badSink(map<int, int> dataMap) { int data = dataMap[2]; { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	"void badSink(map<int, int> <start> dataMap <end> );
if  <start> data < 100 <end> );"	"void badSink(map<int, int> <start> dataMap <end> );
printLine <start> dest <end> );"	"void badSink(map<int, int> <start> dataMap <end> );
<start> printLine(dest) <end> ;"	2
a10948e7-6c15-11ed-81d4-94e6f77dd552	extern int CWE190_Integer_Overflow__int_connect_socket_multiply_22_badGlobal; void CWE190_Integer_Overflow__int_connect_socket_multiply_22_badSink(int data) { if(CWE190_Integer_Overflow__int_connect_socket_multiply_22_badGlobal) { if(data > 0) { int result = data * 2; printIntLine(result); } } }	where is the vulnerable dataflow from result to printIntLine ?	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	"void CWE190_Integer_Overflow__int_connect_socket_multiply_22_badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"int result = <start> data * 2 <end> ;
printIntLine <start> result <end> );"	"int <start> result = data * 2 <end> ;
printIntLine <start> result <end> );"	1
a23a3e44-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; void CWE190_Integer_Overflow__int_fgets_square_04_bad() { int data; data = 0; if(STATIC_CONST_TRUE) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(STATIC_CONST_TRUE) { { int result = data * data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
int <start> result = data * data <end> ;"	"<start> printIntLine(result) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"printIntLine <start> result <end> );
data = <start> atoi(inputBuffer) <end> ;"	0
466e7edf-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int badStatic = 0; static void badSink(int data) { if(badStatic) { if(data > 0) { int result = data * 2; printIntLine(result); } } } void CWE190_Integer_Overflow__int_fgets_multiply_21_bad() { int data; data = 0; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } badStatic = 1; badSink(data); }"	where is the vulnerable dataflow from data ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
badSink <start> data <end> );
static void badSink(int <start> data <end> );
int result = <start> data <end>  * 2;"	"<start> badSink(data) <end> ;
static void badSink(int <start> data <end> );
int result = <start> data <end>  * 2;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"int result = <start> data <end>  * 2;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"int result = <start> data <end>  * 2;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
badSink <start> data <end> );
<start> badSink(data) <end> ;"	0
9187cbe0-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define SEARCH_CHAR 'S' typedef union { char * unionFirst; char * unionSecond; } CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_34_unionType; void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_34_bad() { char * data; CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_34_unionType myUnion; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\0'; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } myUnion.unionFirst = data; { char * data = myUnion.unionSecond; for (; *data != '\0'; data++) { if (*data == SEARCH_CHAR) { printLine(""We have a match!""); break; } } free(data); } }"	where is the vulnerable dataflow from data to free ?	"size_t dataLen = <start> strlen(data) <end> ;
free <start> data <end> );"	"recvResult = <start> recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0) <end> ;
free <start> data <end> );"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
free <start> data <end> );"	"free <start> data <end> );
replace = <start> strchr(data, '\n') <end> ;"	2
584fa84f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_listen_socket_multiply_17_bad() { int i,j; int data; data = 0; for(i = 0; i < 1; i++) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } for(j = 0; j < 1; j++) { if(data < 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  * 2;
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  * 2;"	"int result = <start> data * 2 <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
data = <start> atoi(inputBuffer) <end> ;"	1
656cd3c9-6c15-11ed-81d4-94e6f77dd552	static void badSink(int data) { { int result = data + 1; printIntLine(result); } } void CWE190_Integer_Overflow__int_rand_add_41_bad() { int data; data = 0; data = RAND32(); badSink(data); }	where is the vulnerable dataflow from data ?	"badSink <start> data <end> );
data = <start> RAND32() <end> ;"	"data = <start> RAND32() <end> ;
badSink <start> data <end> );
static void badSink(int <start> data <end> );
int result = <start> data <end>  + 1;"	"static void badSink(int <start> data <end> );
data = <start> RAND32() <end> ;
badSink <start> data <end> );
int <start> result = data + 1 <end> ;"	"data = <start> RAND32() <end> ;
int result = <start> data <end>  + 1;
badSink <start> data <end> );
<start> printIntLine(result) <end> ;"	1
bda4e424-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define EXECL _execl #else #define EXECL execl #endif static char * badSource(char * data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } return data; } void CWE78_OS_Command_Injection__char_listen_socket_execl_42_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; data = badSource(data); EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECL ?	"EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
size_t dataLen = <start> strlen(data) <end> ;
data = <start> badSource <end> (data);"	"<start> EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, COMMAND_ARG3, NULL) <end> ;
data = <start> badSource <end> (data);
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
static char * <start> badSource <end> (char * data);"	"static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
if  <start> listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR <end> );"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
EXECL(COMMAND_INT_PATH, COMMAND_INT_PATH, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	3
a95fd847-6c15-11ed-81d4-94e6f77dd552	namespace CWE191_Integer_Underflow__int_fgets_multiply_81 { void CWE191_Integer_Underflow__int_fgets_multiply_81_bad::action(int data) const { if(data < 0) { int result = data * 2; printIntLine(result); } } }	where is the vulnerable dataflow from result to printIntLine ?	"int result = <start> data * 2 <end> ;
void CWE191_Integer_Underflow__int_fgets_multiply_81_bad::action(int <start> data <end> ) const;"	"<start> printIntLine(result) <end> ;
void CWE191_Integer_Underflow__int_fgets_multiply_81_bad::action(int <start> data <end> ) const;"	"void CWE191_Integer_Underflow__int_fgets_multiply_81_bad::action(int <start> data <end> ) const;
int <start> result = data * 2 <end> ;"	"void CWE191_Integer_Underflow__int_fgets_multiply_81_bad::action(int <start> data <end> ) const;
printIntLine <start> result <end> );"	3
70279c37-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif static void badVaSink(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_file_vfprintf_52c_badSink(char * data) { badVaSink(data, data); }"	where is the vulnerable dataflow from data to vfprintf ?	"void CWE134_Uncontrolled_Format_String__char_file_vfprintf_52c_badSink(char * <start> data <end> );
<start> vfprintf(stdout, data, args) <end> ;
static void badVaSink(char * <start> data <end> , ...);
badVaSink <start> data <end> , data);"	"void CWE134_Uncontrolled_Format_String__char_file_vfprintf_52c_badSink(char * <start> data <end> );
vfprintf(stdout, <start> data <end> , args);
<start> va_start(args, data) <end> ;
static void badVaSink(char * <start> data <end> , ...);"	"static void badVaSink(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);
void CWE134_Uncontrolled_Format_String__char_file_vfprintf_52c_badSink(char * <start> data <end> );"	"void CWE134_Uncontrolled_Format_String__char_file_vfprintf_52c_badSink(char * <start> data <end> );
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);"	3
5133a75a-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticFive = 5; void CWE190_Integer_Overflow__int_fgets_preinc_07_bad() { int data; data = 0; if(staticFive==5) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(staticFive==5) { { ++data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
+ <start> data <end> ;"	"<start> data = 0 <end> ;
+ <start> data <end> ;"	"int <start> result = data <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"+ <start> data <end> ;
<start> printIntLine(result) <end> ;"	0
9d74538f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE127_Buffer_Underread__CWE839_connect_socket_09_bad() { int data; data = -1; if(GLOBAL_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(GLOBAL_CONST_TRUE) { { int buffer[10] = { 0 }; if (data < 10) { printIntLine(buffer[data]); } else { printLine(""ERROR: Array index is too big.""); } } } }"	where is the vulnerable dataflow from buffer[data] to printIntLine ?	"data = <start> atoi(inputBuffer) <end> ;
printIntLine <start> buffer[data] <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[data] <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printIntLine(buffer[data]) <end> ;"	"recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);
printIntLine <start> buffer[data] <end> );"	1
5be3a9cf-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticTrue = 1; static int staticFalse = 0; void CWE191_Integer_Underflow__int_listen_socket_postdec_05_bad() { int data; data = 0; if(staticTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticTrue) { { data--; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> data <end> --;
data = <start> atoi(inputBuffer) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data-- <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data <end> --;"	"int <start> result = data <end> ;
<start> data <end> --;"	2
6b86242f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) typedef union { int unionFirst; int unionSecond; } CWE122_Heap_Based_Buffer_Overflow__c_CWE129_connect_socket_34_unionType; void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_connect_socket_34_bad() { int data; CWE122_Heap_Based_Buffer_Overflow__c_CWE129_connect_socket_34_unionType myUnion; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } myUnion.unionFirst = data; { int data = myUnion.unionSecond; { int i; int * buffer = (int *)malloc(10 * sizeof(int)); if (buffer == NULL) {exit(-1);} for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } free(buffer); } } }"	where is the vulnerable dataflow from buffer to free ?	"<start> free(buffer) <end> ;
free <start> buffer <end> );"	"free <start> buffer <end> );
int <start> * buffer = (int *)malloc(10 * sizeof(int)) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
free <start> buffer <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printIntLine(buffer[i]) <end> ;"	2
453db010-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_multiply_10_bad() { int data; data = 0; if(globalTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalTrue) { if(data > 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  * 2;"	"<start> printIntLine(result) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);
int result = <start> data <end>  * 2;"	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  * 2;"	0
820a46ee-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_file_open_52 { void badSink_c(char * data) { { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
void badSink_c(char * <start> data <end> );"	"void badSink_c(char * <start> data <end> );
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"void badSink_c(char * <start> data <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	2
7e74f311-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_03_bad() { int data; data = -1; if(5==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
char <start> dest[100] = """" <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printLine(dest) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
if  <start> listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR <end> );"	2
445c11f0-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_add_10_bad() { int data; data = 0; if(globalTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalTrue) { { int result = data + 1; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  + 1;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"<start> data = atoi(inputBuffer) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"int result = <start> data <end>  + 1;
<start> printIntLine(result) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  + 1;"	3
b41b879c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 20 #define IP_ADDRESS ""127.0.0.1"" void CWE369_Divide_by_Zero__float_connect_socket_14_bad() { float data; data = 0.0F; if(globalFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = (float)atof(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalFive==5) { { int result = (int)(100.0 / data); printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;"	"printIntLine <start> result <end> );
int result = <start> (int)(100.0 / data) <end> ;"	0
656cd3f7-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__int_rand_multiply_53d_badSink(int data) { if(data > 0) { int result = data * 2; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"void CWE190_Integer_Overflow__int_rand_multiply_53d_badSink(int <start> data <end> );
int result = <start> data <end>  * 2;"	"void CWE190_Integer_Overflow__int_rand_multiply_53d_badSink(int <start> data <end> );
int <start> result = data * 2 <end> ;"	"int result = <start> data <end>  * 2;
void CWE190_Integer_Overflow__int_rand_multiply_53d_badSink(int <start> data <end> );"	"void CWE190_Integer_Overflow__int_rand_multiply_53d_badSink(int <start> data <end> );
int result = <start> data * 2 <end> ;"	0
584fa8a4-6c15-11ed-81d4-94e6f77dd552	extern int CWE191_Integer_Underflow__short_fscanf_multiply_22_badGlobal; void CWE191_Integer_Underflow__short_fscanf_multiply_22_badSink(short data) { if(CWE191_Integer_Underflow__short_fscanf_multiply_22_badGlobal) { if(data < 0) { short result = data * 2; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"short result = <start> data <end>  * 2;
<start> printIntLine(result) <end> ;"	"void CWE191_Integer_Underflow__short_fscanf_multiply_22_badSink(short <start> data <end> );
short result = <start> data <end>  * 2;"	"void CWE191_Integer_Underflow__short_fscanf_multiply_22_badSink(short <start> data <end> );
<start> printIntLine(result) <end> ;"	"short result = <start> data <end>  * 2;
void CWE191_Integer_Underflow__short_fscanf_multiply_22_badSink(short <start> data <end> );"	1
a36a790e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_multiply_01_bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } if(data > 0) { int result = data * 2; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );
printIntLine <start> result <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"int <start> result = data * 2 <end> ;
printIntLine <start> result <end> );"	"int result = <start> data * 2 <end> ;
printIntLine <start> result <end> );"	1
cbf237dd-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif namespace CWE36_Absolute_Path_Traversal__char_console_ifstream_43 { void badSource(char * &data) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; badSource(data); { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
inputFile.open((char * <start> data <end> );"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
badSource <start> data <end> );
inputFile.open((char * <start> data <end> );"	"dataLen = <start> strlen(data) <end> ;
inputFile.open((char * <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
inputFile.open((char * <start> data <end> );
badSource <start> data <end> );"	1
a95fd869-6c15-11ed-81d4-94e6f77dd552	namespace CWE191_Integer_Underflow__int_fgets_sub_62 { void badSource(int &data); void bad() { int data; data = 0; badSource(data); { int result = data - 1; printIntLine(result); } }	where is the vulnerable dataflow from result to printIntLine ?	"<start> data = 0 <end> ;
printIntLine <start> result <end> );"	"int <start> result = data - 1 <end> ;
printIntLine <start> result <end> );"	"<start> printIntLine(result) <end> ;
badSource <start> data <end> );"	"badSource <start> data <end> );
printIntLine <start> result <end> );"	3
bc721f91-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define EXECLP _execlp #else #define EXECLP execlp #endif void CWE78_OS_Command_Injection__char_file_execlp_10_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; if(globalTrue) { { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECLP ?	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
<start> EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL) <end> ;"	"EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	"char <start> dataBuffer[100] = COMMAND_ARG2 <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	0
c99197fb-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif extern char * CWE36_Absolute_Path_Traversal__char_connect_socket_fopen_68_badData; extern char * CWE36_Absolute_Path_Traversal__char_connect_socket_fopen_68_goodG2BData; namespace CWE36_Absolute_Path_Traversal__char_connect_socket_fopen_68 { void badSink() { char * data = CWE36_Absolute_Path_Traversal__char_connect_socket_fopen_68_badData; { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = FOPEN <start> data <end> , ""wb+"");
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
char * data = <start> CWE36_Absolute_Path_Traversal__char_connect_socket_fopen_68_badData <end> ;"	"pFile = FOPEN <start> data <end> , ""wb+"");
char * data = <start> CWE36_Absolute_Path_Traversal__char_connect_socket_fopen_68_badData <end> ;"	"char * data = <start> CWE36_Absolute_Path_Traversal__char_connect_socket_fopen_68_badData <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	3
9c4551af-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE126_Buffer_Overread__CWE129_connect_socket_43 { static void badSource(int &data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } void bad() { int data; data = -1; badSource(data); { int buffer[10] = { 0 }; if (data >= 0) { printIntLine(buffer[data]); } else { printLine(""ERROR: Array index is negative""); } } }"	where is the vulnerable dataflow from buffer[data] to printIntLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[data] <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSource <start> data <end> );
printIntLine <start> buffer[data] <end> );"	"printIntLine <start> buffer[data] <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
badSource <start> data <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[data] <end> );
badSource <start> data <end> );"	1
466e7ef3-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__int_fgets_multiply_72 { void badSink(vector<int> dataVector) { int data = dataVector[2]; if(data > 0) { int result = data * 2; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"int result = <start> data * 2 <end> ;
void badSink(vector<int> <start> dataVector <end> );"	"<start> printIntLine(result) <end> ;
void badSink(vector<int> <start> dataVector <end> );"	"void badSink(vector<int> <start> dataVector <end> );
int result = <start> data <end>  * 2;"	"int result = <start> data <end>  * 2;
void badSink(vector<int> <start> dataVector <end> );"	2
a49c4f54-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_multiply_63b_badSink(int * dataPtr) { int data = *dataPtr; if(data > 0) { int result = data * 2; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"void CWE190_Integer_Overflow__int_listen_socket_multiply_63b_badSink(int * <start> dataPtr <end> );
printIntLine <start> result <end> );"	"void CWE190_Integer_Overflow__int_listen_socket_multiply_63b_badSink(int * <start> dataPtr <end> );
<start> printIntLine(result) <end> ;"	"void CWE190_Integer_Overflow__int_listen_socket_multiply_63b_badSink(int * <start> dataPtr <end> );
int <start> result = data * 2 <end> ;"	"int <start> result = data * 2 <end> ;
printIntLine <start> result <end> );"	0
8a6310d5-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_file_open_67 { typedef struct _structType { char * structFirst; } structType; void badSink(structType myStruct) { char * data = myStruct.structFirst; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
char * data = <start> myStruct <end> .structFirst;
void badSink(structType <start> myStruct <end> );"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
char * data = <start> myStruct <end> .structFirst;
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"void badSink(structType <start> myStruct <end> );
char * data = <start> myStruct <end> .structFirst;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN(data, O_RDWR|O_CREAT, <start> S_IREAD|S_IWRITE <end> );
char * data = <start> myStruct <end> .structFirst;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	2
b8e2bdb5-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 namespace CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_81 { void bad() { char * data; char dataBuffer[250] = ""PATH=""; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (250 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } const CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_81_base& baseObject = CWE427_Uncontrolled_Search_Path_Element__char_listen_socket_81_bad(); baseObject.action(data); }"	where is the vulnerable dataflow from data to action ?	"char <start> dataBuffer[250] = ""PATH="" <end> ;
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (250 - dataLen - 1), 0);"	"size_t dataLen = <start> strlen(data) <end> ;
baseObject.action <start> data <end> );"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (250 - dataLen - 1), 0);
baseObject.action <start> data <end> );"	"if  <start> recvResult == SOCKET_ERROR <end>  || recvResult == 0);
baseObject.action <start> data <end> );"	2
aa91a163-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_listen_socket_multiply_14_bad() { int data; data = 0; if(globalFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalFive==5) { if(data < 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"if  <start> recvResult == SOCKET_ERROR <end>  || recvResult == 0);
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	3
aa91a1a3-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_listen_socket_sub_63b_badSink(int * dataPtr) { int data = *dataPtr; { int result = data - 1; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;"	"void CWE191_Integer_Underflow__int_listen_socket_sub_63b_badSink(int * <start> dataPtr <end> );
printIntLine <start> result <end> );"	"int <start> result = data - 1 <end> ;
printIntLine <start> result <end> );"	"int <start> result = data - 1 <end> ;
void CWE191_Integer_Underflow__int_listen_socket_sub_63b_badSink(int * <start> dataPtr <end> );"	1
aa91a15d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticReturnsTrue() { return 1; } static int staticReturnsFalse() { return 0; } void CWE191_Integer_Underflow__int_listen_socket_multiply_08_bad() { int data; data = 0; if(staticReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticReturnsTrue()) { if(data < 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
data = <start> atoi(inputBuffer) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	3
b54bcf35-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 20 static void badSink(float data) { { int result = (int)(100.0 / data); printIntLine(result); } } void CWE369_Divide_by_Zero__float_listenSocket_41_bad() { float data; data = 0.0F; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = (float)atof(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badSink(data); }"	where is the vulnerable dataflow from result to printIntLine ?	"badSink <start> data <end> );
printIntLine <start> result <end> );
if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );
static void badSink(float <start> data <end> );"	"static void badSink(float <start> data <end> );
printIntLine <start> result <end> );
badSink <start> data <end> );
<start> badSink(data) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSink <start> data <end> );
static void badSink(float <start> data <end> );
printIntLine <start> result <end> );"	"badSink <start> data <end> );
static void badSink(float <start> data <end> );
printIntLine <start> result <end> );
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	2
a95fd817-6c15-11ed-81d4-94e6f77dd552	namespace CWE191_Integer_Underflow__int_connect_socket_sub_72 { void badSink(vector<int> dataVector) { int data = dataVector[2]; { int result = data - 1; printIntLine(result); } }	where is the vulnerable dataflow from result to printIntLine ?	"void badSink(vector<int> <start> dataVector <end> );
printIntLine <start> result <end> );"	"int <start> result = data - 1 <end> ;
printIntLine <start> result <end> );"	"int result = <start> data - 1 <end> ;
printIntLine <start> result <end> );"	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	0
cbf237d0-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif namespace CWE36_Absolute_Path_Traversal__char_console_ifstream_11 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(globalReturnsTrue()) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
inputFile.open((char * <start> data <end> );"	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"inputFile.open((char * <start> data <end> );
dataLen = <start> strlen(data) <end> ;"	"inputFile.open((char * <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	0
445c11fb-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) typedef union { int unionFirst; int unionSecond; } CWE190_Integer_Overflow__int_connect_socket_add_34_unionType; void CWE190_Integer_Overflow__int_connect_socket_add_34_bad() { int data; CWE190_Integer_Overflow__int_connect_socket_add_34_unionType myUnion; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } myUnion.unionFirst = data; { int data = myUnion.unionSecond; { int result = data + 1; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"data = <start> atoi(inputBuffer) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"<start> printIntLine(result) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  + 1;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int <start> data = myUnion.unionSecond <end> ;"	2
a6fd828e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_preinc_16_bad() { int data; data = 0; while(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; } while(1) { { ++data; int result = data; printIntLine(result); } break; } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );"	"printIntLine <start> result <end> );
data = <start> atoi(inputBuffer) <end> ;"	"<start> data = atoi(inputBuffer) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	3
a6fd823a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; void CWE190_Integer_Overflow__int_connect_socket_preinc_04_bad() { int data; data = 0; if(STATIC_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(STATIC_CONST_TRUE) { { ++data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int <start> result = data <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printIntLine(result) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data = atoi(inputBuffer) <end> ;"	1
571e9838-6c15-11ed-81d4-94e6f77dd552	"static void badSink(int data) { { int result = data - 1; printIntLine(result); } } void CWE191_Integer_Underflow__int_fscanf_sub_44_bad() { int data; void (*funcPtr) (int) = badSink; data = 0; fscanf(stdin, ""%d"", &data); funcPtr(data); }"	where is the vulnerable dataflow from data ?	"int result = <start> data - 1 <end> ;
funcPtr <start> data <end> );
fscanf(stdin, ""%d"", <start> &data <end> );
static void badSink(int <start> data <end> );"	"int result = <start> data <end>  - 1;
funcPtr <start> data <end> );"	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  - 1;
funcPtr <start> data <end> );
static void badSink(int <start> data <end> );"	"fscanf(stdin, ""%d"", <start> &data <end> );
funcPtr <start> data <end> );
static void badSink(int <start> data <end> );
int result = <start> data <end>  - 1;"	3
b54bceff-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 20 void CWE369_Divide_by_Zero__float_fgets_11_bad() { float data; data = 0.0F; if(globalReturnsTrue()) { { char inputBuffer[CHAR_ARRAY_SIZE]; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = (float)atof(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(globalReturnsTrue()) { { int result = (int)(100.0 / data); printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"int <start> result = (int)(100.0 / data) <end> ;
printIntLine <start> result <end> );"	"if  <start> fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) <end>  != NULL);
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );"	3
a830bf9e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_connect_socket_sub_14_bad() { int data; data = 0; if(globalFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalFive==5) { { int result = data - 1; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"<start> printIntLine(result) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	1
73bc816c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" static int staticFive = 5; void CWE194_Unexpected_Sign_Extension__connect_socket_memmove_07_bad() { short data; data = 0; if(staticFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> data = 0 <end> ;
printLine <start> dest <end> );"	"<start> memmove(dest, source, data) <end> ;
printLine <start> dest <end> );"	"printLine <start> dest <end> );
<start> data = tempInt <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	3
cf87507a-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_environment_open_01 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN(data, O_RDWR|O_CREAT, <start> S_IREAD|S_IWRITE <end> );
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"fileDesc = OPEN(data, O_RDWR|O_CREAT, <start> S_IREAD|S_IWRITE <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
char <start> dataBuffer[FILENAME_MAX] = """" <end> ;"	0
b2ea8df6-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 8 static short badSource(short data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = (short)atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } return data; } void CWE197_Numeric_Truncation_Error__short_listen_socket_42_bad() { short data; data = -1; data = badSource(data); { char charData = (char)data; printHexCharLine(charData); } }"	where is the vulnerable dataflow from charData to printHexCharLine ?	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
data = <start> badSource <end> (data);
printHexCharLine <start> charData <end> );
static short <start> badSource <end> (short data);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static short <start> badSource <end> (short data);
data = <start> badSource <end> (data);
printHexCharLine <start> charData <end> );"	"data = <start> badSource <end> (data);
printHexCharLine <start> charData <end> );"	"<start> printHexCharLine(charData) <end> ;
printHexCharLine <start> charData <end> );
static short <start> badSource <end> (short data);
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	1
bed4a8ea-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" namespace CWE23_Relative_Path_Traversal__char_connect_socket_ifstream_17 { void bad() { int i; char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; for(i = 0; i < 1; i++) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"replace = <start> strchr(data, '\n') <end> ;
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
inputFile.open((char * <start> data <end> );"	"replace = <start> strchr(data, '\n') <end> ;
inputFile.open((char * <start> data <end> );"	"size_t dataLen = <start> strlen(data) <end> ;
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	1
acf67e0f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_listen_socket_postdec_63b_badSink(int * dataPtr) { int data = *dataPtr; { data--; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;"	"printIntLine <start> result <end> );
void CWE191_Integer_Underflow__int_listen_socket_postdec_63b_badSink(int * <start> dataPtr <end> );"	"void CWE191_Integer_Underflow__int_listen_socket_postdec_63b_badSink(int * <start> dataPtr <end> );
<start> printIntLine(result) <end> ;"	"void CWE191_Integer_Underflow__int_listen_socket_postdec_63b_badSink(int * <start> dataPtr <end> );
printIntLine <start> result <end> );"	3
a49c4f49-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink(int data) { if(data > 0) { int result = data * 2; printIntLine(result); } } void CWE190_Integer_Overflow__int_listen_socket_multiply_41_bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badSink(data); }"	where is the vulnerable dataflow from result to printIntLine ?	"badSink <start> data <end> );
data = <start> atoi(inputBuffer) <end> ;
static void badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );
static void badSink(int <start> data <end> );
<start> badSink(data) <end> ;"	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );
static void badSink(int <start> data <end> );
badSink <start> data <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSink <start> data <end> );
static void badSink(int <start> data <end> );
printIntLine <start> result <end> );"	3
98b01539-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int badSource(int data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } return data; } void CWE121_Stack_Based_Buffer_Overflow__CWE129_listen_socket_42_bad() { int data; data = -1; data = badSource(data); { int i; int buffer[10] = { 0 }; if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } } }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static int <start> badSource <end> (int data);
data = <start> badSource <end> (data);
printIntLine <start> buffer[i] <end> );"	"printIntLine <start> buffer[i] <end> );
static int <start> badSource <end> (int data);
data = <start> badSource <end> (data);
<start> recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"data = <start> badSource <end> (data);
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> buffer[i] <end> );
static int <start> badSource <end> (int data);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
data = <start> badSource <end> (data);"	0
9059f39e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_16_bad() { int data; data = -1; while(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; } { size_t i; int *intPointer; intPointer = (int*)malloc(data * sizeof(int)); if (intPointer == NULL) {exit(-1);} for (i = 0; i < (size_t)data; i++) { intPointer[i] = 0; } printIntLine(intPointer[0]); free(intPointer); } }"	where is the vulnerable dataflow from data to malloc ?	"intPointer = (int*)malloc <start> data * sizeof(int) <end> );
<start> intPointer = (int*)malloc(data * sizeof(int)) <end> ;"	"<start> data = -1 <end> ;
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	3
a49c4f85-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_square_66b_badSink(int dataArray[]) { int data = dataArray[2]; { int result = data * data; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"int result = <start> data * data <end> ;
void CWE190_Integer_Overflow__int_listen_socket_square_66b_badSink(int <start> dataArray <end> []);"	"<start> printIntLine(result) <end> ;
void CWE190_Integer_Overflow__int_listen_socket_square_66b_badSink(int <start> dataArray <end> []);"	"void CWE190_Integer_Overflow__int_listen_socket_square_66b_badSink(int <start> dataArray <end> []);
printIntLine <start> result <end> );"	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	2
79b27565-6c15-11ed-81d4-94e6f77dd552	"namespace CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_62 { void badSource(int &data); void bad() { int data; data = -1; badSource(data); { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"badSource <start> data <end> );
<start> memcpy(dest, source, data) <end> ;"	"badSource <start> data <end> );
printLine <start> dest <end> );"	"badSource <start> data <end> );
char <start> dest[100] = """" <end> ;"	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	1
820a46cb-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_file_fopen_64 { void badSink(void * dataVoidPtr) { char * * dataPtr = (char * *)dataVoidPtr; char * data = (*dataPtr); { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"void badSink(void * <start> dataVoidPtr <end> );
pFile = FOPEN <start> data <end> , ""wb+"");"	"char <start> * data = (*dataPtr) <end> ;
void badSink(void * <start> dataVoidPtr <end> );"	"pFile = FOPEN <start> data <end> , ""wb+"");
void badSink(void * <start> dataVoidPtr <end> );"	"void badSink(void * <start> dataVoidPtr <end> );
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	0
7d44fc74-6c15-11ed-81d4-94e6f77dd552	"namespace CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_62 { void badSource(int &data); void bad() { int data; data = -1; badSource(data); { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"printLine <start> dest <end> );
badSource <start> data <end> );"	"printLine <start> dest <end> );
<start> memmove(dest, source, data) <end> ;"	"<start> printLine(dest) <end> ;
badSource <start> data <end> );"	"badSource <start> data <end> );
printLine <start> dest <end> );"	3
977ea795-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink(int data) { { int i; int buffer[10] = { 0 }; if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } } } void CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_41_bad() { int data; data = -1; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } badSink(data); }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
badSink <start> data <end> );
static void badSink(int <start> data <end> );
printIntLine <start> buffer[i] <end> );"	"static void badSink(int <start> data <end> );
printIntLine <start> buffer[i] <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
if  <start> fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) <end>  != NULL);"	"int <start> buffer[10] = { 0 } <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> buffer[i] <end> );
badSink <start> data <end> );"	"printIntLine <start> buffer[i] <end> );
<start> badSink(data) <end> ;
static void badSink(int <start> data <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	0
98b0155d-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_fgets_12 { void bad() { int data; data = -1; if(globalReturnsTrueOrFalse()) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } else { data = 7; } if(globalReturnsTrueOrFalse()) { { int i; int * buffer = new int[10]; for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } delete[] buffer; } } else { { int i; int * buffer = new int[10]; for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0 && data < (10)) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is out-of-bounds""); } delete[] buffer; } } }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"int <start> * buffer = new int[10] <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"printIntLine <start> buffer[i] <end> );
<start> printIntLine(buffer[i]) <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> buffer[i] <end> );"	"printIntLine <start> buffer[i] <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	2
466e7ebe-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_add_51b_badSink(int data) { { int result = data + 1; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
void CWE190_Integer_Overflow__int_fgets_add_51b_badSink(int <start> data <end> );"	"int result = <start> data <end>  + 1;
void CWE190_Integer_Overflow__int_fgets_add_51b_badSink(int <start> data <end> );"	"void CWE190_Integer_Overflow__int_fgets_add_51b_badSink(int <start> data <end> );
int <start> result = data + 1 <end> ;"	"void CWE190_Integer_Overflow__int_fgets_add_51b_badSink(int <start> data <end> );
int result = <start> data <end>  + 1;"	3
5133a74d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) int CWE190_Integer_Overflow__int_connect_socket_preinc_61b_badSource(int data); void CWE190_Integer_Overflow__int_connect_socket_preinc_61_bad() { int data; data = 0; data = CWE190_Integer_Overflow__int_connect_socket_preinc_61b_badSource(data); { ++data; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
+ <start> data <end> ;"	"data = <start> CWE190_Integer_Overflow__int_connect_socket_preinc_61b_badSource <end> (data);
+ <start> data <end> ;"	"int <start> result = data <end> ;
+ <start> data <end> ;"	"<start> ++data <end> ;
data = <start> CWE190_Integer_Overflow__int_connect_socket_preinc_61b_badSource <end> (data);"	1
8a6310bb-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_file_open_11 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(globalReturnsTrue()) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
fileDesc = OPEN(data, O_RDWR|O_CREAT, <start> S_IREAD|S_IWRITE <end> );"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
size_t dataLen = <start> strlen(data) <end> ;"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	3
774f5813-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 8 void CWE194_Unexpected_Sign_Extension__listen_socket_malloc_14_bad() { short data; data = 0; if(globalFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }"	where is the vulnerable dataflow from data to malloc ?	"<start> data = 0 <end> ;
char * dataBuffer = (char *)malloc <start> data <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printLine(dataBuffer) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
char * dataBuffer = (char *)malloc <start> data <end> );"	"char * dataBuffer = <start> (char *)malloc(data) <end> ;
char * dataBuffer = (char *)malloc <start> data <end> );"	2
6dc61503-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif void CWE134_Uncontrolled_Format_String__char_console_snprintf_01_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"printLine <start> dest <end> );
<start> SNPRINTF(dest, 100-1, data) <end> ;"	"char <start> dataBuffer[100] = """" <end> ;
printLine <start> dest <end> );"	"size_t dataLen = <start> strlen(data) <end> ;
printLine <start> dest <end> );"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
printLine <start> dest <end> );"	3
5be3a9e9-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_listen_socket_postdec_64b_badSink(void * dataVoidPtr) { int * dataPtr = (int *)dataVoidPtr; int data = (*dataPtr); { data--; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"void CWE191_Integer_Underflow__int_listen_socket_postdec_64b_badSink(void * <start> dataVoidPtr <end> );
<start> data <end> --;"	"<start> data <end> --;
void CWE191_Integer_Underflow__int_listen_socket_postdec_64b_badSink(void * <start> dataVoidPtr <end> );"	"<start> printIntLine(result) <end> ;
void CWE191_Integer_Underflow__int_listen_socket_postdec_64b_badSink(void * <start> dataVoidPtr <end> );"	"<start> data <end> --;
<start> printIntLine(result) <end> ;"	0
cf875090-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_environment_open_41 { void badSink(char * data) { { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } } void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } badSink(data); }"	where is the vulnerable dataflow from data to badSink ?	"badSink <start> data <end> );
<start> data = dataBuffer <end> ;"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
badSink <start> data <end> );"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
<start> data = dataBuffer <end> ;"	1
728a5010-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 static void badVaSinkB(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_10_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; if(globalTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalTrue) { badVaSinkB(data, data); } }"	where is the vulnerable dataflow from data to vprintf ?	"static void badVaSinkB(char * <start> data <end> , ...);
vprintf <start> data <end> , args);"	"badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
vprintf <start> data <end> , args);"	"vprintf <start> data <end> , args);
<start> vprintf(data, args) <end> ;
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
static void badVaSinkB(char * <start> data <end> , ...);"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);
vprintf <start> data <end> , args);"	3
87ff9855-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_connect_socket_fopen_45 { static char * badData; static char * goodG2BData; static void badSink() { char * data = badData; { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } } void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } badData = data; badSink(); }"	where is the vulnerable dataflow from data to FOPEN ?	"size_t dataLen = <start> strlen(data) <end> ;
static char * <start> badData <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");
<start> badData = data <end> ;
char * data = <start> badData <end> ;"	"size_t dataLen = <start> strlen(data) <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");
<start> badData = data <end> ;
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
char * data = <start> badData <end> ;"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
<start> badData = data <end> ;
static char * <start> badData <end> ;
char * data = <start> badData <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
<start> badData = data <end> ;
static char * <start> badData <end> ;
size_t dataLen = <start> strlen(data) <end> ;
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	2
6c938bda-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_45_badData; static int CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_45_goodG2BData; static int CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_45_goodB2GData; static void badSink() { int data = CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_45_badData; { int i; int * buffer = (int *)malloc(10 * sizeof(int)); if (buffer == NULL) {exit(-1);} for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } free(buffer); } } void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_45_bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_45_badData = data; badSink(); }"	where is the vulnerable dataflow from buffer to free ?	"free <start> buffer <end> );
int data = <start> CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_45_badData <end> ;
static int <start> CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_45_badData <end> ;
<start> CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_45_badData = data <end> ;
<start> free(buffer) <end> ;"	"if  <start> buffer == NULL <end> ) {exit(-1);};
int data = <start> CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_45_badData <end> ;
static int <start> CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_45_badData <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_45_badData = data <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_45_badData = data <end> ;
static int <start> CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_45_badData <end> ;
int data = <start> CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_45_badData <end> ;
free <start> buffer <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static int <start> CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_45_badData <end> ;
<start> CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_45_badData = data <end> ;
int data = <start> CWE122_Heap_Based_Buffer_Overflow__c_CWE129_listen_socket_45_badData <end> ;
free <start> buffer <end> );"	2
598370c0-6c15-11ed-81d4-94e6f77dd552	"void CWE191_Integer_Underflow__short_fscanf_sub_11_bad() { short data; data = 0; if(globalReturnsTrue()) { fscanf (stdin, ""%hd"", &data); } if(globalReturnsTrue()) { { short result = data - 1; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );"	"short result = <start> data <end>  - 1;
<start> printIntLine(result) <end> ;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
short result = <start> data - 1 <end> ;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
short result = <start> data <end>  - 1;"	3
8a6310d1-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_file_open_63 { void badSink(char * * dataPtr) { char * data = *dataPtr; { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"void badSink(char * * <start> dataPtr <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
void badSink(char * * <start> dataPtr <end> );"	2
74ee23fc-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 8 void CWE194_Unexpected_Sign_Extension__fgets_malloc_09_bad() { short data; data = 0; if(GLOBAL_CONST_TRUE) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = (short)atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }"	where is the vulnerable dataflow from data to malloc ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
char <start> * dataBuffer = (char *)malloc(data) <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
char * dataBuffer = (char *)malloc <start> data <end> );"	"memset(dataBuffer, 'A', <start> data-1 <end> );
char * dataBuffer = (char *)malloc <start> data <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
memset(dataBuffer, 'A', <start> data-1 <end> );"	1
b41b8787-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif namespace CWE23_Relative_Path_Traversal__char_file_open_82 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } CWE23_Relative_Path_Traversal__char_file_open_82_base* baseObject = new CWE23_Relative_Path_Traversal__char_file_open_82_bad; baseObject->action(data); delete baseObject; }"	where is the vulnerable dataflow from data to action ?	"<start> data = dataBuffer <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"baseObject->action <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
baseObject->action <start> data <end> );"	"baseObject->action <start> data <end> );
char <start> dataBuffer[FILENAME_MAX] = BASEPATH <end> ;"	2
aa91a166-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_listen_socket_multiply_17_bad() { int i,j; int data; data = 0; for(i = 0; i < 1; i++) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } for(j = 0; j < 1; j++) { if(data < 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"if  <start> listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR <end> );
printIntLine <start> result <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
if <start> data < 0 <end> ) ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
if  <start> listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR <end> );"	1
73bc8151-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" static short badSource(short data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } return data; } void CWE194_Unexpected_Sign_Extension__connect_socket_memcpy_42_bad() { short data; data = 0; data = badSource(data); { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"data = <start> badSource(data) <end> ;
static short <start> badSource <end> (short data);
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
if  <start> data < 100 <end> );
static short <start> badSource <end> (short data);
printLine <start> dest <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static short <start> badSource <end> (short data);
data = <start> badSource <end> (data);
printLine <start> dest <end> );"	"<start> memcpy(dest, source, data) <end> ;
printLine <start> dest <end> );
data = <start> badSource <end> (data);
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	2
c39a6582-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_environment_fopen_72 { void badSink(vector<char *> dataVector) { char * data = dataVector[2]; { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = FOPEN <start> data <end> , ""wb+"");
void badSink(vector<char *> <start> dataVector <end> );"	"void badSink(vector<char *> <start> dataVector <end> );
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	"void badSink(vector<char *> <start> dataVector <end> );
char <start> * data = dataVector[2] <end> ;"	1
a6fd8253-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_preinc_54e_badSink(int data) { { ++data; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"void CWE190_Integer_Overflow__int_connect_socket_preinc_54e_badSink(int <start> data <end> );
printIntLine <start> result <end> );"	"int <start> result = data <end> ;
void CWE190_Integer_Overflow__int_connect_socket_preinc_54e_badSink(int <start> data <end> );"	"int <start> result = data <end> ;
printIntLine <start> result <end> );"	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	0
70279c05-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif void CWE134_Uncontrolled_Format_String__char_file_snprintf_31_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } { char * dataCopy = data; char * data = dataCopy; { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } } }"	where is the vulnerable dataflow from dest to printLine ?	"printLine <start> dest <end> );
size_t dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
printLine <start> dest <end> );"	"printLine <start> dest <end> );
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	1
584fa88e-6c15-11ed-81d4-94e6f77dd552	namespace CWE191_Integer_Underflow__int_listen_socket_sub_72 { void badSink(vector<int> dataVector) { int data = dataVector[2]; { int result = data - 1; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"int <start> result = data - 1 <end> ;
void badSink(vector<int> <start> dataVector <end> );"	"int result = <start> data <end>  - 1;
int <start> data = dataVector[2] <end> ;"	"int result = <start> data <end>  - 1;
void badSink(vector<int> <start> dataVector <end> );"	"void badSink(vector<int> <start> dataVector <end> );
int result = <start> data <end>  - 1;"	3
964cdc12-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FULL_COMMAND ""dir "" #else #define FULL_COMMAND ""ls "" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define POPEN _popen #define PCLOSE _pclose #else #define POPEN popen #define PCLOSE pclose #endif void CWE78_OS_Command_Injection__char_listen_socket_popen_17_bad() { int i; char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; for(i = 0; i < 1; i++) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { FILE *pipe; pipe = POPEN(data, ""w""); if (pipe != NULL) { PCLOSE(pipe); } } }"	where is the vulnerable dataflow from data to sizeof ?	"pipe = <start> POPEN(data, ""w"") <end> ;"	size_t dataLen = <start> strlen(data) <end> ;	<start> data = data_buf <end> ;	recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);	3
453db03d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_connect_socket_square_13_bad() { int data; data = 0; if(GLOBAL_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(GLOBAL_CONST_FIVE==5) { { int result = data * data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  * data;
recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);"	"int result = <start> data <end>  * data;
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  * data;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printIntLine(result) <end> ;"	2
b1b80826-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_11_bad() { int data; data = -1; if(globalReturnsTrue()) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { short shortData = (short)data; printShortLine(shortData); } }"	where is the vulnerable dataflow from shortData to printShortLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printShortLine <start> shortData <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printShortLine(shortData) <end> ;"	"short <start> shortData = (short)data <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"if  <start> acceptSocket == SOCKET_ERROR <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	0
9fe7ad21-6c15-11ed-81d4-94e6f77dd552	"namespace CWE134_Uncontrolled_Format_String__char_console_fprintf_82 { void bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } CWE134_Uncontrolled_Format_String__char_console_fprintf_82_base* baseObject = new CWE134_Uncontrolled_Format_String__char_console_fprintf_82_bad; baseObject->action(data); delete baseObject; }"	where is the vulnerable dataflow from data to action ?	"<start> data = dataBuffer <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
baseObject->action <start> data <end> );"	"baseObject->action <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	1
cbf237c6-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif namespace CWE36_Absolute_Path_Traversal__char_console_ifstream_01 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"inputFile.open((char * <start> data <end> );
<start> data = dataBuffer <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
<start> data = dataBuffer <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
inputFile.open((char * <start> data <end> );"	"size_t dataLen = <start> strlen(data) <end> ;
inputFile.open((char * <start> data <end> );"	2
c5fc233d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif namespace CWE23_Relative_Path_Traversal__char_file_ifstream_31 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } { char * dataCopy = data; char * data = dataCopy; { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } } }"	where is the vulnerable dataflow from data to open ?	"inputFile.open((char * <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
inputFile.open((char * <start> data <end> );"	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"char <start> dataBuffer[FILENAME_MAX] = BASEPATH <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	1
aa91a188-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_FIVE = 5; void CWE191_Integer_Underflow__int_listen_socket_sub_06_bad() { int data; data = 0; if(STATIC_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(STATIC_CONST_FIVE==5) { { int result = data - 1; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"int result = <start> data - 1 <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"printIntLine <start> result <end> );
recvResult = recv(acceptSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);"	"<start> recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> result <end> );"	0
b54bcf00-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 20 void CWE369_Divide_by_Zero__float_fgets_13_bad() { float data; data = 0.0F; if(GLOBAL_CONST_FIVE==5) { { char inputBuffer[CHAR_ARRAY_SIZE]; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = (float)atof(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(GLOBAL_CONST_FIVE==5) { { int result = (int)(100.0 / data); printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
int result = (int) <start> 100.0 / data <end> );"	"printIntLine <start> result <end> );
int <start> result = (int)(100.0 / data) <end> ;"	1
86cea144-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE369_Divide_by_Zero__int_listen_socket_divide_02_bad() { int data; data = -1; if(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(1) { printIntLine(100 / data); } }"	where is the vulnerable dataflow from data to printIntLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data = -1 <end> ;"	"printIntLine <start> 100 / data <end> );
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"data = <start> atoi(inputBuffer) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> 100 / data <end> );"	3
656cd3d6-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__int_rand_add_73 { void badSink(list<int> dataList) { int data = dataList.back(); { int result = data + 1; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
void badSink(list<int> <start> dataList <end> );"	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  + 1;"	"void badSink(list<int> <start> dataList <end> );
int result = <start> data <end>  + 1;"	"int <start> data = dataList.back() <end> ;
int result = <start> data <end>  + 1;"	2
5e44fc91-6c15-11ed-81d4-94e6f77dd552	"static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; void CWE191_Integer_Underflow__int_fscanf_predec_04_bad() { int data; data = 0; if(STATIC_CONST_TRUE) { fscanf(stdin, ""%d"", &data); } if(STATIC_CONST_TRUE) { { --data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"fscanf(stdin, ""%d"", <start> &data <end> );
- <start> data <end> ;"	"int <start> result = data <end> ;
- <start> data <end> ;"	"<start> printIntLine(result) <end> ;
fscanf(stdin, ""%d"", <start> &data <end> );"	"- <start> data <end> ;
fscanf(stdin, ""%d"", <start> &data <end> );"	0
c26a7e63-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_environment_fopen_03 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(5==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = FOPEN <start> data <end> , ""wb+"");
strncat(data+dataLen, environment, <start> FILENAME_MAX-dataLen-1 <end> );"	"strncat(data+dataLen, environment, FILENAME_MAX <start> dataLen-1 <end> );
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"pFile = FOPEN <start> data <end> , ""wb+"");
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
pFile = FOPEN <start> data <end> , ""wb+"");"	3
d1e9da4f-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_listen_socket_fopen_72 { void badSink(vector<char *> dataVector) { char * data = dataVector[2]; { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = FOPEN <start> data <end> , ""wb+"");
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	"char <start> * data = dataVector[2] <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"void badSink(vector<char *> <start> dataVector <end> );
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
void badSink(vector<char *> <start> dataVector <end> );"	2
78800fc9-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 8 typedef struct _CWE194_Unexpected_Sign_Extension__listen_socket_memmove_67_structType { short structFirst; } CWE194_Unexpected_Sign_Extension__listen_socket_memmove_67_structType; void CWE194_Unexpected_Sign_Extension__listen_socket_memmove_67b_badSink(CWE194_Unexpected_Sign_Extension__listen_socket_memmove_67_structType myStruct) { short data = myStruct.structFirst; { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"printLine <start> dest <end> );
short data = <start> myStruct <end> .structFirst;
<start> memmove(dest, source, data) <end> ;"	"printLine <start> dest <end> );
void CWE194_Unexpected_Sign_Extension__listen_socket_memmove_67b_badSink(CWE194_Unexpected_Sign_Extension__listen_socket_memmove_67_structType <start> myStruct <end> );
short data = <start> myStruct <end> .structFirst;"	"printLine <start> dest <end> );
<start> memmove(dest, source, data) <end> ;
void CWE194_Unexpected_Sign_Extension__listen_socket_memmove_67b_badSink(CWE194_Unexpected_Sign_Extension__listen_socket_memmove_67_structType <start> myStruct <end> );"	"void CWE194_Unexpected_Sign_Extension__listen_socket_memmove_67b_badSink(CWE194_Unexpected_Sign_Extension__listen_socket_memmove_67_structType <start> myStruct <end> );
short data = <start> myStruct <end> .structFirst;
printLine <start> dest <end> );"	3
7ae3a729-6c15-11ed-81d4-94e6f77dd552	"namespace CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_72 { void badSink(vector<int> dataVector) { int data = dataVector[2]; { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> printLine(dest) <end> ;
void badSink(vector<int> <start> dataVector <end> );"	"printLine <start> dest <end> );
void badSink(vector<int> <start> dataVector <end> );"	"char <start> dest[100] = """" <end> ;
printLine <start> dest <end> );"	"void badSink(vector<int> <start> dataVector <end> );
printLine <start> dest <end> );"	3
4db33f7e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink(int data) { { data++; int result = data; printIntLine(result); } } void CWE190_Integer_Overflow__int_connect_socket_postinc_44_bad() { int data; void (*funcPtr) (int) = badSink; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } funcPtr(data); }"	where is the vulnerable dataflow from data ?	"static void badSink(int <start> data <end> );
<start> data <end> ++;
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
funcPtr <start> data <end> );"	"data = <start> atoi(inputBuffer) <end> ;
static void badSink(int <start> data <end> );
funcPtr <start> data <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
funcPtr <start> data <end> );
static void badSink(int <start> data <end> );
<start> data <end> ++;"	"<start> printIntLine(result) <end> ;
funcPtr <start> data <end> );
static void badSink(int <start> data <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	2
79b27564-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) int CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_61b_badSource(int data); void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_61_bad() { int data; data = -1; data = CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_61b_badSource(data); { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"data = <start> CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_61b_badSource <end> (data);
printLine <start> dest <end> );"	"printLine <start> dest <end> );
data = <start> CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_61b_badSource <end> (data);"	"data = <start> CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_61b_badSource(data) <end> ;
printLine <start> dest <end> );"	"<start> printLine(dest) <end> ;
data = <start> CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memcpy_61b_badSource <end> (data);"	0
a49c4f5b-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__int_listen_socket_multiply_73 { void badSink(list<int> dataList) { int data = dataList.back(); if(data > 0) { int result = data * 2; printIntLine(result); } }	where is the vulnerable dataflow from result to printIntLine ?	"void badSink(list<int> <start> dataList <end> );
printIntLine <start> result <end> );"	"int <start> result = data * 2 <end> ;
void badSink(list<int> <start> dataList <end> );"	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;"	"int <start> data = dataList.back() <end> ;
printIntLine <start> result <end> );"	0
6b862471-6c15-11ed-81d4-94e6f77dd552	"namespace CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_82 { void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_82_bad::action(int data) { { int i; int * buffer = (int *)malloc(10 * sizeof(int)); if (buffer == NULL) {exit(-1);} for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } free(buffer); } } }"	where is the vulnerable dataflow from buffer to free ?	"void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_82_bad::action(int <start> data <end> );
free <start> buffer <end> );"	"if  <start> buffer == NULL <end> ) {exit(-1);};
void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_82_bad::action(int <start> data <end> );"	"int <start> * buffer = (int *)malloc(10 * sizeof(int)) <end> ;
void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_82_bad::action(int <start> data <end> );"	"free <start> buffer <end> );
void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_82_bad::action(int <start> data <end> );"	0
70279c14-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif void CWE134_Uncontrolled_Format_String__char_file_snprintf_66b_badSink(char * dataArray[]) { char * data = dataArray[2]; { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"void CWE134_Uncontrolled_Format_String__char_file_snprintf_66b_badSink(char * <start> dataArray <end> []);
printLine <start> dest <end> );"	"printLine <start> dest <end> );
<start> printLine(dest) <end> ;"	"printLine <start> dest <end> );
void CWE134_Uncontrolled_Format_String__char_file_snprintf_66b_badSink(char * <start> dataArray <end> []);"	"void CWE134_Uncontrolled_Format_String__char_file_snprintf_66b_badSink(char * <start> dataArray <end> []);
<start> printLine(dest) <end> ;"	0
4ec5d0be-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_postinc_15_bad() { int data; data = 0; switch(6) { case 6: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; default: printLine(""Benign, fixed string""); break; } switch(7) { case 7: { data++; int result = data; printIntLine(result); } break; default: printLine(""Benign, fixed string""); break; } }"	where is the vulnerable dataflow from data ?	"if  <start> recvResult == SOCKET_ERROR <end>  || recvResult == 0);
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"int <start> result = data <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
<start> data <end> ++;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data <end> ++;"	3
761e295f-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 8 static short CWE194_Unexpected_Sign_Extension__fgets_memcpy_45_badData; static short CWE194_Unexpected_Sign_Extension__fgets_memcpy_45_goodG2BData; static void badSink() { short data = CWE194_Unexpected_Sign_Extension__fgets_memcpy_45_badData; { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } } void CWE194_Unexpected_Sign_Extension__fgets_memcpy_45_bad() { short data; data = 0; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = (short)atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } CWE194_Unexpected_Sign_Extension__fgets_memcpy_45_badData = data; badSink(); }"	where is the vulnerable dataflow from dest to printLine ?	"<start> CWE194_Unexpected_Sign_Extension__fgets_memcpy_45_badData = data <end> ;
static short <start> CWE194_Unexpected_Sign_Extension__fgets_memcpy_45_badData <end> ;
short data = <start> CWE194_Unexpected_Sign_Extension__fgets_memcpy_45_badData <end> ;
<start> memcpy(dest, source, data) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
static short <start> CWE194_Unexpected_Sign_Extension__fgets_memcpy_45_badData <end> ;
short data = <start> CWE194_Unexpected_Sign_Extension__fgets_memcpy_45_badData <end> ;
char <start> dest[100] = """" <end> ;
printLine <start> dest <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> CWE194_Unexpected_Sign_Extension__fgets_memcpy_45_badData = data <end> ;
static short <start> CWE194_Unexpected_Sign_Extension__fgets_memcpy_45_badData <end> ;
short data = <start> CWE194_Unexpected_Sign_Extension__fgets_memcpy_45_badData <end> ;
printLine <start> dest <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
static short <start> CWE194_Unexpected_Sign_Extension__fgets_memcpy_45_badData <end> ;
printLine <start> dest <end> );
<start> printLine(dest) <end> ;
short data = <start> CWE194_Unexpected_Sign_Extension__fgets_memcpy_45_badData <end> ;"	2
70279c33-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif namespace CWE134_Uncontrolled_Format_String__char_file_vfprintf_43 { static void badVaSink(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); va_end(args); } } static void badSource(char * &data) { { size_t dataLen = strlen(data); FILE * pFile; if (100-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } void bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; badSource(data); badVaSink(data, data); }"	where is the vulnerable dataflow from data to vfprintf ?	"badVaSink <start> data <end> , data);
<start> vfprintf(stdout, data, args) <end> ;
static void badVaSink(char * <start> data <end> , ...);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
badSource <start> data <end> );"	"size_t dataLen = <start> strlen(data) <end> ;
vfprintf(stdout, <start> data <end> , args);
badSource <start> data <end> );
static void badVaSink(char * <start> data <end> , ...);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
badVaSink <start> data <end> , data);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), pFile) == NULL);
badSource <start> data <end> );
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);"	3
5e44fc62-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_connect_socket_predec_54e_badSink(int data) { { --data; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
void CWE191_Integer_Underflow__int_connect_socket_predec_54e_badSink(int <start> data <end> );"	"- <start> data <end> ;
int <start> result = data <end> ;"	"void CWE191_Integer_Underflow__int_connect_socket_predec_54e_badSink(int <start> data <end> );
- <start> data <end> ;"	"- <start> data <end> ;
void CWE191_Integer_Underflow__int_connect_socket_predec_54e_badSink(int <start> data <end> );"	2
61da66f1-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__char_rand_square_52c_badSink(char data) { { char result = data * data; printHexCharLine(result); } }	where is the vulnerable dataflow from data ?	"void CWE190_Integer_Overflow__char_rand_square_52c_badSink(char <start> data <end> );
char result = <start> data <end>  * data;"	"char result = <start> data <end>  * data;
void CWE190_Integer_Overflow__char_rand_square_52c_badSink(char <start> data <end> );"	"char result = <start> data * data <end> ;
void CWE190_Integer_Overflow__char_rand_square_52c_badSink(char <start> data <end> );"	"void CWE190_Integer_Overflow__char_rand_square_52c_badSink(char <start> data <end> );
<start> printHexCharLine(result) <end> ;"	0
a95fd846-6c15-11ed-81d4-94e6f77dd552	namespace CWE191_Integer_Underflow__int_fgets_multiply_74 { void badSink(map<int, int> dataMap) { int data = dataMap[2]; if(data < 0) { int result = data * 2; printIntLine(result); } }	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
if <start> data < 0 <end> ) ;"	"int <start> data = dataMap[2] <end> ;
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;"	"void badSink(map<int, int> <start> dataMap <end> );
printIntLine <start> result <end> );"	3
9d745377-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE126_Buffer_Overread__CWE129_listen_socket_14_bad() { int data; data = -1; if(globalFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalFive==5) { { int buffer[10] = { 0 }; if (data >= 0) { printIntLine(buffer[data]); } else { printLine(""ERROR: Array index is negative""); } } } }"	where is the vulnerable dataflow from buffer[data] to printIntLine ?	"printIntLine <start> buffer[data] <end> );
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"printIntLine <start> buffer[data] <end> );
data = <start> atoi(inputBuffer) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[data] <end> );"	"<start> printIntLine(buffer[data]) <end> ;
printIntLine <start> buffer[data] <end> );"	2
c99197bc-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define STAT _stat #define OPEN _open #define WRITE _write #define O_RDWR _O_RDWR #define CLOSE _close #else #define STAT stat #define OPEN open #define WRITE write #define CLOSE close #endif #define BAD_SINK_STRING ""Bad Sink..."" #define GOOD_SINK_STRING ""Good Sink..."" #ifdef _WIN32 #define ACCESS _access #define W_OK 02 #else #define ACCESS access #endif void CWE367_TOC_TOU__access_11_bad() { if(globalReturnsTrue()) { { char filename[100] = """"; int fileDesc = -1; if (fgets(filename, 100, stdin) == NULL) { printLine(""fgets() failed""); filename[0] = '\0'; } if (strlen(filename) > 0) { filename[strlen(filename)-1] = '\0'; } if (ACCESS(filename, W_OK) == -1) { exit(1); } fileDesc  = OPEN(filename, O_RDWR); if (fileDesc == -1) { exit(1); } if (WRITE(fileDesc, BAD_SINK_STRING, strlen(BAD_SINK_STRING)) == -1) { exit(1); } if (fileDesc != -1) { CLOSE(fileDesc); } } } }"	where is the vulnerable dataflow from filename to OPEN ?	"fileDesc  = OPEN <start> filename <end> , O_RDWR);
if  <start> fgets(filename, 100, stdin) <end>  == NULL);"	"fileDesc  = OPEN <start> filename <end> , O_RDWR);
if (fgets <start> filename <end> , 100, stdin) == NULL);"	"if (fgets <start> filename <end> , 100, stdin) == NULL);
fileDesc  = OPEN <start> filename <end> , O_RDWR);"	"fileDesc  = OPEN <start> filename <end> , O_RDWR);
if  <start> strlen(filename) <end>  > 0);"	2
951c5e63-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FULL_COMMAND ""dir "" #else #define FULL_COMMAND ""ls "" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define POPEN _popen #define PCLOSE _pclose #else #define POPEN popen #define PCLOSE pclose #endif void CWE78_OS_Command_Injection__char_connect_socket_popen_03_bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; if(5==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { FILE *pipe; pipe = POPEN(data, ""w""); if (pipe != NULL) { PCLOSE(pipe); } } }"	where is the vulnerable dataflow from data to POPEN ?	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
pipe = POPEN <start> data <end> , ""w"");"	"recvResult = <start> recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0) <end> ;
pipe = POPEN <start> data <end> , ""w"");"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
pipe = <start> POPEN(data, ""w"") <end> ;"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (100 - dataLen - 1), 0);"	0
4ec5d0a8-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__int_fscanf_postinc_53d_badSink(int data) { { data++; int result = data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
void CWE190_Integer_Overflow__int_fscanf_postinc_53d_badSink(int <start> data <end> );"	"<start> data <end> ++;
void CWE190_Integer_Overflow__int_fscanf_postinc_53d_badSink(int <start> data <end> );"	"void CWE190_Integer_Overflow__int_fscanf_postinc_53d_badSink(int <start> data <end> );
<start> data <end> ++;"	"<start> printIntLine(result) <end> ;
<start> data <end> ++;"	2
c72d5d6b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_listen_socket_fopen_66 { void badSink(char * dataArray[]) { char * data = dataArray[2]; { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = FOPEN <start> data <end> , ""wb+"");
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	"pFile = FOPEN <start> data <end> , ""wb+"");
char <start> * data = dataArray[2] <end> ;"	"pFile = FOPEN <start> data <end> , ""wb+"");
void badSink(char * <start> dataArray <end> []);"	"void badSink(char * <start> dataArray <end> []);
pFile = FOPEN <start> data <end> , ""wb+"");"	3
ce547d6d-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif namespace CWE36_Absolute_Path_Traversal__char_environment_ofstream_43 { void badSource(char * &data) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } } void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; badSource(data); { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
badSource <start> data <end> );
outputFile.open((char * <start> data <end> );"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
badSource <start> data <end> );
strncat(data+dataLen, environment, FILENAME_MAX <start> dataLen-1 <end> );"	"size_t dataLen = <start> strlen(data) <end> ;
char * environment = <start> GETENV <end> (ENV_VARIABLE);
badSource <start> data <end> );"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
badSource <start> data <end> );"	0
b54bcf33-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 20 void CWE369_Divide_by_Zero__float_listenSocket_31_bad() { float data; data = 0.0F; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = (float)atof(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { float dataCopy = data; float data = dataCopy; { int result = (int)(100.0 / data); printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"int result = (int) <start> 100.0 / data <end> );
printIntLine <start> result <end> );"	"<start> printIntLine(result) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"int <start> result = (int)(100.0 / data) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	2
893217e8-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_console_open_15 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; switch(6) { case 6: { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } break; default: printLine(""Benign, fixed string""); break; } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
<start> data = dataBuffer <end> ;"	"dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	2
445c11e5-6c15-11ed-81d4-94e6f77dd552	"static void badSink(int64_t data) { { int64_t result = data * data; printLongLongLine(result); } } void CWE190_Integer_Overflow__int64_t_fscanf_square_44_bad() { int64_t data; void (*funcPtr) (int64_t) = badSink; data = 0LL; fscanf (stdin, ""%"" SCNd64, &data); funcPtr(data); }"	where is the vulnerable dataflow from data ?	"int64_t result = <start> data <end>  * data;
static void badSink(int64_t <start> data <end> );
fscanf (stdin, ""%"" SCNd64, <start> &data <end> );"	"int64_t result = <start> data <end>  * data;
static void badSink(int64_t <start> data <end> );
fscanf (stdin, ""%"" SCNd64, <start> &data <end> );
funcPtr <start> data <end> );"	"static void badSink(int64_t <start> data <end> );
fscanf (stdin, ""%"" SCNd64, <start> &data <end> );
int64_t result = <start> data <end>  * data;
<start> funcPtr(data) <end> ;"	"fscanf (stdin, ""%"" SCNd64, <start> &data <end> );
funcPtr <start> data <end> );
static void badSink(int64_t <start> data <end> );
int64_t result = <start> data <end>  * data;"	3
5f76fcaa-6c15-11ed-81d4-94e6f77dd552	"void CWE191_Integer_Underflow__short_fscanf_predec_16_bad() { short data; data = 0; while(1) { fscanf (stdin, ""%hd"", &data); break; } while(1) { { --data; short result = data; printIntLine(result); } break; } }"	where is the vulnerable dataflow from data ?	"fscanf (stdin, ""%hd"", <start> &data <end> );
<start> printIntLine(result) <end> ;"	"fscanf (stdin, ""%hd"", <start> &data <end> );
- <start> data <end> ;"	"- <start> data <end> ;
<start> --data <end> ;"	"- <start> data <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );"	1
9b124d82-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE124_Buffer_Underwrite__CWE839_connect_socket_18_bad() { int data; data = -1; goto source; source: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } goto sink; sink: { int i; int buffer[10] = { 0 }; if (data < 10) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } } }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"printIntLine <start> buffer[i] <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"<start> printIntLine(buffer[i]) <end> ;
printIntLine <start> buffer[i] <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[i] <end> );"	"data = <start> atoi(inputBuffer) <end> ;
printIntLine <start> buffer[i] <end> );"	2
cac216be-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" namespace CWE36_Absolute_Path_Traversal__char_connect_socket_ofstream_21 { static int badStatic = 0; static char * badSource(char * data) { if(badStatic) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } return data; } void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; badStatic = 1; data = badSource(data); { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } ; }"	where is the vulnerable dataflow from data to open ?	"recvResult = recv(connectSocket, (char *)(data + dataLen), <start> sizeof(char) * (FILENAME_MAX - dataLen - 1) <end> , 0);
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
outputFile.open((char * <start> data <end> );
data = <start> badSource <end> (data);"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
outputFile.open((char * <start> data <end> );"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
static char * <start> badSource <end> (char * data);
outputFile.open((char * <start> data <end> );"	"static char * <start> badSource <end> (char * data);
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
data = <start> badSource <end> (data);"	1
571e9826-6c15-11ed-81d4-94e6f77dd552	"static const int STATIC_CONST_FIVE = 5; void CWE191_Integer_Underflow__int_fscanf_sub_06_bad() { int data; data = 0; if(STATIC_CONST_FIVE==5) { fscanf(stdin, ""%d"", &data); } if(STATIC_CONST_FIVE==5) { { int result = data - 1; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  - 1;
<start> printIntLine(result) <end> ;"	"int result = <start> data <end>  - 1;
fscanf(stdin, ""%d"", <start> &data <end> );"	"fscanf(stdin, ""%d"", <start> &data <end> );
int <start> result = data - 1 <end> ;"	"fscanf(stdin, ""%d"", <start> &data <end> );
int result = <start> data <end>  - 1;"	3
571e9804-6c15-11ed-81d4-94e6f77dd552	"void CWE191_Integer_Underflow__int_fscanf_multiply_15_bad() { int data; data = 0; switch(6) { case 6: fscanf(stdin, ""%d"", &data); break; default: printLine(""Benign, fixed string""); break; } switch(7) { case 7: if(data < 0) { int result = data * 2; printIntLine(result); } break; default: printLine(""Benign, fixed string""); break; } }"	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  * 2;
<start> printIntLine(result) <end> ;"	"int result = <start> data <end>  * 2;
fscanf(stdin, ""%d"", <start> &data <end> );"	"fscanf(stdin, ""%d"", <start> &data <end> );
int result = <start> data <end>  * 2;"	"<start> printIntLine(result) <end> ;
fscanf(stdin, ""%d"", <start> &data <end> );"	2
5f76fca6-6c15-11ed-81d4-94e6f77dd552	"void CWE191_Integer_Underflow__short_fscanf_predec_11_bad() { short data; data = 0; if(globalReturnsTrue()) { fscanf (stdin, ""%hd"", &data); } if(globalReturnsTrue()) { { --data; short result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"fscanf (stdin, ""%hd"", <start> &data <end> );
- <start> data <end> ;"	"<start> printIntLine(result) <end> ;
- <start> data <end> ;"	"- <start> data <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );"	"short <start> result = data <end> ;
- <start> data <end> ;"	0
73bc8175-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" void CWE194_Unexpected_Sign_Extension__connect_socket_memmove_16_bad() { short data; data = 0; while(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"printLine <start> dest <end> );
<start> memmove(dest, source, data) <end> ;"	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
if  <start> data < 100 <end> );"	2
b1b8082b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE197_Numeric_Truncation_Error__int_listen_socket_to_short_16_bad() { int data; data = -1; while(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; } { short shortData = (short)data; printShortLine(shortData); } }"	where is the vulnerable dataflow from shortData to printShortLine ?	"printShortLine <start> shortData <end> );
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"if  <start> acceptSocket == SOCKET_ERROR <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"printShortLine <start> shortData <end> );
data = <start> atoi(inputBuffer) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printShortLine <start> shortData <end> );"	3
774f580a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 8 static int staticTrue = 1; static int staticFalse = 0; void CWE194_Unexpected_Sign_Extension__listen_socket_malloc_05_bad() { short data; data = 0; if(staticTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }"	where is the vulnerable dataflow from data to malloc ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
char * dataBuffer = (char *)malloc <start> data <end> );"	"char * dataBuffer = (char *)malloc <start> data <end> );
if  <start> tempInt > SHRT_MAX <end>  || tempInt < SHRT_MIN);"	"char * dataBuffer = (char *)malloc <start> data <end> );
<start> data = 0 <end> ;"	"memset(dataBuffer, 'A', <start> data-1 <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	0
a10948eb-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int badSource(int data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } return data; } void CWE190_Integer_Overflow__int_connect_socket_multiply_42_bad() { int data; data = 0; data = badSource(data); if(data > 0) { int result = data * 2; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static int <start> badSource <end> (int data);
data = <start> badSource <end> (data);
printIntLine <start> result <end> );"	"data = <start> badSource(data) <end> ;
printIntLine <start> result <end> );
static int <start> badSource <end> (int data);
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"data = <start> badSource <end> (data);
printIntLine <start> result <end> );
static int <start> badSource <end> (int data);
int <start> result = data * 2 <end> ;"	"printIntLine <start> result <end> );
data = <start> badSource <end> (data);"	0
7e74f32c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_53d_badSink(int data) { { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"printLine <start> dest <end> );
<start> printLine(dest) <end> ;"	"printLine <start> dest <end> );
void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_53d_badSink(int <start> data <end> );"	"char <start> dest[100] = """" <end> ;
printLine <start> dest <end> );"	"void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_53d_badSink(int <start> data <end> );
printLine <start> dest <end> );"	3
728a5009-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 static void badVaSinkB(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_03_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; if(5==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(5==5) { badVaSinkB(data, data); } }"	where is the vulnerable dataflow from data to vprintf ?	"vprintf <start> data <end> , args);
static void badVaSinkB(char * <start> data <end> , ...);
badVaSinkB <start> data <end> , data);
if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);
vprintf <start> data <end> , args);"	"replace = <start> strchr(data, '\n') <end> ;
badVaSinkB <start> data <end> , data);
vprintf <start> data <end> , args);
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"<start> data = dataBuffer <end> ;
badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);
vprintf <start> data <end> , args);"	1
ce547d1c-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_environment_fopen_13 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(GLOBAL_CONST_FIVE==5) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"strncat(data+dataLen, environment, <start> FILENAME_MAX-dataLen-1 <end> );
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"<start> data = dataBuffer <end> ;
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
pFile = FOPEN <start> data <end> , ""wb+"");"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
size_t dataLen = <start> strlen(data) <end> ;"	2
bb49c5ae-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define COMMAND_INT_PATH ""%WINDIR%\\system32\\cmd.exe"" #define COMMAND_INT ""cmd.exe"" #define COMMAND_ARG1 ""/c"" #define COMMAND_ARG2 ""dir "" #define COMMAND_ARG3 data #else #define COMMAND_INT_PATH ""/bin/sh"" #define COMMAND_INT ""sh"" #define COMMAND_ARG1 ""-c"" #define COMMAND_ARG2 ""ls "" #define COMMAND_ARG3 data #endif #ifdef _WIN32 #define EXECLP _execlp #else #define EXECLP execlp #endif static char * badSource(char * data) { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } return data; } void CWE78_OS_Command_Injection__char_console_execlp_42_bad() { char * data; char dataBuffer[100] = COMMAND_ARG2; data = dataBuffer; data = badSource(data); EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL); }"	where is the vulnerable dataflow from COMMAND_ARG3 to EXECLP ?	"static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, <start> COMMAND_ARG3 <end> , NULL);
static char * <start> badSource <end> (char * data);
dataLen = <start> strlen(data) <end> ;"	"<start> EXECLP(COMMAND_INT, COMMAND_INT, COMMAND_ARG1, COMMAND_ARG3, NULL) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);"	1
acf67e63-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticTrue = 1; static int staticFalse = 0; void CWE191_Integer_Underflow__int_listen_socket_predec_05_bad() { int data; data = 0; if(staticTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticTrue) { { --data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
if  <start> recvResult == SOCKET_ERROR <end>  || recvResult == 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
<start> --data <end> ;"	2
5133a76d-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_fgets_preinc_51b_badSink(int data) { { ++data; int result = data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"void CWE190_Integer_Overflow__int_fgets_preinc_51b_badSink(int <start> data <end> );
+ <start> data <end> ;"	"<start> ++data <end> ;
void CWE190_Integer_Overflow__int_fgets_preinc_51b_badSink(int <start> data <end> );"	"<start> printIntLine(result) <end> ;
+ <start> data <end> ;"	"+ <start> data <end> ;
void CWE190_Integer_Overflow__int_fgets_preinc_51b_badSink(int <start> data <end> );"	0
9059f38c-6c15-11ed-81d4-94e6f77dd552	namespace CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_fgets_73 { void badSink(list<int> dataList) { int data = dataList.back(); { size_t i; int *intPointer; intPointer = (int*)malloc(data * sizeof(int)); if (intPointer == NULL) {exit(-1);} for (i = 0; i < (size_t)data; i++) { intPointer[i] = 0; } printIntLine(intPointer[0]); free(intPointer); } }	where is the vulnerable dataflow from data to malloc ?	"void badSink(list<int> <start> dataList <end> );
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	"intPointer = (int*)malloc <start> data * sizeof(int) <end> );
if  <start> intPointer == NULL <end> ) {exit(-1);};"	"intPointer = (int*)malloc <start> data * sizeof(int) <end> );
int <start> data = dataList.back() <end> ;"	"if  <start> intPointer == NULL <end> ) {exit(-1);};
void badSink(list<int> <start> dataList <end> );"	0
a36a790b-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__int_listen_socket_add_81 { void CWE190_Integer_Overflow__int_listen_socket_add_81_bad::action(int data) const { { int result = data + 1; printIntLine(result); } } }	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
void CWE190_Integer_Overflow__int_listen_socket_add_81_bad::action(int <start> data <end> ) const;"	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	"void CWE190_Integer_Overflow__int_listen_socket_add_81_bad::action(int <start> data <end> ) const;
printIntLine <start> result <end> );"	"void CWE190_Integer_Overflow__int_listen_socket_add_81_bad::action(int <start> data <end> ) const;
<start> printIntLine(result) <end> ;"	2
8f278a37-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define PATH_SZ 100 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define PATH_SZ PATH_MAX #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 void CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__listen_accept_bind_17_bad() { int j; for(j = 0; j < 1; j++) { { char data[100] = """"; #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[recvResult] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif printLine(data); } } }"	where is the vulnerable dataflow from data to printLine ?	"recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);
printLine <start> data <end> );"	"recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);
<start> printLine(data) <end> ;"	"char <start> data[100] = """" <end> ;
recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);"	"size_t dataLen = <start> strlen(data) <end> ;
printLine <start> data <end> );"	0
79b27516-6c15-11ed-81d4-94e6f77dd552	"namespace CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_74 { void badSink(map<int, short> dataMap) { short data = dataMap[2]; { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"void badSink(map<int, short> <start> dataMap <end> );
printLine <start> dest <end> );"	"printLine <start> dest <end> );
void badSink(map<int, short> <start> dataMap <end> );"	"<start> strncpy(dest, source, data) <end> ;
void badSink(map<int, short> <start> dataMap <end> );"	"<start> printLine(dest) <end> ;
void badSink(map<int, short> <start> dataMap <end> );"	0
846ad302-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif void CWE253_Incorrect_Check_of_Function_Return_Value__char_fgets_09_bad() { if(GLOBAL_CONST_TRUE) { { char dataBuffer[100] = """"; char * data = dataBuffer; printLine(""Please enter a string: ""); if (fgets(data, 100, stdin) < 0) { printLine(""fgets failed!""); exit(1); } printLine(data); } } }"	where is the vulnerable dataflow from data to printLine ?	"<start> printLine(data) <end> ;
printLine <start> data <end> );"	"if (fgets <start> data <end> , 100, stdin) < 0);
printLine <start> data <end> );"	"printLine <start> data <end> );
if (fgets <start> data <end> , 100, stdin) < 0);"	"char <start> * data = dataBuffer <end> ;
if (fgets <start> data <end> , 100, stdin) < 0);"	1
8f278a49-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define PATH_SZ 100 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define PATH_SZ PATH_MAX #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 void CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__listen_bind_accept_17_bad() { int j; for(j = 0; j < 1; j++) { { char data[100] = """"; #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[recvResult] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif printLine(data); } } }"	where is the vulnerable dataflow from data to printLine ?	"recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);
printLine <start> data <end> );"	"if  <start> listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR <end> );
printLine <start> data <end> );"	"if  <start> listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR <end> );
recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);"	"printLine <start> data <end> );
replace = <start> strchr(data, '\r') <end> ;"	0
74ee23d0-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 8 #define IP_ADDRESS ""127.0.0.1"" void CWE194_Unexpected_Sign_Extension__connect_socket_strncpy_09_bad() { short data; data = 0; if(GLOBAL_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printLine(dest) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printLine <start> dest <end> );"	"<start> strncpy(dest, source, data) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	1
af58093c-6c15-11ed-81d4-94e6f77dd552	namespace CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_72 { void badSink(vector<int> dataVector) { int data = dataVector[2]; { char charData = (char)data; printHexCharLine(charData); } }	where is the vulnerable dataflow from charData to printHexCharLine ?	"void badSink(vector<int> <start> dataVector <end> );
<start> printHexCharLine(charData) <end> ;"	"void badSink(vector<int> <start> dataVector <end> );
printHexCharLine <start> charData <end> );"	"printHexCharLine <start> charData <end> );
char <start> charData = (char)data <end> ;"	"int <start> data = dataVector[2] <end> ;
void badSink(vector<int> <start> dataVector <end> );"	1
728a4ff3-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 static char * badSource(char * data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } return data; } static void badVaSink(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_listen_socket_vfprintf_42_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; data = badSource(data); badVaSink(data, data); }"	where is the vulnerable dataflow from data to vfprintf ?	"size_t <start> dataLen = strlen(data) <end> ;
static void badVaSink(char * <start> data <end> , ...);
data = <start> badSource <end> (data);
badVaSink <start> data <end> , data);
vfprintf(stdout, <start> data <end> , args);
static char * <start> badSource <end> (char * data);"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (100 - dataLen - 1), 0);
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
data = <start> badSource <end> (data);
static char * <start> badSource <end> (char * data);"	"static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
static void badVaSink(char * <start> data <end> , ...);
replace = <start> strchr(data, '\r') <end> ;
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
badVaSink <start> data <end> , data);"	1
5d16c9d6-6c15-11ed-81d4-94e6f77dd552	"static int badStatic = 0; static void badSink(unsigned int data) { if(badStatic) { { data--; unsigned int result = data; printUnsignedLine(result); } } } void CWE191_Integer_Underflow__unsigned_int_fscanf_postdec_21_bad() { unsigned int data; data = 0; fscanf (stdin, ""%u"", &data); badStatic = 1; badSink(data); }"	where is the vulnerable dataflow from data ?	"fscanf (stdin, ""%u"", <start> &data <end> );
badSink <start> data <end> );
static void badSink(unsigned int <start> data <end> );
<start> data <end> --;"	"static void badSink(unsigned int <start> data <end> );
fscanf (stdin, ""%u"", <start> &data <end> );
<start> badSink(data) <end> ;
<start> data <end> --;"	"<start> data <end> --;
static void badSink(unsigned int <start> data <end> );
badSink <start> data <end> );
fscanf (stdin, ""%u"", <start> &data <end> );"	"<start> badSink(data) <end> ;
badSink <start> data <end> );
static void badSink(unsigned int <start> data <end> );
fscanf (stdin, ""%u"", <start> &data <end> );"	0
d0b64ef6-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif namespace CWE36_Absolute_Path_Traversal__char_file_ofstream_51 { void badSink(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } badSink(data); }"	where is the vulnerable dataflow from data to badSink ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
char <start> dataBuffer[FILENAME_MAX] = """" <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
badSink <start> data <end> );"	"badSink <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"<start> data = dataBuffer <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	1
55ef4cba-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) extern int CWE191_Integer_Underflow__int_fgets_multiply_68_badData; extern int CWE191_Integer_Underflow__int_fgets_multiply_68_goodG2BData; extern int CWE191_Integer_Underflow__int_fgets_multiply_68_goodB2GData; void CWE191_Integer_Underflow__int_fgets_multiply_68b_badSink() { int data = CWE191_Integer_Underflow__int_fgets_multiply_68_badData; if(data < 0) { int result = data * 2; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"int result = <start> data <end>  * 2;
int data = <start> CWE191_Integer_Underflow__int_fgets_multiply_68_badData <end> ;"	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  * 2;"	"int <start> result = data * 2 <end> ;
int data = <start> CWE191_Integer_Underflow__int_fgets_multiply_68_badData <end> ;"	"int data = <start> CWE191_Integer_Underflow__int_fgets_multiply_68_badData <end> ;
int result = <start> data <end>  * 2;"	3
964cdc2a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticTrue = 1; static int staticFalse = 0; void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_05_bad() { int data; data = -1; if(staticTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticTrue) { { int i; int buffer[10] = { 0 }; if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } } } }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int <start> buffer[10] = { 0 } <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[i] <end> );"	"printIntLine <start> buffer[i] <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"printIntLine <start> buffer[i] <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	1
820a46b3-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif static int staticFive = 5; namespace CWE23_Relative_Path_Traversal__char_file_fopen_07 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(staticFive==5) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = FOPEN <start> data <end> , ""wb+"");
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
<start> data = dataBuffer <end> ;"	2
c39a65bd-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif namespace CWE23_Relative_Path_Traversal__char_environment_ofstream_45 { static char * badData; static char * goodG2BData; static void badSink() { char * data = badData; { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } } void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } badData = data; badSink(); }"	where is the vulnerable dataflow from data to open ?	"strncat(data+dataLen, environment, FILENAME_MAX <start> dataLen-1 <end> );
<start> badData = data <end> ;
char * environment = <start> GETENV <end> (ENV_VARIABLE);
char * data = <start> badData <end> ;
outputFile.open((char * <start> data <end> );"	"size_t dataLen = <start> strlen(data) <end> ;
outputFile.open((char * <start> data <end> );
static char * <start> badData <end> ;
char * data = <start> badData <end> ;
char * environment = <start> GETENV <end> (ENV_VARIABLE);"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
<start> badData = data <end> ;
static char * <start> badData <end> ;
char * data = <start> badData <end> ;
outputFile.open((char * <start> data <end> );"	"outputFile.open((char * <start> data <end> );
<start> badData = data <end> ;
char * data = <start> badData <end> ;
strncat(data+dataLen, environment, FILENAME_MAX <start> dataLen-1 <end> );
static char * <start> badData <end> ;"	2
833ac929-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_listen_socket_fopen_72 { void badSink(vector<char *> dataVector) { char * data = dataVector[2]; { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"char <start> * data = dataVector[2] <end> ;
void badSink(vector<char *> <start> dataVector <end> );"	"void badSink(vector<char *> <start> dataVector <end> );
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
void badSink(vector<char *> <start> dataVector <end> );"	"void badSink(vector<char *> <start> dataVector <end> );
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	1
a6fd8282-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; void CWE190_Integer_Overflow__int_listen_socket_preinc_04_bad() { int data; data = 0; if(STATIC_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(STATIC_CONST_TRUE) { { ++data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"<start> printIntLine(result) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	2
5f76fc79-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_listen_socket_predec_02_bad() { int data; data = 0; if(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(1) { { --data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"<start> --data <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"int <start> result = data <end> ;
- <start> data <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
- <start> data <end> ;"	3
820a46e2-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_file_open_17 { void bad() { int i; char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; for(i = 0; i < 1; i++) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
size_t dataLen = <start> strlen(data) <end> ;"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
size_t dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	3
4db33f5f-6c15-11ed-81d4-94e6f77dd552	"static void badSink(unsigned int data) { { unsigned int result = data * data; printUnsignedLine(result); } } void CWE190_Integer_Overflow__unsigned_int_fscanf_square_41_bad() { unsigned int data; data = 0; fscanf (stdin, ""%u"", &data); badSink(data); }"	where is the vulnerable dataflow from data ?	"fscanf (stdin, ""%u"", <start> &data <end> );
static void badSink(unsigned int <start> data <end> );
<start> badSink(data) <end> ;
badSink <start> data <end> );"	"fscanf (stdin, ""%u"", <start> &data <end> );
badSink <start> data <end> );
static void badSink(unsigned int <start> data <end> );
unsigned int result = <start> data <end>  * data;"	"fscanf (stdin, ""%u"", <start> &data <end> );
unsigned int result = <start> data <end>  * data;
badSink <start> data <end> );"	"badSink <start> data <end> );
unsigned int result = <start> data <end>  * data;
static void badSink(unsigned int <start> data <end> );
fscanf (stdin, ""%u"", <start> &data <end> );"	1
b08640fa-6c15-11ed-81d4-94e6f77dd552	namespace CWE197_Numeric_Truncation_Error__int_fgets_to_short_74 { void badSink(map<int, int> dataMap) { int data = dataMap[2]; { short shortData = (short)data; printShortLine(shortData); } }	where is the vulnerable dataflow from shortData to printShortLine ?	"<start> printShortLine(shortData) <end> ;
void badSink(map<int, int> <start> dataMap <end> );"	"<start> printShortLine(shortData) <end> ;
printShortLine <start> shortData <end> );"	"printShortLine <start> shortData <end> );
void badSink(map<int, int> <start> dataMap <end> );"	"void badSink(map<int, int> <start> dataMap <end> );
printShortLine <start> shortData <end> );"	3
c72d5d4a-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_listen_socket_fopen_03 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(5==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = FOPEN <start> data <end> , ""wb+"");
recvResult = recv(acceptSocket, (char *)(data + dataLen), <start> sizeof(char) * (FILENAME_MAX - dataLen - 1) <end> , 0);"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
<start> data = dataBuffer <end> ;"	"pFile = FOPEN <start> data <end> , ""wb+"");
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	1
4ec5d0b6-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_FIVE = 5; void CWE190_Integer_Overflow__int_listen_socket_postinc_06_bad() { int data; data = 0; if(STATIC_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(STATIC_CONST_FIVE==5) { { data++; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> data = atoi(inputBuffer) <end> ;
<start> data <end> ++;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data <end> ++;"	"<start> data <end> ++;
data = <start> atoi(inputBuffer) <end> ;"	"<start> data <end> ++;
<start> printIntLine(result) <end> ;"	1
a830bf68-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticTrue = 1; static int staticFalse = 0; void CWE191_Integer_Underflow__int_connect_socket_multiply_05_bad() { int data; data = 0; if(staticTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticTrue) { if(data < 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
int result = <start> data * 2 <end> ;"	"int <start> result = data * 2 <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
int <start> result = data * 2 <end> ;"	2
a1094906-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticFive = 5; void CWE190_Integer_Overflow__int_connect_socket_square_07_bad() { int data; data = 0; if(staticFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticFive==5) { { int result = data * data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int <start> result = data * data <end> ;"	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> result <end> );"	"data = <start> atoi(inputBuffer) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	3
78800fd6-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 8 static int staticFive = 5; void CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_07_bad() { short data; data = 0; if(staticFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );
printLine <start> dest <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"printLine <start> dest <end> );
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	2
7c127589-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_11_bad() { int data; data = -1; if(globalReturnsTrue()) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printLine <start> dest <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> memcpy(dest, source, data) <end> ;"	"printLine <start> dest <end> );
<start> memcpy(dest, source, data) <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> data = atoi(inputBuffer) <end> ;"	0
aa91a162-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_listen_socket_multiply_13_bad() { int data; data = 0; if(GLOBAL_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(GLOBAL_CONST_FIVE==5) { if(data < 0) { int result = data * 2; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data = 0 <end> ;"	"printIntLine <start> result <end> );
if <start> data < 0 <end> ) ;"	"int result = <start> data * 2 <end> ;
printIntLine <start> result <end> );"	0
d0b64ed9-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif namespace CWE36_Absolute_Path_Traversal__char_file_ifstream_45 { static char * badData; static char * goodG2BData; static void badSink() { char * data = badData; { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } } void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } badData = data; badSink(); }"	where is the vulnerable dataflow from data to open ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
<start> badData = data <end> ;
static char * <start> badData <end> ;
char * data = <start> badData <end> ;
inputFile.open((char * <start> data <end> );"	"<start> badData = data <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
static char * <start> badData <end> ;
inputFile.open((char * <start> data <end> );
<start> data = dataBuffer <end> ;"	"char * data = <start> badData <end> ;
inputFile.open((char * <start> data <end> );
<start> badData = data <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
size_t dataLen = <start> strlen(data) <end> ;"	"static char * <start> badData <end> ;
<start> badData = data <end> ;"	0
c4cd6f6c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_file_fopen_18 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; goto source; source: { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"size_t dataLen = <start> strlen(data) <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
<start> data = dataBuffer <end> ;"	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	1
9ebc76c9-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) typedef struct _CWE127_Buffer_Underread__CWE839_fgets_67_structType { int structFirst; } CWE127_Buffer_Underread__CWE839_fgets_67_structType; void CWE127_Buffer_Underread__CWE839_fgets_67b_badSink(CWE127_Buffer_Underread__CWE839_fgets_67_structType myStruct) { int data = myStruct.structFirst; { int buffer[10] = { 0 }; if (data < 10) { printIntLine(buffer[data]); } else { printLine(""ERROR: Array index is too big.""); } } }"	where is the vulnerable dataflow from buffer[data] to printIntLine ?	"void CWE127_Buffer_Underread__CWE839_fgets_67b_badSink(CWE127_Buffer_Underread__CWE839_fgets_67_structType <start> myStruct <end> );
printIntLine <start> buffer[data] <end> );
int data = <start> myStruct <end> .structFirst;"	"void CWE127_Buffer_Underread__CWE839_fgets_67b_badSink(CWE127_Buffer_Underread__CWE839_fgets_67_structType <start> myStruct <end> );
<start> printIntLine(buffer[data]) <end> ;
int data = <start> myStruct <end> .structFirst;"	"void CWE127_Buffer_Underread__CWE839_fgets_67b_badSink(CWE127_Buffer_Underread__CWE839_fgets_67_structType <start> myStruct <end> );
int data = <start> myStruct <end> .structFirst;
printIntLine <start> buffer[data] <end> );"	"void CWE127_Buffer_Underread__CWE839_fgets_67b_badSink(CWE127_Buffer_Underread__CWE839_fgets_67_structType <start> myStruct <end> );
int data = <start> myStruct <end> .structFirst;"	2
b41b8794-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define CHAR_ARRAY_SIZE 20 #define IP_ADDRESS ""127.0.0.1"" static int staticTrue = 1; static int staticFalse = 0; void CWE369_Divide_by_Zero__float_connect_socket_05_bad() { float data; data = 0.0F; if(staticTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = (float)atof(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticTrue) { { int result = (int)(100.0 / data); printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
<start> printIntLine(result) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
int result = <start> (int)(100.0 / data) <end> ;"	"<start> printIntLine(result) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	1
c5fc235b-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif namespace CWE23_Relative_Path_Traversal__char_file_ofstream_21 { static int badStatic = 0; static char * badSource(char * data) { if(badStatic) { { size_t dataLen = strlen(data); FILE * pFile; if (FILENAME_MAX-dataLen > 1) { pFile = fopen(FILENAME, ""r""); if (pFile != NULL) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), pFile) == NULL) { printLine(""fgets() failed""); data[dataLen] = '\0'; } fclose(pFile); } } } } return data; } void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; badStatic = 1; data = badSource(data); { ofstream outputFile; outputFile.open((char *)data); outputFile.close(); } ; }"	where is the vulnerable dataflow from data to open ?	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);"	"data = <start> badSource <end> (data);
outputFile.open((char * <start> data <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
outputFile.open((char * <start> data <end> );
data = <start> badSource <end> (data);
static char * <start> badSource <end> (char * data);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), pFile) == NULL);
static char * <start> badSource <end> (char * data);
data = <start> badSource <end> (data);
outputFile.open((char * <start> data <end> );"	3
964cdc29-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; void CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_04_bad() { int data; data = -1; if(STATIC_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(STATIC_CONST_TRUE) { { int i; int buffer[10] = { 0 }; if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } } } }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int <start> buffer[10] = { 0 } <end> ;"	"printIntLine <start> buffer[i] <end> );
recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);"	"printIntLine <start> buffer[i] <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[i] <end> );"	3
728a500d-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 static int staticFive = 5; static void badVaSinkB(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_07_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; if(staticFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticFive==5) { badVaSinkB(data, data); } }"	where is the vulnerable dataflow from data to vprintf ?	"vprintf <start> data <end> , args);
badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"if  <start> recvResult == SOCKET_ERROR <end>  || recvResult == 0);
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
vprintf <start> data <end> , args);
static void badVaSinkB(char * <start> data <end> , ...);"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);
vprintf <start> data <end> , args);"	"badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);
vprintf <start> data <end> , args);
if  <start> recvResult == SOCKET_ERROR <end>  || recvResult == 0);"	2
4a021145-6c15-11ed-81d4-94e6f77dd552	namespace CWE190_Integer_Overflow__int_listen_socket_square_81 { void CWE190_Integer_Overflow__int_listen_socket_square_81_bad::action(int data) const { { int result = data * data; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
void CWE190_Integer_Overflow__int_listen_socket_square_81_bad::action(int <start> data <end> ) const;"	"int result = <start> data * data <end> ;
void CWE190_Integer_Overflow__int_listen_socket_square_81_bad::action(int <start> data <end> ) const;"	"void CWE190_Integer_Overflow__int_listen_socket_square_81_bad::action(int <start> data <end> ) const;
int <start> result = data * data <end> ;"	"void CWE190_Integer_Overflow__int_listen_socket_square_81_bad::action(int <start> data <end> ) const;
int result = <start> data <end>  * data;"	3
4a021149-6c15-11ed-81d4-94e6f77dd552	"void CWE190_Integer_Overflow__short_fscanf_add_03_bad() { short data; data = 0; if(5==5) { fscanf (stdin, ""%hd"", &data); } if(5==5) { { short result = data + 1; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"fscanf (stdin, ""%hd"", <start> &data <end> );
short result = <start> data <end>  + 1;"	"short result = <start> data <end>  + 1;
<start> data = 0 <end> ;"	"short result = <start> data <end>  + 1;
fscanf (stdin, ""%hd"", <start> &data <end> );"	"<start> printIntLine(result) <end> ;
fscanf (stdin, ""%hd"", <start> &data <end> );"	0
abc374fc-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_connect_socket_postdec_14_bad() { int data; data = 0; if(globalFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalFive==5) { { data--; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> result <end> );"	"int <start> result = data <end> ;
printIntLine <start> result <end> );"	"data = <start> atoi(inputBuffer) <end> ;
printIntLine <start> result <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	3
4ec5d0b5-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticTrue = 1; static int staticFalse = 0; void CWE190_Integer_Overflow__int_listen_socket_postinc_05_bad() { int data; data = 0; if(staticTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticTrue) { { data++; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> data <end> ++;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
if  <start> recvResult == SOCKET_ERROR <end>  || recvResult == 0);"	"if  <start> recvResult == SOCKET_ERROR <end>  || recvResult == 0);
<start> data <end> ++;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data <end> ++;"	3
8f278a5d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int badStatic = 0; static int badSource(int data) { if(badStatic) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } return data; } void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_connect_socket_21_bad() { int data; data = -1; badStatic = 1; data = badSource(data); { size_t i; int *intPointer; intPointer = (int*)malloc(data * sizeof(int)); if (intPointer == NULL) {exit(-1);} for (i = 0; i < (size_t)data; i++) { intPointer[i] = 0; } printIntLine(intPointer[0]); free(intPointer); } }"	where is the vulnerable dataflow from data to malloc ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static int <start> badSource <end> (int data);
data = <start> badSource <end> (data);
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	"static int <start> badSource <end> (int data);
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
intPointer = (int*)malloc <start> data * sizeof(int) <end> );
data = <start> badSource <end> (data);"	"intPointer = (int*)malloc <start> data * sizeof(int) <end> );
static int <start> badSource <end> (int data);"	"static int <start> badSource <end> (int data);
<start> data = badSource(data) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	0
98b01543-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_TRUE = 1; static const int STATIC_CONST_FALSE = 0; namespace CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_connect_socket_04 { void bad() { int data; data = -1; if(STATIC_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(STATIC_CONST_TRUE) { { int i; int * buffer = new int[10]; for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } delete[] buffer; } } }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"printIntLine <start> buffer[i] <end> );
data = <start> atoi(inputBuffer) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[i] <end> );"	"printIntLine <start> buffer[i] <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
data = <start> atoi(inputBuffer) <end> ;"	1
78800fd4-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE 8 static int staticTrue = 1; static int staticFalse = 0; void CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_05_bad() { short data; data = 0; if(staticTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; int tempInt; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; tempInt = atoi(inputBuffer); if (tempInt > SHRT_MAX || tempInt < SHRT_MIN) { data = -1; } else { data = tempInt; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"char <start> dest[100] = """" <end> ;
printLine <start> dest <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"<start> strncpy(dest, source, data) <end> ;
printLine <start> dest <end> );"	"<start> data = tempInt <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	1
cbf237b8-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_console_fopen_45 { static char * badData; static char * goodG2BData; static void badSink() { char * data = badData; { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } } void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } badData = data; badSink(); }"	where is the vulnerable dataflow from data to FOPEN ?	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
<start> badData = data <end> ;
static char * <start> badData <end> ;
char * data = <start> badData <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
<start> badData = data <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");
dataLen = <start> strlen(data) <end> ;
static char * <start> badData <end> ;"	"static char * <start> badData <end> ;
char * data = <start> badData <end> ;
<start> data = dataBuffer <end> ;
<start> badData = data <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	"static char * <start> badData <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");
<start> badData = data <end> ;
char * data = <start> badData <end> ;
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	0
6dc6150b-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif void CWE134_Uncontrolled_Format_String__char_console_snprintf_09_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; if(GLOBAL_CONST_TRUE) { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } if(GLOBAL_CONST_TRUE) { { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } } }"	where is the vulnerable dataflow from dest to printLine ?	"printLine <start> dest <end> );
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
printLine <start> dest <end> );"	"printLine <start> dest <end> );
SNPRINTF(dest, <start> 100-1 <end> , data);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
char <start> dest[100] = """" <end> ;"	1
584fa874-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_listen_socket_sub_13_bad() { int data; data = 0; if(GLOBAL_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(GLOBAL_CONST_FIVE==5) { { int result = data - 1; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printIntLine(result) <end> ;"	"if  <start> acceptSocket == SOCKET_ERROR <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  - 1;"	"int result = <start> data <end>  - 1;
<start> data = 0 <end> ;"	2
7d44fc93-6c15-11ed-81d4-94e6f77dd552	"int CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_22_badGlobal = 0; int CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_22_badSource(int data); void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_22_bad() { int data; data = -1; CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_22_badGlobal = 1; data = CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_22_badSource(data); { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"<start> strncpy(dest, source, data) <end> ;
data = <start> CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_22_badSource <end> (data);"	"data = <start> CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_22_badSource <end> (data);
printLine <start> dest <end> );"	"printLine <start> dest <end> );
data = <start> CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_22_badSource <end> (data);"	"if  <start> data < 100 <end> );
data = <start> CWE195_Signed_to_Unsigned_Conversion_Error__fgets_strncpy_22_badSource <end> (data);"	1
846ad2f7-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif void CWE252_Unchecked_Return_Value__char_fgets_16_bad() { while(1) { { char dataBuffer[100] = """"; char * data = dataBuffer; printLine(""Please enter a string: ""); fgets(data, 100, stdin); printLine(data); } break; } }"	where is the vulnerable dataflow from data to printLine ?	"fgets <start> data <end> , 100, stdin);
printLine <start> data <end> );"	"<start> printLine(data) <end> ;
printLine <start> data <end> );"	"printLine <start> data <end> );
fgets <start> data <end> , 100, stdin);"	"fgets <start> data <end> , 100, stdin);
<start> fgets(data, 100, stdin) <end> ;"	0
acf67e0d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_listen_socket_postdec_54e_badSink(int data) { { data--; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from result to printIntLine ?	"<start> printIntLine(result) <end> ;
printIntLine <start> result <end> );"	"int <start> result = data <end> ;
void CWE191_Integer_Underflow__int_listen_socket_postdec_54e_badSink(int <start> data <end> );"	"printIntLine <start> result <end> );
void CWE191_Integer_Underflow__int_listen_socket_postdec_54e_badSink(int <start> data <end> );"	"void CWE191_Integer_Underflow__int_listen_socket_postdec_54e_badSink(int <start> data <end> );
printIntLine <start> result <end> );"	3
6dc614cb-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" char * CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_61b_badSource(char * data); static void badVaSink(char * data, ...) { { va_list args; va_start(args, data); vfprintf(stdout, data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_61_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; data = CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_61b_badSource(data); badVaSink(data, data); }"	where is the vulnerable dataflow from data to vfprintf ?	"data = <start> CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_61b_badSource <end> (data);
badVaSink <start> data <end> , data);
vfprintf(stdout, <start> data <end> , args);"	"vfprintf(stdout, <start> data <end> , args);
badVaSink <start> data <end> , data);"	"badVaSink <start> data <end> , data);
vfprintf(stdout, <start> data <end> , args);
data = <start> CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_61b_badSource <end> (data);
static void badVaSink(char * <start> data <end> , ...);"	"data = <start> CWE134_Uncontrolled_Format_String__char_connect_socket_vfprintf_61b_badSource <end> (data);
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
vfprintf(stdout, <start> data <end> , args);"	3
761e298d-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE 8 void CWE194_Unexpected_Sign_Extension__fgets_memmove_52c_badSink(short data) { { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"void CWE194_Unexpected_Sign_Extension__fgets_memmove_52c_badSink(short <start> data <end> );
printLine <start> dest <end> );"	"void CWE194_Unexpected_Sign_Extension__fgets_memmove_52c_badSink(short <start> data <end> );
<start> printLine(dest) <end> ;"	"void CWE194_Unexpected_Sign_Extension__fgets_memmove_52c_badSink(short <start> data <end> );
if  <start> data < 100 <end> );"	"<start> memmove(dest, source, data) <end> ;
printLine <start> dest <end> );"	0
b08640b8-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE197_Numeric_Truncation_Error__int_fgets_to_char_18_bad() { int data; data = -1; goto source; source: { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } { char charData = (char)data; printHexCharLine(charData); } }"	where is the vulnerable dataflow from charData to printHexCharLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printHexCharLine <start> charData <end> );"	"char <start> charData = (char)data <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"char <start> charData = (char)data <end> ;
printHexCharLine <start> charData <end> );"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> data = atoi(inputBuffer) <end> ;"	0
a1094905-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_FIVE = 5; void CWE190_Integer_Overflow__int_connect_socket_square_06_bad() { int data; data = 0; if(STATIC_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(STATIC_CONST_FIVE==5) { { int result = data * data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"printIntLine <start> result <end> );
recvResult = recv(connectSocket, inputBuffer, <start> CHAR_ARRAY_SIZE - 1 <end> , 0);"	"<start> printIntLine(result) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"int <start> result = data * data <end> ;
printIntLine <start> result <end> );"	2
893217f2-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_console_open_43 { void badSource(char * &data) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; badSource(data); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
badSource <start> data <end> );
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
badSource <start> data <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
badSource <start> data <end> );"	2
9059f3a5-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_41_badSink(int data) { { size_t i; int *intPointer; intPointer = (int*)malloc(data * sizeof(int)); if (intPointer == NULL) {exit(-1);} for (i = 0; i < (size_t)data; i++) { intPointer[i] = 0; } printIntLine(intPointer[0]); free(intPointer); } } void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_41_bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_41_badSink(data); }"	where is the vulnerable dataflow from data to malloc ?	"intPointer = (int*)malloc <start> data * sizeof(int) <end> );
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_41_badSink(int <start> data <end> );
CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_41_badSink <start> data <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"intPointer = (int*)malloc <start> data * sizeof(int) <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_41_badSink <start> data <end> );
void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_41_badSink(int <start> data <end> );
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	"void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_41_badSink(int <start> data <end> );
intPointer = (int*)malloc <start> data * sizeof(int) <end> );
CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_41_badSink <start> data <end> );
<start> recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	2
8f278a46-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define PATH_SZ 100 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define PATH_SZ PATH_MAX #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 void CWE666_Operation_on_Resource_in_Wrong_Phase_of_Lifetime__listen_bind_accept_14_bad() { if(globalFive==5) { { char data[100] = """"; #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)data+dataLen, (int)(100-dataLen-1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[recvResult] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif printLine(data); } } }"	where is the vulnerable dataflow from data to printLine ?	"replace = <start> strchr(data, '\n') <end> ;
printLine <start> data <end> );"	"recvResult = recv(acceptSocket, <start> (char *)data <end> +dataLen, (int)(100-dataLen-1), 0);
printLine <start> data <end> );"	"recvResult = recv(acceptSocket, <start> (char *)data+dataLen <end> , (int)(100-dataLen-1), 0);
printLine <start> data <end> );"	"<start> printLine(data) <end> ;
printLine <start> data <end> );"	2
453db01e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE190_Integer_Overflow__int_connect_socket_multiply_43 { static void badSource(int &data) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } void bad() { int data; data = 0; badSource(data); if(data > 0) { int result = data * 2; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
badSource <start> data <end> );
int result = <start> data <end>  * 2;"	"int result = <start> data <end>  * 2;
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
badSource <start> data <end> );"	"<start> badSource(data) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  * 2;"	"badSource <start> data <end> );
data = <start> atoi(inputBuffer) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	0
6c938bf4-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif static int staticFive = 5; void CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_07_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; if(staticFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticFive==5) { { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } } }"	where is the vulnerable dataflow from dest to printLine ?	"replace = <start> strchr(data, '\n') <end> ;
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"size_t dataLen = <start> strlen(data) <end> ;
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
printLine <start> dest <end> );"	"printLine <start> dest <end> );
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (100 - dataLen - 1), 0);"	2
445c11e4-6c15-11ed-81d4-94e6f77dd552	"static int64_t badSource(int64_t data) { fscanf (stdin, ""%"" SCNd64, &data); return data; } void CWE190_Integer_Overflow__int64_t_fscanf_square_42_bad() { int64_t data; data = 0LL; data = badSource(data); { int64_t result = data * data; printLongLongLine(result); } }"	where is the vulnerable dataflow from data ?	"fscanf (stdin, ""%"" SCNd64, <start> &data <end> );
static int64_t <start> badSource <end> (int64_t data);
data = <start> badSource <end> (data);
int64_t result = <start> data <end>  * data;"	"fscanf (stdin, ""%"" SCNd64, <start> &data <end> );
static int64_t <start> badSource <end> (int64_t data);"	"static int64_t <start> badSource <end> (int64_t data);
fscanf (stdin, ""%"" SCNd64, <start> &data <end> );
data = <start> badSource <end> (data);"	"static int64_t <start> badSource <end> (int64_t data);
int64_t result = <start> data <end>  * data;
fscanf (stdin, ""%"" SCNd64, <start> &data <end> );
data = <start> badSource <end> (data);"	0
bed4a8e0-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" static int staticFive = 5; namespace CWE23_Relative_Path_Traversal__char_connect_socket_ifstream_07 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; if(staticFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { ifstream inputFile; inputFile.open((char *)data); inputFile.close(); } }"	where is the vulnerable dataflow from data to open ?	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
char <start> dataBuffer[FILENAME_MAX] = BASEPATH <end> ;"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
inputFile.open((char * <start> data <end> );"	"inputFile.open((char * <start> data <end> );
<start> data = dataBuffer <end> ;"	"recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) *  <start> FILENAME_MAX - dataLen - 1 <end> ), 0);"	1
9ebc76de-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) typedef union { int unionFirst; int unionSecond; } CWE127_Buffer_Underread__CWE839_listen_socket_34_unionType; void CWE127_Buffer_Underread__CWE839_listen_socket_34_bad() { int data; CWE127_Buffer_Underread__CWE839_listen_socket_34_unionType myUnion; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } myUnion.unionFirst = data; { int data = myUnion.unionSecond; { int buffer[10] = { 0 }; if (data < 10) { printIntLine(buffer[data]); } else { printLine(""ERROR: Array index is too big.""); } } } }"	where is the vulnerable dataflow from buffer[data] to printIntLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
data = <start> atoi(inputBuffer) <end> ;"	"printIntLine <start> buffer[data] <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[data] <end> );"	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> buffer[data] <end> );"	2
7ae3a703-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_memmove_02_bad() { int data; data = -1; if(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memmove(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"char <start> dest[100] = """" <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"printLine <start> dest <end> );
<start> memmove(dest, source, data) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"<start> data = -1 <end> ;
printLine <start> dest <end> );"	2
d1e9da20-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FILENAME ""C:\\temp\\file.txt"" #else #define FILENAME ""/tmp/file.txt"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_file_open_64 { void badSink(void * dataVoidPtr) { char * * dataPtr = (char * *)dataVoidPtr; char * data = (*dataPtr); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
void badSink(void * <start> dataVoidPtr <end> );"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
void badSink(void * <start> dataVoidPtr <end> );"	"void badSink(void * <start> dataVoidPtr <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	3
c26a7e45-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_console_open_16 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; while(1) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } break; } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
size_t dataLen = <start> strlen(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"dataLen = <start> strlen(data) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	1
61da66dc-6c15-11ed-81d4-94e6f77dd552	static const int STATIC_CONST_FIVE = 5; void CWE190_Integer_Overflow__char_rand_square_06_bad() { char data; data = ' '; if(STATIC_CONST_FIVE==5) { data = (char)RAND32(); } if(STATIC_CONST_FIVE==5) { { char result = data * data; printHexCharLine(result); } } }	where is the vulnerable dataflow from data ?	"char result = <start> data <end>  * data;
data = (char <start> RAND32() <end> ;"	"data = (char <start> RAND32() <end> ;
char result = <start> data <end>  * data;"	"char <start> result = data * data <end> ;
data = (char <start> RAND32() <end> ;"	"<start> printHexCharLine(result) <end> ;
char result = <start> data <end>  * data;"	1
7c127585-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticFive = 5; void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memcpy_07_bad() { int data; data = -1; if(staticFive==5) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> printLine(dest) <end> ;"	"printLine <start> dest <end> );
<start> printLine(dest) <end> ;"	"printLine <start> dest <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printLine <start> dest <end> );"	3
d31a24ef-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 namespace CWE36_Absolute_Path_Traversal__char_listen_socket_ifstream_65 { void badSink(char * data); void bad() { char * data; void (*funcPtr) (char *) = badSink; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } funcPtr(data); }"	where is the vulnerable dataflow from data to funcPtr ?	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
size_t dataLen = <start> strlen(data) <end> ;"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
<start> data = dataBuffer <end> ;"	"funcPtr <start> data <end> );
<start> funcPtr(data) <end> ;"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
funcPtr <start> data <end> );"	3
af58097c-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE197_Numeric_Truncation_Error__int_fgets_to_char_12_bad() { int data; data = -1; if(globalReturnsTrueOrFalse()) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } else { data = CHAR_MAX-5; } { char charData = (char)data; printHexCharLine(charData); } }"	where is the vulnerable dataflow from charData to printHexCharLine ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
printHexCharLine <start> charData <end> );"	"char <start> charData = (char)data <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"printHexCharLine <start> charData <end> );
char charData = <start> (char)data <end> ;"	"<start> printHexCharLine(charData) <end> ;
printHexCharLine <start> charData <end> );"	0
4ec5d07f-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink(int data) { { data++; int result = data; printIntLine(result); } } void CWE190_Integer_Overflow__int_fgets_postinc_41_bad() { int data; data = 0; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } badSink(data); }"	where is the vulnerable dataflow from data ?	"<start> data++ <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
badSink <start> data <end> );
static void badSink(int <start> data <end> );"	"badSink <start> data <end> );
data = <start> atoi(inputBuffer) <end> ;
static void badSink(int <start> data <end> );
<start> data <end> ++;"	"<start> badSink(data) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
badSink <start> data <end> );
<start> data <end> ++;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
badSink <start> data <end> );
static void badSink(int <start> data <end> );
<start> data <end> ++;"	3
6b86245c-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink(int data) { { int i; int * buffer = (int *)malloc(10 * sizeof(int)); if (buffer == NULL) {exit(-1);} for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } free(buffer); } } void CWE122_Heap_Based_Buffer_Overflow__c_CWE129_fgets_41_bad() { int data; data = -1; { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } badSink(data); }"	where is the vulnerable dataflow from buffer to free ?	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
badSink <start> data <end> );
static void badSink(int <start> data <end> );
free <start> buffer <end> );"	"free <start> buffer <end> );
<start> free(buffer) <end> ;
static void badSink(int <start> data <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"<start> data = -1 <end> ;
static void badSink(int <start> data <end> );
free <start> buffer <end> );
badSink <start> data <end> );"	"int <start> * buffer = (int *)malloc(10 * sizeof(int)) <end> ;
free <start> buffer <end> );
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
badSink <start> data <end> );"	0
4ec5d06e-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticTrue = 1; static int staticFalse = 0; void CWE190_Integer_Overflow__int_fgets_postinc_05_bad() { int data; data = 0; if(staticTrue) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(staticTrue) { { data++; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"<start> data = atoi(inputBuffer) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"<start> data <end> ++;
data = <start> atoi(inputBuffer) <end> ;"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
<start> data <end> ++;"	3
61da66db-6c15-11ed-81d4-94e6f77dd552	static int staticTrue = 1; static int staticFalse = 0; void CWE190_Integer_Overflow__char_rand_square_05_bad() { char data; data = ' '; if(staticTrue) { data = (char)RAND32(); } if(staticTrue) { { char result = data * data; printHexCharLine(result); } } }	where is the vulnerable dataflow from data ?	"data = (char <start> RAND32() <end> ;
char result = <start> data <end>  * data;"	"char result = <start> data <end>  * data;
<start> data = ' ' <end> ;"	"char result = <start> data <end>  * data;
<start> data = (char)RAND32() <end> ;"	"data = (char <start> RAND32() <end> ;
char <start> result = data * data <end> ;"	0
466e7efd-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_FIVE = 5; void CWE190_Integer_Overflow__int_fgets_square_06_bad() { int data; data = 0; if(STATIC_CONST_FIVE==5) { { char inputBuffer[CHAR_ARRAY_SIZE] = """"; if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL) { data = atoi(inputBuffer); } else { printLine(""fgets() failed.""); } } } if(STATIC_CONST_FIVE==5) { { int result = data * data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);"	"if (fgets <start> inputBuffer <end> , CHAR_ARRAY_SIZE, stdin) != NULL);
int result = <start> data <end>  * data;"	"data = <start> atoi(inputBuffer) <end> ;
int result = <start> data <end>  * data;"	"<start> printIntLine(result) <end> ;
int result = <start> data <end>  * data;"	1
8b91e4aa-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(count) + 2) #ifdef _WIN32 #define SLEEP Sleep #else #define SLEEP usleep #endif void CWE400_Resource_Exhaustion__connect_socket_sleep_10_bad() { int count; count = -1; if(globalTrue) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; count = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalTrue) { SLEEP(count); printLine(""Sleep time possibly too long""); } }"	where is the vulnerable dataflow from count to SLEEP ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
SLEEP <start> count <end> );"	"SLEEP <start> count <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"count = <start> atoi(inputBuffer) <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"count = <start> atoi(inputBuffer) <end> ;
SLEEP <start> count <end> );"	0
7ae3a748-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_45_badData; static int CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_45_goodG2BData; static void badSink() { int data = CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_45_badData; { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { strncpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } } void CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_45_bad() { int data; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_45_badData = data; badSink(); }"	where is the vulnerable dataflow from dest to printLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_45_badData = data <end> ;
static int <start> CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_45_badData <end> ;
int data = <start> CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_45_badData <end> ;
printLine <start> dest <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_45_badData = data <end> ;
static int <start> CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_45_badData <end> ;
int data = <start> CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_45_badData <end> ;
<start> strncpy(dest, source, data) <end> ;"	"int data = <start> CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_45_badData <end> ;
static int <start> CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_45_badData <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"static int <start> CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_45_badData <end> ;
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int data = <start> CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_45_badData <end> ;
printLine <start> dest <end> );"	0
af58092e-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink(int data) { { char charData = (char)data; printHexCharLine(charData); } } void CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_44_bad() { int data; void (*funcPtr) (int) = badSink; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } funcPtr(data); }"	where is the vulnerable dataflow from charData to printHexCharLine ?	"char charData = <start> (char)data <end> ;
printHexCharLine <start> charData <end> );
funcPtr <start> data <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
funcPtr <start> data <end> );
static void badSink(int <start> data <end> );
printHexCharLine <start> charData <end> );"	"printHexCharLine <start> charData <end> );
funcPtr <start> data <end> );
static void badSink(int <start> data <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"funcPtr <start> data <end> );
printHexCharLine <start> charData <end> );
<start> funcPtr(data) <end> ;
static void badSink(int <start> data <end> );"	1
4a021129-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_square_14_bad() { int data; data = 0; if(globalFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(globalFive==5) { { int result = data * data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  * data;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printIntLine(result) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data = 0 <end> ;"	"int result = <start> data <end>  * data;
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	0
6dc6150f-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif void CWE134_Uncontrolled_Format_String__char_console_snprintf_13_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; if(GLOBAL_CONST_FIVE==5) { { size_t dataLen = strlen(data); if (100-dataLen > 1) { if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } if(GLOBAL_CONST_FIVE==5) { { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } } }"	where is the vulnerable dataflow from dest to printLine ?	"dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(100-dataLen), stdin) != NULL);
printLine <start> dest <end> );"	"dataLen = <start> strlen(data) <end> ;
printLine <start> dest <end> );"	"<start> printLine(dest) <end> ;
printLine <start> dest <end> );"	1
893217bc-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif static const int STATIC_CONST_FIVE = 5; namespace CWE36_Absolute_Path_Traversal__char_console_fopen_06 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; if(STATIC_CONST_FIVE==5) { { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"char <start> dataBuffer[FILENAME_MAX] = """" <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
pFile = FOPEN <start> data <end> , ""wb+"");"	"<start> data = dataBuffer <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	2
61da66df-6c15-11ed-81d4-94e6f77dd552	void CWE190_Integer_Overflow__char_rand_square_09_bad() { char data; data = ' '; if(GLOBAL_CONST_TRUE) { data = (char)RAND32(); } if(GLOBAL_CONST_TRUE) { { char result = data * data; printHexCharLine(result); } } }	where is the vulnerable dataflow from data ?	"data = (char <start> RAND32() <end> ;
char result = <start> data <end>  * data;"	"data = (char <start> RAND32() <end> ;
char result = <start> data * data <end> ;"	"char result = <start> data <end>  * data;
data = (char <start> RAND32() <end> ;"	"<start> printHexCharLine(result) <end> ;
data = (char <start> RAND32() <end> ;"	0
7fa68e56-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_connect_socket_open_18 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; goto source; source: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
char <start> dataBuffer[FILENAME_MAX] = BASEPATH <end> ;"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
size_t dataLen = <start> strlen(data) <end> ;"	"replace = <start> strchr(data, '\n') <end> ;
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	0
4ec5d07c-6c15-11ed-81d4-94e6f77dd552	extern int CWE190_Integer_Overflow__int_fgets_postinc_22_badGlobal; void CWE190_Integer_Overflow__int_fgets_postinc_22_badSink(int data) { if(CWE190_Integer_Overflow__int_fgets_postinc_22_badGlobal) { { data++; int result = data; printIntLine(result); } } }	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
<start> data <end> ++;"	"void CWE190_Integer_Overflow__int_fgets_postinc_22_badSink(int <start> data <end> );
<start> data <end> ++;"	"<start> data <end> ++;
void CWE190_Integer_Overflow__int_fgets_postinc_22_badSink(int <start> data <end> );"	"<start> data <end> ++;
int <start> result = data <end> ;"	1
9187cbd3-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define SEARCH_CHAR 'S' void CWE761_Free_Pointer_Not_at_Start_of_Buffer__char_connect_socket_09_bad() { char * data; data = (char *)malloc(100*sizeof(char)); if (data == NULL) {exit(-1);} data[0] = '\0'; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } if(GLOBAL_CONST_TRUE) { for (; *data != '\0'; data++) { if (*data == SEARCH_CHAR) { printLine(""We have a match!""); break; } } free(data); } }"	where is the vulnerable dataflow from data to free ?	"free <start> data <end> );
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
free <start> data <end> );"	"replace = <start> strchr(data, '\r') <end> ;
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"size_t dataLen = <start> strlen(data) <end> ;
free <start> data <end> );"	1
9059f3a8-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink(int data) { { size_t i; int *intPointer; intPointer = (int*)malloc(data * sizeof(int)); if (intPointer == NULL) {exit(-1);} for (i = 0; i < (size_t)data; i++) { intPointer[i] = 0; } printIntLine(intPointer[0]); free(intPointer); } } void CWE680_Integer_Overflow_to_Buffer_Overflow__malloc_listen_socket_44_bad() { int data; void (*funcPtr) (int) = badSink; data = -1; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } funcPtr(data); }"	where is the vulnerable dataflow from data to malloc ?	"funcPtr <start> data <end> );
<start> data = atoi(inputBuffer) <end> ;
intPointer = (int*)malloc <start> data * sizeof(int) <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
funcPtr <start> data <end> );
static void badSink(int <start> data <end> );
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
funcPtr <start> data <end> );
intPointer = (int*)malloc <start> data * sizeof(int) <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
static void badSink(int <start> data <end> );
intPointer = (int*)malloc <start> data * sizeof(int) <end> );
funcPtr <start> data <end> );"	1
8b91e487-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_listen_socket_open_64 { void badSink(void * dataVoidPtr) { char * * dataPtr = (char * *)dataVoidPtr; char * data = (*dataPtr); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
char <start> * data = (*dataPtr) <end> ;"	"void badSink(void * <start> dataVoidPtr <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = OPEN(data, <start> O_RDWR|O_CREAT <end> , S_IREAD|S_IWRITE);"	1
7c12756e-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_51b_badSink(int data) { if (data < 100) { char * dataBuffer = (char *)malloc(data); if (dataBuffer == NULL) {exit(-1);} memset(dataBuffer, 'A', data-1); dataBuffer[data-1] = '\0'; printLine(dataBuffer); free(dataBuffer); } }	where is the vulnerable dataflow from data to malloc ?	"void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_51b_badSink(int <start> data <end> );
char * dataBuffer = (char *)malloc <start> data <end> );"	"void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_51b_badSink(int <start> data <end> );
if  <start> dataBuffer == NULL <end> ) {exit(-1);};"	"<start> free(dataBuffer) <end> ;
void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_51b_badSink(int <start> data <end> );"	"void CWE195_Signed_to_Unsigned_Conversion_Error__fgets_malloc_51b_badSink(int <start> data <end> );
memset(dataBuffer, 'A', <start> data-1 <end> );"	0
af580938-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_65b_badSink(int data) { { char charData = (char)data; printHexCharLine(charData); } }"	where is the vulnerable dataflow from charData to printHexCharLine ?	"void CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_65b_badSink(int <start> data <end> );
printHexCharLine <start> charData <end> );"	"<start> printHexCharLine(charData) <end> ;
printHexCharLine <start> charData <end> );"	"<start> printHexCharLine(charData) <end> ;
void CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_65b_badSink(int <start> data <end> );"	"printHexCharLine <start> charData <end> );
void CWE197_Numeric_Truncation_Error__int_connect_socket_to_char_65b_badSink(int <start> data <end> );"	0
93ece307-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) #define HELLO_STRING ""hello"" void CWE789_Uncontrolled_Mem_Alloc__malloc_char_listen_socket_16_bad() { size_t data; data = 0; while(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = strtoul(inputBuffer, NULL, 0); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; } while(1) { { char * myString; if (data > strlen(HELLO_STRING)) { myString = (char *)malloc(data*sizeof(char)); if (myString == NULL) {exit(-1);} strcpy(myString, HELLO_STRING); printLine(myString); free(myString); } else { printLine(""Input is less than the length of the source string""); } } break; } }"	where is the vulnerable dataflow from data to malloc ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> myString = (char *)malloc(data*sizeof(char)) <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
myString = (char *)malloc <start> data*sizeof(char) <end> );"	"if  <start> data > strlen(HELLO_STRING) <end> );
myString = (char *)malloc <start> data*sizeof(char) <end> );"	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
myString = (char *)malloc <start> data*sizeof(char) <end> );"	1
c8600b05-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE23_Relative_Path_Traversal__char_listen_socket_open_16 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; while(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; } { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
recvResult = recv(acceptSocket, (char *)(data + dataLen), <start> sizeof(char) * (FILENAME_MAX - dataLen - 1) <end> , 0);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
recvResult = recv(acceptSocket, (char *)(data + dataLen), <start> sizeof(char) * (FILENAME_MAX - dataLen - 1) <end> , 0);"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;"	0
5af03e0c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE191_Integer_Underflow__int_connect_socket_postdec_64b_badSink(void * dataVoidPtr) { int * dataPtr = (int *)dataVoidPtr; int data = (*dataPtr); { data--; int result = data; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
<start> data <end> --;"	"void CWE191_Integer_Underflow__int_connect_socket_postdec_64b_badSink(void * <start> dataVoidPtr <end> );
<start> printIntLine(result) <end> ;"	"<start> data <end> --;
void CWE191_Integer_Underflow__int_connect_socket_postdec_64b_badSink(void * <start> dataVoidPtr <end> );"	"void CWE191_Integer_Underflow__int_connect_socket_postdec_64b_badSink(void * <start> dataVoidPtr <end> );
<start> data <end> --;"	3
a6fd828f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_preinc_17_bad() { int i,j; int data; data = 0; for(i = 0; i < 1; i++) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } for(j = 0; j < 1; j++) { { ++data; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from result to printIntLine ?	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> result <end> );"	"printIntLine <start> result <end> );
recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"printIntLine <start> result <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"printIntLine <start> result <end> );
data = <start> atoi(inputBuffer) <end> ;"	0
48d25da3-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static int staticFive = 5; void CWE190_Integer_Overflow__int_listen_socket_add_07_bad() { int data; data = 0; if(staticFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(staticFive==5) { { int result = data + 1; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> data = atoi(inputBuffer) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int <start> result = data + 1 <end> ;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int result = <start> data <end>  + 1;"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printIntLine(result) <end> ;"	2
9fe7ad1f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" namespace CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_82 { void bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_82_base* baseObject = new CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_82_bad; baseObject->action(data); delete baseObject; }"	where is the vulnerable dataflow from data to action ?	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
baseObject->action <start> data <end> );"	"baseObject->action <start> data <end> );
recvResult = <start> recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0) <end> ;"	"baseObject->action <start> data <end> );
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"size_t dataLen = <start> strlen(data) <end> ;
recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	0
571e9827-6c15-11ed-81d4-94e6f77dd552	"static int staticFive = 5; void CWE191_Integer_Underflow__int_fscanf_sub_07_bad() { int data; data = 0; if(staticFive==5) { fscanf(stdin, ""%d"", &data); } if(staticFive==5) { { int result = data - 1; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
fscanf(stdin, ""%d"", <start> &data <end> );"	"int result = <start> data <end>  - 1;
fscanf(stdin, ""%d"", <start> &data <end> );"	"int result = <start> data <end>  - 1;
<start> printIntLine(result) <end> ;"	"fscanf(stdin, ""%d"", <start> &data <end> );
int result = <start> data <end>  - 1;"	3
cf87509c-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif #ifdef _WIN32 #define OPEN _open #define CLOSE _close #else #define OPEN open #define CLOSE close #endif namespace CWE36_Absolute_Path_Traversal__char_environment_open_64 { void badSink(void * dataVoidPtr) { char * * dataPtr = (char * *)dataVoidPtr; char * data = (*dataPtr); { int fileDesc; fileDesc = OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE); if (fileDesc != -1) { CLOSE(fileDesc); } } }"	where is the vulnerable dataflow from data to OPEN ?	"void badSink(void * <start> dataVoidPtr <end> );
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
void badSink(void * <start> dataVoidPtr <end> );"	"fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
void badSink(void * <start> dataVoidPtr <end> );"	"fileDesc = <start> OPEN(data, O_RDWR|O_CREAT, S_IREAD|S_IWRITE) <end> ;
fileDesc = OPEN <start> data <end> , O_RDWR|O_CREAT, S_IREAD|S_IWRITE);"	0
5f76fc8f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static void badSink(int data) { { --data; int result = data; printIntLine(result); } } void CWE191_Integer_Underflow__int_listen_socket_predec_44_bad() { int data; void (*funcPtr) (int) = badSink; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } funcPtr(data); }"	where is the vulnerable dataflow from data ?	"- <start> data <end> ;
static void badSink(int <start> data <end> );
funcPtr <start> data <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"static void badSink(int <start> data <end> );
<start> funcPtr(data) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
funcPtr <start> data <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
funcPtr <start> data <end> );
static void badSink(int <start> data <end> );
- <start> data <end> ;"	"int <start> result = data <end> ;
- <start> data <end> ;
static void badSink(int <start> data <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	2
846ad335-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) static const int STATIC_CONST_FIVE = 5; void CWE369_Divide_by_Zero__int_connect_socket_divide_06_bad() { int data; data = -1; if(STATIC_CONST_FIVE==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } if(STATIC_CONST_FIVE==5) { printIntLine(100 / data); } }"	where is the vulnerable dataflow from data to printIntLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> 100 / data <end> );"	"printIntLine <start> 100 / data <end> );
recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
data = <start> atoi(inputBuffer) <end> ;"	"printIntLine <start> 100 / data <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	0
728a5018-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 static void badVaSinkB(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); va_end(args); } } void CWE134_Uncontrolled_Format_String__char_listen_socket_vprintf_18_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; goto source; source: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } goto sink; sink: badVaSinkB(data, data); }"	where is the vulnerable dataflow from data to vprintf ?	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
vprintf <start> data <end> , args);"	"static void badVaSinkB(char * <start> data <end> , ...);
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
vprintf <start> data <end> , args);
<start> va_start(args, data) <end> ;"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
badVaSinkB <start> data <end> , data);
static void badVaSinkB(char * <start> data <end> , ...);
vprintf <start> data <end> , args);"	"badVaSinkB <start> data <end> , data);
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
static void badVaSinkB(char * <start> data <end> , ...);
recvResult = recv(acceptSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (100 - dataLen - 1), 0);"	2
b41b878c-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 namespace CWE23_Relative_Path_Traversal__char_listen_socket_ofstream_81 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (FILENAME_MAX - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } const CWE23_Relative_Path_Traversal__char_listen_socket_ofstream_81_base& baseObject = CWE23_Relative_Path_Traversal__char_listen_socket_ofstream_81_bad(); baseObject.action(data); }"	where is the vulnerable dataflow from data to action ?	"<start> data = dataBuffer <end> ;
baseObject.action <start> data <end> );"	"<start> data = dataBuffer <end> ;
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
baseObject.action <start> data <end> );"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (FILENAME_MAX - dataLen - 1), 0);
size_t dataLen = <start> strlen(data) <end> ;"	2
6dc61500-6c15-11ed-81d4-94e6f77dd552	#ifndef _WIN32 #endif namespace CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_74 { static void badVaSink(char * data, ...) { { va_list args; va_start(args, data); vprintf(data, args); va_end(args); } } void badSink(map<int, char *> dataMap) { char * data = dataMap[2]; badVaSink(data, data); }	where is the vulnerable dataflow from data to vprintf ?	"void badSink(map<int, char *> <start> dataMap <end> );
badVaSink <start> data <end> , data);
static void badVaSink(char * <start> data <end> , ...);
vprintf <start> data <end> , args);"	"badVaSink <start> data <end> , data);
void badSink(map<int, char *> <start> dataMap <end> );"	"void badSink(map<int, char *> <start> dataMap <end> );
static void badVaSink(char * <start> data <end> , ...);
vprintf <start> data <end> , args);
<start> vprintf(data, args) <end> ;"	"static void badVaSink(char * <start> data <end> , ...);
badVaSink <start> data <end> , data);
vprintf <start> data <end> , args);
void badSink(map<int, char *> <start> dataMap <end> );"	0
964cdc08-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define FULL_COMMAND ""dir "" #else #define FULL_COMMAND ""ls "" #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define POPEN _popen #define PCLOSE _pclose #else #define POPEN popen #define PCLOSE pclose #endif static int staticFive = 5; void CWE78_OS_Command_Injection__char_listen_socket_popen_07_bad() { char * data; char data_buf[100] = FULL_COMMAND; data = data_buf; if(staticFive==5) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { FILE *pipe; pipe = POPEN(data, ""w""); if (pipe != NULL) { PCLOSE(pipe); } } }"	where is the vulnerable dataflow from data to POPEN ?	"pipe = <start> POPEN(data, ""w"") <end> ;
recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);"	"pipe = POPEN <start> data <end> , ""w"");
size_t dataLen = <start> strlen(data) <end> ;"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
pipe = POPEN <start> data <end> , ""w"");"	"recvResult = recv(acceptSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
replace = <start> strchr(data, '\n') <end> ;"	2
98b0154f-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE122_Heap_Based_Buffer_Overflow__cpp_CWE129_connect_socket_16 { void bad() { int data; data = -1; while(1) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET connectSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; } while(1) { { int i; int * buffer = new int[10]; for (i = 0; i < 10; i++) { buffer[i] = 0; } if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } delete[] buffer; } break; } }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printIntLine <start> buffer[i] <end> );"	"recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
int <start> * buffer = new int[10] <end> ;"	"printIntLine <start> buffer[i] <end> );
recvResult = recv(connectSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = <start> recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printIntLine <start> buffer[i] <end> );"	0
6c938bff-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define IP_ADDRESS ""127.0.0.1"" #ifdef _WIN32 #define SNPRINTF _snprintf #else #define SNPRINTF snprintf #endif void CWE134_Uncontrolled_Format_String__char_connect_socket_snprintf_18_bad() { char * data; char dataBuffer[100] = """"; data = dataBuffer; goto source; source: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; char *replace; SOCKET connectSocket = INVALID_SOCKET; size_t dataLen = strlen(data); do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (connectSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = inet_addr(IP_ADDRESS); service.sin_port = htons(TCP_PORT); if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } data[dataLen + recvResult / sizeof(char)] = '\0'; replace = strchr(data, '\r'); if (replace) { *replace = '\0'; } replace = strchr(data, '\n'); if (replace) { *replace = '\0'; } } while (0); if (connectSocket != INVALID_SOCKET) { CLOSE_SOCKET(connectSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } goto sink; sink: { char dest[100] = """"; SNPRINTF(dest, 100-1, data); printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
size_t dataLen = <start> strlen(data) <end> ;"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
printLine <start> dest <end> );"	"recvResult = recv(connectSocket, <start> (char *)(data + dataLen) <end> , sizeof(char) * (100 - dataLen - 1), 0);
recvResult = recv(connectSocket, (char *) <start> data + dataLen <end> ), sizeof(char) * (100 - dataLen - 1), 0);"	"printLine <start> dest <end> );
<start> printLine(dest) <end> ;"	1
977ea79a-6c15-11ed-81d4-94e6f77dd552	"#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) typedef struct _CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_67_structType { int structFirst; } CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_67_structType; void CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_67b_badSink(CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_67_structType myStruct) { int data = myStruct.structFirst; { int i; int buffer[10] = { 0 }; if (data >= 0) { buffer[data] = 1; for(i = 0; i < 10; i++) { printIntLine(buffer[i]); } } else { printLine(""ERROR: Array index is negative.""); } } }"	where is the vulnerable dataflow from buffer[i] to printIntLine ?	"printIntLine <start> buffer[i] <end> );
void CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_67b_badSink(CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_67_structType <start> myStruct <end> );
int data = <start> myStruct <end> .structFirst;"	"void CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_67b_badSink(CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_67_structType <start> myStruct <end> );
int data = <start> myStruct <end> .structFirst;
printIntLine <start> buffer[i] <end> );"	"printIntLine <start> buffer[i] <end> );
void CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_67b_badSink(CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_67_structType <start> myStruct <end> );"	"void CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_67b_badSink(CWE121_Stack_Based_Buffer_Overflow__CWE129_fgets_67_structType <start> myStruct <end> );
int <start> buffer[10] = { 0 } <end> ;
printIntLine <start> buffer[i] <end> );"	1
4ff7827e-6c15-11ed-81d4-94e6f77dd552	short CWE190_Integer_Overflow__short_fscanf_postinc_61b_badSource(short data); void CWE190_Integer_Overflow__short_fscanf_postinc_61_bad() { short data; data = 0; data = CWE190_Integer_Overflow__short_fscanf_postinc_61b_badSource(data); { data++; short result = data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"<start> data <end> ++;
data = <start> CWE190_Integer_Overflow__short_fscanf_postinc_61b_badSource(data) <end> ;"	"data = <start> CWE190_Integer_Overflow__short_fscanf_postinc_61b_badSource <end> (data);
<start> printIntLine(result) <end> ;"	"data = <start> CWE190_Integer_Overflow__short_fscanf_postinc_61b_badSource <end> (data);
<start> data <end> ++;"	"data = <start> CWE190_Integer_Overflow__short_fscanf_postinc_61b_badSource <end> (data);
<start> data++ <end> ;"	2
584fa863-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) typedef struct _CWE191_Integer_Underflow__int_listen_socket_multiply_67_structType { int structFirst; } CWE191_Integer_Underflow__int_listen_socket_multiply_67_structType; void CWE191_Integer_Underflow__int_listen_socket_multiply_67b_badSink(CWE191_Integer_Underflow__int_listen_socket_multiply_67_structType myStruct) { int data = myStruct.structFirst; if(data < 0) { int result = data * 2; printIntLine(result); } }"	where is the vulnerable dataflow from data ?	"void CWE191_Integer_Underflow__int_listen_socket_multiply_67b_badSink(CWE191_Integer_Underflow__int_listen_socket_multiply_67_structType <start> myStruct <end> );
<start> printIntLine(result) <end> ;
int result = <start> data <end>  * 2;"	"int result = <start> data <end>  * 2;
int data = <start> myStruct <end> .structFirst;"	"int <start> data = myStruct.structFirst <end> ;
int result = <start> data <end>  * 2;
void CWE191_Integer_Underflow__int_listen_socket_multiply_67b_badSink(CWE191_Integer_Underflow__int_listen_socket_multiply_67_structType <start> myStruct <end> );"	"void CWE191_Integer_Underflow__int_listen_socket_multiply_67b_badSink(CWE191_Integer_Underflow__int_listen_socket_multiply_67_structType <start> myStruct <end> );
int data = <start> myStruct <end> .structFirst;
int result = <start> data <end>  * 2;"	3
7e74f31d-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_15_bad() { int data; data = -1; switch(6) { case 6: { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } break; default: printLine(""Benign, fixed string""); break; } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"printLine <start> dest <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
printLine <start> dest <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"char <start> dest[100] = """" <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	2
cbf237bb-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_console_fopen_53 { void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = """"; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } badSink_b(data); }"	where is the vulnerable dataflow from data to badSink_b ?	"badSink_b <start> data <end> );
<start> badSink_b(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
badSink_b <start> data <end> );"	"size_t dataLen = <start> strlen(data) <end> ;
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
dataLen = <start> strlen(data) <end> ;"	1
c1366253-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_console_fopen_54 { void badSink_b(char * data); void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; { size_t dataLen = strlen(data); if (FILENAME_MAX-dataLen > 1) { if (fgets(data+dataLen, (int)(FILENAME_MAX-dataLen), stdin) != NULL) { dataLen = strlen(data); if (dataLen > 0 && data[dataLen-1] == '\n') { data[dataLen-1] = '\0'; } } else { printLine(""fgets() failed""); data[dataLen] = '\0'; } } } badSink_b(data); }"	where is the vulnerable dataflow from data to badSink_b ?	"if (dataLen > 0 && <start> data[dataLen-1] == '\n' <end> );
if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);"	"badSink_b <start> data <end> );
size_t dataLen = <start> strlen(data) <end> ;"	"badSink_b <start> data <end> );
<start> badSink_b(data) <end> ;"	"if (fgets <start> data+dataLen <end> , (int)(FILENAME_MAX-dataLen), stdin) != NULL);
badSink_b <start> data <end> );"	3
8b91e45e-6c15-11ed-81d4-94e6f77dd552	"#ifndef _WIN32 #endif #ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE36_Absolute_Path_Traversal__char_listen_socket_fopen_64 { void badSink(void * dataVoidPtr) { char * * dataPtr = (char * *)dataVoidPtr; char * data = (*dataPtr); { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = FOPEN <start> data <end> , ""wb+"");
void badSink(void * <start> dataVoidPtr <end> );"	"void badSink(void * <start> dataVoidPtr <end> );
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
char <start> * data = (*dataPtr) <end> ;"	"pFile = <start> FOPEN(data, ""wb+"") <end> ;
pFile = FOPEN <start> data <end> , ""wb+"");"	1
c26a7e70-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #define BASEPATH ""c:\\temp\\"" #else #define BASEPATH ""/tmp/"" #endif #define ENV_VARIABLE ""ADD"" #ifdef _WIN32 #define GETENV getenv #else #define GETENV getenv #endif #ifdef _WIN32 #define FOPEN fopen #else #define FOPEN fopen #endif namespace CWE23_Relative_Path_Traversal__char_environment_fopen_16 { void bad() { char * data; char dataBuffer[FILENAME_MAX] = BASEPATH; data = dataBuffer; while(1) { { size_t dataLen = strlen(data); char * environment = GETENV(ENV_VARIABLE); if (environment != NULL) { strncat(data+dataLen, environment, FILENAME_MAX-dataLen-1); } } break; } { FILE *pFile = NULL; pFile = FOPEN(data, ""wb+""); if (pFile != NULL) { fclose(pFile); } } }"	where is the vulnerable dataflow from data to FOPEN ?	"pFile = FOPEN <start> data <end> , ""wb+"");
pFile = <start> FOPEN(data, ""wb+"") <end> ;"	"pFile = FOPEN <start> data <end> , ""wb+"");
strncat(data+dataLen, environment, <start> FILENAME_MAX-dataLen-1 <end> );"	"char * environment = <start> GETENV <end> (ENV_VARIABLE);
pFile = FOPEN <start> data <end> , ""wb+"");"	"pFile = FOPEN <start> data <end> , ""wb+"");
size_t dataLen = <start> strlen(data) <end> ;"	2
5e44fc87-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) int CWE191_Integer_Underflow__int_fgets_predec_61b_badSource(int data); void CWE191_Integer_Underflow__int_fgets_predec_61_bad() { int data; data = 0; data = CWE191_Integer_Underflow__int_fgets_predec_61b_badSource(data); { --data; int result = data; printIntLine(result); } }	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
- <start> data <end> ;"	"data = <start> CWE191_Integer_Underflow__int_fgets_predec_61b_badSource <end> (data);
- <start> data <end> ;"	"- <start> data <end> ;
data = <start> CWE191_Integer_Underflow__int_fgets_predec_61b_badSource <end> (data);"	"<start> printIntLine(result) <end> ;
data = <start> CWE191_Integer_Underflow__int_fgets_predec_61b_badSource <end> (data);"	1
4ec5d0c0-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE190_Integer_Overflow__int_listen_socket_postinc_17_bad() { int i,j; int data; data = 0; for(i = 0; i < 1; i++) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } for(j = 0; j < 1; j++) { { data++; int result = data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"<start> printIntLine(result) <end> ;
<start> data <end> ++;"	"data = <start> atoi(inputBuffer) <end> ;
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> data <end> ++;"	"if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	2
abc374ee-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE191_Integer_Underflow__int_listen_socket_sub_82 { void bad() { int data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } CWE191_Integer_Underflow__int_listen_socket_sub_82_base* baseObject = new CWE191_Integer_Underflow__int_listen_socket_sub_82_bad; baseObject->action(data); delete baseObject; }"	where is the vulnerable dataflow from data to action ?	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
baseObject->action <start> data <end> );"	"baseObject->action <start> data <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
baseObject->action <start> data <end> );"	"data = <start> atoi(inputBuffer) <end> ;
baseObject->action <start> data <end> );"	2
7e74f317-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) void CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_memcpy_09_bad() { int data; data = -1; if(GLOBAL_CONST_TRUE) { { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = atoi(inputBuffer); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } } { char source[100]; char dest[100] = """"; memset(source, 'A', 100-1); source[100-1] = '\0'; if (data < 100) { memcpy(dest, source, data); dest[data] = '\0'; } printLine(dest); } }"	where is the vulnerable dataflow from dest to printLine ?	"if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );
recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);"	"<start> memcpy(dest, source, data) <end> ;
printLine <start> dest <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
printLine <start> dest <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
<start> printLine(dest) <end> ;"	2
a5ce1c6a-6c15-11ed-81d4-94e6f77dd552	#define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) int CWE190_Integer_Overflow__int_fgets_postinc_61b_badSource(int data); void CWE190_Integer_Overflow__int_fgets_postinc_61_bad() { int data; data = 0; data = CWE190_Integer_Overflow__int_fgets_postinc_61b_badSource(data); { data++; int result = data; printIntLine(result); } }	where is the vulnerable dataflow from result to printIntLine ?	"data = <start> CWE190_Integer_Overflow__int_fgets_postinc_61b_badSource <end> (data);
printIntLine <start> result <end> );"	"<start> printIntLine(result) <end> ;
data = <start> CWE190_Integer_Overflow__int_fgets_postinc_61b_badSource <end> (data);"	"printIntLine <start> result <end> );
<start> data++ <end> ;"	"data = <start> CWE190_Integer_Overflow__int_fgets_postinc_61b_badSource <end> (data);
<start> data = 0 <end> ;"	0
ba102b75-6c15-11ed-81d4-94e6f77dd552	"#ifdef _WIN32 #pragma comment(lib, ""ws2_32"") #define CLOSE_SOCKET closesocket #else #define INVALID_SOCKET -1 #define SOCKET_ERROR -1 #define CLOSE_SOCKET close #define SOCKET int #endif #define TCP_PORT 27015 #define LISTEN_BACKLOG 5 #define CHAR_ARRAY_SIZE (3 * sizeof(data) + 2) namespace CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_81 { void bad() { size_t data; data = 0; { #ifdef _WIN32 WSADATA wsaData; int wsaDataInit = 0; #endif int recvResult; struct sockaddr_in service; SOCKET listenSocket = INVALID_SOCKET; SOCKET acceptSocket = INVALID_SOCKET; char inputBuffer[CHAR_ARRAY_SIZE]; do { #ifdef _WIN32 if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR) { break; } wsaDataInit = 1; #endif listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (listenSocket == INVALID_SOCKET) { break; } memset(&service, 0, sizeof(service)); service.sin_family = AF_INET; service.sin_addr.s_addr = INADDR_ANY; service.sin_port = htons(TCP_PORT); if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR) { break; } if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR) { break; } acceptSocket = accept(listenSocket, NULL, NULL); if (acceptSocket == SOCKET_ERROR) { break; } recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0); if (recvResult == SOCKET_ERROR || recvResult == 0) { break; } inputBuffer[recvResult] = '\0'; data = strtoul(inputBuffer, NULL, 0); } while (0); if (listenSocket != INVALID_SOCKET) { CLOSE_SOCKET(listenSocket); } if (acceptSocket != INVALID_SOCKET) { CLOSE_SOCKET(acceptSocket); } #ifdef _WIN32 if (wsaDataInit) { WSACleanup(); } #endif } const CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_81_base& o = CWE789_Uncontrolled_Mem_Alloc__new_char_listen_socket_81_bad(); o.action(data); }"	where is the vulnerable dataflow from data to action ?	"if  <start> bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR <end> );
o.action <start> data <end> );"	"recvResult = recv(acceptSocket, <start> inputBuffer <end> , CHAR_ARRAY_SIZE - 1, 0);
o.action <start> data <end> );"	"o.action <start> data <end> );
acceptSocket = <start> accept(listenSocket, NULL, NULL) <end> ;"	"recvResult = <start> recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0) <end> ;
o.action <start> data <end> );"	1
48d25d86-6c15-11ed-81d4-94e6f77dd552	"void CWE190_Integer_Overflow__int_fscanf_square_31_bad() { int data; data = 0; fscanf(stdin, ""%d"", &data); { int dataCopy = data; int data = dataCopy; { int result = data * data; printIntLine(result); } } }"	where is the vulnerable dataflow from data ?	"fscanf(stdin, ""%d"", <start> &data <end> );
int result = <start> data * data <end> ;"	"int result = <start> data <end>  * data;
fscanf(stdin, ""%d"", <start> &data <end> );"	"fscanf(stdin, ""%d"", <start> &data <end> );
<start> printIntLine(result) <end> ;"	"fscanf(stdin, ""%d"", <start> &data <end> );
int result = <start> data <end>  * data;"	3
